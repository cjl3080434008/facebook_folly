!_TAG_FILE_FORMAT	2	/extended format; --format=1 will not append ;" to lines/
!_TAG_FILE_SORTED	1	/0=unsorted, 1=sorted, 2=foldcase/
!_TAG_PROGRAM_AUTHOR	Darren Hiebert	/dhiebert@users.sourceforge.net/
!_TAG_PROGRAM_NAME	Exuberant Ctags	//
!_TAG_PROGRAM_URL	http://ctags.sourceforge.net	/official site/
!_TAG_PROGRAM_VERSION	5.8	//
A	.\FBVector.h	/^  typedef std::allocator_traits<Allocator> A;$/;"	t	class:folly::fbvector	access:private
A	.\test\DynamicConverterTest.cpp	/^struct A {$/;"	s	file:
A	.\wangle\test\Thens.h	/^typedef unique_ptr<int> A;$/;"	t
A::i	.\test\DynamicConverterTest.cpp	/^  int i;$/;"	m	struct:A	file:	access:public
A::operator ==	.\test\DynamicConverterTest.cpp	/^  bool operator==(const A & o) const { return i == o.i; }$/;"	f	struct:A	access:public	signature:(const A & o) const
AHA	.\test\AtomicHashMapTest.cpp	/^typedef AtomicHashArray<int32_t, int32_t> AHA;$/;"	t	file:
AHArrayT	.\test\AtomicHashMapTest.cpp	/^typedef AtomicHashArray<KeyT,ValueT> AHArrayT;$/;"	t	file:
AHMapT	.\test\AtomicHashMapTest.cpp	/^typedef AtomicHashMap<KeyT,ValueT> AHMapT;$/;"	t	file:
ALL	.\String.h	/^  ALL = 0,$/;"	m	class:folly::UriEscapeMode	access:private
ALLOW_UNALIGNED_READS	.\SpookyHashV1.cpp	31;"	d	file:
ALLOW_UNALIGNED_READS	.\SpookyHashV2.cpp	32;"	d	file:
ALLTIME	.\test\TimeseriesHistogramTest.cpp	/^    ALLTIME,$/;"	e	enum:IntMHTS::Levels	file:
ALLTIME	.\test\TimeseriesHistogramTest.cpp	/^    ALLTIME,$/;"	e	enum:IntMTMHTS::Levels	file:
ALLTIME	.\test\TimeseriesTest.cpp	/^    ALLTIME,$/;"	e	enum:IntMHTS::Levels	file:
ALL_DELETE	.\test\stl_tests\StlVectorTest.cpp	/^  ALL_DELETE  = DC_DELETE | CC_DELETE | MC_DELETE$/;"	e	enum:Flags	file:
ARGIFY	.\test\stl_tests\StlVectorTest.cpp	823;"	d	file:
ARRAY	.\dynamic.h	/^    ARRAY,$/;"	e	enum:folly::dynamic::Type
AWOKEN	.\detail\Futex.h	/^  AWOKEN,        \/* futex wait matched with a futex wake *\/$/;"	m	class:folly::detail::FutexResult	access:private
AbstractIntException	.\test\ExceptionWrapperTest.cpp	/^class AbstractIntException : public std::exception {$/;"	c	file:	inherits:std::exception
AbstractIntException::getInt	.\test\ExceptionWrapperTest.cpp	/^  virtual int getInt() const = 0;$/;"	p	class:AbstractIntException	file:	access:public	signature:() const
AccessSpreader	.\detail\CacheLocality.h	/^  explicit AccessSpreader(size_t spreaderNumStripes,$/;"	f	struct:folly::detail::AccessSpreader	access:public	signature:(size_t spreaderNumStripes, const CacheLocality& cacheLocality = CacheLocality::system<Atom>(), Getcpu::Func getcpuFunc = nullptr)
AccessSpreader	.\detail\CacheLocality.h	/^struct AccessSpreader {$/;"	s	namespace:folly::detail
AccessSpreaderArray	.\detail\CacheLocality.h	/^  AccessSpreaderArray() {$/;"	f	struct:folly::detail::AccessSpreaderArray	access:public	signature:()
AccessSpreaderArray	.\detail\CacheLocality.h	/^struct AccessSpreaderArray {$/;"	s	namespace:folly::detail
AccessSpreaderArray	.\detail\CacheLocality.h	/^struct AccessSpreaderArray;$/;"	x
Accessor	.\ConcurrentSkipList.h	/^  Accessor(const Accessor &accessor) :$/;"	f	class:folly::ConcurrentSkipList::Accessor	access:public	signature:(const Accessor &accessor)
Accessor	.\ConcurrentSkipList.h	/^  class Accessor;$/;"	x
Accessor	.\ConcurrentSkipList.h	/^  explicit Accessor(ConcurrentSkipList *skip_list) : sl_(skip_list) {$/;"	f	class:folly::ConcurrentSkipList::Accessor	access:public	signature:(ConcurrentSkipList *skip_list)
Accessor	.\ConcurrentSkipList.h	/^  explicit Accessor(std::shared_ptr<ConcurrentSkipList> skip_list)$/;"	f	class:folly::ConcurrentSkipList::Accessor	access:public	signature:(std::shared_ptr<ConcurrentSkipList> skip_list)
Accessor	.\ConcurrentSkipList.h	/^  typedef typename SkipListType::Accessor Accessor;$/;"	t	class:folly::ConcurrentSkipList::Skipper	access:private
Accessor	.\ConcurrentSkipList.h	/^class ConcurrentSkipList<T, Comp, NodeAlloc, MAX_HEIGHT>::Accessor {$/;"	c	class:folly::ConcurrentSkipList
Accessor	.\ThreadLocal.h	/^      friend class Accessor;$/;"	x
Accessor	.\ThreadLocal.h	/^    Accessor()$/;"	f	class:folly::ThreadLocalPtr::Accessor	access:public	signature:()
Accessor	.\ThreadLocal.h	/^    Accessor(const Accessor&) = delete;$/;"	p	class:folly::ThreadLocalPtr::Accessor	access:public	signature:(const Accessor&)
Accessor	.\ThreadLocal.h	/^    explicit Accessor(int id)$/;"	f	class:folly::ThreadLocalPtr::Accessor	access:private	signature:(int id)
Accessor	.\ThreadLocal.h	/^  class Accessor {$/;"	c	class:folly::ThreadLocalPtr	access:public
Accessor	.\ThreadLocal.h	/^  typedef typename ThreadLocalPtr<T,Tag>::Accessor Accessor;$/;"	t	class:folly::ThreadLocal	access:public
Action	.\wangle\Executor.h	/^     typedef std::function<void()> Action;$/;"	t	class:folly::wangle::Executor	access:public
ActualSizePolicy	.\small_vector.h	/^      ActualSizePolicy;$/;"	t	struct:folly::detail::small_vector_base	access:public
Adaptor	.\Padded.h	/^  Adaptor() : lastCount_(Node::kElementCount) { }$/;"	f	class:folly::Adaptor	access:public	signature:()
Adaptor	.\Padded.h	/^  Adaptor(Adaptor&& other)$/;"	f	class:folly::Adaptor	access:public	signature:(Adaptor&& other)
Adaptor	.\Padded.h	/^  Adaptor(const Adaptor&) = default;$/;"	p	class:folly::Adaptor	access:public	signature:(const Adaptor&)
Adaptor	.\Padded.h	/^  explicit Adaptor(Container c, size_t lastCount=Node::kElementCount)$/;"	f	class:folly::Adaptor	access:public	signature:(Container c, size_t lastCount=Node::kElementCount)
Adaptor	.\Padded.h	/^  explicit Adaptor(size_t n, const value_type& value = value_type())$/;"	f	class:folly::Adaptor	access:public	signature:(size_t n, const value_type& value = value_type())
Adaptor	.\Padded.h	/^class Adaptor {$/;"	c	namespace:folly
Add	.\test\SpookyHashV1Test.cpp	/^static void Add(const void *data, size_t length, uint64_t *hash1, uint64_t *hash2)$/;"	f	file:	signature:(const void *data, size_t length, uint64_t *hash1, uint64_t *hash2)
Add	.\test\SpookyHashV2Test.cpp	/^static void Add(const void *data, size_t length, uint64_t *hash1, uint64_t *hash2)$/;"	f	file:	signature:(const void *data, size_t length, uint64_t *hash1, uint64_t *hash2)
AddressData	.\test\IPAddressTest.h	/^  AddressData(): address(""), bytes(), version(0) {}$/;"	f	struct:folly::AddressData	access:public	signature:()
AddressData	.\test\IPAddressTest.h	/^  AddressData(const std::string& address, const ByteVector& bytes,$/;"	f	struct:folly::AddressData	access:public	signature:(const std::string& address, const ByteVector& bytes, uint8_t version)
AddressData	.\test\IPAddressTest.h	/^  AddressData(const std::string& address, uint8_t version)$/;"	f	struct:folly::AddressData	access:public	signature:(const std::string& address, uint8_t version)
AddressData	.\test\IPAddressTest.h	/^  explicit AddressData(const std::string& address)$/;"	f	struct:folly::AddressData	access:public	signature:(const std::string& address)
AddressData	.\test\IPAddressTest.h	/^struct AddressData {$/;"	s	namespace:folly
AddressFlags	.\test\IPAddressTest.h	/^  AddressFlags(const std::string& addr, uint8_t version, uint8_t flags)$/;"	f	struct:folly::AddressFlags	access:public	signature:(const std::string& addr, uint8_t version, uint8_t flags)
AddressFlags	.\test\IPAddressTest.h	/^struct AddressFlags {$/;"	s	namespace:folly
AddressFormatter	.\experimental\symbolizer\Symbolizer.cpp	/^AddressFormatter::AddressFormatter() {$/;"	f	class:folly::symbolizer::AddressFormatter	signature:()
AddressFormatter	.\experimental\symbolizer\Symbolizer.h	/^  AddressFormatter();$/;"	p	class:folly::symbolizer::AddressFormatter	access:public	signature:()
AddressFormatter	.\experimental\symbolizer\Symbolizer.h	/^class AddressFormatter {$/;"	c	namespace:folly::symbolizer
AddressStorage	.\IPAddressV4.h	/^    AddressStorage() {$/;"	f	union:folly::IPAddressV4::AddressStorage	access:public	signature:()
AddressStorage	.\IPAddressV4.h	/^    explicit AddressStorage(const ByteArray4 bytes): bytes_(bytes) {}$/;"	f	union:folly::IPAddressV4::AddressStorage	access:public	signature:(const ByteArray4 bytes)
AddressStorage	.\IPAddressV4.h	/^    explicit AddressStorage(const in_addr addr): inAddr_(addr) {}$/;"	f	union:folly::IPAddressV4::AddressStorage	access:public	signature:(const in_addr addr)
AddressStorage	.\IPAddressV4.h	/^  union AddressStorage {$/;"	u	class:folly::IPAddressV4	access:private
AddressStorage	.\IPAddressV6.cpp	/^IPAddressV6::AddressStorage::AddressStorage(MacAddress mac) {$/;"	f	class:folly::IPAddressV6::AddressStorage	signature:(MacAddress mac)
AddressStorage	.\IPAddressV6.h	/^    AddressStorage() {$/;"	f	union:folly::IPAddressV6::AddressStorage	access:public	signature:()
AddressStorage	.\IPAddressV6.h	/^    explicit AddressStorage(MacAddress mac);$/;"	p	union:folly::IPAddressV6::AddressStorage	access:public	signature:(MacAddress mac)
AddressStorage	.\IPAddressV6.h	/^    explicit AddressStorage(const ByteArray16& bytes): bytes_(bytes) {}$/;"	f	union:folly::IPAddressV6::AddressStorage	access:public	signature:(const ByteArray16& bytes)
AddressStorage	.\IPAddressV6.h	/^    explicit AddressStorage(const in6_addr& addr): in6Addr_(addr) {}$/;"	f	union:folly::IPAddressV6::AddressStorage	access:public	signature:(const in6_addr& addr)
AddressStorage	.\IPAddressV6.h	/^  union AddressStorage {$/;"	u	class:folly::IPAddressV6	access:private
Align	.\FormatArg.h	/^  enum class Align : uint8_t {$/;"	c	struct:folly::FormatArg	inherits:uint8_t	access:public
All	.\gen\Base-inl.h	/^  All() {}$/;"	f	class:folly::gen::detail::All	access:public	signature:()
All	.\gen\Base-inl.h	/^  explicit All(Predicate pred)$/;"	f	class:folly::gen::detail::All	access:public	signature:(Predicate pred)
All	.\gen\Base-inl.h	/^class All : public Operator<All<Predicate>> {$/;"	c	namespace:folly::gen::detail	inherits:Operator
All	.\gen\Base.h	/^class All;$/;"	x
Alloc	.\test\stl_tests\StlVectorTest.cpp	/^  Alloc(Alloc&& o) : a(move(o.a)), id(o.id) {}$/;"	f	struct:Alloc	access:public	signature:(Alloc&& o)
Alloc	.\test\stl_tests\StlVectorTest.cpp	/^  Alloc(const Alloc& o) : a(o.a), id(o.id) {}$/;"	f	struct:Alloc	access:public	signature:(const Alloc& o)
Alloc	.\test\stl_tests\StlVectorTest.cpp	/^  explicit Alloc(int i = 8) : a(a), id(i) {}$/;"	f	struct:Alloc	access:public	signature:(int i = 8)
Alloc	.\test\stl_tests\StlVectorTest.cpp	/^struct Alloc : AllocTracker, Ticker {$/;"	s	file:	inherits:AllocTracker,Ticker
Alloc::Alloc	.\test\stl_tests\StlVectorTest.cpp	/^  Alloc(Alloc&& o) : a(move(o.a)), id(o.id) {}$/;"	f	struct:Alloc	access:public	signature:(Alloc&& o)
Alloc::Alloc	.\test\stl_tests\StlVectorTest.cpp	/^  Alloc(const Alloc& o) : a(o.a), id(o.id) {}$/;"	f	struct:Alloc	access:public	signature:(const Alloc& o)
Alloc::Alloc	.\test\stl_tests\StlVectorTest.cpp	/^  explicit Alloc(int i = 8) : a(a), id(i) {}$/;"	f	struct:Alloc	access:public	signature:(int i = 8)
Alloc::a	.\test\stl_tests\StlVectorTest.cpp	/^  std::allocator<T> a;$/;"	m	struct:Alloc	file:	access:public
Alloc::allocate	.\test\stl_tests\StlVectorTest.cpp	/^  pointer allocate(size_type n) {$/;"	f	struct:Alloc	access:public	signature:(size_type n)
Alloc::const_pointer	.\test\stl_tests\StlVectorTest.cpp	/^  typedef typename std::allocator<T>::const_pointer const_pointer;$/;"	t	struct:Alloc	file:	access:public
Alloc::construct	.\test\stl_tests\StlVectorTest.cpp	/^  void construct(U* p, Args&&... args) {$/;"	f	struct:Alloc	access:public	signature:(U* p, Args&&... args)
Alloc::deallocate	.\test\stl_tests\StlVectorTest.cpp	/^  void deallocate(pointer p, size_type n) {$/;"	f	struct:Alloc	access:public	signature:(pointer p, size_type n)
Alloc::destroy	.\test\stl_tests\StlVectorTest.cpp	/^  void destroy(U* p) {$/;"	f	struct:Alloc	access:public	signature:(U* p)
Alloc::id	.\test\stl_tests\StlVectorTest.cpp	/^  int id;$/;"	m	struct:Alloc	file:	access:public
Alloc::operator !=	.\test\stl_tests\StlVectorTest.cpp	/^  bool operator!=(const Alloc& o) const { return !(*this == o); }$/;"	f	struct:Alloc	access:public	signature:(const Alloc& o) const
Alloc::operator =	.\test\stl_tests\StlVectorTest.cpp	/^  Alloc& operator=(Alloc&&) = default;$/;"	p	struct:Alloc	file:	access:public	signature:(Alloc&&)
Alloc::operator =	.\test\stl_tests\StlVectorTest.cpp	/^  Alloc& operator=(const Alloc&) = default;$/;"	p	struct:Alloc	file:	access:public	signature:(const Alloc&)
Alloc::operator ==	.\test\stl_tests\StlVectorTest.cpp	/^  bool operator==(const Alloc& o) const { return a == o.a && id == o.id; }$/;"	f	struct:Alloc	access:public	signature:(const Alloc& o) const
Alloc::pointer	.\test\stl_tests\StlVectorTest.cpp	/^  typedef typename std::allocator<T>::pointer pointer;$/;"	t	struct:Alloc	file:	access:public
Alloc::propagate_on_container_copy_assignment	.\test\stl_tests\StlVectorTest.cpp	/^  typedef isPropCopy<T> propagate_on_container_copy_assignment;$/;"	t	struct:Alloc	file:	access:public
Alloc::propagate_on_container_move_assignment	.\test\stl_tests\StlVectorTest.cpp	/^  typedef isPropMove<T> propagate_on_container_move_assignment;$/;"	t	struct:Alloc	file:	access:public
Alloc::propagate_on_container_swap	.\test\stl_tests\StlVectorTest.cpp	/^  typedef isPropSwap<T> propagate_on_container_swap;$/;"	t	struct:Alloc	file:	access:public
Alloc::select_on_container_copy_construction	.\test\stl_tests\StlVectorTest.cpp	/^  Alloc select_on_container_copy_construction() const {$/;"	f	struct:Alloc	access:public	signature:() const
Alloc::size_type	.\test\stl_tests\StlVectorTest.cpp	/^  typedef typename std::allocator<T>::size_type size_type;$/;"	t	struct:Alloc	file:	access:public
Alloc::value_type	.\test\stl_tests\StlVectorTest.cpp	/^  typedef typename std::allocator<T>::value_type value_type;$/;"	t	struct:Alloc	file:	access:public
AllocAndSize	.\Arena.h	/^    explicit AllocAndSize(const Alloc& a, size_t s)$/;"	f	struct:folly::Arena::AllocAndSize	access:public	signature:(const Alloc& a, size_t s)
AllocAndSize	.\Arena.h	/^  struct AllocAndSize : public Alloc {$/;"	s	class:folly::Arena	inherits:Alloc	access:private
AllocTracker	.\test\stl_tests\StlVectorTest.cpp	/^struct AllocTracker {$/;"	s	file:
AllocTracker::Allocated	.\test\stl_tests\StlVectorTest.cpp	/^  static map<void*, size_t> Allocated;$/;"	m	struct:AllocTracker	file:	access:public
AllocTracker::Allocated	.\test\stl_tests\StlVectorTest.cpp	/^map<void*, size_t> AllocTracker::Allocated;$/;"	m	class:AllocTracker	file:
AllocTracker::Constructed	.\test\stl_tests\StlVectorTest.cpp	/^  static int Constructed;$/;"	m	struct:AllocTracker	file:	access:public
AllocTracker::Constructed	.\test\stl_tests\StlVectorTest.cpp	/^int AllocTracker::Constructed = 0;$/;"	m	class:AllocTracker	file:
AllocTracker::Destroyed	.\test\stl_tests\StlVectorTest.cpp	/^  static int Destroyed;$/;"	m	struct:AllocTracker	file:	access:public
AllocTracker::Destroyed	.\test\stl_tests\StlVectorTest.cpp	/^int AllocTracker::Destroyed = 0;$/;"	m	class:AllocTracker	file:
AllocTracker::Owner	.\test\stl_tests\StlVectorTest.cpp	/^  static map<void*, int> Owner;$/;"	m	struct:AllocTracker	file:	access:public
AllocTracker::Owner	.\test\stl_tests\StlVectorTest.cpp	/^map<void*, int> AllocTracker::Owner;$/;"	m	class:AllocTracker	file:
Allocated	.\test\stl_tests\StlVectorTest.cpp	/^  static map<void*, size_t> Allocated;$/;"	m	struct:AllocTracker	file:	access:public
Allocated	.\test\stl_tests\StlVectorTest.cpp	/^map<void*, size_t> AllocTracker::Allocated;$/;"	m	class:AllocTracker	file:
AllocatorUniquePtr	.\Memory.h	/^struct AllocatorUniquePtr {$/;"	s	namespace:folly
AmplificationProduct	.\detail\MPMCPipelineDetail.h	/^struct AmplificationProduct<std::tuple<T, Ts...>> {$/;"	s	namespace:folly::detail
AmplificationProduct	.\detail\MPMCPipelineDetail.h	/^template <> struct AmplificationProduct<std::tuple<>> {$/;"	s	namespace:folly::detail
AmplificationProduct	.\detail\MPMCPipelineDetail.h	/^template <class Tuple> struct AmplificationProduct;$/;"	x
AnonymousType	.\MemoryMapping.h	/^  enum AnonymousType {$/;"	g	class:folly::MemoryMapping	access:public
Any	.\gen\Base-inl.h	/^  Any() { }$/;"	f	class:folly::gen::detail::Any	access:public	signature:()
Any	.\gen\Base-inl.h	/^class Any : public Operator<Any> {$/;"	c	namespace:folly::gen::detail	inherits:Operator
Any	.\gen\Base.h	/^class Any;$/;"	x
Append	.\gen\Base-inl.h	/^  explicit Append(Collection* collection)$/;"	f	class:folly::gen::detail::Append	access:public	signature:(Collection* collection)
Append	.\gen\Base-inl.h	/^class Append : public Operator<Append<Collection>> {$/;"	c	namespace:folly::gen::detail	inherits:Operator
Append	.\gen\Base.h	/^class Append;$/;"	x
Appender	.\io\Cursor.h	/^  Appender(IOBuf* buf, uint64_t growth)$/;"	f	class:folly::io::Appender	access:public	signature:(IOBuf* buf, uint64_t growth)
Appender	.\io\Cursor.h	/^class Appender : public detail::Writable<Appender> {$/;"	c	namespace:folly::io	inherits:detail::Writable
ApplyConstVisitor	.\detail\DiscriminatedPtrDetail.h	/^struct ApplyConstVisitor$/;"	s	namespace:folly::dptr_detail	inherits:ApplyConstVisitor1
ApplyConstVisitor1	.\detail\DiscriminatedPtrDetail.h	/^struct ApplyConstVisitor1<V, R, T, Types...> {$/;"	s	namespace:folly::dptr_detail
ApplyConstVisitor1	.\detail\DiscriminatedPtrDetail.h	/^struct ApplyConstVisitor1<V, R> {$/;"	s	namespace:folly::dptr_detail
ApplyConstVisitor1	.\detail\DiscriminatedPtrDetail.h	/^template <typename V, typename R, typename... Types> struct ApplyConstVisitor1;$/;"	x
ApplyVisitor	.\detail\DiscriminatedPtrDetail.h	/^struct ApplyVisitor$/;"	s	namespace:folly::dptr_detail	inherits:ApplyVisitor1
ApplyVisitor1	.\detail\DiscriminatedPtrDetail.h	/^struct ApplyVisitor1<V, R, T, Types...> {$/;"	s	namespace:folly::dptr_detail
ApplyVisitor1	.\detail\DiscriminatedPtrDetail.h	/^struct ApplyVisitor1<V, R> {$/;"	s	namespace:folly::dptr_detail
ApplyVisitor1	.\detail\DiscriminatedPtrDetail.h	/^template <typename V, typename R, typename... Types> struct ApplyVisitor1;$/;"	x
Arena	.\Arena.h	/^  Arena(Arena&&) = default;$/;"	p	class:folly::Arena	access:private	signature:(Arena&&)
Arena	.\Arena.h	/^  Arena(const Arena&) = delete;$/;"	p	class:folly::Arena	access:private	signature:(const Arena&)
Arena	.\Arena.h	/^  explicit Arena(const Alloc& alloc,$/;"	f	class:folly::Arena	access:public	signature:(const Alloc& alloc, size_t minBlockSize = kDefaultMinBlockSize, size_t sizeLimit = kNoSizeLimit, size_t maxAlign = kDefaultMaxAlign)
Arena	.\Arena.h	/^class Arena {$/;"	c	namespace:folly
ArenaAllocatorTraits	.\Arena.h	/^struct ArenaAllocatorTraits {$/;"	s	namespace:folly
ArenaAllocatorTraits	.\Arena.h	/^struct ArenaAllocatorTraits<SysAlloc> {$/;"	s	namespace:folly
ArenaAllocatorTraits	.\Arena.h	/^template <class Alloc> struct ArenaAllocatorTraits;$/;"	x
ArenaTester	.\test\ThreadCachedArenaTest.cpp	/^  explicit ArenaTester(ThreadCachedArena& arena) : arena_(&arena) { }$/;"	f	class:__anon143::ArenaTester	access:public	signature:(ThreadCachedArena& arena)
ArenaTester	.\test\ThreadCachedArenaTest.cpp	/^class ArenaTester {$/;"	c	namespace:__anon143	file:
ArgumentReference	.\gen\Base-inl.h	/^struct ArgumentReference$/;"	s	namespace:folly::gen	inherits:std::conditional
Array	.\dynamic.h	/^  typedef std::vector<dynamic> Array;$/;"	t	struct:folly::dynamic	access:private
AsciiCaseInsensitive	.\Range.h	/^struct AsciiCaseInsensitive {$/;"	s	namespace:folly
AsciiCaseInsensitiveLegacy	.\test\AsciiCaseInsensitiveBenchmark.cpp	/^struct AsciiCaseInsensitiveLegacy {$/;"	s	file:
AsciiCaseInsensitiveLegacy::operator ()	.\test\AsciiCaseInsensitiveBenchmark.cpp	/^  bool operator()(char lhs, char rhs) const {$/;"	f	struct:AsciiCaseInsensitiveLegacy	access:public	signature:(char lhs, char rhs) const
AsciiCaseSensitive	.\Range.h	/^struct AsciiCaseSensitive {$/;"	s	namespace:folly
AsyncIO	.\experimental\io\AsyncIO.cpp	/^AsyncIO::AsyncIO(size_t capacity, PollMode pollMode)$/;"	f	class:folly::AsyncIO	signature:(size_t capacity, PollMode pollMode)
AsyncIO	.\experimental\io\AsyncIO.h	/^  explicit AsyncIO(size_t capacity, PollMode pollMode=NOT_POLLABLE);$/;"	p	class:folly::AsyncIO	access:public	signature:(size_t capacity, PollMode pollMode=NOT_POLLABLE)
AsyncIO	.\experimental\io\AsyncIO.h	/^  friend class AsyncIO;$/;"	x
AsyncIO	.\experimental\io\AsyncIO.h	/^class AsyncIO : private boost::noncopyable {$/;"	c	namespace:folly	inherits:boost::noncopyable
AsyncIOOp	.\experimental\io\AsyncIO.cpp	/^AsyncIOOp::AsyncIOOp(NotificationCallback cb)$/;"	f	class:folly::AsyncIOOp	signature:(NotificationCallback cb)
AsyncIOOp	.\experimental\io\AsyncIO.h	/^  explicit AsyncIOOp(NotificationCallback cb = NotificationCallback());$/;"	p	class:folly::AsyncIOOp	access:public	signature:(NotificationCallback cb = NotificationCallback())
AsyncIOOp	.\experimental\io\AsyncIO.h	/^class AsyncIOOp : private boost::noncopyable {$/;"	c	namespace:folly	inherits:boost::noncopyable
AsyncIOQueue	.\experimental\io\AsyncIO.cpp	/^AsyncIOQueue::AsyncIOQueue(AsyncIO* asyncIO)$/;"	f	class:folly::AsyncIOQueue	signature:(AsyncIO* asyncIO)
AsyncIOQueue	.\experimental\io\AsyncIO.h	/^  explicit AsyncIOQueue(AsyncIO* asyncIO);$/;"	p	class:folly::AsyncIOQueue	access:public	signature:(AsyncIO* asyncIO)
AsyncIOQueue	.\experimental\io\AsyncIO.h	/^class AsyncIOQueue {$/;"	c	namespace:folly
AsyncTimeout	.\io\async\AsyncTimeout.cpp	/^AsyncTimeout::AsyncTimeout(): timeoutManager_(nullptr) {$/;"	f	class:folly::AsyncTimeout	signature:()
AsyncTimeout	.\io\async\AsyncTimeout.cpp	/^AsyncTimeout::AsyncTimeout(EventBase* eventBase)$/;"	f	class:folly::AsyncTimeout	signature:(EventBase* eventBase)
AsyncTimeout	.\io\async\AsyncTimeout.cpp	/^AsyncTimeout::AsyncTimeout(EventBase* eventBase, InternalEnum internal)$/;"	f	class:folly::AsyncTimeout	signature:(EventBase* eventBase, InternalEnum internal)
AsyncTimeout	.\io\async\AsyncTimeout.cpp	/^AsyncTimeout::AsyncTimeout(TimeoutManager* timeoutManager)$/;"	f	class:folly::AsyncTimeout	signature:(TimeoutManager* timeoutManager)
AsyncTimeout	.\io\async\AsyncTimeout.cpp	/^AsyncTimeout::AsyncTimeout(TimeoutManager* timeoutManager,$/;"	f	class:folly::AsyncTimeout	signature:(TimeoutManager* timeoutManager, InternalEnum internal)
AsyncTimeout	.\io\async\AsyncTimeout.h	/^  AsyncTimeout();$/;"	p	class:folly::AsyncTimeout	access:public	signature:()
AsyncTimeout	.\io\async\AsyncTimeout.h	/^  AsyncTimeout(EventBase* eventBase, InternalEnum internal);$/;"	p	class:folly::AsyncTimeout	access:public	signature:(EventBase* eventBase, InternalEnum internal)
AsyncTimeout	.\io\async\AsyncTimeout.h	/^  AsyncTimeout(TimeoutManager* timeoutManager, InternalEnum internal);$/;"	p	class:folly::AsyncTimeout	access:public	signature:(TimeoutManager* timeoutManager, InternalEnum internal)
AsyncTimeout	.\io\async\AsyncTimeout.h	/^  explicit AsyncTimeout(EventBase* eventBase);$/;"	p	class:folly::AsyncTimeout	access:public	signature:(EventBase* eventBase)
AsyncTimeout	.\io\async\AsyncTimeout.h	/^  explicit AsyncTimeout(TimeoutManager* timeoutManager);$/;"	p	class:folly::AsyncTimeout	access:public	signature:(TimeoutManager* timeoutManager)
AsyncTimeout	.\io\async\AsyncTimeout.h	/^class AsyncTimeout : private boost::noncopyable {$/;"	c	namespace:folly	inherits:boost::noncopyable
AsyncTimeout	.\io\async\TimeoutManager.h	/^class AsyncTimeout;$/;"	x
AtomicBitSet	.\AtomicBitSet.h	/^  AtomicBitSet();$/;"	p	class:folly::AtomicBitSet	access:public	signature:()
AtomicBitSet	.\AtomicBitSet.h	/^class AtomicBitSet : private boost::noncopyable {$/;"	c	namespace:folly	inherits:boost::noncopyable
AtomicBitSet	.\AtomicBitSet.h	/^inline AtomicBitSet<N>::AtomicBitSet() : data_() {$/;"	f	class:folly::AtomicBitSet	signature:()
AtomicBlockType	.\AtomicBitSet.h	/^  typedef std::atomic<BlockType> AtomicBlockType;$/;"	t	class:folly::AtomicBitSet	access:private
AtomicHashArray	.\AtomicHashArray-inl.h	/^  friend class AtomicHashArray;$/;"	x
AtomicHashArray	.\AtomicHashArray-inl.h	/^AtomicHashArray(size_t capacity, KeyT emptyKey, KeyT lockedKey,$/;"	f	class:folly::AtomicHashArray	signature:(size_t capacity, KeyT emptyKey, KeyT lockedKey, KeyT erasedKey, double maxLoadFactor, size_t cacheSize)
AtomicHashArray	.\AtomicHashArray.h	/^  AtomicHashArray(size_t capacity, KeyT emptyKey, KeyT lockedKey,$/;"	p	class:folly::AtomicHashArray	access:private	signature:(size_t capacity, KeyT emptyKey, KeyT lockedKey, KeyT erasedKey, double maxLoadFactor, size_t cacheSize)
AtomicHashArray	.\AtomicHashArray.h	/^class AtomicHashArray : boost::noncopyable {$/;"	c	namespace:folly	inherits:boost::noncopyable
AtomicHashMap	.\AtomicHashArray.h	/^  friend class AtomicHashMap<KeyT, ValueT, HashFcn, EqualFcn, Allocator>;$/;"	x
AtomicHashMap	.\AtomicHashArray.h	/^class AtomicHashMap;$/;"	x
AtomicHashMap	.\AtomicHashMap-inl.h	/^  friend class AtomicHashMap;$/;"	x
AtomicHashMap	.\AtomicHashMap-inl.h	/^AtomicHashMap(size_t size, const Config& config)$/;"	f	class:folly::AtomicHashMap	signature:(size_t size, const Config& config)
AtomicHashMap	.\AtomicHashMap.h	/^  explicit AtomicHashMap(size_t finalSizeEst, const Config& = defaultConfig);$/;"	p	class:folly::AtomicHashMap	access:public	signature:(size_t finalSizeEst, const Config& = defaultConfig)
AtomicHashMap	.\AtomicHashMap.h	/^class AtomicHashMap : boost::noncopyable {$/;"	c	namespace:folly	inherits:boost::noncopyable
AtomicHashMapFullError	.\AtomicHashMap.h	/^  explicit AtomicHashMapFullError()$/;"	f	struct:folly::AtomicHashMapFullError	access:public	signature:()
AtomicHashMapFullError	.\AtomicHashMap.h	/^struct AtomicHashMapFullError : std::runtime_error {$/;"	s	namespace:folly	inherits:std::runtime_error
AtomicStruct	.\AtomicStruct.h	/^  AtomicStruct() = default;$/;"	p	class:folly::AtomicStruct	access:public	signature:()
AtomicStruct	.\AtomicStruct.h	/^  AtomicStruct(AtomicStruct<T> const &) = delete;$/;"	p	class:folly::AtomicStruct	access:public	signature:(AtomicStruct<T> const &)
AtomicStruct	.\AtomicStruct.h	/^class AtomicStruct {$/;"	c	namespace:folly
AtomicStructIntPick	.\AtomicStruct.h	/^template <> struct AtomicStructIntPick<1> { typedef uint8_t type; };$/;"	s	namespace:folly::detail
AtomicStructIntPick	.\AtomicStruct.h	/^template <> struct AtomicStructIntPick<2> { typedef uint16_t type; };$/;"	s	namespace:folly::detail
AtomicStructIntPick	.\AtomicStruct.h	/^template <> struct AtomicStructIntPick<3> { typedef uint32_t type; };$/;"	s	namespace:folly::detail
AtomicStructIntPick	.\AtomicStruct.h	/^template <> struct AtomicStructIntPick<4> { typedef uint32_t type; };$/;"	s	namespace:folly::detail
AtomicStructIntPick	.\AtomicStruct.h	/^template <> struct AtomicStructIntPick<5> { typedef uint64_t type; };$/;"	s	namespace:folly::detail
AtomicStructIntPick	.\AtomicStruct.h	/^template <> struct AtomicStructIntPick<6> { typedef uint64_t type; };$/;"	s	namespace:folly::detail
AtomicStructIntPick	.\AtomicStruct.h	/^template <> struct AtomicStructIntPick<7> { typedef uint64_t type; };$/;"	s	namespace:folly::detail
AtomicStructIntPick	.\AtomicStruct.h	/^template <> struct AtomicStructIntPick<8> { typedef uint64_t type; };$/;"	s	namespace:folly::detail
AtomicStructIntPick	.\AtomicStruct.h	/^template <int N> struct AtomicStructIntPick {};$/;"	s	namespace:folly::detail
Attribute	.\experimental\symbolizer\Dwarf.h	/^    struct Attribute {$/;"	s	struct:folly::symbolizer::Dwarf::DIEAbbreviation	access:public
AttributeValue	.\experimental\symbolizer\Dwarf.h	/^  typedef boost::variant<uint64_t, folly::StringPiece> AttributeValue;$/;"	t	class:folly::symbolizer::Dwarf	access:private
Available	.\io\Compression.cpp	/^size_t IOBufSnappySource::Available() const {$/;"	f	class:folly::io::__anon64::IOBufSnappySource	signature:() const
AvgFromBucket	.\stats\Histogram.h	/^  struct AvgFromBucket {$/;"	s	class:folly::Histogram	access:private
AvgFromInterval	.\stats\TimeseriesHistogram.h	/^    explicit AvgFromInterval(TimeType start, TimeType end)$/;"	f	struct:folly::TimeseriesHistogram::AvgFromInterval	access:public	signature:(TimeType start, TimeType end)
AvgFromInterval	.\stats\TimeseriesHistogram.h	/^  struct AvgFromInterval {$/;"	s	class:folly::TimeseriesHistogram	access:private
AvgFromLevel	.\stats\TimeseriesHistogram.h	/^    explicit AvgFromLevel(int level) : level_(level) {}$/;"	f	struct:folly::TimeseriesHistogram::AvgFromLevel	access:public	signature:(int level)
AvgFromLevel	.\stats\TimeseriesHistogram.h	/^  struct AvgFromLevel {$/;"	s	class:folly::TimeseriesHistogram	access:private
B	.\wangle\test\Thens.h	/^struct B {};$/;"	s
BENCHFUN	.\test\FBStringBenchmark.cpp	86;"	d	file:
BENCHFUN	.\test\FBStringTestBenchmarks.cpp.h	/^BENCHMARK_PARAM(BENCHFUN(assignmentFill), 0);$/;"	p	signature:(assignmentFill)
BENCHFUN	.\test\FBStringTestBenchmarks.cpp.h	/^BENCHMARK_PARAM(BENCHFUN(assignmentOp), 256);$/;"	p	signature:(assignmentOp)
BENCHFUN	.\test\FBStringTestBenchmarks.cpp.h	/^BENCHMARK_PARAM(BENCHFUN(copyCtor), 32768);$/;"	p	signature:(copyCtor)
BENCHFUN	.\test\FBStringTestBenchmarks.cpp.h	/^BENCHMARK_PARAM(BENCHFUN(ctorFromArray), 32768);$/;"	p	signature:(ctorFromArray)
BENCHFUN	.\test\FBStringTestBenchmarks.cpp.h	/^BENCHMARK_PARAM(BENCHFUN(ctorFromChar), 1048576);$/;"	p	signature:(ctorFromChar)
BENCHFUN	.\test\FBStringTestBenchmarks.cpp.h	/^BENCHMARK_PARAM(BENCHFUN(ctorFromTwoPointers), 0);$/;"	p	signature:(ctorFromTwoPointers)
BENCHFUN	.\test\FBStringTestBenchmarks.cpp.h	/^BENCHMARK_PARAM(BENCHFUN(ctorFromTwoPointers), 15);$/;"	p	signature:(ctorFromTwoPointers)
BENCHFUN	.\test\FBStringTestBenchmarks.cpp.h	/^BENCHMARK_PARAM(BENCHFUN(ctorFromTwoPointers), 23);$/;"	p	signature:(ctorFromTwoPointers)
BENCHFUN	.\test\FBStringTestBenchmarks.cpp.h	/^BENCHMARK_PARAM(BENCHFUN(ctorFromTwoPointers), 24);$/;"	p	signature:(ctorFromTwoPointers)
BENCHFUN	.\test\FBStringTestBenchmarks.cpp.h	/^BENCHMARK_PARAM(BENCHFUN(ctorFromTwoPointers), 7);$/;"	p	signature:(ctorFromTwoPointers)
BENCHFUN	.\test\FBStringTestBenchmarks.cpp.h	/^BENCHMARK_PARAM(BENCHFUN(defaultCtor), 0);$/;"	p	signature:(defaultCtor)
BENCHFUN	.\test\FBStringTestBenchmarks.cpp.h	/^BENCHMARK_PARAM(BENCHFUN(equality), 65536);$/;"	p	signature:(equality)
BENCHFUN	.\test\FBStringTestBenchmarks.cpp.h	/^BENCHMARK_PARAM(BENCHFUN(findSuccessful), 524288);$/;"	p	signature:(findSuccessful)
BENCHFUN	.\test\FBStringTestBenchmarks.cpp.h	/^BENCHMARK_PARAM(BENCHFUN(findUnsuccessful), 524288);$/;"	p	signature:(findUnsuccessful)
BENCHFUN	.\test\FBStringTestBenchmarks.cpp.h	/^BENCHMARK_PARAM(BENCHFUN(initRNG), 0);$/;"	p	signature:(initRNG)
BENCHFUN	.\test\FBStringTestBenchmarks.cpp.h	/^BENCHMARK_PARAM(BENCHFUN(push_back), 1);$/;"	p	signature:(push_back)
BENCHFUN	.\test\FBStringTestBenchmarks.cpp.h	/^BENCHMARK_PARAM(BENCHFUN(push_back), 1024);$/;"	p	signature:(push_back)
BENCHFUN	.\test\FBStringTestBenchmarks.cpp.h	/^BENCHMARK_PARAM(BENCHFUN(push_back), 127);$/;"	p	signature:(push_back)
BENCHFUN	.\test\FBStringTestBenchmarks.cpp.h	/^BENCHMARK_PARAM(BENCHFUN(push_back), 23);$/;"	p	signature:(push_back)
BENCHFUN	.\test\FBStringTestBenchmarks.cpp.h	/^BENCHMARK_PARAM(BENCHFUN(replace), 256);$/;"	p	signature:(replace)
BENCHFUN	.\test\FBStringTestBenchmarks.cpp.h	/^BENCHMARK_PARAM(BENCHFUN(resize), 524288);$/;"	p	signature:(resize)
BENCHFUN	.\test\FBStringTestBenchmarks.cpp.h	/^BENCHMARK_PARAM(BENCHFUN(short_append), 1024);$/;"	p	signature:(short_append)
BENCHFUN	.\test\FBStringTestBenchmarks.cpp.h	/^BENCHMARK_PARAM(BENCHFUN(short_append), 23);$/;"	p	signature:(short_append)
BENCHFUN	.\test\FBVectorBenchmark.cpp	87;"	d	file:
BENCHFUN	.\test\FBVectorTestBenchmarks.cpp.h	/^BENCHMARK(BENCHFUN(defaultCtor), iters) {$/;"	p	signature:(defaultCtor)
BENCHFUN	.\test\FBVectorTestBenchmarks.cpp.h	/^BENCHMARK(BENCHFUN(zzInitRNG), iters) {$/;"	p	signature:(zzInitRNG)
BENCHFUN	.\test\FBVectorTestBenchmarks.cpp.h	/^BENCHMARK_PARAM(BENCHFUN(erase), 1024);$/;"	p	signature:(erase)
BENCHFUN	.\test\FBVectorTestBenchmarks.cpp.h	/^BENCHMARK_PARAM(BENCHFUN(fillCtor), 1024);$/;"	p	signature:(fillCtor)
BENCHFUN	.\test\FBVectorTestBenchmarks.cpp.h	/^BENCHMARK_PARAM(BENCHFUN(fillCtor), 10240);$/;"	p	signature:(fillCtor)
BENCHFUN	.\test\FBVectorTestBenchmarks.cpp.h	/^BENCHMARK_PARAM(BENCHFUN(fillCtor), 128);$/;"	p	signature:(fillCtor)
BENCHFUN	.\test\FBVectorTestBenchmarks.cpp.h	/^BENCHMARK_PARAM(BENCHFUN(insert), 100);$/;"	p	signature:(insert)
BENCHFUN	.\test\FBVectorTestBenchmarks.cpp.h	/^BENCHMARK_PARAM(BENCHFUN(pushBack), 1024);$/;"	p	signature:(pushBack)
BENCHFUN	.\test\FBVectorTestBenchmarks.cpp.h	/^BENCHMARK_PARAM(BENCHFUN(pushBack), 10240);$/;"	p	signature:(pushBack)
BENCHFUN	.\test\FBVectorTestBenchmarks.cpp.h	/^BENCHMARK_PARAM(BENCHFUN(pushBack), 102400);$/;"	p	signature:(pushBack)
BENCHFUN	.\test\FBVectorTestBenchmarks.cpp.h	/^BENCHMARK_PARAM(BENCHFUN(pushBack), 128);$/;"	p	signature:(pushBack)
BENCHFUN	.\test\FBVectorTestBenchmarks.cpp.h	/^BENCHMARK_PARAM(BENCHFUN(pushBack), 512000);$/;"	p	signature:(pushBack)
BENCHFUN	.\test\FBVectorTestBenchmarks.cpp.h	/^BENCHMARK_PARAM(BENCHFUN(reserve), 1024);$/;"	p	signature:(reserve)
BENCHFUN	.\test\FBVectorTestBenchmarks.cpp.h	/^BENCHMARK_PARAM(BENCHFUN(reserve), 10240);$/;"	p	signature:(reserve)
BENCHFUN	.\test\FBVectorTestBenchmarks.cpp.h	/^BENCHMARK_PARAM(BENCHFUN(reserve), 128);$/;"	p	signature:(reserve)
BENCHFUN	.\test\FBVectorTestBenchmarks.cpp.h	/^BENCHMARK_PARAM(BENCHFUN(sizeCtor), 1024);$/;"	p	signature:(sizeCtor)
BENCHFUN	.\test\FBVectorTestBenchmarks.cpp.h	/^BENCHMARK_PARAM(BENCHFUN(sizeCtor), 1048576);$/;"	p	signature:(sizeCtor)
BENCHFUN	.\test\FBVectorTestBenchmarks.cpp.h	/^BENCHMARK_PARAM(BENCHFUN(sizeCtor), 128);$/;"	p	signature:(sizeCtor)
BENCHMARK	.\Benchmark.cpp	/^BENCHMARK(globalBenchmarkBaseline) {$/;"	f	namespace:folly	signature:(globalBenchmarkBaseline)
BENCHMARK	.\Benchmark.h	305;"	d
BENCHMARK	.\experimental\exception_tracer\ExceptionTracerBenchmark.cpp	/^BENCHMARK(ExceptionTracer, iters) {$/;"	f	signature:(ExceptionTracer, iters)
BENCHMARK	.\experimental\test\EliasFanoCodingTest.cpp	/^BENCHMARK(Encode_10) {$/;"	f	signature:(Encode_10)
BENCHMARK	.\experimental\test\EliasFanoCodingTest.cpp	/^BENCHMARK(Encode_1M) {$/;"	f	signature:(Encode_1M)
BENCHMARK	.\experimental\test\EliasFanoCodingTest.cpp	/^BENCHMARK(JumpTo_SkipQ128_1M) {$/;"	f	signature:(JumpTo_SkipQ128_1M)
BENCHMARK	.\experimental\test\EliasFanoCodingTest.cpp	/^BENCHMARK(Jump_ForwardQ128_1M) {$/;"	f	signature:(Jump_ForwardQ128_1M)
BENCHMARK	.\experimental\test\EliasFanoCodingTest.cpp	/^BENCHMARK(Next_1M) {$/;"	f	signature:(Next_1M)
BENCHMARK	.\experimental\test\EliasFanoCodingTest.cpp	/^BENCHMARK(Skip1000_ForwardQ128_1M) {$/;"	f	signature:(Skip1000_ForwardQ128_1M)
BENCHMARK	.\experimental\test\EliasFanoCodingTest.cpp	/^BENCHMARK(Skip100_ForwardQ128_1M) {$/;"	f	signature:(Skip100_ForwardQ128_1M)
BENCHMARK	.\experimental\test\EliasFanoCodingTest.cpp	/^BENCHMARK(Skip10_ForwarQ128_1M) {$/;"	f	signature:(Skip10_ForwarQ128_1M)
BENCHMARK	.\experimental\test\EliasFanoCodingTest.cpp	/^BENCHMARK(Skip1_ForwarQ128_1M) {$/;"	f	signature:(Skip1_ForwarQ128_1M)
BENCHMARK	.\experimental\test\EliasFanoCodingTest.cpp	/^BENCHMARK(SkipTo1000_SkipQ128_1M) {$/;"	f	signature:(SkipTo1000_SkipQ128_1M)
BENCHMARK	.\experimental\test\EliasFanoCodingTest.cpp	/^BENCHMARK(SkipTo100_SkipQ128_1M) {$/;"	f	signature:(SkipTo100_SkipQ128_1M)
BENCHMARK	.\experimental\test\EliasFanoCodingTest.cpp	/^BENCHMARK(SkipTo10_SkipQ128_1M) {$/;"	f	signature:(SkipTo10_SkipQ128_1M)
BENCHMARK	.\experimental\test\EliasFanoCodingTest.cpp	/^BENCHMARK(SkipTo1_SkipQ128_1M) {$/;"	f	signature:(SkipTo1_SkipQ128_1M)
BENCHMARK	.\experimental\test\SingletonTest.cpp	/^BENCHMARK(NormalSingleton, n) {$/;"	f	signature:(NormalSingleton, n)
BENCHMARK	.\gen\test\BaseBenchmark.cpp	/^BENCHMARK(Composed_NoGen, iters) {$/;"	f	signature:(Composed_NoGen, iters)
BENCHMARK	.\gen\test\BaseBenchmark.cpp	/^BENCHMARK(Concat_NoGen, iters) {$/;"	f	signature:(Concat_NoGen, iters)
BENCHMARK	.\gen\test\BaseBenchmark.cpp	/^BENCHMARK(Count_Vector_NoGen, iters) {$/;"	f	signature:(Count_Vector_NoGen, iters)
BENCHMARK	.\gen\test\BaseBenchmark.cpp	/^BENCHMARK(Fib_Sum_NoGen, iters) {$/;"	f	signature:(Fib_Sum_NoGen, iters)
BENCHMARK	.\gen\test\BaseBenchmark.cpp	/^BENCHMARK(Member, iters) {$/;"	f	signature:(Member, iters)
BENCHMARK	.\gen\test\BaseBenchmark.cpp	/^BENCHMARK(Sample, iters) {$/;"	f	signature:(Sample, iters)
BENCHMARK	.\gen\test\BaseBenchmark.cpp	/^BENCHMARK(Sum_Basic_NoGen, iters) {$/;"	f	signature:(Sum_Basic_NoGen, iters)
BENCHMARK	.\gen\test\BaseBenchmark.cpp	/^BENCHMARK(Sum_Vector_NoGen, iters) {$/;"	f	signature:(Sum_Vector_NoGen, iters)
BENCHMARK	.\gen\test\BaseBenchmark.cpp	/^BENCHMARK(VirtualGen_0Virtual, iters) {$/;"	f	signature:(VirtualGen_0Virtual, iters)
BENCHMARK	.\gen\test\FileBenchmark.cpp	/^BENCHMARK(ByLine_Pipes, iters) {$/;"	f	signature:(ByLine_Pipes, iters)
BENCHMARK	.\gen\test\ParallelMapBenchmark.cpp	/^BENCHMARK(FibSumMap, n) {$/;"	f	signature:(FibSumMap, n)
BENCHMARK	.\gen\test\StringBenchmark.cpp	/^BENCHMARK(Records_EachToTuple, iters) {$/;"	f	signature:(Records_EachToTuple, iters)
BENCHMARK	.\gen\test\StringBenchmark.cpp	/^BENCHMARK(StringResplitter_Big, iters) {$/;"	f	signature:(StringResplitter_Big, iters)
BENCHMARK	.\gen\test\StringBenchmark.cpp	/^BENCHMARK(StringSplit_Old, iters) {$/;"	f	signature:(StringSplit_Old, iters)
BENCHMARK	.\gen\test\StringBenchmark.cpp	/^BENCHMARK(StringSplit_Old_ReuseVector, iters) {$/;"	f	signature:(StringSplit_Old_ReuseVector, iters)
BENCHMARK	.\gen\test\StringBenchmark.cpp	/^BENCHMARK(StringUnsplit_Old, iters) {$/;"	f	signature:(StringUnsplit_Old, iters)
BENCHMARK	.\io\test\IOBufCursorTest.cpp	/^BENCHMARK(cursorBenchmark, iters) {$/;"	f	signature:(cursorBenchmark, iters)
BENCHMARK	.\io\test\IOBufCursorTest.cpp	/^BENCHMARK(rwPrivateCursorBenchmark, iters) {$/;"	f	signature:(rwPrivateCursorBenchmark, iters)
BENCHMARK	.\io\test\IOBufCursorTest.cpp	/^BENCHMARK(rwUnshareCursorBenchmark, iters) {$/;"	f	signature:(rwUnshareCursorBenchmark, iters)
BENCHMARK	.\io\test\IOBufCursorTest.cpp	/^BENCHMARK(skipBenchmark, iters) {$/;"	f	signature:(skipBenchmark, iters)
BENCHMARK	.\io\test\NetworkBenchmark.cpp	/^BENCHMARK(chainBenchmark, iters) {$/;"	f	signature:(chainBenchmark, iters)
BENCHMARK	.\io\test\NetworkBenchmark.cpp	/^BENCHMARK(poolBenchmark, iters) {$/;"	f	signature:(poolBenchmark, iters)
BENCHMARK	.\io\test\NetworkBenchmark.cpp	/^BENCHMARK(reserveBenchmark, iters) {$/;"	f	signature:(reserveBenchmark, iters)
BENCHMARK	.\test\AsciiCaseInsensitiveBenchmark.cpp	/^BENCHMARK(CurrentCaseInsensitiveCheck, iters) {$/;"	f	signature:(CurrentCaseInsensitiveCheck, iters)
BENCHMARK	.\test\AsciiCaseInsensitiveBenchmark.cpp	/^BENCHMARK(LegacyCaseInsensitiveCheck, iters) {$/;"	f	signature:(LegacyCaseInsensitiveCheck, iters)
BENCHMARK	.\test\AtomicHashMapTest.cpp	/^BENCHMARK(mt_aha_find, iters) {$/;"	f	signature:(mt_aha_find, iters)
BENCHMARK	.\test\AtomicHashMapTest.cpp	/^BENCHMARK(mt_ahm_find, iters) {$/;"	f	signature:(mt_ahm_find, iters)
BENCHMARK	.\test\AtomicHashMapTest.cpp	/^BENCHMARK(mt_ahm_find_insert_mix, iters) {$/;"	f	signature:(mt_ahm_find_insert_mix, iters)
BENCHMARK	.\test\AtomicHashMapTest.cpp	/^BENCHMARK(mt_ahm_insert, iters) {$/;"	f	signature:(mt_ahm_insert, iters)
BENCHMARK	.\test\AtomicHashMapTest.cpp	/^BENCHMARK(mt_ahm_miss, iters) {$/;"	f	signature:(mt_ahm_miss, iters)
BENCHMARK	.\test\AtomicHashMapTest.cpp	/^BENCHMARK(st_aha_find, iters) {$/;"	f	signature:(st_aha_find, iters)
BENCHMARK	.\test\AtomicHashMapTest.cpp	/^BENCHMARK(st_ahm_find, iters) {$/;"	f	signature:(st_ahm_find, iters)
BENCHMARK	.\test\AtomicHashMapTest.cpp	/^BENCHMARK(st_ahm_insert, iters) {$/;"	f	signature:(st_ahm_insert, iters)
BENCHMARK	.\test\AtomicHashMapTest.cpp	/^BENCHMARK(st_ahm_miss, iters) {$/;"	f	signature:(st_ahm_miss, iters)
BENCHMARK	.\test\AtomicHashMapTest.cpp	/^BENCHMARK(st_baseline_modulus_and_random, iters) {$/;"	f	signature:(st_baseline_modulus_and_random, iters)
BENCHMARK	.\test\BatonTest.cpp	/^BENCHMARK(baton_pingpong, iters) {$/;"	f	signature:(baton_pingpong, iters)
BENCHMARK	.\test\BatonTest.cpp	/^BENCHMARK(posix_sem_pingpong, iters) {$/;"	f	signature:(posix_sem_pingpong, iters)
BENCHMARK	.\test\BenchmarkTest.cpp	/^BENCHMARK(baselinevector) {$/;"	f	signature:(baselinevector)
BENCHMARK	.\test\BenchmarkTest.cpp	/^BENCHMARK(bmFun) { fun(); }$/;"	f	signature:(bmFun)
BENCHMARK	.\test\BenchmarkTest.cpp	/^BENCHMARK(bmRepeatedFun, n) {$/;"	f	signature:(bmRepeatedFun, n)
BENCHMARK	.\test\BenchmarkTest.cpp	/^BENCHMARK(gun) {$/;"	f	signature:(gun)
BENCHMARK	.\test\BenchmarkTest.cpp	/^BENCHMARK(noMulti) {$/;"	f	signature:(noMulti)
BENCHMARK	.\test\BenchmarkTest.cpp	/^BENCHMARK(superslow) {$/;"	f	signature:(superslow)
BENCHMARK	.\test\BitIteratorTest.cpp	/^BENCHMARK(RealFFSTest, iters) {$/;"	f	signature:(RealFFSTest, iters)
BENCHMARK	.\test\BitIteratorTest.cpp	/^BENCHMARK(SimpleFFSTest, iters) {$/;"	f	signature:(SimpleFFSTest, iters)
BENCHMARK	.\test\BitsTest.cpp	/^BENCHMARK(isPowTwo, iters) {$/;"	f	signature:(isPowTwo, iters)
BENCHMARK	.\test\BitsTest.cpp	/^BENCHMARK(nextPowTwoClz, iters) {$/;"	f	signature:(nextPowTwoClz, iters)
BENCHMARK	.\test\CacheLocalityTest.cpp	/^BENCHMARK(AccessSpreaderConstruction, iters) {$/;"	f	signature:(AccessSpreaderConstruction, iters)
BENCHMARK	.\test\CacheLocalityTest.cpp	/^BENCHMARK(LocalAccessSpreaderUse, iters) {$/;"	f	signature:(LocalAccessSpreaderUse, iters)
BENCHMARK	.\test\CacheLocalityTest.cpp	/^BENCHMARK(SharedAccessSpreaderUse, iters) {$/;"	f	signature:(SharedAccessSpreaderUse, iters)
BENCHMARK	.\test\ChecksumTest.cpp	/^BENCHMARK(crc32c_hardware_1KB_block, iters) {$/;"	f	signature:(crc32c_hardware_1KB_block, iters)
BENCHMARK	.\test\ChecksumTest.cpp	/^BENCHMARK(crc32c_hardware_512KB_block, iters) {$/;"	f	signature:(crc32c_hardware_512KB_block, iters)
BENCHMARK	.\test\ChecksumTest.cpp	/^BENCHMARK(crc32c_hardware_64KB_block, iters) {$/;"	f	signature:(crc32c_hardware_64KB_block, iters)
BENCHMARK	.\test\ChecksumTest.cpp	/^BENCHMARK(crc32c_software_1KB_block, iters) {$/;"	f	signature:(crc32c_software_1KB_block, iters)
BENCHMARK	.\test\ChecksumTest.cpp	/^BENCHMARK(crc32c_software_512KB_block, iters) {$/;"	f	signature:(crc32c_software_512KB_block, iters)
BENCHMARK	.\test\ChecksumTest.cpp	/^BENCHMARK(crc32c_software_64KB_block, iters) {$/;"	f	signature:(crc32c_software_64KB_block, iters)
BENCHMARK	.\test\ConcurrentSkipListBenchmark.cpp	/^BENCHMARK(Accessor, iters) {$/;"	f	namespace:__anon113	signature:(Accessor, iters)
BENCHMARK	.\test\ConcurrentSkipListBenchmark.cpp	/^BENCHMARK(accessorBasicRefcounting, iters) {$/;"	f	namespace:__anon113	signature:(accessorBasicRefcounting, iters)
BENCHMARK	.\test\ConvTest.cpp	/^BENCHMARK(preallocateTestFloat, n) {$/;"	f	signature:(preallocateTestFloat, n)
BENCHMARK	.\test\ConvTest.cpp	/^BENCHMARK(preallocateTestNoFloat, n) {$/;"	f	signature:(preallocateTestNoFloat, n)
BENCHMARK	.\test\ExceptionWrapperBenchmark.cpp	/^BENCHMARK(exception_ptr_create_and_test, iters) {$/;"	f	signature:(exception_ptr_create_and_test, iters)
BENCHMARK	.\test\ExceptionWrapperBenchmark.cpp	/^BENCHMARK(exception_ptr_create_and_test_concurrent, iters) {$/;"	f	signature:(exception_ptr_create_and_test_concurrent, iters)
BENCHMARK	.\test\ExceptionWrapperBenchmark.cpp	/^BENCHMARK(exception_ptr_create_and_throw, iters) {$/;"	f	signature:(exception_ptr_create_and_throw, iters)
BENCHMARK	.\test\ExceptionWrapperBenchmark.cpp	/^BENCHMARK(exception_ptr_create_and_throw_concurrent, iters) {$/;"	f	signature:(exception_ptr_create_and_throw_concurrent, iters)
BENCHMARK	.\test\ForeachTest.cpp	/^BENCHMARK(ForEachDescendingManual, iters) {$/;"	f	signature:(ForEachDescendingManual, iters)
BENCHMARK	.\test\ForeachTest.cpp	/^BENCHMARK(ForEachKVMacro, iters) {$/;"	f	signature:(ForEachKVMacro, iters)
BENCHMARK	.\test\ForeachTest.cpp	/^BENCHMARK(ForEachKVNoMacroAssign, iters) {$/;"	f	signature:(ForEachKVNoMacroAssign, iters)
BENCHMARK	.\test\ForeachTest.cpp	/^BENCHMARK(ForEachKVNoMacroNoAssign, iters) {$/;"	f	signature:(ForEachKVNoMacroNoAssign, iters)
BENCHMARK	.\test\ForeachTest.cpp	/^BENCHMARK(ForEachManual, iters) {$/;"	f	signature:(ForEachManual, iters)
BENCHMARK	.\test\ForeachTest.cpp	/^BENCHMARK(ForEachRange, iters) {$/;"	f	signature:(ForEachRange, iters)
BENCHMARK	.\test\ForeachTest.cpp	/^BENCHMARK(ForEachRangeR, iters) {$/;"	f	signature:(ForEachRangeR, iters)
BENCHMARK	.\test\ForeachTest.cpp	/^BENCHMARK(ManualLoopNoAssign, iters) {$/;"	f	signature:(ManualLoopNoAssign, iters)
BENCHMARK	.\test\FormatBenchmark.cpp	/^BENCHMARK(bigFormat_sprintf, iters) {$/;"	f	signature:(bigFormat_sprintf, iters)
BENCHMARK	.\test\FormatBenchmark.cpp	/^BENCHMARK(format_nested_strings, iters) {$/;"	f	signature:(format_nested_strings, iters)
BENCHMARK	.\test\FormatBenchmark.cpp	/^BENCHMARK(hex_sprintf, iters) {$/;"	f	signature:(hex_sprintf, iters)
BENCHMARK	.\test\FormatBenchmark.cpp	/^BENCHMARK(intAppend_sprintf) {$/;"	f	signature:(intAppend_sprintf)
BENCHMARK	.\test\FormatBenchmark.cpp	/^BENCHMARK(octal_sprintf, iters) {$/;"	f	signature:(octal_sprintf, iters)
BENCHMARK	.\test\IPAddressBenchmark.cpp	/^BENCHMARK(ipv4_to_string_inet_ntop, iters) {$/;"	f	signature:(ipv4_to_string_inet_ntop, iters)
BENCHMARK	.\test\IPAddressBenchmark.cpp	/^BENCHMARK(ipv6_to_string_inet_ntop, iters) {$/;"	f	signature:(ipv6_to_string_inet_ntop, iters)
BENCHMARK	.\test\JsonTest.cpp	/^BENCHMARK(jsonSerialize, iters) {$/;"	f	signature:(jsonSerialize, iters)
BENCHMARK	.\test\JsonTest.cpp	/^BENCHMARK(jsonSerializeWithNonAsciiEncoding, iters) {$/;"	f	signature:(jsonSerializeWithNonAsciiEncoding, iters)
BENCHMARK	.\test\JsonTest.cpp	/^BENCHMARK(jsonSerializeWithUtf8Validation, iters) {$/;"	f	signature:(jsonSerializeWithUtf8Validation, iters)
BENCHMARK	.\test\JsonTest.cpp	/^BENCHMARK(parseBigString, iters) {$/;"	f	signature:(parseBigString, iters)
BENCHMARK	.\test\JsonTest.cpp	/^BENCHMARK(parseNormalString, iters) {$/;"	f	signature:(parseNormalString, iters)
BENCHMARK	.\test\JsonTest.cpp	/^BENCHMARK(parseSmallStringWithUtf, iters) {$/;"	f	signature:(parseSmallStringWithUtf, iters)
BENCHMARK	.\test\JsonTest.cpp	/^BENCHMARK(toJson, iters) {$/;"	f	signature:(toJson, iters)
BENCHMARK	.\test\LifoSemTests.cpp	/^BENCHMARK(lifo_sem_oneway, iters) {$/;"	f	signature:(lifo_sem_oneway, iters)
BENCHMARK	.\test\LifoSemTests.cpp	/^BENCHMARK(lifo_sem_pingpong, iters) {$/;"	f	signature:(lifo_sem_pingpong, iters)
BENCHMARK	.\test\LifoSemTests.cpp	/^BENCHMARK(single_thread_lifo_post, iters) {$/;"	f	signature:(single_thread_lifo_post, iters)
BENCHMARK	.\test\LifoSemTests.cpp	/^BENCHMARK(single_thread_lifo_postwait, iters) {$/;"	f	signature:(single_thread_lifo_postwait, iters)
BENCHMARK	.\test\LifoSemTests.cpp	/^BENCHMARK(single_thread_lifo_trywait, iters) {$/;"	f	signature:(single_thread_lifo_trywait, iters)
BENCHMARK	.\test\LifoSemTests.cpp	/^BENCHMARK(single_thread_lifo_wait, iters) {$/;"	f	signature:(single_thread_lifo_wait, iters)
BENCHMARK	.\test\LifoSemTests.cpp	/^BENCHMARK(single_thread_posix_postwait, iters) {$/;"	f	signature:(single_thread_posix_postwait, iters)
BENCHMARK	.\test\LifoSemTests.cpp	/^BENCHMARK(single_thread_posix_trywait, iters) {$/;"	f	signature:(single_thread_posix_trywait, iters)
BENCHMARK	.\test\LoggingTest.cpp	/^BENCHMARK(dev_null_log_overhead, iter) {$/;"	f	signature:(dev_null_log_overhead, iter)
BENCHMARK	.\test\LoggingTest.cpp	/^BENCHMARK(skip_overhead, iter) {$/;"	f	signature:(skip_overhead, iter)
BENCHMARK	.\test\MemoryIdlerTest.cpp	/^BENCHMARK(releaseMallocTLS, iters) {$/;"	f	signature:(releaseMallocTLS, iters)
BENCHMARK	.\test\MemoryIdlerTest.cpp	/^BENCHMARK(releaseStack, iters) {$/;"	f	signature:(releaseStack, iters)
BENCHMARK	.\test\RandomTest.cpp	/^BENCHMARK(Random32) { doNotOptimizeAway(Random::rand32()); }$/;"	f	signature:(Random32)
BENCHMARK	.\test\RandomTest.cpp	/^BENCHMARK(Random32Num) { doNotOptimizeAway(Random::rand32(100)); }$/;"	f	signature:(Random32Num)
BENCHMARK	.\test\RandomTest.cpp	/^BENCHMARK(Random64) { doNotOptimizeAway(Random::rand64()); }$/;"	f	signature:(Random64)
BENCHMARK	.\test\RandomTest.cpp	/^BENCHMARK(Random64Num) { doNotOptimizeAway(Random::rand64(100ul << 32)); }$/;"	f	signature:(Random64Num)
BENCHMARK	.\test\RandomTest.cpp	/^BENCHMARK(Random64OneIn) { doNotOptimizeAway(Random::oneIn(100)); }$/;"	f	signature:(Random64OneIn)
BENCHMARK	.\test\RandomTest.cpp	/^BENCHMARK(RandomDouble) { doNotOptimizeAway(Random::randDouble01()); }$/;"	f	signature:(RandomDouble)
BENCHMARK	.\test\RandomTest.cpp	/^BENCHMARK(minstdrand, n) {$/;"	f	signature:(minstdrand, n)
BENCHMARK	.\test\RandomTest.cpp	/^BENCHMARK(mt19937, n) {$/;"	f	signature:(mt19937, n)
BENCHMARK	.\test\RandomTest.cpp	/^BENCHMARK(threadprng, n) {$/;"	f	signature:(threadprng, n)
BENCHMARK	.\test\RangeFindBenchmark.cpp	/^BENCHMARK(FindFirstOf16NeedlesBase, n) {$/;"	f	signature:(FindFirstOf16NeedlesBase, n)
BENCHMARK	.\test\RangeFindBenchmark.cpp	/^BENCHMARK(FindFirstOf2NeedlesBase, n) {$/;"	f	signature:(FindFirstOf2NeedlesBase, n)
BENCHMARK	.\test\RangeFindBenchmark.cpp	/^BENCHMARK(FindFirstOf32NeedlesBase, n) {$/;"	f	signature:(FindFirstOf32NeedlesBase, n)
BENCHMARK	.\test\RangeFindBenchmark.cpp	/^BENCHMARK(FindFirstOf4NeedlesBase, n) {$/;"	f	signature:(FindFirstOf4NeedlesBase, n)
BENCHMARK	.\test\RangeFindBenchmark.cpp	/^BENCHMARK(FindFirstOf64NeedlesBase, n) {$/;"	f	signature:(FindFirstOf64NeedlesBase, n)
BENCHMARK	.\test\RangeFindBenchmark.cpp	/^BENCHMARK(FindFirstOf8NeedlesBase, n) {$/;"	f	signature:(FindFirstOf8NeedlesBase, n)
BENCHMARK	.\test\RangeFindBenchmark.cpp	/^BENCHMARK(FindFirstOfOffsetRange, n) {$/;"	f	signature:(FindFirstOfOffsetRange, n)
BENCHMARK	.\test\RangeFindBenchmark.cpp	/^BENCHMARK(FindFirstOfRandomBase, n) {$/;"	f	signature:(FindFirstOfRandomBase, n)
BENCHMARK	.\test\RangeFindBenchmark.cpp	/^BENCHMARK(FindSingleCharMemchr, n) {$/;"	f	signature:(FindSingleCharMemchr, n)
BENCHMARK	.\test\StringBenchmark.cpp	/^BENCHMARK(folly_toLowerAscii, iters) {$/;"	f	signature:(folly_toLowerAscii, iters)
BENCHMARK	.\test\StringBenchmark.cpp	/^BENCHMARK(libc_tolower, iters) {$/;"	f	signature:(libc_tolower, iters)
BENCHMARK	.\test\StringTest.cpp	/^BENCHMARK(BM_cEscape, iters) {$/;"	f	namespace:__anon136	signature:(BM_cEscape, iters)
BENCHMARK	.\test\StringTest.cpp	/^BENCHMARK(BM_cUnescape, iters) {$/;"	f	namespace:__anon136	signature:(BM_cUnescape, iters)
BENCHMARK	.\test\StringTest.cpp	/^BENCHMARK(BM_uriEscape, iters) {$/;"	f	namespace:__anon136	signature:(BM_uriEscape, iters)
BENCHMARK	.\test\StringTest.cpp	/^BENCHMARK(BM_uriUnescape, iters) {$/;"	f	namespace:__anon136	signature:(BM_uriUnescape, iters)
BENCHMARK	.\test\StringTest.cpp	/^BENCHMARK(boost_splitOnSingleChar, iters) {$/;"	f	signature:(boost_splitOnSingleChar, iters)
BENCHMARK	.\test\StringTest.cpp	/^BENCHMARK(joinCharStr, iters) {$/;"	f	signature:(joinCharStr, iters)
BENCHMARK	.\test\StringTest.cpp	/^BENCHMARK(joinInt, iters) {$/;"	f	signature:(joinInt, iters)
BENCHMARK	.\test\StringTest.cpp	/^BENCHMARK(joinStrStr, iters) {$/;"	f	signature:(joinStrStr, iters)
BENCHMARK	.\test\StringTest.cpp	/^BENCHMARK(new_stringPrintfSmall, iters) {$/;"	f	signature:(new_stringPrintfSmall, iters)
BENCHMARK	.\test\StringTest.cpp	/^BENCHMARK(splitOnSingleChar, iters) {$/;"	f	signature:(splitOnSingleChar, iters)
BENCHMARK	.\test\StringTest.cpp	/^BENCHMARK(splitOnSingleCharFixed, iters) {$/;"	f	signature:(splitOnSingleCharFixed, iters)
BENCHMARK	.\test\StringTest.cpp	/^BENCHMARK(splitOnSingleCharFixedAllowExtra, iters) {$/;"	f	signature:(splitOnSingleCharFixedAllowExtra, iters)
BENCHMARK	.\test\StringTest.cpp	/^BENCHMARK(splitStr, iters) {$/;"	f	signature:(splitStr, iters)
BENCHMARK	.\test\StringTest.cpp	/^BENCHMARK(splitStrFixed, iters) {$/;"	f	signature:(splitStrFixed, iters)
BENCHMARK	.\test\ThreadCachedArenaTest.cpp	/^BENCHMARK(bmMArena, iters) {$/;"	f	namespace:__anon144	signature:(bmMArena, iters)
BENCHMARK	.\test\ThreadCachedArenaTest.cpp	/^BENCHMARK(bmMStandard, iters) {$/;"	f	namespace:__anon144	signature:(bmMStandard, iters)
BENCHMARK	.\test\ThreadCachedArenaTest.cpp	/^BENCHMARK(bmUMArena, iters) {$/;"	f	namespace:__anon144	signature:(bmUMArena, iters)
BENCHMARK	.\test\ThreadCachedArenaTest.cpp	/^BENCHMARK(bmUMStandard, iters) {$/;"	f	namespace:__anon144	signature:(bmUMStandard, iters)
BENCHMARK	.\test\ThreadCachedIntTest.cpp	/^BENCHMARK(Atomic_readFull) {$/;"	f	signature:(Atomic_readFull)
BENCHMARK	.\test\ThreadCachedIntTest.cpp	/^BENCHMARK(Sharded_readFast) {$/;"	f	signature:(Sharded_readFast)
BENCHMARK	.\test\ThreadCachedIntTest.cpp	/^BENCHMARK(Sharded_readFull) {$/;"	f	signature:(Sharded_readFull)
BENCHMARK	.\test\ThreadCachedIntTest.cpp	/^BENCHMARK(ThrCache_readFast) {$/;"	f	signature:(ThrCache_readFast)
BENCHMARK	.\test\ThreadCachedIntTest.cpp	/^BENCHMARK(ThrCache_readFull) {$/;"	f	signature:(ThrCache_readFull)
BENCHMARK	.\test\VarintTest.cpp	/^BENCHMARK(VarintDecoding, iters) {$/;"	f	namespace:folly::test::__anon149	signature:(VarintDecoding, iters)
BENCHMARK	.\test\VarintTest.cpp	/^BENCHMARK(VarintEncoding, iters) {$/;"	f	namespace:folly::test::__anon149	signature:(VarintEncoding, iters)
BENCHMARK	.\test\function_benchmark\main.cpp	/^BENCHMARK(catch_no_exception, iters) {$/;"	f	signature:(catch_no_exception, iters)
BENCHMARK	.\test\function_benchmark\main.cpp	/^BENCHMARK(exc_ptr_param_return, iters) {$/;"	f	signature:(exc_ptr_param_return, iters)
BENCHMARK	.\test\function_benchmark\main.cpp	/^BENCHMARK(exc_ptr_param_return_null, iters) {$/;"	f	signature:(exc_ptr_param_return_null, iters)
BENCHMARK	.\test\function_benchmark\main.cpp	/^BENCHMARK(fn_invoke, iters) {$/;"	f	signature:(fn_invoke, iters)
BENCHMARK	.\test\function_benchmark\main.cpp	/^BENCHMARK(fn_ptr_create_invoke, iters) {$/;"	f	signature:(fn_ptr_create_invoke, iters)
BENCHMARK	.\test\function_benchmark\main.cpp	/^BENCHMARK(fn_ptr_invoke, iters) {$/;"	f	signature:(fn_ptr_invoke, iters)
BENCHMARK	.\test\function_benchmark\main.cpp	/^BENCHMARK(fn_ptr_invoke_through_inline, iters) {$/;"	f	signature:(fn_ptr_invoke_through_inline, iters)
BENCHMARK	.\test\function_benchmark\main.cpp	/^BENCHMARK(fn_ptr_invoke_through_template, iters) {$/;"	f	signature:(fn_ptr_invoke_through_template, iters)
BENCHMARK	.\test\function_benchmark\main.cpp	/^BENCHMARK(lambda_invoke_fn, iters) {$/;"	f	signature:(lambda_invoke_fn, iters)
BENCHMARK	.\test\function_benchmark\main.cpp	/^BENCHMARK(lambda_local_var, iters) {$/;"	f	signature:(lambda_local_var, iters)
BENCHMARK	.\test\function_benchmark\main.cpp	/^BENCHMARK(lambda_noop, iters) {$/;"	f	signature:(lambda_noop, iters)
BENCHMARK	.\test\function_benchmark\main.cpp	/^BENCHMARK(mem_fn_create_invoke, iters) {$/;"	f	signature:(mem_fn_create_invoke, iters)
BENCHMARK	.\test\function_benchmark\main.cpp	/^BENCHMARK(mem_fn_invoke, iters) {$/;"	f	signature:(mem_fn_invoke, iters)
BENCHMARK	.\test\function_benchmark\main.cpp	/^BENCHMARK(return_code, iters) {$/;"	f	signature:(return_code, iters)
BENCHMARK	.\test\function_benchmark\main.cpp	/^BENCHMARK(return_code_noexcept, iters) {$/;"	f	signature:(return_code_noexcept, iters)
BENCHMARK	.\test\function_benchmark\main.cpp	/^BENCHMARK(return_exc_ptr, iters) {$/;"	f	signature:(return_exc_ptr, iters)
BENCHMARK	.\test\function_benchmark\main.cpp	/^BENCHMARK(return_string, iters) {$/;"	f	signature:(return_string, iters)
BENCHMARK	.\test\function_benchmark\main.cpp	/^BENCHMARK(return_string_noexcept, iters) {$/;"	f	signature:(return_string_noexcept, iters)
BENCHMARK	.\test\function_benchmark\main.cpp	/^BENCHMARK(scope_guard_fn_ptr, iters) {$/;"	f	signature:(scope_guard_fn_ptr, iters)
BENCHMARK	.\test\function_benchmark\main.cpp	/^BENCHMARK(scope_guard_lambda_function, iters) {$/;"	f	signature:(scope_guard_lambda_function, iters)
BENCHMARK	.\test\function_benchmark\main.cpp	/^BENCHMARK(scope_guard_lambda_local_var, iters) {$/;"	f	signature:(scope_guard_lambda_local_var, iters)
BENCHMARK	.\test\function_benchmark\main.cpp	/^BENCHMARK(scope_guard_lambda_noop, iters) {$/;"	f	signature:(scope_guard_lambda_noop, iters)
BENCHMARK	.\test\function_benchmark\main.cpp	/^BENCHMARK(scope_guard_std_function, iters) {$/;"	f	signature:(scope_guard_std_function, iters)
BENCHMARK	.\test\function_benchmark\main.cpp	/^BENCHMARK(scope_guard_std_function_rvalue, iters) {$/;"	f	signature:(scope_guard_std_function_rvalue, iters)
BENCHMARK	.\test\function_benchmark\main.cpp	/^BENCHMARK(std_bind_create_invoke, iters) {$/;"	f	signature:(std_bind_create_invoke, iters)
BENCHMARK	.\test\function_benchmark\main.cpp	/^BENCHMARK(std_bind_direct_invoke, iters) {$/;"	f	signature:(std_bind_direct_invoke, iters)
BENCHMARK	.\test\function_benchmark\main.cpp	/^BENCHMARK(std_function_create_invoke, iters) {$/;"	f	signature:(std_function_create_invoke, iters)
BENCHMARK	.\test\function_benchmark\main.cpp	/^BENCHMARK(std_function_invoke, iters) {$/;"	f	signature:(std_function_invoke, iters)
BENCHMARK	.\test\function_benchmark\main.cpp	/^BENCHMARK(throw_exception, iters) {$/;"	f	signature:(throw_exception, iters)
BENCHMARK	.\test\function_benchmark\main.cpp	/^BENCHMARK(virtual_fn_invoke, iters) {$/;"	f	signature:(virtual_fn_invoke, iters)
BENCHMARK_DRAW_LINE	.\Benchmark.h	498;"	d
BENCHMARK_DRAW_LINE	.\test\ConcurrentSkipListBenchmark.cpp	/^BENCHMARK_DRAW_LINE();$/;"	p	namespace:__anon113	file:	signature:()
BENCHMARK_DRAW_LINE	.\test\ProducerConsumerQueueBenchmark.cpp	/^BENCHMARK_DRAW_LINE();$/;"	p	namespace:__anon127	file:	signature:()
BENCHMARK_IMPL	.\Benchmark.h	264;"	d
BENCHMARK_IMPL_H_	.\test\function_benchmark\benchmark_impl.h	3;"	d
BENCHMARK_MULTI	.\Benchmark.h	328;"	d
BENCHMARK_MULTI	.\test\BenchmarkTest.cpp	/^BENCHMARK_MULTI(multiIterArgs, iter) {$/;"	f	signature:(multiIterArgs, iter)
BENCHMARK_MULTI	.\test\BenchmarkTest.cpp	/^BENCHMARK_MULTI(multiSimple) {$/;"	f	signature:(multiSimple)
BENCHMARK_MULTI_IMPL	.\Benchmark.h	278;"	d
BENCHMARK_NAMED_PARAM	.\Benchmark.h	390;"	d
BENCHMARK_NAMED_PARAM_MULTI	.\Benchmark.h	404;"	d
BENCHMARK_PARAM	.\Benchmark.h	357;"	d
BENCHMARK_PARAM	.\test\ConcurrentSkipListBenchmark.cpp	/^BENCHMARK_PARAM(BM_AddSet,      1000);$/;"	p	namespace:__anon113	file:	signature:(BM_AddSet, 1000)
BENCHMARK_PARAM	.\test\ConcurrentSkipListBenchmark.cpp	/^BENCHMARK_PARAM(BM_AddSet,      1000000);$/;"	p	namespace:__anon113	file:	signature:(BM_AddSet, 1000000)
BENCHMARK_PARAM	.\test\ConcurrentSkipListBenchmark.cpp	/^BENCHMARK_PARAM(BM_AddSet,      65536);$/;"	p	namespace:__anon113	file:	signature:(BM_AddSet, 65536)
BENCHMARK_PARAM	.\test\ConcurrentSkipListBenchmark.cpp	/^BENCHMARK_PARAM(BM_AddSkipList, 1000);$/;"	p	namespace:__anon113	file:	signature:(BM_AddSkipList, 1000)
BENCHMARK_PARAM	.\test\ConcurrentSkipListBenchmark.cpp	/^BENCHMARK_PARAM(BM_AddSkipList, 1000000);$/;"	p	namespace:__anon113	file:	signature:(BM_AddSkipList, 1000000)
BENCHMARK_PARAM	.\test\ConcurrentSkipListBenchmark.cpp	/^BENCHMARK_PARAM(BM_AddSkipList, 65536);$/;"	p	namespace:__anon113	file:	signature:(BM_AddSkipList, 65536)
BENCHMARK_PARAM	.\test\ConcurrentSkipListBenchmark.cpp	/^BENCHMARK_PARAM(BM_CSLContainsFound, 1000);$/;"	p	namespace:__anon113	file:	signature:(BM_CSLContainsFound, 1000)
BENCHMARK_PARAM	.\test\ConcurrentSkipListBenchmark.cpp	/^BENCHMARK_PARAM(BM_CSLContainsFound, 100000);$/;"	p	namespace:__anon113	file:	signature:(BM_CSLContainsFound, 100000)
BENCHMARK_PARAM	.\test\ConcurrentSkipListBenchmark.cpp	/^BENCHMARK_PARAM(BM_CSLContainsFound, 1000000);$/;"	p	namespace:__anon113	file:	signature:(BM_CSLContainsFound, 1000000)
BENCHMARK_PARAM	.\test\ConcurrentSkipListBenchmark.cpp	/^BENCHMARK_PARAM(BM_CSLContainsFound, 10000000);$/;"	p	namespace:__anon113	file:	signature:(BM_CSLContainsFound, 10000000)
BENCHMARK_PARAM	.\test\ConcurrentSkipListBenchmark.cpp	/^BENCHMARK_PARAM(BM_CSLContainsNotFound, 1000);$/;"	p	namespace:__anon113	file:	signature:(BM_CSLContainsNotFound, 1000)
BENCHMARK_PARAM	.\test\ConcurrentSkipListBenchmark.cpp	/^BENCHMARK_PARAM(BM_CSLContainsNotFound, 100000);$/;"	p	namespace:__anon113	file:	signature:(BM_CSLContainsNotFound, 100000)
BENCHMARK_PARAM	.\test\ConcurrentSkipListBenchmark.cpp	/^BENCHMARK_PARAM(BM_CSLContainsNotFound, 1000000);$/;"	p	namespace:__anon113	file:	signature:(BM_CSLContainsNotFound, 1000000)
BENCHMARK_PARAM	.\test\ConcurrentSkipListBenchmark.cpp	/^BENCHMARK_PARAM(BM_CSLMergeIntersection, 1000);$/;"	p	namespace:__anon113	file:	signature:(BM_CSLMergeIntersection, 1000)
BENCHMARK_PARAM	.\test\ConcurrentSkipListBenchmark.cpp	/^BENCHMARK_PARAM(BM_CSLMergeIntersection, 1000000);$/;"	p	namespace:__anon113	file:	signature:(BM_CSLMergeIntersection, 1000000)
BENCHMARK_PARAM	.\test\ConcurrentSkipListBenchmark.cpp	/^BENCHMARK_PARAM(BM_CSLMergeIntersection, 65536);$/;"	p	namespace:__anon113	file:	signature:(BM_CSLMergeIntersection, 65536)
BENCHMARK_PARAM	.\test\ConcurrentSkipListBenchmark.cpp	/^BENCHMARK_PARAM(BM_CSLMergeLookup,       1000);$/;"	p	namespace:__anon113	file:	signature:(BM_CSLMergeLookup, 1000)
BENCHMARK_PARAM	.\test\ConcurrentSkipListBenchmark.cpp	/^BENCHMARK_PARAM(BM_CSLMergeLookup,       1000000);$/;"	p	namespace:__anon113	file:	signature:(BM_CSLMergeLookup, 1000000)
BENCHMARK_PARAM	.\test\ConcurrentSkipListBenchmark.cpp	/^BENCHMARK_PARAM(BM_CSLMergeLookup,       65536);$/;"	p	namespace:__anon113	file:	signature:(BM_CSLMergeLookup, 65536)
BENCHMARK_PARAM	.\test\ConcurrentSkipListBenchmark.cpp	/^BENCHMARK_PARAM(BM_ContentionCSL,    1024);$/;"	p	namespace:__anon113	file:	signature:(BM_ContentionCSL, 1024)
BENCHMARK_PARAM	.\test\ConcurrentSkipListBenchmark.cpp	/^BENCHMARK_PARAM(BM_ContentionCSL,    1048576);$/;"	p	namespace:__anon113	file:	signature:(BM_ContentionCSL, 1048576)
BENCHMARK_PARAM	.\test\ConcurrentSkipListBenchmark.cpp	/^BENCHMARK_PARAM(BM_ContentionCSL,    65536);$/;"	p	namespace:__anon113	file:	signature:(BM_ContentionCSL, 65536)
BENCHMARK_PARAM	.\test\ConcurrentSkipListBenchmark.cpp	/^BENCHMARK_PARAM(BM_ContentionStdSet, 1024);$/;"	p	namespace:__anon113	file:	signature:(BM_ContentionStdSet, 1024)
BENCHMARK_PARAM	.\test\ConcurrentSkipListBenchmark.cpp	/^BENCHMARK_PARAM(BM_ContentionStdSet, 1048576);$/;"	p	namespace:__anon113	file:	signature:(BM_ContentionStdSet, 1048576)
BENCHMARK_PARAM	.\test\ConcurrentSkipListBenchmark.cpp	/^BENCHMARK_PARAM(BM_ContentionStdSet, 65536);$/;"	p	namespace:__anon113	file:	signature:(BM_ContentionStdSet, 65536)
BENCHMARK_PARAM	.\test\ConcurrentSkipListBenchmark.cpp	/^BENCHMARK_PARAM(BM_IterateOverSet,  1000);$/;"	p	namespace:__anon113	file:	signature:(BM_IterateOverSet, 1000)
BENCHMARK_PARAM	.\test\ConcurrentSkipListBenchmark.cpp	/^BENCHMARK_PARAM(BM_IterateOverSet,  1000000);$/;"	p	namespace:__anon113	file:	signature:(BM_IterateOverSet, 1000000)
BENCHMARK_PARAM	.\test\ConcurrentSkipListBenchmark.cpp	/^BENCHMARK_PARAM(BM_IterateSkipList, 1000);$/;"	p	namespace:__anon113	file:	signature:(BM_IterateSkipList, 1000)
BENCHMARK_PARAM	.\test\ConcurrentSkipListBenchmark.cpp	/^BENCHMARK_PARAM(BM_IterateSkipList, 1000000);$/;"	p	namespace:__anon113	file:	signature:(BM_IterateSkipList, 1000000)
BENCHMARK_PARAM	.\test\ConcurrentSkipListBenchmark.cpp	/^BENCHMARK_PARAM(BM_SetContainsFound, 1000);$/;"	p	namespace:__anon113	file:	signature:(BM_SetContainsFound, 1000)
BENCHMARK_PARAM	.\test\ConcurrentSkipListBenchmark.cpp	/^BENCHMARK_PARAM(BM_SetContainsFound, 100000);$/;"	p	namespace:__anon113	file:	signature:(BM_SetContainsFound, 100000)
BENCHMARK_PARAM	.\test\ConcurrentSkipListBenchmark.cpp	/^BENCHMARK_PARAM(BM_SetContainsFound, 1000000);$/;"	p	namespace:__anon113	file:	signature:(BM_SetContainsFound, 1000000)
BENCHMARK_PARAM	.\test\ConcurrentSkipListBenchmark.cpp	/^BENCHMARK_PARAM(BM_SetContainsFound, 10000000);$/;"	p	namespace:__anon113	file:	signature:(BM_SetContainsFound, 10000000)
BENCHMARK_PARAM	.\test\ConcurrentSkipListBenchmark.cpp	/^BENCHMARK_PARAM(BM_SetContainsNotFound, 1000);$/;"	p	namespace:__anon113	file:	signature:(BM_SetContainsNotFound, 1000)
BENCHMARK_PARAM	.\test\ConcurrentSkipListBenchmark.cpp	/^BENCHMARK_PARAM(BM_SetContainsNotFound, 100000);$/;"	p	namespace:__anon113	file:	signature:(BM_SetContainsNotFound, 100000)
BENCHMARK_PARAM	.\test\ConcurrentSkipListBenchmark.cpp	/^BENCHMARK_PARAM(BM_SetContainsNotFound, 1000000);$/;"	p	namespace:__anon113	file:	signature:(BM_SetContainsNotFound, 1000000)
BENCHMARK_PARAM	.\test\ConcurrentSkipListBenchmark.cpp	/^BENCHMARK_PARAM(BM_SetMerge,             1000);$/;"	p	namespace:__anon113	file:	signature:(BM_SetMerge, 1000)
BENCHMARK_PARAM	.\test\ConcurrentSkipListBenchmark.cpp	/^BENCHMARK_PARAM(BM_SetMerge,             1000000);$/;"	p	namespace:__anon113	file:	signature:(BM_SetMerge, 1000000)
BENCHMARK_PARAM	.\test\ConcurrentSkipListBenchmark.cpp	/^BENCHMARK_PARAM(BM_SetMerge,             65536);$/;"	p	namespace:__anon113	file:	signature:(BM_SetMerge, 65536)
BENCHMARK_PARAM	.\test\ProducerConsumerQueueBenchmark.cpp	/^BENCHMARK_PARAM(BM_ProducerConsumer, 1048574);$/;"	p	namespace:__anon127	file:	signature:(BM_ProducerConsumer, 1048574)
BENCHMARK_PARAM	.\test\ProducerConsumerQueueBenchmark.cpp	/^BENCHMARK_PARAM(BM_ProducerConsumerAffinity, 1048574);$/;"	p	namespace:__anon127	file:	signature:(BM_ProducerConsumerAffinity, 1048574)
BENCHMARK_PARAM	.\test\ProducerConsumerQueueBenchmark.cpp	/^BENCHMARK_PARAM(BM_ProducerConsumerLatency, 1048574);$/;"	p	namespace:__anon127	file:	signature:(BM_ProducerConsumerLatency, 1048574)
BENCHMARK_PARAM_MULTI	.\Benchmark.h	364;"	d
BENCHMARK_RELATIVE	.\Benchmark.h	437;"	d
BENCHMARK_RELATIVE	.\experimental\test\SingletonTest.cpp	/^BENCHMARK_RELATIVE(FollySingleton, n) {$/;"	f	signature:(FollySingleton, n)
BENCHMARK_RELATIVE	.\experimental\test\SingletonTest.cpp	/^BENCHMARK_RELATIVE(MeyersSingleton, n) {$/;"	f	signature:(MeyersSingleton, n)
BENCHMARK_RELATIVE	.\gen\test\BaseBenchmark.cpp	/^BENCHMARK_RELATIVE(Composed_Gen, iters) {$/;"	f	signature:(Composed_Gen, iters)
BENCHMARK_RELATIVE	.\gen\test\BaseBenchmark.cpp	/^BENCHMARK_RELATIVE(Composed_GenRegular, iters) {$/;"	f	signature:(Composed_GenRegular, iters)
BENCHMARK_RELATIVE	.\gen\test\BaseBenchmark.cpp	/^BENCHMARK_RELATIVE(Concat_Gen, iters) {$/;"	f	signature:(Concat_Gen, iters)
BENCHMARK_RELATIVE	.\gen\test\BaseBenchmark.cpp	/^BENCHMARK_RELATIVE(Count_Vector_Gen, iters) {$/;"	f	signature:(Count_Vector_Gen, iters)
BENCHMARK_RELATIVE	.\gen\test\BaseBenchmark.cpp	/^BENCHMARK_RELATIVE(Fib_Sum_Gen, iters) {$/;"	f	signature:(Fib_Sum_Gen, iters)
BENCHMARK_RELATIVE	.\gen\test\BaseBenchmark.cpp	/^BENCHMARK_RELATIVE(Fib_Sum_Gen_Static, iters) {$/;"	f	signature:(Fib_Sum_Gen_Static, iters)
BENCHMARK_RELATIVE	.\gen\test\BaseBenchmark.cpp	/^BENCHMARK_RELATIVE(MapMember, iters) {$/;"	f	signature:(MapMember, iters)
BENCHMARK_RELATIVE	.\gen\test\BaseBenchmark.cpp	/^BENCHMARK_RELATIVE(Sum_Basic_Gen, iters) {$/;"	f	signature:(Sum_Basic_Gen, iters)
BENCHMARK_RELATIVE	.\gen\test\BaseBenchmark.cpp	/^BENCHMARK_RELATIVE(Sum_Vector_Gen, iters) {$/;"	f	signature:(Sum_Vector_Gen, iters)
BENCHMARK_RELATIVE	.\gen\test\BaseBenchmark.cpp	/^BENCHMARK_RELATIVE(VirtualGen_1Virtual, iters) {$/;"	f	signature:(VirtualGen_1Virtual, iters)
BENCHMARK_RELATIVE	.\gen\test\BaseBenchmark.cpp	/^BENCHMARK_RELATIVE(VirtualGen_2Virtual, iters) {$/;"	f	signature:(VirtualGen_2Virtual, iters)
BENCHMARK_RELATIVE	.\gen\test\BaseBenchmark.cpp	/^BENCHMARK_RELATIVE(VirtualGen_3Virtual, iters) {$/;"	f	signature:(VirtualGen_3Virtual, iters)
BENCHMARK_RELATIVE	.\gen\test\ParallelMapBenchmark.cpp	/^BENCHMARK_RELATIVE(FibSumPmap, n) {$/;"	f	signature:(FibSumPmap, n)
BENCHMARK_RELATIVE	.\gen\test\ParallelMapBenchmark.cpp	/^BENCHMARK_RELATIVE(FibSumThreads, n) {$/;"	f	signature:(FibSumThreads, n)
BENCHMARK_RELATIVE	.\gen\test\StringBenchmark.cpp	/^BENCHMARK_RELATIVE(Records_VectorString, iters) {$/;"	f	signature:(Records_VectorString, iters)
BENCHMARK_RELATIVE	.\gen\test\StringBenchmark.cpp	/^BENCHMARK_RELATIVE(Records_VectorStringPiece, iters) {$/;"	f	signature:(Records_VectorStringPiece, iters)
BENCHMARK_RELATIVE	.\gen\test\StringBenchmark.cpp	/^BENCHMARK_RELATIVE(Records_VectorStringPieceReused, iters) {$/;"	f	signature:(Records_VectorStringPieceReused, iters)
BENCHMARK_RELATIVE	.\gen\test\StringBenchmark.cpp	/^BENCHMARK_RELATIVE(StringResplitter_Small, iters) {$/;"	f	signature:(StringResplitter_Small, iters)
BENCHMARK_RELATIVE	.\gen\test\StringBenchmark.cpp	/^BENCHMARK_RELATIVE(StringSplit_Gen, iters) {$/;"	f	signature:(StringSplit_Gen, iters)
BENCHMARK_RELATIVE	.\gen\test\StringBenchmark.cpp	/^BENCHMARK_RELATIVE(StringSplit_Gen_ReuseVector, iters) {$/;"	f	signature:(StringSplit_Gen_ReuseVector, iters)
BENCHMARK_RELATIVE	.\gen\test\StringBenchmark.cpp	/^BENCHMARK_RELATIVE(StringSplit_Gen_Take, iters) {$/;"	f	signature:(StringSplit_Gen_Take, iters)
BENCHMARK_RELATIVE	.\gen\test\StringBenchmark.cpp	/^BENCHMARK_RELATIVE(StringSplit_Gen_Vector, iters) {$/;"	f	signature:(StringSplit_Gen_Vector, iters)
BENCHMARK_RELATIVE	.\gen\test\StringBenchmark.cpp	/^BENCHMARK_RELATIVE(StringUnsplit_Gen, iters) {$/;"	f	signature:(StringUnsplit_Gen, iters)
BENCHMARK_RELATIVE	.\gen\test\StringBenchmark.cpp	/^BENCHMARK_RELATIVE(StringUnsplit_Gen_ReusedBuffer, iters) {$/;"	f	signature:(StringUnsplit_Gen_ReusedBuffer, iters)
BENCHMARK_RELATIVE	.\gen\test\StringBenchmark.cpp	/^BENCHMARK_RELATIVE(StringUnsplit_Old_ReusedBuffer, iters) {$/;"	f	signature:(StringUnsplit_Old_ReusedBuffer, iters)
BENCHMARK_RELATIVE	.\test\BenchmarkTest.cpp	/^BENCHMARK_RELATIVE(bmVector) {$/;"	f	signature:(bmVector)
BENCHMARK_RELATIVE	.\test\ExceptionWrapperBenchmark.cpp	/^BENCHMARK_RELATIVE(exception_wrapper_create_and_cast, iters) {$/;"	f	signature:(exception_wrapper_create_and_cast, iters)
BENCHMARK_RELATIVE	.\test\ExceptionWrapperBenchmark.cpp	/^BENCHMARK_RELATIVE(exception_wrapper_create_and_cast_concurrent, iters) {$/;"	f	signature:(exception_wrapper_create_and_cast_concurrent, iters)
BENCHMARK_RELATIVE	.\test\ExceptionWrapperBenchmark.cpp	/^BENCHMARK_RELATIVE(exception_wrapper_create_and_test, iters) {$/;"	f	signature:(exception_wrapper_create_and_test, iters)
BENCHMARK_RELATIVE	.\test\ExceptionWrapperBenchmark.cpp	/^BENCHMARK_RELATIVE(exception_wrapper_create_and_test_concurrent, iters) {$/;"	f	signature:(exception_wrapper_create_and_test_concurrent, iters)
BENCHMARK_RELATIVE	.\test\ExceptionWrapperBenchmark.cpp	/^BENCHMARK_RELATIVE(exception_wrapper_create_and_throw, iters) {$/;"	f	signature:(exception_wrapper_create_and_throw, iters)
BENCHMARK_RELATIVE	.\test\ExceptionWrapperBenchmark.cpp	/^BENCHMARK_RELATIVE(exception_wrapper_create_and_throw_concurrent, iters) {$/;"	f	signature:(exception_wrapper_create_and_throw_concurrent, iters)
BENCHMARK_RELATIVE	.\test\FormatBenchmark.cpp	/^BENCHMARK_RELATIVE(bigFormat_format, iters) {$/;"	f	signature:(bigFormat_format, iters)
BENCHMARK_RELATIVE	.\test\FormatBenchmark.cpp	/^BENCHMARK_RELATIVE(format_nested_direct, iters) {$/;"	f	signature:(format_nested_direct, iters)
BENCHMARK_RELATIVE	.\test\FormatBenchmark.cpp	/^BENCHMARK_RELATIVE(format_nested_fbstrings, iters) {$/;"	f	signature:(format_nested_fbstrings, iters)
BENCHMARK_RELATIVE	.\test\FormatBenchmark.cpp	/^BENCHMARK_RELATIVE(hex_uintToHex, iters) {$/;"	f	signature:(hex_uintToHex, iters)
BENCHMARK_RELATIVE	.\test\FormatBenchmark.cpp	/^BENCHMARK_RELATIVE(intAppend_format) {$/;"	f	signature:(intAppend_format)
BENCHMARK_RELATIVE	.\test\FormatBenchmark.cpp	/^BENCHMARK_RELATIVE(intAppend_to) {$/;"	f	signature:(intAppend_to)
BENCHMARK_RELATIVE	.\test\FormatBenchmark.cpp	/^BENCHMARK_RELATIVE(octal_uintToOctal, iters) {$/;"	f	signature:(octal_uintToOctal, iters)
BENCHMARK_RELATIVE	.\test\IPAddressBenchmark.cpp	/^BENCHMARK_RELATIVE(ipv4_to_fully_qualified, iters) {$/;"	f	signature:(ipv4_to_fully_qualified, iters)
BENCHMARK_RELATIVE	.\test\IPAddressBenchmark.cpp	/^BENCHMARK_RELATIVE(ipv6_to_fully_qualified, iters) {$/;"	f	signature:(ipv6_to_fully_qualified, iters)
BENCHMARK_RELATIVE	.\test\RangeFindBenchmark.cpp	/^BENCHMARK_RELATIVE(FindFirstOf16NeedlesByteSet, n) {$/;"	f	signature:(FindFirstOf16NeedlesByteSet, n)
BENCHMARK_RELATIVE	.\test\RangeFindBenchmark.cpp	/^BENCHMARK_RELATIVE(FindFirstOf16NeedlesMemchr, n) {$/;"	f	signature:(FindFirstOf16NeedlesMemchr, n)
BENCHMARK_RELATIVE	.\test\RangeFindBenchmark.cpp	/^BENCHMARK_RELATIVE(FindFirstOf16NeedlesNoSSE, n) {$/;"	f	signature:(FindFirstOf16NeedlesNoSSE, n)
BENCHMARK_RELATIVE	.\test\RangeFindBenchmark.cpp	/^BENCHMARK_RELATIVE(FindFirstOf16NeedlesStd, n) {$/;"	f	signature:(FindFirstOf16NeedlesStd, n)
BENCHMARK_RELATIVE	.\test\RangeFindBenchmark.cpp	/^BENCHMARK_RELATIVE(FindFirstOf2NeedlesByteSet, n) {$/;"	f	signature:(FindFirstOf2NeedlesByteSet, n)
BENCHMARK_RELATIVE	.\test\RangeFindBenchmark.cpp	/^BENCHMARK_RELATIVE(FindFirstOf2NeedlesMemchr, n) {$/;"	f	signature:(FindFirstOf2NeedlesMemchr, n)
BENCHMARK_RELATIVE	.\test\RangeFindBenchmark.cpp	/^BENCHMARK_RELATIVE(FindFirstOf2NeedlesNoSSE, n) {$/;"	f	signature:(FindFirstOf2NeedlesNoSSE, n)
BENCHMARK_RELATIVE	.\test\RangeFindBenchmark.cpp	/^BENCHMARK_RELATIVE(FindFirstOf2NeedlesStd, n) {$/;"	f	signature:(FindFirstOf2NeedlesStd, n)
BENCHMARK_RELATIVE	.\test\RangeFindBenchmark.cpp	/^BENCHMARK_RELATIVE(FindFirstOf32NeedlesByteSet, n) {$/;"	f	signature:(FindFirstOf32NeedlesByteSet, n)
BENCHMARK_RELATIVE	.\test\RangeFindBenchmark.cpp	/^BENCHMARK_RELATIVE(FindFirstOf32NeedlesMemchr, n) {$/;"	f	signature:(FindFirstOf32NeedlesMemchr, n)
BENCHMARK_RELATIVE	.\test\RangeFindBenchmark.cpp	/^BENCHMARK_RELATIVE(FindFirstOf32NeedlesNoSSE, n) {$/;"	f	signature:(FindFirstOf32NeedlesNoSSE, n)
BENCHMARK_RELATIVE	.\test\RangeFindBenchmark.cpp	/^BENCHMARK_RELATIVE(FindFirstOf32NeedlesStd, n) {$/;"	f	signature:(FindFirstOf32NeedlesStd, n)
BENCHMARK_RELATIVE	.\test\RangeFindBenchmark.cpp	/^BENCHMARK_RELATIVE(FindFirstOf4NeedlesByteSet, n) {$/;"	f	signature:(FindFirstOf4NeedlesByteSet, n)
BENCHMARK_RELATIVE	.\test\RangeFindBenchmark.cpp	/^BENCHMARK_RELATIVE(FindFirstOf4NeedlesMemchr, n) {$/;"	f	signature:(FindFirstOf4NeedlesMemchr, n)
BENCHMARK_RELATIVE	.\test\RangeFindBenchmark.cpp	/^BENCHMARK_RELATIVE(FindFirstOf4NeedlesNoSSE, n) {$/;"	f	signature:(FindFirstOf4NeedlesNoSSE, n)
BENCHMARK_RELATIVE	.\test\RangeFindBenchmark.cpp	/^BENCHMARK_RELATIVE(FindFirstOf4NeedlesStd, n) {$/;"	f	signature:(FindFirstOf4NeedlesStd, n)
BENCHMARK_RELATIVE	.\test\RangeFindBenchmark.cpp	/^BENCHMARK_RELATIVE(FindFirstOf64NeedlesByteSet, n) {$/;"	f	signature:(FindFirstOf64NeedlesByteSet, n)
BENCHMARK_RELATIVE	.\test\RangeFindBenchmark.cpp	/^BENCHMARK_RELATIVE(FindFirstOf64NeedlesMemchr, n) {$/;"	f	signature:(FindFirstOf64NeedlesMemchr, n)
BENCHMARK_RELATIVE	.\test\RangeFindBenchmark.cpp	/^BENCHMARK_RELATIVE(FindFirstOf64NeedlesNoSSE, n) {$/;"	f	signature:(FindFirstOf64NeedlesNoSSE, n)
BENCHMARK_RELATIVE	.\test\RangeFindBenchmark.cpp	/^BENCHMARK_RELATIVE(FindFirstOf64NeedlesStd, n) {$/;"	f	signature:(FindFirstOf64NeedlesStd, n)
BENCHMARK_RELATIVE	.\test\RangeFindBenchmark.cpp	/^BENCHMARK_RELATIVE(FindFirstOf8NeedlesByteSet, n) {$/;"	f	signature:(FindFirstOf8NeedlesByteSet, n)
BENCHMARK_RELATIVE	.\test\RangeFindBenchmark.cpp	/^BENCHMARK_RELATIVE(FindFirstOf8NeedlesMemchr, n) {$/;"	f	signature:(FindFirstOf8NeedlesMemchr, n)
BENCHMARK_RELATIVE	.\test\RangeFindBenchmark.cpp	/^BENCHMARK_RELATIVE(FindFirstOf8NeedlesNoSSE, n) {$/;"	f	signature:(FindFirstOf8NeedlesNoSSE, n)
BENCHMARK_RELATIVE	.\test\RangeFindBenchmark.cpp	/^BENCHMARK_RELATIVE(FindFirstOf8NeedlesStd, n) {$/;"	f	signature:(FindFirstOf8NeedlesStd, n)
BENCHMARK_RELATIVE	.\test\RangeFindBenchmark.cpp	/^BENCHMARK_RELATIVE(FindFirstOfRandomByteSet, n) {$/;"	f	signature:(FindFirstOfRandomByteSet, n)
BENCHMARK_RELATIVE	.\test\RangeFindBenchmark.cpp	/^BENCHMARK_RELATIVE(FindFirstOfRandomMemchr, n) {$/;"	f	signature:(FindFirstOfRandomMemchr, n)
BENCHMARK_RELATIVE	.\test\RangeFindBenchmark.cpp	/^BENCHMARK_RELATIVE(FindFirstOfRandomNoSSE, n) {$/;"	f	signature:(FindFirstOfRandomNoSSE, n)
BENCHMARK_RELATIVE	.\test\RangeFindBenchmark.cpp	/^BENCHMARK_RELATIVE(FindFirstOfRandomStd, n) {$/;"	f	signature:(FindFirstOfRandomStd, n)
BENCHMARK_RELATIVE	.\test\RangeFindBenchmark.cpp	/^BENCHMARK_RELATIVE(FindSingleCharRange, n) {$/;"	f	signature:(FindSingleCharRange, n)
BENCHMARK_RELATIVE_MULTI	.\Benchmark.h	449;"	d
BENCHMARK_RELATIVE_MULTI	.\test\BenchmarkTest.cpp	/^BENCHMARK_RELATIVE_MULTI(multiIterArgsRel, iter) {$/;"	f	signature:(multiIterArgsRel, iter)
BENCHMARK_RELATIVE_MULTI	.\test\BenchmarkTest.cpp	/^BENCHMARK_RELATIVE_MULTI(multiSimpleRel) {$/;"	f	signature:(multiSimpleRel)
BENCHMARK_RELATIVE_NAMED_PARAM	.\Benchmark.h	472;"	d
BENCHMARK_RELATIVE_NAMED_PARAM_MULTI	.\Benchmark.h	486;"	d
BENCHMARK_RELATIVE_PARAM	.\Benchmark.h	459;"	d
BENCHMARK_RELATIVE_PARAM_MULTI	.\Benchmark.h	466;"	d
BENCHMARK_SUSPEND	.\Benchmark.h	517;"	d
BENCH_GEN	.\gen\test\Bench.h	32;"	d
BENCH_GEN_IMPL	.\gen\test\Bench.h	22;"	d
BENCH_GEN_REL	.\gen\test\Bench.h	33;"	d
BLUE	.\experimental\symbolizer\Symbolizer.h	/^  enum Color { DEFAULT, RED, GREEN, YELLOW, BLUE, CYAN, WHITE, PURPLE };$/;"	e	enum:folly::symbolizer::SymbolizePrinter::Color
BM_AddSet	.\test\ConcurrentSkipListBenchmark.cpp	/^void BM_AddSet(int iters, int size) {$/;"	f	namespace:__anon113	signature:(int iters, int size)
BM_AddSkipList	.\test\ConcurrentSkipListBenchmark.cpp	/^void BM_AddSkipList(int iters, int size) {$/;"	f	namespace:__anon113	signature:(int iters, int size)
BM_CSLContainsFound	.\test\ConcurrentSkipListBenchmark.cpp	/^void BM_CSLContainsFound(int iters, int size) {$/;"	f	namespace:__anon113	signature:(int iters, int size)
BM_CSLContainsNotFound	.\test\ConcurrentSkipListBenchmark.cpp	/^void BM_CSLContainsNotFound(int iters, int size) {$/;"	f	namespace:__anon113	signature:(int iters, int size)
BM_CSLMergeIntersection	.\test\ConcurrentSkipListBenchmark.cpp	/^void BM_CSLMergeIntersection(int iters, int size) {$/;"	f	namespace:__anon113	signature:(int iters, int size)
BM_CSLMergeLookup	.\test\ConcurrentSkipListBenchmark.cpp	/^void BM_CSLMergeLookup(int iters, int size) {$/;"	f	namespace:__anon113	signature:(int iters, int size)
BM_ContentionCSL	.\test\ConcurrentSkipListBenchmark.cpp	/^void BM_ContentionCSL(int iters, int size) {$/;"	f	namespace:__anon113	signature:(int iters, int size)
BM_ContentionStdSet	.\test\ConcurrentSkipListBenchmark.cpp	/^void BM_ContentionStdSet(int iters, int size) {$/;"	f	namespace:__anon113	signature:(int iters, int size)
BM_IterateOverSet	.\test\ConcurrentSkipListBenchmark.cpp	/^void BM_IterateOverSet(int iters, int size) {$/;"	f	namespace:__anon113	signature:(int iters, int size)
BM_IterateSkipList	.\test\ConcurrentSkipListBenchmark.cpp	/^void BM_IterateSkipList(int iters, int size) {$/;"	f	namespace:__anon113	signature:(int iters, int size)
BM_ProducerConsumer	.\test\ProducerConsumerQueueBenchmark.cpp	/^void BM_ProducerConsumer(int iters, int size) {$/;"	f	namespace:__anon127	signature:(int iters, int size)
BM_ProducerConsumerAffinity	.\test\ProducerConsumerQueueBenchmark.cpp	/^void BM_ProducerConsumerAffinity(int iters, int size) {$/;"	f	namespace:__anon127	signature:(int iters, int size)
BM_ProducerConsumerLatency	.\test\ProducerConsumerQueueBenchmark.cpp	/^void BM_ProducerConsumerLatency(int iters, int size) {$/;"	f	namespace:__anon127	signature:(int iters, int size)
BM_SetContainsFound	.\test\ConcurrentSkipListBenchmark.cpp	/^void BM_SetContainsFound(int iters, int size) {$/;"	f	namespace:__anon113	signature:(int iters, int size)
BM_SetContainsNotFound	.\test\ConcurrentSkipListBenchmark.cpp	/^void BM_SetContainsNotFound(int iters, int size) {$/;"	f	namespace:__anon113	signature:(int iters, int size)
BM_SetMerge	.\test\ConcurrentSkipListBenchmark.cpp	/^void BM_SetMerge(int iters, int size) {$/;"	f	namespace:__anon113	signature:(int iters, int size)
BM_fn_ptr_invoke_impl	.\test\function_benchmark\benchmark_impl.cpp	/^void BM_fn_ptr_invoke_impl(int iters, void (*fn)()) {$/;"	f	signature:(int iters, void (*fn)())
BM_fn_ptr_invoke_impl	.\test\function_benchmark\benchmark_impl.h	/^void BM_fn_ptr_invoke_impl(int iters, void (*fn)());$/;"	p	signature:(int iters, void (*fn)())
BM_fn_ptr_invoke_inlined_impl	.\test\function_benchmark\benchmark_impl.h	/^inline void BM_fn_ptr_invoke_inlined_impl(int iters, void (*fn)()) {$/;"	f	signature:(int iters, void (*fn)())
BM_invoke_fn_template_impl	.\test\function_benchmark\benchmark_impl.h	/^void BM_invoke_fn_template_impl(int iters, const T& fn) {$/;"	f	signature:(int iters, const T& fn)
BM_mem_fn_invoke_impl	.\test\function_benchmark\benchmark_impl.cpp	/^void BM_mem_fn_invoke_impl(int iters,$/;"	f	signature:(int iters, TestClass* tc, void (TestClass::*memfn)())
BM_mem_fn_invoke_impl	.\test\function_benchmark\benchmark_impl.h	/^void BM_mem_fn_invoke_impl(int iters,$/;"	p	signature:(int iters, TestClass* tc, void (TestClass::*memfn)())
BM_std_function_invoke_impl	.\test\function_benchmark\benchmark_impl.cpp	/^void BM_std_function_invoke_impl(int iters,$/;"	f	signature:(int iters, const std::function<void()>& fn)
BM_std_function_invoke_impl	.\test\function_benchmark\benchmark_impl.h	/^void BM_std_function_invoke_impl(int iters, const std::function<void()>& fn);$/;"	p	signature:(int iters, const std::function<void()>& fn)
BM_virtual_fn_invoke_impl	.\test\function_benchmark\benchmark_impl.cpp	/^void BM_virtual_fn_invoke_impl(int iters, VirtualClass* vc) {$/;"	f	signature:(int iters, VirtualClass* vc)
BM_virtual_fn_invoke_impl	.\test\function_benchmark\benchmark_impl.h	/^void BM_virtual_fn_invoke_impl(int iters, VirtualClass* vc);$/;"	p	signature:(int iters, VirtualClass* vc)
BOOL	.\dynamic.h	/^    BOOL,$/;"	e	enum:folly::dynamic::Type
BOOST_MPL_HAS_XXX_TRAIT_DEF	.\DynamicConverter.h	/^BOOST_MPL_HAS_XXX_TRAIT_DEF(iterator);$/;"	p	namespace:folly::dynamicconverter_detail	signature:(iterator)
BOOST_MPL_HAS_XXX_TRAIT_DEF	.\DynamicConverter.h	/^BOOST_MPL_HAS_XXX_TRAIT_DEF(mapped_type);$/;"	p	namespace:folly::dynamicconverter_detail	signature:(mapped_type)
BOOST_MPL_HAS_XXX_TRAIT_DEF	.\DynamicConverter.h	/^BOOST_MPL_HAS_XXX_TRAIT_DEF(value_type);$/;"	p	namespace:folly::dynamicconverter_detail	signature:(value_type)
BOOST_STATIC_ASSERT	.\stats\TimeseriesHistogram.h	/^   BOOST_STATIC_ASSERT(std::numeric_limits<T>::is_signed);$/;"	p	class:folly::TimeseriesHistogram	access:private	signature:(std::numeric_limits<T>::is_signed)
BROADCAST	.\MacAddress.h	/^  static const MacAddress BROADCAST;$/;"	m	class:folly::MacAddress	access:public
BUFFER_SIZE	.\test\ChecksumTest.cpp	/^const unsigned int BUFFER_SIZE = 512 * 1024 * sizeof(uint64_t);$/;"	m	namespace:__anon112	file:
BUFSIZE	.\test\SpookyHashV1Test.cpp	257;"	d	file:
BUFSIZE	.\test\SpookyHashV1Test.cpp	261;"	d	file:
BUFSIZE	.\test\SpookyHashV1Test.cpp	318;"	d	file:
BUFSIZE	.\test\SpookyHashV1Test.cpp	321;"	d	file:
BUFSIZE	.\test\SpookyHashV1Test.cpp	348;"	d	file:
BUFSIZE	.\test\SpookyHashV1Test.cpp	350;"	d	file:
BUFSIZE	.\test\SpookyHashV1Test.cpp	379;"	d	file:
BUFSIZE	.\test\SpookyHashV1Test.cpp	382;"	d	file:
BUFSIZE	.\test\SpookyHashV1Test.cpp	463;"	d	file:
BUFSIZE	.\test\SpookyHashV1Test.cpp	469;"	d	file:
BUFSIZE	.\test\SpookyHashV1Test.cpp	530;"	d	file:
BUFSIZE	.\test\SpookyHashV1Test.cpp	91;"	d	file:
BUFSIZE	.\test\SpookyHashV2Test.cpp	183;"	d	file:
BUFSIZE	.\test\SpookyHashV2Test.cpp	187;"	d	file:
BUFSIZE	.\test\SpookyHashV2Test.cpp	244;"	d	file:
BUFSIZE	.\test\SpookyHashV2Test.cpp	247;"	d	file:
BUFSIZE	.\test\SpookyHashV2Test.cpp	274;"	d	file:
BUFSIZE	.\test\SpookyHashV2Test.cpp	276;"	d	file:
BUFSIZE	.\test\SpookyHashV2Test.cpp	305;"	d	file:
BUFSIZE	.\test\SpookyHashV2Test.cpp	308;"	d	file:
BUFSIZE	.\test\SpookyHashV2Test.cpp	389;"	d	file:
BUFSIZE	.\test\SpookyHashV2Test.cpp	395;"	d	file:
BUFSIZE	.\test\SpookyHashV2Test.cpp	456;"	d	file:
BUFSIZE	.\test\SpookyHashV2Test.cpp	91;"	d	file:
BY_EXPIRATION	.\TimeoutQueue.h	/^    BY_EXPIRATION=1$/;"	e	enum:folly::TimeoutQueue::__anon150
BY_ID	.\TimeoutQueue.h	/^    BY_ID=0,$/;"	e	enum:folly::TimeoutQueue::__anon150
BadFormatArg	.\FormatArg.h	/^  explicit BadFormatArg(const std::string& msg)$/;"	f	class:folly::BadFormatArg	access:public	signature:(const std::string& msg)
BadFormatArg	.\FormatArg.h	/^class BadFormatArg : public std::invalid_argument {$/;"	c	namespace:folly	inherits:std::invalid_argument
Bar	.\test\HasMemberFnTraitsTest.cpp	/^struct Bar {$/;"	s	file:
Bar::test	.\test\HasMemberFnTraitsTest.cpp	/^  double test(int,long);$/;"	p	struct:Bar	file:	access:public	signature:(int,long)
Bar::test	.\test\HasMemberFnTraitsTest.cpp	/^  int test();$/;"	p	struct:Bar	file:	access:public	signature:()
Bar::test	.\test\HasMemberFnTraitsTest.cpp	/^  long test(int) const;$/;"	p	struct:Bar	file:	access:public	signature:(int) const
Base	.\ExceptionWrapper.h	/^  typedef try_and_catch<Exceptions...> Base;$/;"	t	class:folly::try_and_catch	access:protected
Base	.\GroupVarint.h	/^  typedef GroupVarint<T> Base;$/;"	t	class:folly::GroupVarintDecoder	access:public
Base	.\GroupVarint.h	/^  typedef GroupVarint<T> Base;$/;"	t	class:folly::GroupVarintEncoder	access:public
Base	.\test\PortabilityTest.cpp	/^class Base {$/;"	c	file:
Base::foo	.\test\PortabilityTest.cpp	/^  virtual int foo() const { return 1; }$/;"	f	class:Base	access:public	signature:() const
Base::~Base	.\test\PortabilityTest.cpp	/^  virtual ~Base() { }$/;"	f	class:Base	access:public	signature:()
BaseFormatter	.\Format-inl.h	/^BaseFormatter<Derived, containerMode, Args...>::BaseFormatter(StringPiece str,$/;"	f	class:folly::BaseFormatter	signature:(StringPiece str, Args&&... args)
BaseFormatter	.\Format.h	/^class BaseFormatter {$/;"	c	namespace:folly
BaseFormatter	.\test\FormatTest.cpp	/^  friend class BaseFormatter<TestExtendingFormatter<containerMode, Args...>,$/;"	x	file:
BaseType	.\Format.h	/^  typedef BaseFormatter BaseType;$/;"	t	class:folly::BaseFormatter	access:public
BaseType	.\small_vector.h	/^  >::type BaseType;$/;"	t	class:folly::small_vector	access:private
Batch	.\gen\Base-inl.h	/^  explicit Batch(size_t batchSize)$/;"	f	class:folly::gen::detail::Batch	access:public	signature:(size_t batchSize)
Batch	.\gen\Base-inl.h	/^class Batch : public Operator<Batch> {$/;"	c	namespace:folly::gen::detail	inherits:Operator
Batch	.\gen\Base.h	/^class Batch;$/;"	x
Baton	.\Baton.h	/^  Baton() : state_(INIT) {}$/;"	f	struct:folly::Baton	access:public	signature:()
Baton	.\Baton.h	/^struct Baton : boost::noncopyable {$/;"	s	namespace:folly	inherits:boost::noncopyable
BeingBorn	.\experimental\Singleton.h	/^    BeingBorn,$/;"	m	class:folly::SingletonVault::SingletonEntryState	access:private
BenchmarkFun	.\Benchmark.cpp	/^typedef function<detail::TimeIterPair(unsigned int)> BenchmarkFun;$/;"	t	namespace:folly	file:
BenchmarkSingleton	.\experimental\test\SingletonTest.cpp	/^struct BenchmarkSingleton {$/;"	s	file:
BenchmarkSingleton::val	.\experimental\test\SingletonTest.cpp	/^  int val = 0;$/;"	m	struct:BenchmarkSingleton	file:	access:public
BenchmarkSuspender	.\Benchmark.h	/^  BenchmarkSuspender() {$/;"	f	struct:folly::BenchmarkSuspender	access:public	signature:()
BenchmarkSuspender	.\Benchmark.h	/^  BenchmarkSuspender(BenchmarkSuspender && rhs) {$/;"	f	struct:folly::BenchmarkSuspender	access:public	signature:(BenchmarkSuspender && rhs)
BenchmarkSuspender	.\Benchmark.h	/^  BenchmarkSuspender(const BenchmarkSuspender &) = delete;$/;"	p	struct:folly::BenchmarkSuspender	access:public	signature:(const BenchmarkSuspender &)
BenchmarkSuspender	.\Benchmark.h	/^struct BenchmarkSuspender {$/;"	s	namespace:folly
BiggerThanChar	.\Foreach.h	/^  struct BiggerThanChar { char unused[2]; };$/;"	s	class:folly::detail::HasLess	access:private
BitIterator	.\detail\BitIteratorDetail.h	/^template <class BaseIter> class BitIterator;$/;"	x
BitIteratorBase	.\detail\BitIteratorDetail.h	/^struct BitIteratorBase {$/;"	s	namespace:folly::bititerator_detail
BitReference	.\detail\BitIteratorDetail.h	/^  BitReference(Ref r, size_t bit) : ref_(r), bit_(bit) { }$/;"	f	class:folly::bititerator_detail::BitReference	access:public	signature:(Ref r, size_t bit)
BitReference	.\detail\BitIteratorDetail.h	/^class BitReference {$/;"	c	namespace:folly::bititerator_detail
Bits	.\experimental\Bits.h	/^struct Bits {$/;"	s	namespace:folly
BitsTraits	.\experimental\Bits.h	/^struct BitsTraits;$/;"	x
BitsTraits	.\experimental\Bits.h	/^struct BitsTraits<T, typename std::enable_if<$/;"	s	namespace:folly::detail
BitsTraits	.\experimental\Bits.h	/^struct BitsTraits<Unaligned<T>, typename std::enable_if<$/;"	s	namespace:folly::detail
BitsTraits	.\experimental\Bits.h	/^struct BitsTraits<UnalignedNoASan<T>, typename std::enable_if<$/;"	s	namespace:folly::detail
Block	.\Arena.h	/^    Block() { }$/;"	f	struct:folly::Arena::Block	access:private	signature:()
Block	.\Arena.h	/^  struct Block {$/;"	s	class:folly::Arena	access:private
Block	.\Arena.h	/^  struct Block;$/;"	x
BlockLink	.\Arena.h	/^    boost::intrusive::tag<Arena>> BlockLink;$/;"	t	class:folly::Arena	access:private
BlockList	.\Arena.h	/^    boost::intrusive::cache_last<true>> BlockList;$/;"	t	class:folly::Arena	access:private
BlockType	.\AtomicBitSet.h	/^  typedef unsigned int BlockType;$/;"	t	class:folly::AtomicBitSet	access:private
BlockType	.\AtomicBitSet.h	/^  typedef unsigned long BlockType;$/;"	t	class:folly::AtomicBitSet	access:private
BlockType	.\AtomicBitSet.h	/^  typedef unsigned long long BlockType;$/;"	t	class:folly::AtomicBitSet	access:private
BlockingQueue	.\experimental\wangle\concurrent\BlockingQueue.h	/^class BlockingQueue {$/;"	c	namespace:folly::wangle
BrokenPromise	.\wangle\WangleException.h	/^    explicit BrokenPromise() :$/;"	f	class:folly::wangle::BrokenPromise	access:public	signature:()
BrokenPromise	.\wangle\WangleException.h	/^class BrokenPromise : public WangleException {$/;"	c	namespace:folly::wangle	inherits:WangleException
Bucket	.\detail\Stats.h	/^  Bucket()$/;"	f	struct:folly::detail::Bucket	access:public	signature:()
Bucket	.\detail\Stats.h	/^struct Bucket {$/;"	s	namespace:folly::detail
Bucket	.\stats\BucketedTimeSeries.h	/^  typedef detail::Bucket<ValueType> Bucket;$/;"	t	class:folly::BucketedTimeSeries	access:public
Bucket	.\stats\Histogram.h	/^  typedef detail::Bucket<T> Bucket;$/;"	t	class:folly::Histogram	access:public
Bucket	.\stats\TimeseriesHistogram.h	/^  typedef ContainerType Bucket;$/;"	t	class:folly::TimeseriesHistogram	access:private
BucketType	.\stats\Histogram.h	/^  typedef BucketT BucketType;$/;"	t	class:folly::detail::HistogramBuckets	access:public
BucketedTimeSeries	.\stats\BucketedTimeSeries-defs.h	/^BucketedTimeSeries<VT, TT>::BucketedTimeSeries(size_t nBuckets,$/;"	f	class:folly::BucketedTimeSeries	signature:(size_t nBuckets, TimeType maxDuration)
BucketedTimeSeries	.\stats\BucketedTimeSeries.h	/^  BucketedTimeSeries(size_t numBuckets, TimeType duration);$/;"	p	class:folly::BucketedTimeSeries	access:public	signature:(size_t numBuckets, TimeType duration)
BucketedTimeSeries	.\stats\BucketedTimeSeries.h	/^class BucketedTimeSeries {$/;"	c	namespace:folly
BucketedTimeSeries	.\stats\Instantiations.cpp	/^template class BucketedTimeSeries<int64_t>;$/;"	x	file:
BufType	.\io\test\IOBufTest.cpp	/^enum BufType {$/;"	g	file:
BufferedRandomDevice	.\Random.cpp	/^  explicit BufferedRandomDevice(size_t bufferSize = kDefaultBufferSize);$/;"	p	class:folly::__anon82::BufferedRandomDevice	file:	access:public	signature:(size_t bufferSize = kDefaultBufferSize)
BufferedRandomDevice	.\Random.cpp	/^BufferedRandomDevice::BufferedRandomDevice(size_t bufferSize)$/;"	f	class:folly::__anon82::BufferedRandomDevice	signature:(size_t bufferSize)
BufferedRandomDevice	.\Random.cpp	/^class BufferedRandomDevice {$/;"	c	namespace:folly::__anon82	file:
ByteArray16	.\IPAddressV6.h	/^typedef std::array<uint8_t, 16> ByteArray16;$/;"	t	namespace:folly
ByteArray4	.\IPAddressV4.h	/^typedef std::array<uint8_t, 4> ByteArray4;$/;"	t	namespace:folly
ByteRange	.\Range.h	/^typedef Range<const unsigned char*> ByteRange;$/;"	t	namespace:folly
ByteSetNeedleFinder	.\test\RangeTest.cpp	/^struct ByteSetNeedleFinder {$/;"	s	file:
ByteSetNeedleFinder::find_first_byte_of	.\test\RangeTest.cpp	/^  static size_t find_first_byte_of(StringPiece haystack, StringPiece needles) {$/;"	f	struct:ByteSetNeedleFinder	access:public	signature:(StringPiece haystack, StringPiece needles)
ByteVector	.\test\IPAddressTest.h	/^typedef std::vector<uint8_t> ByteVector;$/;"	t	namespace:folly
Bytes	.\detail\IPAddress.h	/^  Bytes() = delete;$/;"	p	struct:folly::detail::Bytes	access:private	signature:()
Bytes	.\detail\IPAddress.h	/^struct Bytes : private boost::noncopyable {$/;"	s	namespace:folly::detail	inherits:boost::noncopyable
C	.\CpuId.h	117;"	d
C	.\CpuId.h	50;"	d
CA_DELETE	.\test\stl_tests\StlVectorTest.cpp	/^  CA_DELETE   = 0x40000,$/;"	e	enum:Flags	file:
CA_NOEXCEPT	.\test\stl_tests\StlVectorTest.cpp	/^  CA_NOEXCEPT = 0x100,$/;"	e	enum:Flags	file:
CA_THROW	.\test\stl_tests\StlVectorTest.cpp	/^  CA_THROW    = 0x200,$/;"	e	enum:Flags	file:
CC_DELETE	.\test\stl_tests\StlVectorTest.cpp	/^  CC_DELETE   = 0x10000,$/;"	e	enum:Flags	file:
CC_NOEXCEPT	.\test\stl_tests\StlVectorTest.cpp	/^  CC_NOEXCEPT = 0x4,$/;"	e	enum:Flags	file:
CC_THROW	.\test\stl_tests\StlVectorTest.cpp	/^  CC_THROW    = 0x8,$/;"	e	enum:Flags	file:
CENTER	.\FormatArg.h	/^    CENTER,$/;"	m	class:folly::FormatArg::Align	access:private
CHECK_THROW	.\Exception.h	123;"	d
CIDRNetwork	.\IPAddress.h	/^typedef std::pair<IPAddress, uint8_t> CIDRNetwork;$/;"	t	namespace:folly
CIDRNetworkV4	.\IPAddressV4.h	/^typedef std::pair<IPAddressV4, uint8_t> CIDRNetworkV4;$/;"	t	namespace:folly
CIDRNetworkV6	.\IPAddressV6.h	/^typedef std::pair<IPAddressV6, uint8_t> CIDRNetworkV6;$/;"	t	namespace:folly
CLOCK_REALTIME	.\detail\Clock.h	36;"	d
CLOSE	.\Subprocess.h	/^  static const int CLOSE = -1;$/;"	m	class:folly::Subprocess	access:public
CLOSER_a	.\test\stl_tests\StlVectorTest.cpp	1116;"	d	file:
CLOSER_b	.\test\stl_tests\StlVectorTest.cpp	1140;"	d	file:
CLOSER_i	.\test\stl_tests\StlVectorTest.cpp	1164;"	d	file:
CLOSER_j	.\test\stl_tests\StlVectorTest.cpp	1174;"	d	file:
CLOSER_m	.\test\stl_tests\StlVectorTest.cpp	1275;"	d	file:
CLOSER_n	.\test\stl_tests\StlVectorTest.cpp	1152;"	d	file:
CLOSER_p	.\test\stl_tests\StlVectorTest.cpp	1228;"	d	file:
CLOSER_q	.\test\stl_tests\StlVectorTest.cpp	1238;"	d	file:
CLOSER_t	.\test\stl_tests\StlVectorTest.cpp	1261;"	d	file:
CLOSER_ticks	.\test\stl_tests\StlVectorTest.cpp	1061;"	d	file:
CLOSER_z	.\test\stl_tests\StlVectorTest.cpp	1027;"	d	file:
COLOR	.\experimental\symbolizer\Symbolizer.h	/^    COLOR = 1 << 2,$/;"	e	enum:folly::symbolizer::SymbolizePrinter::Options
COLOR_IF_TTY	.\experimental\symbolizer\Symbolizer.h	/^    COLOR_IF_TTY = 1 << 3,$/;"	e	enum:folly::symbolizer::SymbolizePrinter::Options
COMMIT	.\experimental\symbolizer\Dwarf.h	/^      COMMIT,    \/\/ Commit new <address, file, line> tuple$/;"	e	enum:folly::symbolizer::Dwarf::LineNumberVM::StepResult
COMPRESSION_LEVEL_BEST	.\io\Compression.h	/^constexpr int COMPRESSION_LEVEL_BEST = -3;$/;"	m	namespace:folly::io
COMPRESSION_LEVEL_DEFAULT	.\io\Compression.h	/^constexpr int COMPRESSION_LEVEL_DEFAULT = -2;$/;"	m	namespace:folly::io
COMPRESSION_LEVEL_FASTEST	.\io\Compression.h	/^constexpr int COMPRESSION_LEVEL_FASTEST = -1;$/;"	m	namespace:folly::io
CONCAT	.\test\FBStringBenchmark.cpp	84;"	d	file:
CONCAT	.\test\FBVectorBenchmark.cpp	85;"	d	file:
CONCAT_HELPER	.\test\FBStringBenchmark.cpp	85;"	d	file:
CONCAT_HELPER	.\test\FBVectorBenchmark.cpp	86;"	d	file:
CONTINUE	.\experimental\symbolizer\Dwarf.h	/^      CONTINUE,  \/\/ Continue feeding opcodes$/;"	e	enum:folly::symbolizer::Dwarf::LineNumberVM::StepResult
COPY_BUFFER	.\io\IOBuf.h	/^  enum CopyBufferOp { COPY_BUFFER };$/;"	e	enum:folly::IOBuf::CopyBufferOp
COPY_CONSTRUCTOR	.\test\MPMCQueueTest.cpp	/^  COPY_CONSTRUCTOR,$/;"	e	enum:LifecycleEvent	file:
COPY_OPERATOR	.\test\MPMCQueueTest.cpp	/^  COPY_OPERATOR,$/;"	e	enum:LifecycleEvent	file:
CPORTABILITY_H	.\CPortability.h	18;"	d
CPUThreadPoolExecutor	.\experimental\wangle\concurrent\CPUThreadPoolExecutor.cpp	/^CPUThreadPoolExecutor::CPUThreadPoolExecutor($/;"	f	class:folly::wangle::CPUThreadPoolExecutor	signature:( size_t numThreads, std::unique_ptr<BlockingQueue<Task>> taskQueue, std::unique_ptr<ThreadFactory> threadFactory)
CPUThreadPoolExecutor	.\experimental\wangle\concurrent\CPUThreadPoolExecutor.h	/^  explicit CPUThreadPoolExecutor($/;"	p	class:folly::wangle::CPUThreadPoolExecutor	access:public	signature:( size_t numThreads, std::unique_ptr<BlockingQueue<Task>> taskQueue = folly::make_unique<LifoSemMPMCQueue<Task>>( CPUThreadPoolExecutor::kDefaultMaxQueueSize), std::unique_ptr<ThreadFactory> threadFactory = folly::make_unique<NamedThreadFactory>())
CPUThreadPoolExecutor	.\experimental\wangle\concurrent\CPUThreadPoolExecutor.h	/^class CPUThreadPoolExecutor : public ThreadPoolExecutor {$/;"	c	namespace:folly::wangle	inherits:ThreadPoolExecutor
CREATE	.\io\IOBuf.h	/^  enum CreateOp { CREATE };$/;"	e	enum:folly::IOBuf::CreateOp
CREATE	.\io\test\IOBufTest.cpp	/^  CREATE,$/;"	e	enum:BufType	file:
CREATE_INC_FUNC	.\test\ThreadCachedIntTest.cpp	64;"	d	file:
CV	.\test\HasMemberFnTraitsTest.cpp	/^struct CV {$/;"	s	file:
CV::test	.\test\HasMemberFnTraitsTest.cpp	/^  void test() const volatile;$/;"	p	struct:CV	file:	access:public	signature:() const volatile
CYAN	.\experimental\symbolizer\Symbolizer.h	/^  enum Color { DEFAULT, RED, GREEN, YELLOW, BLUE, CYAN, WHITE, PURPLE };$/;"	e	enum:folly::symbolizer::SymbolizePrinter::Color
CacheLocality	.\detail\CacheLocality.h	/^struct CacheLocality {$/;"	s	namespace:folly::detail
Callback	.\TimeoutQueue.h	/^  typedef std::function<void(Id, int64_t)> Callback;$/;"	t	class:folly::TimeoutQueue	access:public
Callback	.\experimental\wangle\ConnectionManager.h	/^  class Callback {$/;"	c	class:folly::wangle::ConnectionManager	access:public
Callback	.\io\async\HHWheelTimer.h	/^    Callback()$/;"	f	class:folly::HHWheelTimer::Callback	access:public	signature:()
Callback	.\io\async\HHWheelTimer.h	/^  class Callback {$/;"	c	class:folly::HHWheelTimer	access:public
CallbackList	.\io\async\HHWheelTimer.h	/^  typedef Callback::List CallbackList;$/;"	t	class:folly::HHWheelTimer	access:private
CalledProcessError	.\Subprocess.cpp	/^CalledProcessError::CalledProcessError(ProcessReturnCode rc)$/;"	f	class:folly::CalledProcessError	signature:(ProcessReturnCode rc)
CalledProcessError	.\Subprocess.h	/^  explicit CalledProcessError(ProcessReturnCode rc);$/;"	p	class:folly::CalledProcessError	access:public	signature:(ProcessReturnCode rc)
CalledProcessError	.\Subprocess.h	/^class CalledProcessError : public SubprocessError {$/;"	c	namespace:folly	inherits:SubprocessError
Cast	.\gen\Base.h	/^class Cast {$/;"	c	namespace:folly::gen
Chain	.\gen\Core-inl.h	/^  explicit Chain(First first, Second second)$/;"	f	class:folly::gen::detail::Chain	access:public	signature:(First first, Second second)
Chain	.\gen\Core-inl.h	/^class Chain : public GenImpl<Value,$/;"	c	namespace:folly::gen::detail	inherits:GenImpl
Chain	.\gen\Core.h	/^class Chain;$/;"	x
CheckFirstLessThanSecond	.\test\SocketAddressTest.cpp	/^void CheckFirstLessThanSecond(SocketAddress first, SocketAddress second) {$/;"	f	signature:(SocketAddress first, SocketAddress second)
CheckPrefixMatch	.\test\SocketAddressTest.cpp	/^void CheckPrefixMatch(const SocketAddress& first,$/;"	f	signature:(const SocketAddress& first, const SocketAddress& second, unsigned matchingPrefixLen)
ChildErrorInfo	.\Subprocess.cpp	/^struct ChildErrorInfo {$/;"	s	namespace:folly::__anon98	file:
ChildWatchdog	.\experimental\test\SingletonTest.cpp	/^struct ChildWatchdog : public Watchdog {};$/;"	s	file:	inherits:Watchdog
ChunkedRangeSource	.\gen\Parallel-inl.h	/^  ChunkedRangeSource() {}$/;"	f	class:folly::gen::detail::ChunkedRangeSource	access:public	signature:()
ChunkedRangeSource	.\gen\Parallel-inl.h	/^  ChunkedRangeSource(int chunkSize, Range<Iterator> range)$/;"	f	class:folly::gen::detail::ChunkedRangeSource	access:public	signature:(int chunkSize, Range<Iterator> range)
ChunkedRangeSource	.\gen\Parallel-inl.h	/^class ChunkedRangeSource$/;"	c	namespace:folly::gen::detail	inherits:GenImpl
ChunkedRangeSource	.\gen\Parallel.h	/^class ChunkedRangeSource;$/;"	x
Clock	.\Benchmark.h	/^enum Clock { DEFAULT_CLOCK_ID = CLOCK_REALTIME };$/;"	g	namespace:folly::detail
ClosableMPMCQueue	.\gen\Parallel-inl.h	/^  explicit ClosableMPMCQueue(size_t capacity) : queue_(capacity) {}$/;"	f	class:folly::gen::detail::ClosableMPMCQueue	access:public	signature:(size_t capacity)
ClosableMPMCQueue	.\gen\Parallel-inl.h	/^class ClosableMPMCQueue {$/;"	c	namespace:folly::gen::detail
CloseIdleConnsCallback	.\experimental\wangle\ConnectionManager.h	/^    explicit CloseIdleConnsCallback(ConnectionManager* manager)$/;"	f	class:folly::wangle::ConnectionManager::CloseIdleConnsCallback	access:public	signature:(ConnectionManager* manager)
CloseIdleConnsCallback	.\experimental\wangle\ConnectionManager.h	/^  class CloseIdleConnsCallback :$/;"	c	class:folly::wangle::ConnectionManager	inherits:folly::EventBase::LoopCallback,folly::AsyncTimeout	access:private
Cob	.\io\async\EventBase.h	/^typedef std::function<void()> Cob;$/;"	t	namespace:folly
CobTimeout	.\io\async\EventBase.h	/^    CobTimeout(EventBase* b, const Cob& c, TimeoutManager::InternalEnum in)$/;"	f	class:folly::EventBase::CobTimeout	access:public	signature:(EventBase* b, const Cob& c, TimeoutManager::InternalEnum in)
CobTimeout	.\io\async\EventBase.h	/^  class CobTimeout : public AsyncTimeout {$/;"	c	class:folly::EventBase	inherits:AsyncTimeout	access:private
Codec	.\io\Compression.cpp	/^Codec::Codec(CodecType type) : type_(type) { }$/;"	f	class:folly::io::Codec	signature:(CodecType type)
Codec	.\io\Compression.h	/^  explicit Codec(CodecType type);$/;"	p	class:folly::io::Codec	access:protected	signature:(CodecType type)
Codec	.\io\Compression.h	/^class Codec {$/;"	c	namespace:folly::io
CodecFactory	.\io\Compression.cpp	/^typedef std::unique_ptr<Codec> (*CodecFactory)(int, CodecType);$/;"	t	class:folly::io::__anon64::std	file:
CodecType	.\io\Compression.h	/^enum class CodecType {$/;"	c	namespace:folly::io
Collect	.\gen\Base-inl.h	/^  Collect() { }$/;"	f	class:folly::gen::detail::Collect	access:public	signature:()
Collect	.\gen\Base-inl.h	/^class Collect : public Operator<Collect<Collection>> {$/;"	c	namespace:folly::gen::detail	inherits:Operator
Collect	.\gen\Base.h	/^class Collect;$/;"	x
CollectTemplate	.\gen\Base-inl.h	/^  CollectTemplate() { }$/;"	f	class:folly::gen::detail::CollectTemplate	access:public	signature:()
CollectTemplate	.\gen\Base-inl.h	/^class CollectTemplate : public Operator<CollectTemplate<Container, Allocator>> {$/;"	c	namespace:folly::gen::detail	inherits:Operator
CollectTemplate	.\gen\Base.h	/^class CollectTemplate;$/;"	x
Color	.\experimental\symbolizer\Symbolizer.h	/^  enum Color { DEFAULT, RED, GREEN, YELLOW, BLUE, CYAN, WHITE, PURPLE };$/;"	g	class:folly::symbolizer::SymbolizePrinter	access:public
CompactStripe	.\detail\CacheLocality.h	/^  typedef uint8_t CompactStripe;$/;"	t	struct:folly::detail::AccessSpreader	access:private
ComparableAsStringPiece	.\Range.h	/^struct ComparableAsStringPiece {$/;"	s	namespace:folly::detail
CompareOp	.\dynamic-inl.h	/^struct dynamic::CompareOp {$/;"	s	class:folly::dynamic
CompareOp	.\dynamic-inl.h	/^struct dynamic::CompareOp<dynamic::ObjectImpl> {$/;"	s	class:folly::dynamic
CompareOp	.\dynamic.h	/^  template<class T> struct CompareOp;$/;"	x
CompleteType	.\test\TraitsTest.cpp	/^struct CompleteType {};$/;"	s	file:
Composed	.\gen\Core-inl.h	/^  Composed() {}$/;"	f	class:folly::gen::detail::Composed	access:public	signature:()
Composed	.\gen\Core-inl.h	/^  Composed(First first, Second second)$/;"	f	class:folly::gen::detail::Composed	access:public	signature:(First first, Second second)
Composed	.\gen\Core-inl.h	/^class Composed : public Operator<Composed<First, Second>> {$/;"	c	namespace:folly::gen::detail	inherits:Operator
Composed	.\gen\Core.h	/^class Composed;$/;"	x
Composer	.\gen\Base-inl.h	/^  explicit Composer(Operators op)$/;"	f	class:folly::gen::detail::Composer	access:public	signature:(Operators op)
Composer	.\gen\Base-inl.h	/^class Composer {$/;"	c	namespace:folly::gen::detail
Composer	.\gen\Base.h	/^class Composer;$/;"	x
CompressedList	.\experimental\EliasFanoCoding.h	/^  typedef EliasFanoCompressedList CompressedList;$/;"	t	struct:folly::compression::EliasFanoEncoder	access:public
CompressionCorruptionTest	.\io\test\CompressionTest.cpp	/^class CompressionCorruptionTest : public testing::TestWithParam<CodecType> {$/;"	c	namespace:folly::io::test	file:	inherits:testing::TestWithParam
CompressionTest	.\io\test\CompressionTest.cpp	/^class CompressionTest : public testing::TestWithParam<$/;"	c	namespace:folly::io::test	file:	inherits:testing::TestWithParam
Concat	.\gen\Base-inl.h	/^  Concat() { }$/;"	f	class:folly::gen::detail::Concat	access:public	signature:()
Concat	.\gen\Base-inl.h	/^class Concat : public Operator<Concat> {$/;"	c	namespace:folly::gen::detail	inherits:Operator
Concat	.\gen\Base.h	/^class Concat;$/;"	x
ConcurrentAccessData	.\test\ConcurrentSkipListBenchmark.cpp	/^  explicit ConcurrentAccessData(int size) :$/;"	f	class:__anon113::ConcurrentAccessData	access:public	signature:(int size)
ConcurrentAccessData	.\test\ConcurrentSkipListBenchmark.cpp	/^class ConcurrentAccessData {$/;"	c	namespace:__anon113	file:
ConcurrentSkipList	.\ConcurrentSkipList.h	/^  explicit ConcurrentSkipList(int height, const NodeAlloc& alloc = NodeAlloc())$/;"	f	class:folly::ConcurrentSkipList	access:public	signature:(int height, const NodeAlloc& alloc = NodeAlloc())
ConcurrentSkipList	.\ConcurrentSkipList.h	/^class ConcurrentSkipList {$/;"	c	namespace:folly
Config	.\AtomicHashArray.h	/^    constexpr Config() : emptyKey((KeyT)-1),$/;"	f	struct:folly::AtomicHashArray::Config	access:public	signature:()
Config	.\AtomicHashArray.h	/^  struct Config {$/;"	s	class:folly::AtomicHashArray	access:public
Config	.\AtomicHashMap.h	/^  typedef typename SubMap::Config Config;$/;"	t	class:folly::AtomicHashMap	access:public
ConnectionManager	.\experimental\wangle\ConnectionManager.cpp	/^ConnectionManager::ConnectionManager(EventBase* eventBase,$/;"	f	class:folly::wangle::ConnectionManager	signature:(EventBase* eventBase, milliseconds timeout, Callback* callback)
ConnectionManager	.\experimental\wangle\ConnectionManager.h	/^  ConnectionManager(const ConnectionManager&) = delete;$/;"	p	class:folly::wangle::ConnectionManager	access:private	signature:(const ConnectionManager&)
ConnectionManager	.\experimental\wangle\ConnectionManager.h	/^  ConnectionManager(folly::EventBase* eventBase,$/;"	p	class:folly::wangle::ConnectionManager	access:public	signature:(folly::EventBase* eventBase, std::chrono::milliseconds timeout, Callback* callback = nullptr)
ConnectionManager	.\experimental\wangle\ConnectionManager.h	/^class ConnectionManager: public folly::DelayedDestruction {$/;"	c	namespace:folly::wangle	inherits:folly::DelayedDestruction
ConnectionManager	.\experimental\wangle\ManagedConnection.h	/^  friend class ConnectionManager;$/;"	x
ConnectionManager	.\experimental\wangle\ManagedConnection.h	/^class ConnectionManager;$/;"	x
Const	.\gen\Base.h	/^  Const,$/;"	e	enum:folly::gen::MemberType
Const	.\test\HasMemberFnTraitsTest.cpp	/^struct Const {$/;"	s	file:
Const::test	.\test\HasMemberFnTraitsTest.cpp	/^  void test() const;$/;"	p	struct:Const	file:	access:public	signature:() const
ConstLockedPtr	.\Synchronized.h	/^    ConstLockedPtr() = delete;$/;"	p	struct:folly::Synchronized::ConstLockedPtr	access:public	signature:()
ConstLockedPtr	.\Synchronized.h	/^    ConstLockedPtr(const ConstLockedPtr& rhs) : parent_(rhs.parent_) {$/;"	f	struct:folly::Synchronized::ConstLockedPtr	access:public	signature:(const ConstLockedPtr& rhs)
ConstLockedPtr	.\Synchronized.h	/^    ConstLockedPtr(const Synchronized* parent, detail::InternalDoNotUse)$/;"	f	struct:folly::Synchronized::ConstLockedPtr	access:public	signature:(const Synchronized* parent, detail::InternalDoNotUse)
ConstLockedPtr	.\Synchronized.h	/^    ConstLockedPtr(const Synchronized* parent, unsigned int milliseconds) {$/;"	f	struct:folly::Synchronized::ConstLockedPtr	access:public	signature:(const Synchronized* parent, unsigned int milliseconds)
ConstLockedPtr	.\Synchronized.h	/^    explicit ConstLockedPtr(const LockedPtr& rhs) : parent_(rhs.parent_) {$/;"	f	struct:folly::Synchronized::ConstLockedPtr	access:public	signature:(const LockedPtr& rhs)
ConstLockedPtr	.\Synchronized.h	/^    explicit ConstLockedPtr(const Synchronized* parent) : parent_(parent) {$/;"	f	struct:folly::Synchronized::ConstLockedPtr	access:public	signature:(const Synchronized* parent)
ConstLockedPtr	.\Synchronized.h	/^  struct ConstLockedPtr {$/;"	s	struct:folly::Synchronized	access:public
ConstMemberFunction	.\gen\Base.h	/^  explicit ConstMemberFunction(MemberPtr member)$/;"	f	class:folly::gen::ConstMemberFunction	access:public	signature:(MemberPtr member)
ConstMemberFunction	.\gen\Base.h	/^class ConstMemberFunction{$/;"	c	namespace:folly::gen
ConstRefType	.\gen\Combine-inl.h	/^    typedef const typename Container::value_type& ConstRefType;$/;"	t	class:folly::gen::detail::Interleave::Generator	access:private
ConstVisitorResult	.\detail\DiscriminatedPtrDetail.h	/^struct ConstVisitorResult {$/;"	s	namespace:folly::dptr_detail
ConstVisitorResult1	.\detail\DiscriminatedPtrDetail.h	/^struct ConstVisitorResult1 {$/;"	s	namespace:folly::dptr_detail
ConstantDataHolder	.\io\test\CompressionTest.cpp	/^  explicit ConstantDataHolder(size_t sizeLog2);$/;"	p	class:folly::io::test::ConstantDataHolder	file:	access:public	signature:(size_t sizeLog2)
ConstantDataHolder	.\io\test\CompressionTest.cpp	/^ConstantDataHolder::ConstantDataHolder(size_t sizeLog2)$/;"	f	class:folly::io::test::ConstantDataHolder	signature:(size_t sizeLog2)
ConstantDataHolder	.\io\test\CompressionTest.cpp	/^class ConstantDataHolder : public DataHolder {$/;"	c	namespace:folly::io::test	file:	inherits:DataHolder
Constructed	.\test\stl_tests\StlVectorTest.cpp	/^  static int Constructed;$/;"	m	struct:AllocTracker	file:	access:public
Constructed	.\test\stl_tests\StlVectorTest.cpp	/^int AllocTracker::Constructed = 0;$/;"	m	class:AllocTracker	file:
Consumer	.\io\async\NotificationQueue.h	/^    Consumer()$/;"	f	class:folly::NotificationQueue::Consumer	access:public	signature:()
Consumer	.\io\async\NotificationQueue.h	/^  class Consumer : private EventHandler {$/;"	c	class:folly::NotificationQueue	inherits:EventHandler	access:public
ContainerT	.\sorted_vector_types.h	/^  typedef std::vector<T,Allocator> ContainerT;$/;"	t	class:folly::sorted_vector_set	access:private
ContainerT	.\sorted_vector_types.h	/^  typedef std::vector<std::pair<Key,Value>,Allocator> ContainerT;$/;"	t	class:folly::sorted_vector_map	access:private
ContainerType	.\gen\Base-inl.h	/^  typedef Container ContainerType;$/;"	t	class:folly::gen::detail::CopiedSource	access:public
ContainerType	.\stats\TimeseriesHistogram.h	/^  typedef C ContainerType;$/;"	t	class:folly::TimeseriesHistogram	access:public
Contains	.\gen\Base-inl.h	/^  explicit Contains(Needle needle)$/;"	f	class:folly::gen::detail::Contains	access:public	signature:(Needle needle)
Contains	.\gen\Base-inl.h	/^class Contains : public Operator<Contains<Needle>> {$/;"	c	namespace:folly::gen::detail	inherits:Operator
Contains	.\gen\Base.h	/^class Contains;$/;"	x
Contains	.\wangle\Try.h	/^  enum class Contains {$/;"	c	class:folly::wangle::Try	access:private
ContainsOptional	.\test\OptionalTest.cpp	/^  ContainsOptional() { }$/;"	f	class:folly::ContainsOptional	access:public	signature:()
ContainsOptional	.\test\OptionalTest.cpp	/^  explicit ContainsOptional(int x) : opt_(x) { }$/;"	f	class:folly::ContainsOptional	access:public	signature:(int x)
ContainsOptional	.\test\OptionalTest.cpp	/^class ContainsOptional {$/;"	c	namespace:folly	file:
ConversionHelper	.\dynamic-inl.h	/^  struct ConversionHelper<$/;"	s	namespace:folly::detail
ConversionHelper	.\dynamic-inl.h	/^  template<class T, class Enable = void> struct ConversionHelper;$/;"	x
CopiedSource	.\gen\Base-inl.h	/^  CopiedSource(const CopiedSource<StorageType, Container>& source)$/;"	f	class:folly::gen::detail::CopiedSource	access:public	signature:(const CopiedSource<StorageType, Container>& source)
CopiedSource	.\gen\Base-inl.h	/^  explicit CopiedSource(Container&& container) :$/;"	f	class:folly::gen::detail::CopiedSource	access:public	signature:(Container&& container)
CopiedSource	.\gen\Base-inl.h	/^  explicit CopiedSource(const SourceContainer& container)$/;"	f	class:folly::gen::detail::CopiedSource	access:public	signature:(const SourceContainer& container)
CopiedSource	.\gen\Base-inl.h	/^class CopiedSource :$/;"	c	namespace:folly::gen::detail	inherits:GenImpl
CopiedSource	.\gen\Base.h	/^class CopiedSource;$/;"	x
CopyBufferOp	.\io\IOBuf.h	/^  enum CopyBufferOp { COPY_BUFFER };$/;"	g	class:folly::IOBuf	access:public
CopyCount	.\test\ApplyTupleTest.cpp	/^  CopyCount() {}$/;"	f	struct:__anon104::CopyCount	access:public	signature:()
CopyCount	.\test\ApplyTupleTest.cpp	/^  CopyCount(CopyCount const&) {$/;"	f	struct:__anon104::CopyCount	access:public	signature:(CopyCount const&)
CopyCount	.\test\ApplyTupleTest.cpp	/^struct CopyCount {$/;"	s	namespace:__anon104	file:
CopyCount	.\test\LazyTest.cpp	/^  CopyCount() {}$/;"	f	struct:folly::CopyCount	access:public	signature:()
CopyCount	.\test\LazyTest.cpp	/^  CopyCount(CopyCount&&)      {}$/;"	f	struct:folly::CopyCount	access:public	signature:(CopyCount&&)
CopyCount	.\test\LazyTest.cpp	/^  CopyCount(const CopyCount&) { ++count; }$/;"	f	struct:folly::CopyCount	access:public	signature:(const CopyCount&)
CopyCount	.\test\LazyTest.cpp	/^struct CopyCount {$/;"	s	namespace:folly	file:
CopyCounter	.\gen\test\BaseTest.cpp	/^  CopyCounter() : copies(0), moves(0) {$/;"	f	struct:CopyCounter	access:public	signature:()
CopyCounter	.\gen\test\BaseTest.cpp	/^  CopyCounter(const CopyCounter& source) {$/;"	f	struct:CopyCounter	access:public	signature:(const CopyCounter& source)
CopyCounter	.\gen\test\BaseTest.cpp	/^struct CopyCounter {$/;"	s	file:
CopyCounter::CopyCounter	.\gen\test\BaseTest.cpp	/^  CopyCounter() : copies(0), moves(0) {$/;"	f	struct:CopyCounter	access:public	signature:()
CopyCounter::CopyCounter	.\gen\test\BaseTest.cpp	/^  CopyCounter(const CopyCounter& source) {$/;"	f	struct:CopyCounter	access:public	signature:(const CopyCounter& source)
CopyCounter::alive	.\gen\test\BaseTest.cpp	/^  static int alive;$/;"	m	struct:CopyCounter	file:	access:public
CopyCounter::alive	.\gen\test\BaseTest.cpp	/^int CopyCounter::alive = 0;$/;"	m	class:CopyCounter	file:
CopyCounter::copies	.\gen\test\BaseTest.cpp	/^  int copies;$/;"	m	struct:CopyCounter	file:	access:public
CopyCounter::moves	.\gen\test\BaseTest.cpp	/^  int moves;$/;"	m	struct:CopyCounter	file:	access:public
CopyCounter::operator =	.\gen\test\BaseTest.cpp	/^  CopyCounter& operator=(CopyCounter&& source) {$/;"	f	struct:CopyCounter	access:public	signature:(CopyCounter&& source)
CopyCounter::operator =	.\gen\test\BaseTest.cpp	/^  CopyCounter& operator=(const CopyCounter& source) {$/;"	f	struct:CopyCounter	access:public	signature:(const CopyCounter& source)
CopyCounter::~CopyCounter	.\gen\test\BaseTest.cpp	/^  ~CopyCounter() {$/;"	f	struct:CopyCounter	access:public	signature:()
CorrectnessTest	.\test\ProducerConsumerQueueTest.cpp	/^  explicit CorrectnessTest()$/;"	f	struct:__anon128::CorrectnessTest	access:public	signature:()
CorrectnessTest	.\test\ProducerConsumerQueueTest.cpp	/^struct CorrectnessTest {$/;"	s	namespace:__anon128	file:
Count	.\gen\Base-inl.h	/^  Count() { }$/;"	f	class:folly::gen::detail::Count	access:public	signature:()
Count	.\gen\Base-inl.h	/^class Count : public Operator<Count> {$/;"	c	namespace:folly::gen::detail	inherits:Operator
CountCA	.\test\stl_tests\StlVectorTest.cpp	/^  static int CountDC, CountCC, CountMC, CountOC, CountCA, CountMA;$/;"	m	struct:Counter	file:	access:public
CountCA	.\test\stl_tests\StlVectorTest.cpp	/^int Counter::CountCA = 0;$/;"	m	class:Counter	file:
CountCC	.\test\stl_tests\StlVectorTest.cpp	/^  static int CountDC, CountCC, CountMC, CountOC, CountCA, CountMA;$/;"	m	struct:Counter	file:	access:public
CountCC	.\test\stl_tests\StlVectorTest.cpp	/^int Counter::CountCC = 0;$/;"	m	class:Counter	file:
CountCopyCtor	.\test\sorted_vector_test.cpp	/^  CountCopyCtor(const CountCopyCtor& c)$/;"	f	struct:__anon133::CountCopyCtor	access:public	signature:(const CountCopyCtor& c)
CountCopyCtor	.\test\sorted_vector_test.cpp	/^  explicit CountCopyCtor() : val_(0) {}$/;"	f	struct:__anon133::CountCopyCtor	access:public	signature:()
CountCopyCtor	.\test\sorted_vector_test.cpp	/^  explicit CountCopyCtor(int val) : val_(val), count_(0) {}$/;"	f	struct:__anon133::CountCopyCtor	access:public	signature:(int val)
CountCopyCtor	.\test\sorted_vector_test.cpp	/^struct CountCopyCtor {$/;"	s	namespace:__anon133	file:
CountDC	.\test\stl_tests\StlVectorTest.cpp	/^  static int CountDC, CountCC, CountMC, CountOC, CountCA, CountMA;$/;"	m	struct:Counter	file:	access:public
CountDC	.\test\stl_tests\StlVectorTest.cpp	/^int Counter::CountDC = 0;$/;"	m	class:Counter	file:
CountDestroy	.\test\stl_tests\StlVectorTest.cpp	/^  static int CountDestroy, CountTotalOps, CountLoggedConstruction;$/;"	m	struct:Counter	file:	access:public
CountDestroy	.\test\stl_tests\StlVectorTest.cpp	/^int Counter::CountDestroy = 0;$/;"	m	class:Counter	file:
CountFromBucket	.\stats\Histogram.h	/^  struct CountFromBucket {$/;"	s	class:folly::Histogram	access:private
CountFromInterval	.\stats\TimeseriesHistogram.h	/^    explicit CountFromInterval(TimeType start, TimeType end)$/;"	f	struct:folly::TimeseriesHistogram::CountFromInterval	access:public	signature:(TimeType start, TimeType end)
CountFromInterval	.\stats\TimeseriesHistogram.h	/^  struct CountFromInterval {$/;"	s	class:folly::TimeseriesHistogram	access:private
CountFromLevel	.\stats\TimeseriesHistogram.h	/^    explicit CountFromLevel(int level) : level_(level) {}$/;"	f	struct:folly::TimeseriesHistogram::CountFromLevel	access:public	signature:(int level)
CountFromLevel	.\stats\TimeseriesHistogram.h	/^  struct CountFromLevel {$/;"	s	class:folly::TimeseriesHistogram	access:private
CountLoggedConstruction	.\test\stl_tests\StlVectorTest.cpp	/^  static int CountDestroy, CountTotalOps, CountLoggedConstruction;$/;"	m	struct:Counter	file:	access:public
CountLoggedConstruction	.\test\stl_tests\StlVectorTest.cpp	/^int Counter::CountLoggedConstruction = 0;$/;"	m	class:Counter	file:
CountMA	.\test\stl_tests\StlVectorTest.cpp	/^  static int CountDC, CountCC, CountMC, CountOC, CountCA, CountMA;$/;"	m	struct:Counter	file:	access:public
CountMA	.\test\stl_tests\StlVectorTest.cpp	/^int Counter::CountMA = 0;$/;"	m	class:Counter	file:
CountMC	.\test\stl_tests\StlVectorTest.cpp	/^  static int CountDC, CountCC, CountMC, CountOC, CountCA, CountMA;$/;"	m	struct:Counter	file:	access:public
CountMC	.\test\stl_tests\StlVectorTest.cpp	/^int Counter::CountMC = 0;$/;"	m	class:Counter	file:
CountOC	.\test\stl_tests\StlVectorTest.cpp	/^  static int CountDC, CountCC, CountMC, CountOC, CountCA, CountMA;$/;"	m	struct:Counter	file:	access:public
CountOC	.\test\stl_tests\StlVectorTest.cpp	/^int Counter::CountOC = 0;$/;"	m	class:Counter	file:
CountTicks	.\test\stl_tests\StlVectorTest.cpp	/^  static int CountTicks;$/;"	m	struct:Ticker	file:	access:public
CountTicks	.\test\stl_tests\StlVectorTest.cpp	/^int Ticker::CountTicks = 0;$/;"	m	class:Ticker	file:
CountTotalOps	.\test\stl_tests\StlVectorTest.cpp	/^  static int CountDestroy, CountTotalOps, CountLoggedConstruction;$/;"	m	struct:Counter	file:	access:public
CountTotalOps	.\test\stl_tests\StlVectorTest.cpp	/^int Counter::CountTotalOps = 0;$/;"	m	class:Counter	file:
CountedIntrusiveList	.\IntrusiveList.h	/^class CountedIntrusiveList : public boost::intrusive::list<$/;"	c	namespace:folly	inherits:boost::intrusive::list
Counter	.\test\stl_tests\StlVectorTest.cpp	/^struct Counter {$/;"	s	file:
Counter::CountCA	.\test\stl_tests\StlVectorTest.cpp	/^  static int CountDC, CountCC, CountMC, CountOC, CountCA, CountMA;$/;"	m	struct:Counter	file:	access:public
Counter::CountCA	.\test\stl_tests\StlVectorTest.cpp	/^int Counter::CountCA = 0;$/;"	m	class:Counter	file:
Counter::CountCC	.\test\stl_tests\StlVectorTest.cpp	/^  static int CountDC, CountCC, CountMC, CountOC, CountCA, CountMA;$/;"	m	struct:Counter	file:	access:public
Counter::CountCC	.\test\stl_tests\StlVectorTest.cpp	/^int Counter::CountCC = 0;$/;"	m	class:Counter	file:
Counter::CountDC	.\test\stl_tests\StlVectorTest.cpp	/^  static int CountDC, CountCC, CountMC, CountOC, CountCA, CountMA;$/;"	m	struct:Counter	file:	access:public
Counter::CountDC	.\test\stl_tests\StlVectorTest.cpp	/^int Counter::CountDC = 0;$/;"	m	class:Counter	file:
Counter::CountDestroy	.\test\stl_tests\StlVectorTest.cpp	/^  static int CountDestroy, CountTotalOps, CountLoggedConstruction;$/;"	m	struct:Counter	file:	access:public
Counter::CountDestroy	.\test\stl_tests\StlVectorTest.cpp	/^int Counter::CountDestroy = 0;$/;"	m	class:Counter	file:
Counter::CountLoggedConstruction	.\test\stl_tests\StlVectorTest.cpp	/^  static int CountDestroy, CountTotalOps, CountLoggedConstruction;$/;"	m	struct:Counter	file:	access:public
Counter::CountLoggedConstruction	.\test\stl_tests\StlVectorTest.cpp	/^int Counter::CountLoggedConstruction = 0;$/;"	m	class:Counter	file:
Counter::CountMA	.\test\stl_tests\StlVectorTest.cpp	/^  static int CountDC, CountCC, CountMC, CountOC, CountCA, CountMA;$/;"	m	struct:Counter	file:	access:public
Counter::CountMA	.\test\stl_tests\StlVectorTest.cpp	/^int Counter::CountMA = 0;$/;"	m	class:Counter	file:
Counter::CountMC	.\test\stl_tests\StlVectorTest.cpp	/^  static int CountDC, CountCC, CountMC, CountOC, CountCA, CountMA;$/;"	m	struct:Counter	file:	access:public
Counter::CountMC	.\test\stl_tests\StlVectorTest.cpp	/^int Counter::CountMC = 0;$/;"	m	class:Counter	file:
Counter::CountOC	.\test\stl_tests\StlVectorTest.cpp	/^  static int CountDC, CountCC, CountMC, CountOC, CountCA, CountMA;$/;"	m	struct:Counter	file:	access:public
Counter::CountOC	.\test\stl_tests\StlVectorTest.cpp	/^int Counter::CountOC = 0;$/;"	m	class:Counter	file:
Counter::CountTotalOps	.\test\stl_tests\StlVectorTest.cpp	/^  static int CountDestroy, CountTotalOps, CountLoggedConstruction;$/;"	m	struct:Counter	file:	access:public
Counter::CountTotalOps	.\test\stl_tests\StlVectorTest.cpp	/^int Counter::CountTotalOps = 0;$/;"	m	class:Counter	file:
Counters	.\test\AtomicHashMapTest.cpp	/^  explicit Counters(size_t numCounters) : ahm(numCounters) {}$/;"	f	class:Counters	access:public	signature:(size_t numCounters)
Counters	.\test\AtomicHashMapTest.cpp	/^class Counters {$/;"	c	file:
Counters::Counters	.\test\AtomicHashMapTest.cpp	/^  explicit Counters(size_t numCounters) : ahm(numCounters) {}$/;"	f	class:Counters	access:public	signature:(size_t numCounters)
Counters::ahm	.\test\AtomicHashMapTest.cpp	/^  AtomicHashMap<int64_t,int64_t> ahm;$/;"	m	class:Counters	file:	access:private
Counters::getValue	.\test\AtomicHashMapTest.cpp	/^  int64_t getValue(int64_t obj_id) {$/;"	f	class:Counters	access:public	signature:(int64_t obj_id)
Counters::increment	.\test\AtomicHashMapTest.cpp	/^  void increment(int64_t obj_id) {$/;"	f	class:Counters	access:public	signature:(int64_t obj_id)
Counters::toString	.\test\AtomicHashMapTest.cpp	/^  string toString() {$/;"	f	class:Counters	access:public	signature:()
CpuId	.\CpuId.h	/^  CpuId() {$/;"	f	class:folly::CpuId	access:public	signature:()
CpuId	.\CpuId.h	/^class CpuId {$/;"	c	namespace:folly
CreateFunc	.\experimental\Singleton.h	/^  typedef std::function<T*(void)> CreateFunc;$/;"	t	class:folly::Singleton	access:public
CreateFunc	.\experimental\Singleton.h	/^  typedef std::function<void*(void)> CreateFunc;$/;"	t	class:folly::SingletonVault	access:public
CreateOp	.\io\IOBuf.h	/^  enum CreateOp { CREATE };$/;"	g	class:folly::IOBuf	access:public
Cursor	.\io\Cursor.h	/^  explicit Cursor(const IOBuf* buf)$/;"	f	class:folly::io::Cursor	access:public	signature:(const IOBuf* buf)
Cursor	.\io\Cursor.h	/^  explicit Cursor(const detail::CursorBase<OtherDerived, OtherBuf>& cursor)$/;"	f	class:folly::io::Cursor	access:public	signature:(const detail::CursorBase<OtherDerived, OtherBuf>& cursor)
Cursor	.\io\Cursor.h	/^class Cursor : public detail::CursorBase<Cursor, const IOBuf> {$/;"	c	namespace:folly::io	inherits:detail::CursorBase
CursorAccess	.\io\Cursor.h	/^enum class CursorAccess {$/;"	c	namespace:folly::io
CursorBase	.\io\Cursor.h	/^  explicit CursorBase(BufType* buf)$/;"	f	class:folly::io::detail::CursorBase	access:public	signature:(BufType* buf)
CursorBase	.\io\Cursor.h	/^  explicit CursorBase(const CursorBase<OtherDerived, OtherBuf>& cursor)$/;"	f	class:folly::io::detail::CursorBase	access:public	signature:(const CursorBase<OtherDerived, OtherBuf>& cursor)
CursorBase	.\io\Cursor.h	/^  template <class D, typename B> friend class CursorBase;$/;"	x
CursorBase	.\io\Cursor.h	/^class CursorBase {$/;"	c	namespace:folly::io::detail
CustomDeleter	.\detail\ThreadLocalDetail.h	/^  explicit CustomDeleter(Deleter d) : deleter_(d) { }$/;"	f	class:folly::threadlocal_detail::CustomDeleter	access:public	signature:(Deleter d)
CustomDeleter	.\detail\ThreadLocalDetail.h	/^class CustomDeleter : public DeleterBase {$/;"	c	namespace:folly::threadlocal_detail	inherits:DeleterBase
CustomDeleter	.\io\test\IOBufTest.cpp	/^typedef std::function<void(OwnershipTestClass*)> CustomDeleter;$/;"	t	namespace:__anon71	file:
CxaBeginCatchType	.\experimental\exception_tracer\ExceptionTracerLib.cpp	/^typedef void* (*CxaBeginCatchType)(void*);$/;"	t	file:
CxaEndCatchType	.\experimental\exception_tracer\ExceptionTracerLib.cpp	/^typedef void (*CxaEndCatchType)(void);$/;"	t	file:
CxaRethrowType	.\experimental\exception_tracer\ExceptionTracerLib.cpp	/^FOLLY_NORETURN typedef void (*CxaRethrowType)(void);$/;"	t	file:
CxaThrowType	.\experimental\exception_tracer\ExceptionTracerLib.cpp	/^FOLLY_NORETURN typedef void (*CxaThrowType)(void*, std::type_info*,$/;"	t	file:
Cycle	.\gen\Base-inl.h	/^  Cycle()$/;"	f	class:folly::gen::detail::Cycle	access:public	signature:()
Cycle	.\gen\Base-inl.h	/^  explicit Cycle(off_t limit)$/;"	f	class:folly::gen::detail::Cycle	access:public	signature:(off_t limit)
Cycle	.\gen\Base-inl.h	/^class Cycle : public Operator<Cycle> {$/;"	c	namespace:folly::gen::detail	inherits:Operator
Cycle	.\gen\Base.h	/^class Cycle;$/;"	x
D	.\CpuId.h	116;"	d
D	.\CpuId.h	51;"	d
D	.\Foreach.h	/^  template <typename C, typename D> static char test(decltype(C() < D())*);$/;"	p	class:folly::detail::HasLess	access:private	signature:()
D0	.\test\stl_tests\StlVectorTest.cpp	/^  D0() = default;$/;"	p	struct:D0	file:	access:public	signature:()
D0	.\test\stl_tests\StlVectorTest.cpp	/^  D0() = delete;$/;"	p	struct:D0	file:	access:public	signature:()
D0	.\test\stl_tests\StlVectorTest.cpp	/^  D0(D0&&) = default;$/;"	p	struct:D0	file:	access:public	signature:(D0&&)
D0	.\test\stl_tests\StlVectorTest.cpp	/^  D0(const D0&) = default;$/;"	p	struct:D0	file:	access:public	signature:(const D0&)
D0	.\test\stl_tests\StlVectorTest.cpp	/^  explicit D0(std::nullptr_t) {}$/;"	f	struct:D0	access:public	signature:(std::nullptr_t)
D0	.\test\stl_tests\StlVectorTest.cpp	/^template <> struct D0<true> {$/;"	s	file:
D0	.\test\stl_tests\StlVectorTest.cpp	/^template <bool b> struct D0 {$/;"	s	file:
D0::D0	.\test\stl_tests\StlVectorTest.cpp	/^  D0() = default;$/;"	p	struct:D0	file:	access:public	signature:()
D0::D0	.\test\stl_tests\StlVectorTest.cpp	/^  D0() = delete;$/;"	p	struct:D0	file:	access:public	signature:()
D0::D0	.\test\stl_tests\StlVectorTest.cpp	/^  D0(D0&&) = default;$/;"	p	struct:D0	file:	access:public	signature:(D0&&)
D0::D0	.\test\stl_tests\StlVectorTest.cpp	/^  D0(const D0&) = default;$/;"	p	struct:D0	file:	access:public	signature:(const D0&)
D0::D0	.\test\stl_tests\StlVectorTest.cpp	/^  explicit D0(std::nullptr_t) {}$/;"	f	struct:D0	access:public	signature:(std::nullptr_t)
D0::operator =	.\test\stl_tests\StlVectorTest.cpp	/^  D0& operator=(D0&&) = default;$/;"	p	struct:D0	file:	access:public	signature:(D0&&)
D0::operator =	.\test\stl_tests\StlVectorTest.cpp	/^  D0& operator=(const D0&) = default;$/;"	p	struct:D0	file:	access:public	signature:(const D0&)
D1	.\test\stl_tests\StlVectorTest.cpp	/^  D1() = default;$/;"	p	struct:D1	file:	access:public	signature:()
D1	.\test\stl_tests\StlVectorTest.cpp	/^  D1(D1&&) = default;$/;"	p	struct:D1	file:	access:public	signature:(D1&&)
D1	.\test\stl_tests\StlVectorTest.cpp	/^  D1(const D1&) = default;$/;"	p	struct:D1	file:	access:public	signature:(const D1&)
D1	.\test\stl_tests\StlVectorTest.cpp	/^  D1(const D1&) = delete;$/;"	p	struct:D1	file:	access:public	signature:(const D1&)
D1	.\test\stl_tests\StlVectorTest.cpp	/^  explicit D1(std::nullptr_t) {}$/;"	f	struct:D1	access:public	signature:(std::nullptr_t)
D1	.\test\stl_tests\StlVectorTest.cpp	/^template <> struct D1<true> {$/;"	s	file:
D1	.\test\stl_tests\StlVectorTest.cpp	/^template <bool b> struct D1 {$/;"	s	file:
D1::D1	.\test\stl_tests\StlVectorTest.cpp	/^  D1() = default;$/;"	p	struct:D1	file:	access:public	signature:()
D1::D1	.\test\stl_tests\StlVectorTest.cpp	/^  D1(D1&&) = default;$/;"	p	struct:D1	file:	access:public	signature:(D1&&)
D1::D1	.\test\stl_tests\StlVectorTest.cpp	/^  D1(const D1&) = default;$/;"	p	struct:D1	file:	access:public	signature:(const D1&)
D1::D1	.\test\stl_tests\StlVectorTest.cpp	/^  D1(const D1&) = delete;$/;"	p	struct:D1	file:	access:public	signature:(const D1&)
D1::D1	.\test\stl_tests\StlVectorTest.cpp	/^  explicit D1(std::nullptr_t) {}$/;"	f	struct:D1	access:public	signature:(std::nullptr_t)
D1::operator =	.\test\stl_tests\StlVectorTest.cpp	/^  D1& operator=(D1&&) = default;$/;"	p	struct:D1	file:	access:public	signature:(D1&&)
D1::operator =	.\test\stl_tests\StlVectorTest.cpp	/^  D1& operator=(const D1&) = default;$/;"	p	struct:D1	file:	access:public	signature:(const D1&)
D2	.\test\stl_tests\StlVectorTest.cpp	/^  D2() = default;$/;"	p	struct:D2	file:	access:public	signature:()
D2	.\test\stl_tests\StlVectorTest.cpp	/^  D2(D2&&) = default;$/;"	p	struct:D2	file:	access:public	signature:(D2&&)
D2	.\test\stl_tests\StlVectorTest.cpp	/^  D2(D2&&) = delete;$/;"	p	struct:D2	file:	access:public	signature:(D2&&)
D2	.\test\stl_tests\StlVectorTest.cpp	/^  D2(const D2&) = default;$/;"	p	struct:D2	file:	access:public	signature:(const D2&)
D2	.\test\stl_tests\StlVectorTest.cpp	/^  explicit D2(std::nullptr_t) {}$/;"	f	struct:D2	access:public	signature:(std::nullptr_t)
D2	.\test\stl_tests\StlVectorTest.cpp	/^template <> struct D2<true> {$/;"	s	file:
D2	.\test\stl_tests\StlVectorTest.cpp	/^template <bool b> struct D2 {$/;"	s	file:
D2::D2	.\test\stl_tests\StlVectorTest.cpp	/^  D2() = default;$/;"	p	struct:D2	file:	access:public	signature:()
D2::D2	.\test\stl_tests\StlVectorTest.cpp	/^  D2(D2&&) = default;$/;"	p	struct:D2	file:	access:public	signature:(D2&&)
D2::D2	.\test\stl_tests\StlVectorTest.cpp	/^  D2(D2&&) = delete;$/;"	p	struct:D2	file:	access:public	signature:(D2&&)
D2::D2	.\test\stl_tests\StlVectorTest.cpp	/^  D2(const D2&) = default;$/;"	p	struct:D2	file:	access:public	signature:(const D2&)
D2::D2	.\test\stl_tests\StlVectorTest.cpp	/^  explicit D2(std::nullptr_t) {}$/;"	f	struct:D2	access:public	signature:(std::nullptr_t)
D2::operator =	.\test\stl_tests\StlVectorTest.cpp	/^  D2& operator=(D2&&) = default;$/;"	p	struct:D2	file:	access:public	signature:(D2&&)
D2::operator =	.\test\stl_tests\StlVectorTest.cpp	/^  D2& operator=(const D2&) = default;$/;"	p	struct:D2	file:	access:public	signature:(const D2&)
D3	.\test\stl_tests\StlVectorTest.cpp	/^  D3() = default;$/;"	p	struct:D3	file:	access:public	signature:()
D3	.\test\stl_tests\StlVectorTest.cpp	/^  D3(D3&&) = default;$/;"	p	struct:D3	file:	access:public	signature:(D3&&)
D3	.\test\stl_tests\StlVectorTest.cpp	/^  D3(const D3&) = default;$/;"	p	struct:D3	file:	access:public	signature:(const D3&)
D3	.\test\stl_tests\StlVectorTest.cpp	/^  explicit D3(std::nullptr_t) {}$/;"	f	struct:D3	access:public	signature:(std::nullptr_t)
D3	.\test\stl_tests\StlVectorTest.cpp	/^template <> struct D3<true> {$/;"	s	file:
D3	.\test\stl_tests\StlVectorTest.cpp	/^template <bool b> struct D3 {$/;"	s	file:
D3::D3	.\test\stl_tests\StlVectorTest.cpp	/^  D3() = default;$/;"	p	struct:D3	file:	access:public	signature:()
D3::D3	.\test\stl_tests\StlVectorTest.cpp	/^  D3(D3&&) = default;$/;"	p	struct:D3	file:	access:public	signature:(D3&&)
D3::D3	.\test\stl_tests\StlVectorTest.cpp	/^  D3(const D3&) = default;$/;"	p	struct:D3	file:	access:public	signature:(const D3&)
D3::D3	.\test\stl_tests\StlVectorTest.cpp	/^  explicit D3(std::nullptr_t) {}$/;"	f	struct:D3	access:public	signature:(std::nullptr_t)
D3::operator =	.\test\stl_tests\StlVectorTest.cpp	/^  D3& operator=(D3&&) = default;$/;"	p	struct:D3	file:	access:public	signature:(D3&&)
D3::operator =	.\test\stl_tests\StlVectorTest.cpp	/^  D3& operator=(const D3&) = default;$/;"	p	struct:D3	file:	access:public	signature:(const D3&)
D3::operator =	.\test\stl_tests\StlVectorTest.cpp	/^  D3& operator=(const D3&) = delete;$/;"	p	struct:D3	file:	access:public	signature:(const D3&)
D4	.\test\stl_tests\StlVectorTest.cpp	/^  D4() = default;$/;"	p	struct:D4	file:	access:public	signature:()
D4	.\test\stl_tests\StlVectorTest.cpp	/^  D4(D4&&) = default;$/;"	p	struct:D4	file:	access:public	signature:(D4&&)
D4	.\test\stl_tests\StlVectorTest.cpp	/^  D4(const D4&) = default;$/;"	p	struct:D4	file:	access:public	signature:(const D4&)
D4	.\test\stl_tests\StlVectorTest.cpp	/^  explicit D4(std::nullptr_t) {}$/;"	f	struct:D4	access:public	signature:(std::nullptr_t)
D4	.\test\stl_tests\StlVectorTest.cpp	/^template <> struct D4<true> {$/;"	s	file:
D4	.\test\stl_tests\StlVectorTest.cpp	/^template <bool b> struct D4 {$/;"	s	file:
D4::D4	.\test\stl_tests\StlVectorTest.cpp	/^  D4() = default;$/;"	p	struct:D4	file:	access:public	signature:()
D4::D4	.\test\stl_tests\StlVectorTest.cpp	/^  D4(D4&&) = default;$/;"	p	struct:D4	file:	access:public	signature:(D4&&)
D4::D4	.\test\stl_tests\StlVectorTest.cpp	/^  D4(const D4&) = default;$/;"	p	struct:D4	file:	access:public	signature:(const D4&)
D4::D4	.\test\stl_tests\StlVectorTest.cpp	/^  explicit D4(std::nullptr_t) {}$/;"	f	struct:D4	access:public	signature:(std::nullptr_t)
D4::operator =	.\test\stl_tests\StlVectorTest.cpp	/^  D4& operator=(D4&&) = default;$/;"	p	struct:D4	file:	access:public	signature:(D4&&)
D4::operator =	.\test\stl_tests\StlVectorTest.cpp	/^  D4& operator=(D4&&) = delete;$/;"	p	struct:D4	file:	access:public	signature:(D4&&)
D4::operator =	.\test\stl_tests\StlVectorTest.cpp	/^  D4& operator=(const D4&) = default;$/;"	p	struct:D4	file:	access:public	signature:(const D4&)
DC_DELETE	.\test\stl_tests\StlVectorTest.cpp	/^  DC_DELETE   = 0x8000,$/;"	e	enum:Flags	file:
DC_NOEXCEPT	.\test\stl_tests\StlVectorTest.cpp	/^  DC_NOEXCEPT = 0x1,$/;"	e	enum:Flags	file:
DC_THROW	.\test\stl_tests\StlVectorTest.cpp	/^  DC_THROW    = 0x2,$/;"	e	enum:Flags	file:
DD1	.\test\stl_tests\StlVectorTest.cpp	/^typedef Data<ALL_DELETE> DD1; \/\/ unoperable$/;"	t	file:
DD2	.\test\stl_tests\StlVectorTest.cpp	/^typedef Data<DC_DELETE | CC_DELETE | MC_DELETE> DD2; \/\/ unconstructible$/;"	t	file:
DD3	.\test\stl_tests\StlVectorTest.cpp	/^typedef Data<CA_DELETE | MA_DELETE> DD3; \/\/ unassignable$/;"	t	file:
DD4	.\test\stl_tests\StlVectorTest.cpp	/^typedef Data<CC_DELETE | MC_DELETE> DD4; \/\/ uncopyable$/;"	t	file:
DD5	.\test\stl_tests\StlVectorTest.cpp	/^typedef Data<ALL_DELETE & ~DC_DELETE> DD5; \/\/ only default constructible$/;"	t	file:
DD6	.\test\stl_tests\StlVectorTest.cpp	/^typedef Data<CC_DELETE> DD6; \/\/ move-only copy construction$/;"	t	file:
DD7	.\test\stl_tests\StlVectorTest.cpp	/^typedef Data<CA_DELETE> DD7; \/\/ move-only assignment$/;"	t	file:
DDSMA	.\test\stl_tests\StlVectorTest.cpp	/^typedef Data<ALL_DELETE | PROP_MOVE> DDSMA;$/;"	t	file:
DECL	.\test\stl_tests\StlVectorTest.cpp	870;"	d	file:
DECR	.\LifoSem.h	/^    DECR,$/;"	m	class:folly::detail::LifoSemBase::WaitResult	access:private
DEFAULT	.\FormatArg.h	/^    DEFAULT,$/;"	m	class:folly::FormatArg::Align	access:private
DEFAULT	.\FormatArg.h	/^    DEFAULT,$/;"	m	class:folly::FormatArg::Sign	access:private
DEFAULT	.\experimental\symbolizer\Symbolizer.h	/^  enum Color { DEFAULT, RED, GREEN, YELLOW, BLUE, CYAN, WHITE, PURPLE };$/;"	e	enum:folly::symbolizer::SymbolizePrinter::Color
DEFAULT_CATCHUP_EVERY_N	.\io\async\HHWheelTimer.h	/^  static constexpr uint32_t DEFAULT_CATCHUP_EVERY_N = 100;$/;"	m	class:folly::HHWheelTimer	access:private
DEFAULT_CLOCK_ID	.\Benchmark.h	/^enum Clock { DEFAULT_CLOCK_ID = CLOCK_REALTIME };$/;"	e	enum:folly::detail::Clock
DEFAULT_CONSTRUCTOR	.\test\MPMCQueueTest.cpp	/^  DEFAULT_CONSTRUCTOR,$/;"	e	enum:LifecycleEvent	file:
DEFAULT_TICK_INTERVAL	.\io\async\HHWheelTimer.cpp	/^int HHWheelTimer::DEFAULT_TICK_INTERVAL = 10;$/;"	m	class:folly::HHWheelTimer	file:
DEFAULT_TICK_INTERVAL	.\io\async\HHWheelTimer.h	/^  static int DEFAULT_TICK_INTERVAL;$/;"	m	class:folly::HHWheelTimer	access:public
DEFINE_BENCHMARK_GROUP	.\test\ConvTest.cpp	1022;"	d	file:
DEFINE_BENCHMARK_GROUP	.\test\ConvTest.cpp	1024;"	d	file:
DEFINE_BENCHMARK_GROUP	.\test\ConvTest.cpp	1051;"	d	file:
DEFINE_BENCHMARK_GROUP	.\test\ConvTest.cpp	1053;"	d	file:
DEFINE_BENCHMARK_GROUP	.\test\ConvTest.cpp	1065;"	d	file:
DEFINE_BENCHMARK_GROUP	.\test\ConvTest.cpp	995;"	d	file:
DEF_TYPE	.\dynamic.cpp	/^DEF_TYPE(bool,                "boolean", dynamic::BOOL);$/;"	p	namespace:folly	file:	signature:(bool, , dynamic::BOOL)
DEF_TYPE	.\dynamic.cpp	/^DEF_TYPE(double,              "double",  dynamic::DOUBLE);$/;"	p	namespace:folly	file:	signature:(double, , dynamic::DOUBLE)
DEF_TYPE	.\dynamic.cpp	/^DEF_TYPE(dynamic::Array,      "array",   dynamic::ARRAY);$/;"	p	namespace:folly	file:	signature:(dynamic::Array, , dynamic::ARRAY)
DEF_TYPE	.\dynamic.cpp	/^DEF_TYPE(dynamic::ObjectImpl, "object",  dynamic::OBJECT);$/;"	p	namespace:folly	file:	signature:(dynamic::ObjectImpl, , dynamic::OBJECT)
DEF_TYPE	.\dynamic.cpp	/^DEF_TYPE(fbstring,            "string",  dynamic::STRING);$/;"	p	namespace:folly	file:	signature:(fbstring, , dynamic::STRING)
DEF_TYPE	.\dynamic.cpp	/^DEF_TYPE(int64_t,             "int64",   dynamic::INT64);$/;"	p	namespace:folly	file:	signature:(int64_t, , dynamic::INT64)
DEF_TYPE	.\dynamic.cpp	/^DEF_TYPE(void*,               "null",    dynamic::NULLT);$/;"	p	namespace:folly	file:	signature:(void*, , dynamic::NULLT)
DEF_TYPE	.\dynamic.cpp	23;"	d	file:
DEF_TYPE	.\dynamic.cpp	35;"	d	file:
DESTRUCTOR	.\test\MPMCQueueTest.cpp	/^  DESTRUCTOR,$/;"	e	enum:LifecycleEvent	file:
DIEAbbreviation	.\experimental\symbolizer\Dwarf.h	/^  struct DIEAbbreviation {$/;"	s	class:folly::symbolizer::Dwarf	access:private
DLifoSem	.\test\LifoSemTests.cpp	/^typedef LifoSemImpl<DeterministicAtomic> DLifoSem;$/;"	t	file:
DMGL_ANSI	.\Demangle.cpp	42;"	d	file:
DMGL_ANSI	.\String.cpp	542;"	d	file:
DMGL_JAVA	.\Demangle.cpp	43;"	d	file:
DMGL_JAVA	.\String.cpp	543;"	d	file:
DMGL_NO_OPTS	.\Demangle.cpp	40;"	d	file:
DMGL_NO_OPTS	.\String.cpp	540;"	d	file:
DMGL_PARAMS	.\Demangle.cpp	41;"	d	file:
DMGL_PARAMS	.\String.cpp	541;"	d	file:
DMGL_RET_POSTFIX	.\Demangle.cpp	46;"	d	file:
DMGL_RET_POSTFIX	.\String.cpp	546;"	d	file:
DMGL_TYPES	.\Demangle.cpp	45;"	d	file:
DMGL_TYPES	.\String.cpp	545;"	d	file:
DMGL_VERBOSE	.\Demangle.cpp	44;"	d	file:
DMGL_VERBOSE	.\String.cpp	544;"	d	file:
DOUBLE	.\dynamic.h	/^    DOUBLE,$/;"	e	enum:folly::dynamic::Type
DRAIN1	.\experimental\wangle\ConnectionManager.h	/^    DRAIN1 = 0,$/;"	m	class:folly::wangle::ConnectionManager::ShutdownAction	access:private
DRAIN2	.\experimental\wangle\ConnectionManager.h	/^    DRAIN2 = 1,$/;"	m	class:folly::wangle::ConnectionManager::ShutdownAction	access:private
DSched	.\test\BatonTest.cpp	/^typedef DeterministicSchedule DSched;$/;"	t	file:
DSched	.\test\FutexTest.cpp	/^typedef DeterministicSchedule DSched;$/;"	t	file:
DSched	.\test\LifoSemTests.cpp	/^typedef DeterministicSchedule DSched;$/;"	t	file:
DSched	.\test\MPMCQueueTest.cpp	/^typedef DeterministicSchedule DSched;$/;"	t	file:
DYNAMIC_CONVERTER_H	.\DynamicConverter.h	20;"	d
D_allocate	.\FBVector.h	/^    T* D_allocate(size_type n) {$/;"	f	struct:folly::fbvector::Impl	access:public	signature:(size_type n)
D_uninitialized_copy_a	.\FBVector.h	/^  void D_uninitialized_copy_a(T* dest, It first, It last) {$/;"	f	signature:(T* dest, It first, It last)
D_uninitialized_fill_n_a	.\FBVector.h	/^  void D_uninitialized_fill_n_a(T* dest, size_type sz) {$/;"	f	signature:(T* dest, size_type sz)
D_uninitialized_fill_n_a	.\FBVector.h	/^  void D_uninitialized_fill_n_a(T* dest, size_type sz, VT value) {$/;"	f	signature:(T* dest, size_type sz, VT value)
D_uninitialized_move_a	.\FBVector.h	/^  void D_uninitialized_move_a(T* dest, It first, It last) {$/;"	f	signature:(T* dest, It first, It last)
Data	.\dynamic.h	/^    explicit Data() : nul(nullptr) {}$/;"	f	union:folly::dynamic::Data	access:public	signature:()
Data	.\dynamic.h	/^  union Data {$/;"	u	struct:folly::dynamic	access:private
Data	.\test\stl_tests\StlVectorTest.cpp	/^  Data() = default;$/;"	p	struct:Data	file:	access:public	signature:()
Data	.\test\stl_tests\StlVectorTest.cpp	/^  Data(Data&&) = default;$/;"	p	struct:Data	file:	access:public	signature:(Data&&)
Data	.\test\stl_tests\StlVectorTest.cpp	/^  Data(const Data&) = default;$/;"	p	struct:Data	file:	access:public	signature:(const Data&)
Data	.\test\stl_tests\StlVectorTest.cpp	/^  \/* implicit *\/ Data(int i)$/;"	f	struct:Data	access:public	signature:(int i)
Data	.\test\stl_tests\StlVectorTest.cpp	/^struct Data : DataTracker<f & IS_RELOCATABLE>,$/;"	s	file:	inherits:DataTracker,Counter,DataTicker,Delete
Data::Data	.\test\stl_tests\StlVectorTest.cpp	/^  Data() = default;$/;"	p	struct:Data	file:	access:public	signature:()
Data::Data	.\test\stl_tests\StlVectorTest.cpp	/^  Data(Data&&) = default;$/;"	p	struct:Data	file:	access:public	signature:(Data&&)
Data::Data	.\test\stl_tests\StlVectorTest.cpp	/^  Data(const Data&) = default;$/;"	p	struct:Data	file:	access:public	signature:(const Data&)
Data::Data	.\test\stl_tests\StlVectorTest.cpp	/^  \/* implicit *\/ Data(int i)$/;"	f	struct:Data	access:public	signature:(int i)
Data::flags	.\test\stl_tests\StlVectorTest.cpp	/^  static const Flags flags = f;$/;"	m	struct:Data	file:	access:public
Data::operator &	.\test\stl_tests\StlVectorTest.cpp	/^  int operator&() const;$/;"	p	struct:Data	file:	access:private	signature:() const
Data::operator =	.\test\stl_tests\StlVectorTest.cpp	/^  Data& operator=(Data&&) = default;$/;"	p	struct:Data	file:	access:public	signature:(Data&&)
Data::operator =	.\test\stl_tests\StlVectorTest.cpp	/^  Data& operator=(const Data&) = default;$/;"	p	struct:Data	file:	access:public	signature:(const Data&)
Data::spacehog	.\test\stl_tests\StlVectorTest.cpp	/^  char spacehog[pad ? pad : 1];$/;"	m	struct:Data	file:	access:public
Data::~Data	.\test\stl_tests\StlVectorTest.cpp	/^  ~Data() = default;$/;"	p	struct:Data	file:	access:public	signature:()
DataHolder	.\io\test\CompressionTest.cpp	/^  explicit DataHolder(size_t sizeLog2);$/;"	p	class:folly::io::test::DataHolder	file:	access:protected	signature:(size_t sizeLog2)
DataHolder	.\io\test\CompressionTest.cpp	/^DataHolder::DataHolder(size_t sizeLog2)$/;"	f	class:folly::io::test::DataHolder	signature:(size_t sizeLog2)
DataHolder	.\io\test\CompressionTest.cpp	/^class DataHolder : private boost::noncopyable {$/;"	c	namespace:folly::io::test	file:	inherits:boost::noncopyable
DataState	.\test\stl_tests\StlVectorTest.cpp	/^  \/* implicit *\/ DataState(const Vector& v) {$/;"	f	class:DataState	access:public	signature:(const Vector& v)
DataState	.\test\stl_tests\StlVectorTest.cpp	/^class DataState {$/;"	c	file:
DataState::DataState	.\test\stl_tests\StlVectorTest.cpp	/^  \/* implicit *\/ DataState(const Vector& v) {$/;"	f	class:DataState	access:public	signature:(const Vector& v)
DataState::data_	.\test\stl_tests\StlVectorTest.cpp	/^  int* data_;$/;"	m	class:DataState	file:	access:private
DataState::operator ==	.\test\stl_tests\StlVectorTest.cpp	/^  bool operator==(const DataState& o) const {$/;"	f	class:DataState	access:public	signature:(const DataState& o) const
DataState::operator []	.\test\stl_tests\StlVectorTest.cpp	/^  int operator[](size_type i) {$/;"	f	class:DataState	access:public	signature:(size_type i)
DataState::size	.\test\stl_tests\StlVectorTest.cpp	/^  size_type size() { return size_; }$/;"	f	class:DataState	access:public	signature:()
DataState::size_	.\test\stl_tests\StlVectorTest.cpp	/^  size_type size_;$/;"	m	class:DataState	file:	access:private
DataState::size_type	.\test\stl_tests\StlVectorTest.cpp	/^  typedef typename Vector::size_type size_type;$/;"	t	class:DataState	file:	access:private
DataState::~DataState	.\test\stl_tests\StlVectorTest.cpp	/^  ~DataState() {$/;"	f	class:DataState	access:public	signature:()
DataTicker	.\test\stl_tests\StlVectorTest.cpp	/^struct DataTicker : Ticker {$/;"	s	file:	inherits:Ticker
DataTicker::noexcept	.\test\stl_tests\StlVectorTest.cpp	/^  DataTicker() noexcept(f & DC_NOEXCEPT) {$/;"	f	struct:DataTicker	access:public	signature:(f & DC_NOEXCEPT)
DataTicker::noexcept	.\test\stl_tests\StlVectorTest.cpp	/^  DataTicker(DataTicker&&) noexcept(f & MC_NOEXCEPT) {$/;"	f	struct:DataTicker	access:public	signature:(f & MC_NOEXCEPT)
DataTicker::noexcept	.\test\stl_tests\StlVectorTest.cpp	/^  DataTicker(const DataTicker&) noexcept(f & CC_NOEXCEPT) {$/;"	f	struct:DataTicker	access:public	signature:(f & CC_NOEXCEPT)
DataTicker::noexcept	.\test\stl_tests\StlVectorTest.cpp	/^  explicit DataTicker(std::nullptr_t) noexcept(f & OC_NOEXCEPT) {$/;"	f	struct:DataTicker	access:public	signature:(f & OC_NOEXCEPT)
DataTicker::noexcept	.\test\stl_tests\StlVectorTest.cpp	/^  void operator=(DataTicker&&) noexcept(f & MA_NOEXCEPT) {$/;"	f	struct:DataTicker	access:public	signature:(f & MA_NOEXCEPT)
DataTicker::noexcept	.\test\stl_tests\StlVectorTest.cpp	/^  void operator=(const DataTicker&) noexcept(f & CA_NOEXCEPT) {$/;"	f	struct:DataTicker	access:public	signature:(f & CA_NOEXCEPT)
DataTracker	.\test\stl_tests\StlVectorTest.cpp	/^struct DataTracker : Tracker {$/;"	s	file:	inherits:Tracker
DataTracker::noexcept	.\test\stl_tests\StlVectorTest.cpp	/^  DataTracker() noexcept : Tracker(this, UID++) {$/;"	m	struct:DataTracker	file:	access:public
DataTracker::noexcept	.\test\stl_tests\StlVectorTest.cpp	/^  DataTracker(DataTracker&& o) noexcept : Tracker(this, o.uid) {$/;"	m	struct:DataTracker	file:	access:public
DataTracker::noexcept	.\test\stl_tests\StlVectorTest.cpp	/^  DataTracker(const DataTracker& o) noexcept : Tracker(this, o.uid) {$/;"	m	struct:DataTracker	file:	access:public
DataTracker::noexcept	.\test\stl_tests\StlVectorTest.cpp	/^  explicit DataTracker(int uid) noexcept : Tracker(this, uid) {$/;"	m	struct:DataTracker	file:	access:public
DataTracker::print	.\test\stl_tests\StlVectorTest.cpp	/^  void print(const std::string& fun) {$/;"	f	struct:DataTracker	access:public	signature:(const std::string& fun)
Dead	.\experimental\Singleton.h	/^    Dead,$/;"	m	class:folly::SingletonVault::SingletonEntryState	access:private
Default	.\experimental\EliasFanoCoding.h	/^struct Default {$/;"	s	namespace:folly::compression::instructions
DefaultGenerator	.\Random.h	/^  typedef __gnu_cxx::sfmt19937 DefaultGenerator;$/;"	t	class:folly::Random	access:public
DelayedDestruction	.\io\async\DelayedDestruction.h	/^  DelayedDestruction()$/;"	f	class:folly::DelayedDestruction	access:protected	signature:()
DelayedDestruction	.\io\async\DelayedDestruction.h	/^class DelayedDestruction : private boost::noncopyable {$/;"	c	namespace:folly	inherits:boost::noncopyable
Delete	.\test\stl_tests\StlVectorTest.cpp	/^  Delete() = default;$/;"	p	struct:Delete	file:	access:public	signature:()
Delete	.\test\stl_tests\StlVectorTest.cpp	/^  Delete(Delete&&) = default;$/;"	p	struct:Delete	file:	access:public	signature:(Delete&&)
Delete	.\test\stl_tests\StlVectorTest.cpp	/^  Delete(const Delete&) = default;$/;"	p	struct:Delete	file:	access:public	signature:(const Delete&)
Delete	.\test\stl_tests\StlVectorTest.cpp	/^  explicit Delete(std::nullptr_t)$/;"	f	struct:Delete	access:public	signature:(std::nullptr_t)
Delete	.\test\stl_tests\StlVectorTest.cpp	/^struct Delete : D0<f & DC_DELETE>$/;"	s	file:	inherits:D0,D1,D2,D3,D4
Delete::Delete	.\test\stl_tests\StlVectorTest.cpp	/^  Delete() = default;$/;"	p	struct:Delete	file:	access:public	signature:()
Delete::Delete	.\test\stl_tests\StlVectorTest.cpp	/^  Delete(Delete&&) = default;$/;"	p	struct:Delete	file:	access:public	signature:(Delete&&)
Delete::Delete	.\test\stl_tests\StlVectorTest.cpp	/^  Delete(const Delete&) = default;$/;"	p	struct:Delete	file:	access:public	signature:(const Delete&)
Delete::Delete	.\test\stl_tests\StlVectorTest.cpp	/^  explicit Delete(std::nullptr_t)$/;"	f	struct:Delete	access:public	signature:(std::nullptr_t)
Delete::operator =	.\test\stl_tests\StlVectorTest.cpp	/^  Delete& operator=(Delete&&) = default;$/;"	p	struct:Delete	file:	access:public	signature:(Delete&&)
Delete::operator =	.\test\stl_tests\StlVectorTest.cpp	/^  Delete& operator=(const Delete&) = default;$/;"	p	struct:Delete	file:	access:public	signature:(const Delete&)
Deleter	.\AtomicHashArray.h	/^  struct Deleter {$/;"	s	class:folly::AtomicHashArray	access:private
Deleter	.\io\IOBuf.h	/^    typedef typename UniquePtr::deleter_type Deleter;$/;"	t	struct:folly::IOBuf::UniquePtrDeleter	access:public
DeleterBase	.\detail\ThreadLocalDetail.h	/^class DeleterBase {$/;"	c	namespace:folly::threadlocal_detail
DeleterBase	.\io\IOBuf.h	/^  struct DeleterBase {$/;"	s	class:folly::IOBuf	access:private
DemangleBuf	.\Demangle.cpp	/^struct DemangleBuf {$/;"	s	namespace:folly::__anon10	file:
DerefSize	.\ApplyTuple.h	/^struct DerefSize$/;"	s	namespace:folly::detail	inherits:std::tuple_size
Dereference	.\gen\Base-inl.h	/^  Dereference() {}$/;"	f	class:folly::gen::detail::Dereference	access:public	signature:()
Dereference	.\gen\Base-inl.h	/^class Dereference : public Operator<Dereference> {$/;"	c	namespace:folly::gen::detail	inherits:Operator
Dereference	.\gen\Base.h	/^class Dereference;$/;"	x
Dereferencer	.\DynamicConverter.h	/^struct Dereferencer {$/;"	s	namespace:folly::dynamicconverter_detail
Dereferencer	.\DynamicConverter.h	/^struct Dereferencer<std::pair<F, S>> {$/;"	s	namespace:folly::dynamicconverter_detail
Derived	.\detail\GroupVarintDetail.h	/^  typedef GroupVarint<T> Derived;$/;"	t	class:folly::detail::GroupVarintBase	access:private
Derived	.\test\PortabilityTest.cpp	/^class Derived : public Base {$/;"	c	file:	inherits:Base
Destroy	.\dynamic-inl.h	/^  struct Destroy {$/;"	s	namespace:folly::detail
Destroyed	.\test\stl_tests\StlVectorTest.cpp	/^  static int Destroyed;$/;"	m	struct:AllocTracker	file:	access:public
Destroyed	.\test\stl_tests\StlVectorTest.cpp	/^int AllocTracker::Destroyed = 0;$/;"	m	class:AllocTracker	file:
Destructor	.\io\async\DelayedDestruction.h	/^  class Destructor {$/;"	c	class:folly::DelayedDestruction	access:public
DestructorGuard	.\io\async\DelayedDestruction.h	/^    DestructorGuard(const DestructorGuard& dg) : dd_(dg.dd_) {$/;"	f	class:folly::DelayedDestruction::DestructorGuard	access:public	signature:(const DestructorGuard& dg)
DestructorGuard	.\io\async\DelayedDestruction.h	/^    explicit DestructorGuard(DelayedDestruction* dd) : dd_(dd) {$/;"	f	class:folly::DelayedDestruction::DestructorGuard	access:public	signature:(DelayedDestruction* dd)
DestructorGuard	.\io\async\DelayedDestruction.h	/^  class DestructorGuard {$/;"	c	class:folly::DelayedDestruction	access:public
DeterministicAtomic	.\test\DeterministicSchedule.h	/^  DeterministicAtomic() = default;$/;"	p	struct:folly::test::DeterministicAtomic	access:public	signature:()
DeterministicAtomic	.\test\DeterministicSchedule.h	/^  DeterministicAtomic(DeterministicAtomic<T> const &) = delete;$/;"	p	struct:folly::test::DeterministicAtomic	access:public	signature:(DeterministicAtomic<T> const &)
DeterministicAtomic	.\test\DeterministicSchedule.h	/^struct DeterministicAtomic {$/;"	s	namespace:folly::test
DeterministicSchedule	.\test\DeterministicSchedule.cpp	/^DeterministicSchedule::DeterministicSchedule($/;"	f	class:folly::test::DeterministicSchedule	signature:( const std::function<int(int)>& scheduler)
DeterministicSchedule	.\test\DeterministicSchedule.h	/^  explicit DeterministicSchedule(const std::function<int(int)>& scheduler);$/;"	p	class:folly::test::DeterministicSchedule	access:public	signature:(const std::function<int(int)>& scheduler)
DeterministicSchedule	.\test\DeterministicSchedule.h	/^class DeterministicSchedule : boost::noncopyable {$/;"	c	namespace:folly::test	inherits:boost::noncopyable
DiscriminatedPtr	.\DiscriminatedPtr.h	/^  DiscriminatedPtr() : data_(0) {$/;"	f	class:folly::DiscriminatedPtr	access:public	signature:()
DiscriminatedPtr	.\DiscriminatedPtr.h	/^  explicit DiscriminatedPtr(T* ptr) {$/;"	f	class:folly::DiscriminatedPtr	access:public	signature:(T* ptr)
DiscriminatedPtr	.\DiscriminatedPtr.h	/^class DiscriminatedPtr {$/;"	c	namespace:folly
Distinct	.\gen\Base-inl.h	/^  Distinct() {}$/;"	f	class:folly::gen::detail::Distinct	access:public	signature:()
Distinct	.\gen\Base-inl.h	/^  explicit Distinct(Selector selector)$/;"	f	class:folly::gen::detail::Distinct	access:public	signature:(Selector selector)
Distinct	.\gen\Base-inl.h	/^class Distinct : public Operator<Distinct<Selector>> {$/;"	c	namespace:folly::gen::detail	inherits:Operator
Distinct	.\gen\Base.h	/^class Distinct;$/;"	x
DoTimingBig	.\test\SpookyHashV1Test.cpp	/^void DoTimingBig(int seed)$/;"	f	signature:(int seed)
DoTimingBig	.\test\SpookyHashV2Test.cpp	/^void DoTimingBig(int seed)$/;"	f	signature:(int seed)
DoTimingSmall	.\test\SpookyHashV1Test.cpp	/^void DoTimingSmall(int seed)$/;"	f	signature:(int seed)
DoTimingSmall	.\test\SpookyHashV2Test.cpp	/^void DoTimingSmall(int seed)$/;"	f	signature:(int seed)
DtorChecker	.\test\ProducerConsumerQueueTest.cpp	/^  DtorChecker() { ++numInstances; }$/;"	f	struct:__anon128::DtorChecker	access:public	signature:()
DtorChecker	.\test\ProducerConsumerQueueTest.cpp	/^  DtorChecker(const DtorChecker& o) { ++numInstances; }$/;"	f	struct:__anon128::DtorChecker	access:public	signature:(const DtorChecker& o)
DtorChecker	.\test\ProducerConsumerQueueTest.cpp	/^struct DtorChecker {$/;"	s	namespace:__anon128	file:
Duration	.\wangle\Executor.h	/^     typedef std::chrono::microseconds Duration;$/;"	t	class:folly::wangle::Executor	access:public
Dwarf	.\experimental\symbolizer\Dwarf.cpp	/^Dwarf::Dwarf(const ElfFile* elf) : elf_(elf) {$/;"	f	class:folly::symbolizer::Dwarf	signature:(const ElfFile* elf)
Dwarf	.\experimental\symbolizer\Dwarf.h	/^  explicit Dwarf(const ElfFile* elf);$/;"	p	class:folly::symbolizer::Dwarf	access:public	signature:(const ElfFile* elf)
Dwarf	.\experimental\symbolizer\Dwarf.h	/^class Dwarf {$/;"	c	namespace:folly::symbolizer
DynamicConstructor	.\DynamicConverter.h	/^struct DynamicConstructor {$/;"	s	namespace:folly
DynamicConstructor	.\DynamicConverter.h	/^struct DynamicConstructor<C,$/;"	s	namespace:folly
DynamicConstructor	.\DynamicConverter.h	/^struct DynamicConstructor<std::pair<A, B>, void> {$/;"	s	namespace:folly
DynamicConverter	.\DynamicConverter.h	/^struct DynamicConverter<C,$/;"	s	namespace:folly
DynamicConverter	.\DynamicConverter.h	/^struct DynamicConverter<T,$/;"	s	namespace:folly
DynamicConverter	.\DynamicConverter.h	/^struct DynamicConverter<bool> {$/;"	s	namespace:folly
DynamicConverter	.\DynamicConverter.h	/^struct DynamicConverter<folly::fbstring> {$/;"	s	namespace:folly
DynamicConverter	.\DynamicConverter.h	/^struct DynamicConverter<std::pair<F,S>> {$/;"	s	namespace:folly
DynamicConverter	.\DynamicConverter.h	/^struct DynamicConverter<std::string> {$/;"	s	namespace:folly
DynamicConverter	.\DynamicConverter.h	/^template <typename T, typename Enable = void> struct DynamicConverter;$/;"	x
DynamicConverter	.\test\DynamicConverterTest.cpp	/^template <> struct DynamicConverter<A> {$/;"	s	namespace:folly	file:
DynamicConverter	.\test\DynamicConverterTest.cpp	/^template <> struct DynamicConverter<Token> {$/;"	s	namespace:folly	file:
EACH_SIGNED_SIZE	.\experimental\test\BitsTest.cpp	269;"	d	file:
EACH_UNSIGNED_SIZE	.\experimental\test\BitsTest.cpp	264;"	d	file:
EACH_UNSIGNED_SIZE	.\experimental\test\BitsTest.cpp	302;"	d	file:
EARLY_DELIVERY	.\Baton.h	/^    EARLY_DELIVERY = 1,$/;"	m	struct:folly::Baton	typeref:enum:folly::Baton::	access:private
EBO	.\sorted_vector_types.h	/^    explicit EBO(const Compare& c, const Allocator& alloc)$/;"	f	struct:folly::sorted_vector_set::EBO	access:public	signature:(const Compare& c, const Allocator& alloc)
EBO	.\sorted_vector_types.h	/^    explicit EBO(const value_compare& c, const Allocator& alloc)$/;"	f	struct:folly::sorted_vector_map::EBO	access:public	signature:(const value_compare& c, const Allocator& alloc)
EBO	.\sorted_vector_types.h	/^  struct EBO : Compare {$/;"	s	class:folly::sorted_vector_set	inherits:Compare	access:private
EBO	.\sorted_vector_types.h	/^  struct EBO : value_compare {$/;"	s	class:folly::sorted_vector_map	inherits:value_compare	access:private
ED1	.\test\stl_tests\StlVectorTest.cpp	/^typedef Data<> ED1;$/;"	t	file:
ED2	.\test\stl_tests\StlVectorTest.cpp	/^typedef Data<0, 4080> ED2;$/;"	t	file:
ED3	.\test\stl_tests\StlVectorTest.cpp	/^typedef Data<MC_NOEXCEPT> ED3;$/;"	t	file:
ED4	.\test\stl_tests\StlVectorTest.cpp	/^typedef Data<MC_NOEXCEPT | CC_DELETE> ED4;$/;"	t	file:
ED5	.\test\stl_tests\StlVectorTest.cpp	/^typedef Data<IS_RELOCATABLE> ED5;$/;"	t	file:
EFD_CLOEXEC	.\io\async\EventFDWrapper.h	/^    EFD_CLOEXEC = 02000000,$/;"	e	enum:__anon63
EFD_CLOEXEC	.\io\async\EventFDWrapper.h	65;"	d
EFD_NONBLOCK	.\io\async\EventFDWrapper.h	/^    EFD_NONBLOCK = 04000$/;"	e	enum:__anon63
EFD_NONBLOCK	.\io\async\EventFDWrapper.h	67;"	d
EFD_SEMAPHORE	.\io\async\EventFDWrapper.h	/^    EFD_SEMAPHORE = 1,$/;"	e	enum:__anon63
EFD_SEMAPHORE	.\io\async\EventFDWrapper.h	63;"	d
END	.\experimental\symbolizer\Dwarf.h	/^      END,       \/\/ End of sequence$/;"	e	enum:folly::symbolizer::Dwarf::LineNumberVM::StepResult
EP1	.\test\stl_tests\StlVectorTest.cpp	/^typedef Data<PROP_COPY> EP1;$/;"	t	file:
EP2	.\test\stl_tests\StlVectorTest.cpp	/^typedef Data<PROP_MOVE> EP2;$/;"	t	file:
EP3	.\test\stl_tests\StlVectorTest.cpp	/^typedef Data<PROP_SWAP> EP3;$/;"	t	file:
EVENTFD	.\io\async\NotificationQueue.h	/^    EVENTFD,$/;"	m	class:folly::NotificationQueue::FdType	access:private
EXCEPTION	.\wangle\Try.h	/^    EXCEPTION,$/;"	m	class:folly::wangle::Try::Contains	access:private
EXITED	.\Subprocess.h	/^    EXITED,$/;"	e	enum:folly::ProcessReturnCode::State
EXPECTED_CLASS	.\experimental\symbolizer\Elf.cpp	149;"	d	file:
EXPECTED_CLASS	.\experimental\symbolizer\Elf.cpp	158;"	d	file:
EXPECTED_ENCODING	.\experimental\symbolizer\Elf.cpp	162;"	d	file:
EXPECTED_ENCODING	.\experimental\symbolizer\Elf.cpp	172;"	d	file:
EXPECT_CONTAINS	.\test\FileTest.cpp	100;"	d	file:
EXPECT_SAME	.\gen\test\BaseTest.cpp	42;"	d	file:
EXPECT_SPAWN_ERROR	.\test\SubprocessTest.cpp	58;"	d	file:
EXPECT_SYSTEM_ERROR	.\test\ExceptionTest.cpp	27;"	d	file:
EXPECT_TYPE	.\wangle\test\FutureTest.cpp	36;"	d	file:
ElementWrapper	.\detail\ThreadLocalDetail.h	/^struct ElementWrapper {$/;"	s	namespace:folly::threadlocal_detail
ElfCache	.\experimental\symbolizer\ElfCache.cpp	/^ElfCache::ElfCache(size_t capacity) : capacity_(capacity) { }$/;"	f	class:folly::symbolizer::ElfCache	signature:(size_t capacity)
ElfCache	.\experimental\symbolizer\ElfCache.h	/^  explicit ElfCache(size_t capacity);$/;"	p	class:folly::symbolizer::ElfCache	access:public	signature:(size_t capacity)
ElfCache	.\experimental\symbolizer\ElfCache.h	/^class ElfCache : public ElfCacheBase {$/;"	c	namespace:folly::symbolizer	inherits:ElfCacheBase
ElfCacheBase	.\experimental\symbolizer\ElfCache.h	/^class ElfCacheBase {$/;"	c	namespace:folly::symbolizer
ElfCacheTest	.\experimental\symbolizer\test\SymbolizerTest.cpp	/^class ElfCacheTest : public testing::Test {$/;"	c	namespace:folly::symbolizer::test	file:	inherits:testing::Test
ElfFile	.\experimental\symbolizer\Elf.cpp	/^ElfFile::ElfFile(const char* name, bool readOnly)$/;"	f	class:folly::symbolizer::ElfFile	signature:(const char* name, bool readOnly)
ElfFile	.\experimental\symbolizer\Elf.h	/^  ElfFile(const ElfFile&) = delete;$/;"	p	class:folly::symbolizer::ElfFile	access:private	signature:(const ElfFile&)
ElfFile	.\experimental\symbolizer\Elf.h	/^  explicit ElfFile(const char* name, bool readOnly=true);$/;"	p	class:folly::symbolizer::ElfFile	access:public	signature:(const char* name, bool readOnly=true)
ElfFile	.\experimental\symbolizer\Elf.h	/^class ElfFile {$/;"	c	namespace:folly::symbolizer
ElfTest	.\experimental\symbolizer\test\ElfTests.cpp	/^  ElfTest() : elfFile_(binaryPath.c_str()) {$/;"	f	class:ElfTest	access:public	signature:()
ElfTest	.\experimental\symbolizer\test\ElfTests.cpp	/^class ElfTest : public ::testing::Test {$/;"	c	file:	inherits:::testing::Test
ElfTest::ElfTest	.\experimental\symbolizer\test\ElfTests.cpp	/^  ElfTest() : elfFile_(binaryPath.c_str()) {$/;"	f	class:ElfTest	access:public	signature:()
ElfTest::binaryPath	.\experimental\symbolizer\test\ElfTests.cpp	/^  static std::string binaryPath;$/;"	m	class:ElfTest	file:	access:public
ElfTest::binaryPath	.\experimental\symbolizer\test\ElfTests.cpp	/^std::string ElfTest::binaryPath;$/;"	m	class:ElfTest	file:
ElfTest::elfFile_	.\experimental\symbolizer\test\ElfTests.cpp	/^  ElfFile elfFile_;$/;"	m	class:ElfTest	file:	access:protected
ElfTest::~ElfTest	.\experimental\symbolizer\test\ElfTests.cpp	/^  virtual ~ElfTest() {$/;"	f	class:ElfTest	access:public	signature:()
EliasFanoCodingTest	.\experimental\test\EliasFanoCodingTest.cpp	/^class EliasFanoCodingTest : public ::testing::Test {$/;"	c	file:	inherits:::testing::Test
EliasFanoCodingTest::doTestAll	.\experimental\test\EliasFanoCodingTest.cpp	/^  void doTestAll() {$/;"	f	class:EliasFanoCodingTest	access:public	signature:()
EliasFanoCodingTest::doTestEmpty	.\experimental\test\EliasFanoCodingTest.cpp	/^  void doTestEmpty() {$/;"	f	class:EliasFanoCodingTest	access:public	signature:()
EliasFanoCompressedList	.\experimental\EliasFanoCoding.h	/^  EliasFanoCompressedList() { }$/;"	f	struct:folly::compression::EliasFanoCompressedList	access:public	signature:()
EliasFanoCompressedList	.\experimental\EliasFanoCoding.h	/^struct EliasFanoCompressedList {$/;"	s	namespace:folly::compression
EliasFanoEncoder	.\experimental\EliasFanoCoding.h	/^  EliasFanoEncoder(size_t size, ValueType upperBound) {$/;"	f	struct:folly::compression::EliasFanoEncoder	access:public	signature:(size_t size, ValueType upperBound)
EliasFanoEncoder	.\experimental\EliasFanoCoding.h	/^struct EliasFanoEncoder {$/;"	s	namespace:folly::compression
EliasFanoReader	.\experimental\EliasFanoCoding.h	/^  explicit EliasFanoReader(const EliasFanoCompressedList& list)$/;"	f	class:folly::compression::EliasFanoReader	access:public	signature:(const EliasFanoCompressedList& list)
EliasFanoReader	.\experimental\EliasFanoCoding.h	/^class EliasFanoReader : private boost::noncopyable {$/;"	c	namespace:folly::compression	inherits:boost::noncopyable
Empty	.\gen\Base-inl.h	/^class Empty : public GenImpl<Value, Empty<Value>> {$/;"	c	namespace:folly::gen::detail	inherits:GenImpl
Empty	.\gen\Base.h	/^class Empty;$/;"	x
EmptySequence	.\gen\Base.h	/^class EmptySequence : public std::exception {$/;"	c	namespace:folly::gen	inherits:std::exception
Encoder	.\experimental\test\EliasFanoCodingTest.cpp	/^typedef EliasFanoEncoder<uint32_t, uint32_t, 128, 128, kVersion> Encoder;$/;"	t	namespace:bm	file:
EncoderType	.\experimental\EliasFanoCoding.h	/^  typedef Encoder EncoderType;$/;"	t	class:folly::compression::EliasFanoReader	access:public
End	.\SpookyHashV1.h	/^    static inline void End($/;"	f	class:folly::hash::SpookyHashV1	access:public	signature:( uint64_t &h0, uint64_t &h1, uint64_t &h2, uint64_t &h3, uint64_t &h4, uint64_t &h5, uint64_t &h6, uint64_t &h7, uint64_t &h8, uint64_t &h9, uint64_t &h10,uint64_t &h11)
End	.\SpookyHashV2.h	/^    static inline void End($/;"	f	class:folly::hash::SpookyHashV2	access:public	signature:( const uint64_t *data, uint64_t &h0, uint64_t &h1, uint64_t &h2, uint64_t &h3, uint64_t &h4, uint64_t &h5, uint64_t &h6, uint64_t &h7, uint64_t &h8, uint64_t &h9, uint64_t &h10,uint64_t &h11)
EndPartial	.\SpookyHashV1.h	/^    static inline void EndPartial($/;"	f	class:folly::hash::SpookyHashV1	access:public	signature:( uint64_t &h0, uint64_t &h1, uint64_t &h2, uint64_t &h3, uint64_t &h4, uint64_t &h5, uint64_t &h6, uint64_t &h7, uint64_t &h8, uint64_t &h9, uint64_t &h10,uint64_t &h11)
EndPartial	.\SpookyHashV2.h	/^    static inline void EndPartial($/;"	f	class:folly::hash::SpookyHashV2	access:public	signature:( uint64_t &h0, uint64_t &h1, uint64_t &h2, uint64_t &h3, uint64_t &h4, uint64_t &h5, uint64_t &h6, uint64_t &h7, uint64_t &h8, uint64_t &h9, uint64_t &h10,uint64_t &h11)
Entry	.\experimental\symbolizer\ElfCache.h	/^  struct Entry {$/;"	s	class:folly::symbolizer::ElfCache	access:private
ErrorBehavior	.\test\ScopeGuardTest.cpp	/^enum class ErrorBehavior {$/;"	c	file:
ErrorBehavior::HANDLED_ERROR	.\test\ScopeGuardTest.cpp	/^  HANDLED_ERROR,$/;"	m	class:ErrorBehavior	file:	access:private
ErrorBehavior::SUCCESS	.\test\ScopeGuardTest.cpp	/^  SUCCESS,$/;"	m	class:ErrorBehavior	file:	access:private
ErrorBehavior::UNHANDLED_ERROR	.\test\ScopeGuardTest.cpp	/^  UNHANDLED_ERROR,$/;"	m	class:ErrorBehavior	file:	access:private
Event	.\TimeoutQueue.h	/^  struct Event {$/;"	s	class:folly::TimeoutQueue	access:private
EventBase	.\io\async\AsyncTimeout.h	/^class EventBase;$/;"	x
EventBase	.\io\async\EventBase.cpp	/^EventBase::EventBase()$/;"	f	class:folly::EventBase	signature:()
EventBase	.\io\async\EventBase.cpp	/^EventBase::EventBase(event_base* evb)$/;"	f	class:folly::EventBase	signature:(event_base* evb)
EventBase	.\io\async\EventBase.h	/^    friend class EventBase;$/;"	x
EventBase	.\io\async\EventBase.h	/^  EventBase();$/;"	p	class:folly::EventBase	access:public	signature:()
EventBase	.\io\async\EventBase.h	/^  explicit EventBase(event_base* evb);$/;"	p	class:folly::EventBase	access:public	signature:(event_base* evb)
EventBase	.\io\async\EventBase.h	/^class EventBase : private boost::noncopyable, public TimeoutManager {$/;"	c	namespace:folly	inherits:boost::noncopyable,TimeoutManager
EventBase	.\io\async\EventHandler.h	/^class EventBase;$/;"	x
EventBaseObserver	.\io\async\EventBase.h	/^class EventBaseObserver {$/;"	c	namespace:folly
EventCount	.\experimental\EventCount.h	/^    friend class EventCount;$/;"	x
EventCount	.\experimental\EventCount.h	/^  EventCount(EventCount&&) = delete;$/;"	p	class:folly::EventCount	access:private	signature:(EventCount&&)
EventCount	.\experimental\EventCount.h	/^  EventCount(const EventCount&) = delete;$/;"	p	class:folly::EventCount	access:private	signature:(const EventCount&)
EventCount	.\experimental\EventCount.h	/^class EventCount {$/;"	c	namespace:folly
EventFlags	.\io\async\EventHandler.h	/^  enum EventFlags {$/;"	g	class:folly::EventHandler	access:public
EventHandler	.\io\async\EventHandler.cpp	/^EventHandler::EventHandler(EventBase* eventBase, int fd) {$/;"	f	class:folly::EventHandler	signature:(EventBase* eventBase, int fd)
EventHandler	.\io\async\EventHandler.h	/^  explicit EventHandler(EventBase* eventBase = nullptr, int fd = -1);$/;"	p	class:folly::EventHandler	access:public	signature:(EventBase* eventBase = nullptr, int fd = -1)
EventHandler	.\io\async\EventHandler.h	/^class EventHandler : private boost::noncopyable {$/;"	c	namespace:folly	inherits:boost::noncopyable
EventUtil	.\io\async\EventUtil.h	/^class EventUtil {$/;"	c	namespace:folly
EvictingCacheMap	.\EvictingCacheMap.h	/^  explicit EvictingCacheMap(std::size_t maxSize, std::size_t clearSize = 1)$/;"	f	class:folly::EvictingCacheMap	access:public	signature:(std::size_t maxSize, std::size_t clearSize = 1)
EvictingCacheMap	.\EvictingCacheMap.h	/^class EvictingCacheMap : private boost::noncopyable {$/;"	c	namespace:folly	inherits:boost::noncopyable
Exception	.\test\function_benchmark\test_functions.cpp	/^  explicit Exception(const std::string& value) : value_(value) {}$/;"	f	class:Exception	access:public	signature:(const std::string& value)
Exception	.\test\function_benchmark\test_functions.cpp	/^class Exception : public std::exception {$/;"	c	file:	inherits:std::exception
Exception::Exception	.\test\function_benchmark\test_functions.cpp	/^  explicit Exception(const std::string& value) : value_(value) {}$/;"	f	class:Exception	access:public	signature:(const std::string& value)
Exception::value_	.\test\function_benchmark\test_functions.cpp	/^  std::string value_;$/;"	m	class:Exception	file:	access:private
Exception::what	.\test\function_benchmark\test_functions.cpp	/^  virtual const char *what(void) const throw() {$/;"	f	class:Exception	access:public	signature:(void) const
Exception::~Exception	.\test\function_benchmark\test_functions.cpp	/^  virtual ~Exception(void) throw() {}$/;"	f	class:Exception	access:public	signature:(void)
ExceptionInfo	.\experimental\exception_tracer\ExceptionTracer.h	/^struct ExceptionInfo {$/;"	s	namespace:folly::exception_tracer
ExecutionPipeline	.\gen\ParallelMap-inl.h	/^      ExecutionPipeline(const Predicate& pred, size_t nThreads)$/;"	f	class:folly::gen::detail::PMap::Generator::ExecutionPipeline	access:public	signature:(const Predicate& pred, size_t nThreads)
ExecutionPipeline	.\gen\ParallelMap-inl.h	/^    class ExecutionPipeline {$/;"	c	class:folly::gen::detail::PMap::Generator	access:private
Executor	.\experimental\wangle\concurrent\Executor.h	/^class Executor {$/;"	c	namespace:folly::wangle
Executor	.\gen\Parallel-inl.h	/^      Executor(size_t threads, const Ops* ops)$/;"	f	class:folly::gen::detail::Parallel::Generator::Executor	access:public	signature:(size_t threads, const Ops* ops)
Executor	.\gen\Parallel-inl.h	/^    class Executor {$/;"	c	class:folly::gen::detail::Parallel::Generator	access:private
Executor	.\wangle\Executor.h	/^  class Executor : boost::noncopyable {$/;"	c	namespace:folly::wangle	inherits:boost::noncopyable
ExpectIsValid	.\test\IPAddressTest.h	/^  void ExpectIsValid(const IPAddress& addr) {$/;"	f	struct:folly::IPAddressTest	access:public	signature:(const IPAddress& addr)
ExpectedResult	.\test\ChecksumTest.cpp	/^struct ExpectedResult {$/;"	s	namespace:__anon112	file:
ExprDoUnpack	.\ApplyTuple.h	/^template<class Tuple, class ...Unpacked> struct ExprDoUnpack {$/;"	s	namespace:folly::detail
ExprIsConst	.\gen\Base.h	/^template <MemberType Constness> struct ExprIsConst {$/;"	s	namespace:folly::gen
ExprIsMutable	.\gen\Base.h	/^template <MemberType Constness> struct ExprIsMutable {$/;"	s	namespace:folly::gen
ExternalUnixAddr	.\SocketAddress.h	/^  struct ExternalUnixAddr {$/;"	s	class:folly::SocketAddress	access:private
F1	.\test\TraitsTest.cpp	/^struct F1 {};$/;"	s	file:
F2	.\test\TraitsTest.cpp	/^struct F2 { typedef int IsRelocatable; };$/;"	s	file:
F2::IsRelocatable	.\test\TraitsTest.cpp	/^struct F2 { typedef int IsRelocatable; };$/;"	t	struct:F2	file:	access:public
F3	.\test\TraitsTest.cpp	/^struct F3 : T3 { typedef std::false_type IsRelocatable; };$/;"	s	file:	inherits:T3
F3::IsRelocatable	.\test\TraitsTest.cpp	/^struct F3 : T3 { typedef std::false_type IsRelocatable; };$/;"	t	struct:F3	file:	access:public
F4	.\test\TraitsTest.cpp	/^struct F4 : T1 {};$/;"	s	file:	inherits:T1
FBSTRING_DISABLE_ADDRESS_SANITIZER	.\FBString.h	104;"	d
FBSTRING_DISABLE_ADDRESS_SANITIZER	.\FBString.h	119;"	d
FBSTRING_DISABLE_ADDRESS_SANITIZER	.\FBString.h	2458;"	d
FBSTRING_LIKELY	.\FBString.h	2460;"	d
FBSTRING_LIKELY	.\FBString.h	76;"	d
FBSTRING_LIKELY	.\FBString.h	79;"	d
FBSTRING_UNLIKELY	.\FBString.h	2461;"	d
FBSTRING_UNLIKELY	.\FBString.h	77;"	d
FBSTRING_UNLIKELY	.\FBString.h	80;"	d
FBStringFBVector	.\test\FBVectorBenchmark.cpp	/^typedef fbvector<folly::fbstring> FBStringFBVector;$/;"	t	file:
FBStringVector	.\test\FBVectorBenchmark.cpp	/^typedef vector<folly::fbstring> FBStringVector;$/;"	t	file:
FB_ANONYMOUS_VARIABLE	.\Preprocessor.h	84;"	d
FB_ANONYMOUS_VARIABLE	.\Preprocessor.h	86;"	d
FB_ARG_1	.\Preprocessor.h	54;"	d
FB_ARG_2_OR_1	.\Preprocessor.h	61;"	d
FB_ARG_2_OR_1_IMPL	.\Preprocessor.h	63;"	d
FB_CONCATENATE	.\Preprocessor.h	82;"	d
FB_CONCATENATE_IMPL	.\Preprocessor.h	81;"	d
FB_DEC_TYPE	.\dynamic-inl.h	/^FB_DEC_TYPE(bool);$/;"	p	namespace:folly	signature:(bool)
FB_DEC_TYPE	.\dynamic-inl.h	/^FB_DEC_TYPE(double);$/;"	p	namespace:folly	signature:(double)
FB_DEC_TYPE	.\dynamic-inl.h	/^FB_DEC_TYPE(dynamic::Array);$/;"	p	namespace:folly	signature:(dynamic::Array)
FB_DEC_TYPE	.\dynamic-inl.h	/^FB_DEC_TYPE(dynamic::ObjectImpl);$/;"	p	namespace:folly	signature:(dynamic::ObjectImpl)
FB_DEC_TYPE	.\dynamic-inl.h	/^FB_DEC_TYPE(fbstring);$/;"	p	namespace:folly	signature:(fbstring)
FB_DEC_TYPE	.\dynamic-inl.h	/^FB_DEC_TYPE(int64_t);$/;"	p	namespace:folly	signature:(int64_t)
FB_DEC_TYPE	.\dynamic-inl.h	/^FB_DEC_TYPE(void*);$/;"	p	namespace:folly	signature:(void*)
FB_DEC_TYPE	.\dynamic-inl.h	736;"	d
FB_DEC_TYPE	.\dynamic-inl.h	748;"	d
FB_DOBTR	.\SmallLocks.h	260;"	d
FB_DOBTR	.\SmallLocks.h	276;"	d
FB_DOBTS	.\SmallLocks.h	227;"	d
FB_DOBTS	.\SmallLocks.h	240;"	d
FB_DYNAMIC_APPLY	.\dynamic-inl.h	44;"	d
FB_DYNAMIC_APPLY	.\dynamic-inl.h	975;"	d
FB_DYNAMIC_INTEGER_OP	.\dynamic-inl.h	463;"	d
FB_DYNAMIC_INTEGER_OP	.\dynamic-inl.h	477;"	d
FB_GEN	.\Bits.h	313;"	d
FB_GEN	.\Bits.h	337;"	d
FB_GEN	.\Bits.h	377;"	d
FB_GEN	.\Bits.h	413;"	d
FB_GEN1	.\Bits.h	369;"	d
FB_GEN1	.\Bits.h	415;"	d
FB_GEN2	.\Bits.h	372;"	d
FB_GEN2	.\Bits.h	414;"	d
FB_LOG_EVERY_MS	.\Logging.h	36;"	d
FB_ONE_OR_NONE	.\Preprocessor.h	43;"	d
FB_ONE_OR_NONE	.\Preprocessor.h	46;"	d
FB_ONE_OR_NONE0	.\Preprocessor.h	39;"	d
FB_ONE_OR_NONE1	.\Preprocessor.h	40;"	d
FB_ONE_OR_NONE2	.\Preprocessor.h	41;"	d
FB_ONE_OR_NONE3	.\Preprocessor.h	42;"	d
FB_PACK_ATTR	.\small_vector.h	/^  } FB_PACK_ATTR;$/;"	m	class:folly::small_vector	typeref:struct:folly::small_vector::HeapPtr	access:private
FB_PACK_ATTR	.\small_vector.h	/^  } FB_PACK_ATTR;$/;"	m	class:folly::small_vector	typeref:struct:folly::small_vector::HeapPtrWithCapacity	access:private
FB_PACK_ATTR	.\small_vector.h	53;"	d
FB_PACK_ATTR	.\small_vector.h	57;"	d
FB_PACK_POP	.\small_vector.h	55;"	d
FB_PACK_POP	.\small_vector.h	59;"	d
FB_PACK_PUSH	.\small_vector.h	54;"	d
FB_PACK_PUSH	.\small_vector.h	58;"	d
FB_SINGLE_ARG	.\Preprocessor.h	74;"	d
FB_STRINGIZE	.\Preprocessor.h	94;"	d
FB_THIRD	.\Preprocessor.h	47;"	d
FB_X	.\dynamic-inl.h	418;"	d
FB_X	.\dynamic-inl.h	421;"	d
FB_X	.\dynamic-inl.h	434;"	d
FB_X	.\dynamic-inl.h	436;"	d
FB_X	.\dynamic-inl.h	492;"	d
FB_X	.\dynamic-inl.h	494;"	d
FB_X	.\dynamic-inl.h	503;"	d
FB_X	.\dynamic-inl.h	505;"	d
FB_X	.\dynamic-inl.h	833;"	d
FB_X	.\dynamic-inl.h	835;"	d
FB_X	.\dynamic-inl.h	842;"	d
FB_X	.\dynamic-inl.h	844;"	d
FB_X	.\dynamic-inl.h	879;"	d
FB_X	.\dynamic-inl.h	881;"	d
FBounded	.\gen\Base.h	/^struct FBounded;$/;"	x
FBounded	.\gen\Core-inl.h	/^struct FBounded {$/;"	s	namespace:folly::gen
FBounded	.\gen\Core.h	/^struct FBounded;$/;"	x
FDSymbolizePrinter	.\experimental\symbolizer\Symbolizer.cpp	/^FDSymbolizePrinter::FDSymbolizePrinter(int fd, int options, size_t bufferSize)$/;"	f	class:folly::symbolizer::FDSymbolizePrinter	signature:(int fd, int options, size_t bufferSize)
FDSymbolizePrinter	.\experimental\symbolizer\Symbolizer.h	/^  explicit FDSymbolizePrinter(int fd, int options=0,$/;"	p	class:folly::symbolizer::FDSymbolizePrinter	access:public	signature:(int fd, int options=0, size_t bufferSize=0)
FDSymbolizePrinter	.\experimental\symbolizer\Symbolizer.h	/^class FDSymbolizePrinter : public SymbolizePrinter {$/;"	c	namespace:folly::symbolizer	inherits:SymbolizePrinter
FILESymbolizePrinter	.\experimental\symbolizer\Symbolizer.cpp	/^FILESymbolizePrinter::FILESymbolizePrinter(FILE* file, int options)$/;"	f	class:folly::symbolizer::FILESymbolizePrinter	signature:(FILE* file, int options)
FILESymbolizePrinter	.\experimental\symbolizer\Symbolizer.h	/^  explicit FILESymbolizePrinter(FILE* file, int options=0);$/;"	p	class:folly::symbolizer::FILESymbolizePrinter	access:public	signature:(FILE* file, int options=0)
FILESymbolizePrinter	.\experimental\symbolizer\Symbolizer.h	/^class FILESymbolizePrinter : public SymbolizePrinter {$/;"	c	namespace:folly::symbolizer	inherits:SymbolizePrinter
FLAGS_enable_request_context	.\io\async\Request.cpp	/^  bool FLAGS_enable_request_context = true;$/;"	m	namespace:folly	file:
FLOAT	.\FormatArg.h	/^    FLOAT,$/;"	m	class:folly::FormatArg::Type	access:private
FNV_32_HASH_START	.\Hash.h	/^const uint32_t FNV_32_HASH_START = 2166136261UL;$/;"	m	namespace:folly::hash
FNV_64_HASH_START	.\Hash.h	/^const uint64_t FNV_64_HASH_START = 14695981039346656037ULL;$/;"	m	namespace:folly::hash
FOLLY_ALIGN_TO_AVOID_FALSE_SHARING	.\LifoSem.h	/^      FOLLY_ALIGN_TO_AVOID_FALSE_SHARING;$/;"	m	struct:folly::detail::LifoSemBase	access:private
FOLLY_ALIGN_TO_AVOID_FALSE_SHARING	.\detail\CacheLocality.h	130;"	d
FOLLY_ALWAYS_INLINE	.\Portability.h	101;"	d
FOLLY_ALWAYS_INLINE	.\Portability.h	97;"	d
FOLLY_ALWAYS_INLINE	.\Portability.h	99;"	d
FOLLY_APPLYTUPLE_H_	.\ApplyTuple.h	29;"	d
FOLLY_ARENA_H_	.\Arena.h	18;"	d
FOLLY_ASSUME_FBVECTOR_COMPATIBLE	.\Traits.h	196;"	d
FOLLY_ASSUME_FBVECTOR_COMPATIBLE_1	.\Traits.h	201;"	d
FOLLY_ASSUME_FBVECTOR_COMPATIBLE_2	.\Traits.h	207;"	d
FOLLY_ASSUME_FBVECTOR_COMPATIBLE_3	.\Traits.h	215;"	d
FOLLY_ASSUME_FBVECTOR_COMPATIBLE_4	.\Traits.h	223;"	d
FOLLY_ASSUME_HAS_NOTHROW_CONSTRUCTOR	.\Traits.h	167;"	d
FOLLY_ASSUME_RELOCATABLE	.\Traits.h	151;"	d
FOLLY_ASSUME_RELOCATABLE	.\test\TraitsTest.cpp	/^  template <> FOLLY_ASSUME_RELOCATABLE(T2);$/;"	p	namespace:folly	file:	signature:(T2)
FOLLY_ATOMICBITSET_H_	.\AtomicBitSet.h	18;"	d
FOLLY_ATOMICHASHARRAY_H_	.\AtomicHashArray.h	33;"	d
FOLLY_ATOMICHASHMAP_H_	.\AtomicHashMap.h	83;"	d
FOLLY_ATOMIC_STRUCT_H_	.\AtomicStruct.h	18;"	d
FOLLY_BASE_CONV_H_	.\Conv.h	25;"	d
FOLLY_BASE_FBSTRING_H_	.\FBString.h	21;"	d
FOLLY_BASE_FOREACH_H_	.\Foreach.h	18;"	d
FOLLY_BASE_HASH_H_	.\Hash.h	18;"	d
FOLLY_BASE_LIKELY_H_	.\Likely.h	25;"	d
FOLLY_BASE_STRING_H_	.\String.h	18;"	d
FOLLY_BASE_TRAITS_H_	.\Traits.h	20;"	d
FOLLY_BATON_H	.\Baton.h	18;"	d
FOLLY_BENCHMARK_H_	.\Benchmark.h	18;"	d
FOLLY_BITS_H_	.\Bits.h	56;"	d
FOLLY_BUILD_FINGERPRINTPOLYNOMIAL_H_	.\detail\FingerprintPolynomial.h	18;"	d
FOLLY_CACHE_LINE_SIZE	.\SmallLocks.h	/^  static_assert(sizeof(PaddedSpinLock) == FOLLY_CACHE_LINE_SIZE,$/;"	m	struct:folly::SpinLockArray	access:private
FOLLY_CACHE_LINE_SIZE	.\SmallLocks.h	289;"	d
FOLLY_CHECKSUM_H_	.\Checksum.h	18;"	d
FOLLY_CHRONO_H_	.\Chrono.h	19;"	d
FOLLY_CONCURRENTSKIPLIST_INL_H_	.\ConcurrentSkipList-inl.h	20;"	d
FOLLY_CONCURRENT_SKIP_LIST_H_	.\ConcurrentSkipList.h	121;"	d
FOLLY_CONV_INTERNAL	.\Conv.cpp	16;"	d	file:
FOLLY_CPUID_H_	.\CpuId.h	18;"	d
FOLLY_CREATE_HAS_MEMBER_FN_TRAITS	.\Memory.h	/^  FOLLY_CREATE_HAS_MEMBER_FN_TRAITS(has_destroy, destroy);$/;"	p	class:folly::is_simple_allocator	access:private	signature:(has_destroy, destroy)
FOLLY_CREATE_HAS_MEMBER_FN_TRAITS	.\Traits.h	517;"	d
FOLLY_CREATE_HAS_MEMBER_FN_TRAITS_IMPL	.\Traits.h	454;"	d
FOLLY_CURSOR_H	.\io\Cursor.h	18;"	d
FOLLY_DEFINED_DMGL	.\Demangle.cpp	39;"	d	file:
FOLLY_DEFINED_DMGL	.\String.cpp	539;"	d	file:
FOLLY_DETAIL_BITITERATORDETAIL_H_	.\detail\BitIteratorDetail.h	18;"	d
FOLLY_DETAIL_BITSDETAIL_H_	.\detail\BitsDetail.h	18;"	d
FOLLY_DETAIL_CACHELOCALITY_H_	.\detail\CacheLocality.h	18;"	d
FOLLY_DETAIL_CHECKSUMDETAIL_H_	.\detail\ChecksumDetail.h	18;"	d
FOLLY_DETAIL_CLOCK_H_	.\detail\Clock.h	18;"	d
FOLLY_DETAIL_DISCRIMINATEDPTRDETAIL_H_	.\detail\DiscriminatedPtrDetail.h	18;"	d
FOLLY_DETAIL_EXCEPTIONWRAPPER_H	.\detail\ExceptionWrapper.h	18;"	d
FOLLY_DETAIL_FILEUTILDETAIL_H_	.\detail\FileUtilDetail.h	18;"	d
FOLLY_DETAIL_FUNCTIONAL_EXCEPT_H	.\detail\FunctionalExcept.h	18;"	d
FOLLY_DETAIL_GROUPVARINTDETAIL_H_	.\detail\GroupVarintDetail.h	18;"	d
FOLLY_DETAIL_MALLOC_H	.\detail\Malloc.h	18;"	d
FOLLY_DETAIL_MEMORYIDLER_H	.\detail\MemoryIdler.h	18;"	d
FOLLY_DETAIL_SLOWFINGERPRINT_H_	.\detail\SlowFingerprint.h	18;"	d
FOLLY_DETAIL_STATS_H_	.\detail\Stats.h	18;"	d
FOLLY_DETAIL_THREADLOCALDETAIL_H_	.\detail\ThreadLocalDetail.h	18;"	d
FOLLY_DETAIL_UNCAUGHTEXCEPTIONCOUNTER_H_	.\detail\UncaughtExceptionCounter.h	18;"	d
FOLLY_DISABLE_ADDRESS_SANITIZER	.\CPortability.h	41;"	d
FOLLY_DISABLE_ADDRESS_SANITIZER	.\CPortability.h	44;"	d
FOLLY_DISABLE_ADDRESS_SANITIZER	.\CPortability.h	48;"	d
FOLLY_DISABLE_ADDRESS_SANITIZER	.\CPortability.h	53;"	d
FOLLY_DISABLE_ADDRESS_SANITIZER	.\Range.cpp	/^  FOLLY_DISABLE_ADDRESS_SANITIZER;$/;"	m	namespace:folly::__anon83	file:
FOLLY_DISABLE_ADDRESS_SANITIZER	.\Range.cpp	/^  FOLLY_DISABLE_ADDRESS_SANITIZER;$/;"	m	namespace:folly::detail	file:
FOLLY_DISCRIMINATEDPTR_H_	.\DiscriminatedPtr.h	28;"	d
FOLLY_DYNAMIC_H_	.\dynamic.h	64;"	d
FOLLY_DYNAMIC_INL_H_	.\dynamic-inl.h	18;"	d
FOLLY_EVICTINGHASHMAP_H_	.\EvictingCacheMap.h	18;"	d
FOLLY_EXCEPTIONWRAPPER_H	.\ExceptionWrapper.h	18;"	d
FOLLY_EXCEPTION_COUNT_USE_CXA_GET_GLOBALS	.\detail\UncaughtExceptionCounter.h	23;"	d
FOLLY_EXCEPTION_H_	.\Exception.h	18;"	d
FOLLY_EXPERIMENTAL_BITS_H_	.\experimental\Bits.h	18;"	d
FOLLY_EXPERIMENTAL_CODING_TEST_UTILS_H	.\experimental\test\CodingTestUtils.h	18;"	d
FOLLY_EXPERIMENTAL_ELIAS_FANO_CODING_H	.\experimental\EliasFanoCoding.h	25;"	d
FOLLY_EXPERIMENTAL_EVENTCOUNT_H_	.\experimental\EventCount.h	18;"	d
FOLLY_EXPERIMENTAL_EXCEPTION_TRACER_EXCEPTIONABI_H_	.\experimental\exception_tracer\ExceptionAbi.h	19;"	d
FOLLY_EXPERIMENTAL_EXCEPTION_TRACER_EXCEPTIONTRACER_H_	.\experimental\exception_tracer\ExceptionTracer.h	21;"	d
FOLLY_EXPERIMENTAL_EXCEPTION_TRACER_STACKTRACE_H_	.\experimental\exception_tracer\StackTrace.h	19;"	d
FOLLY_EXPERIMENTAL_SYMBOLIZER_DWARF_H_	.\experimental\symbolizer\Dwarf.h	20;"	d
FOLLY_EXPERIMENTAL_SYMBOLIZER_ELF_H_	.\experimental\symbolizer\Elf.h	20;"	d
FOLLY_EXPERIMENTAL_SYMBOLIZER_SYMBOLIZER_H_	.\experimental\symbolizer\Symbolizer.h	18;"	d
FOLLY_FBSTRING_HASH	.\FBString.h	2429;"	d
FOLLY_FBSTRING_HASH	.\FBString.h	2451;"	d
FOLLY_FBSTRING_HASH1	.\FBString.h	2420;"	d
FOLLY_FBSTRING_HASH1	.\FBString.h	2452;"	d
FOLLY_FBVECTOR_H	.\FBVector.h	26;"	d
FOLLY_FBVECTOR_INSERT_END	.\FBVector.h	1381;"	d
FOLLY_FBVECTOR_INSERT_START	.\FBVector.h	1341;"	d
FOLLY_FBVECTOR_INSERT_TRY	.\FBVector.h	1363;"	d
FOLLY_FBV_OP	.\FBVector.h	383;"	d
FOLLY_FBV_OP	.\FBVector.h	385;"	d
FOLLY_FBV_UNROLL_PTR	.\FBVector.h	62;"	d
FOLLY_FILEUTIL_H_	.\FileUtil.h	18;"	d
FOLLY_FILE_H_	.\File.h	18;"	d
FOLLY_FINAL	.\Portability.h	141;"	d
FOLLY_FINAL	.\Portability.h	144;"	d
FOLLY_FINAL	.\io\Compression.cpp	/^class IOBufSnappySource FOLLY_FINAL : public snappy::Source {$/;"	c	namespace:folly::io::__anon64	file:	inherits:snappy::Source
FOLLY_FINAL	.\io\Compression.cpp	/^class LZ4Codec FOLLY_FINAL : public Codec {$/;"	c	namespace:folly::io::__anon64	file:	inherits:Codec
FOLLY_FINAL	.\io\Compression.cpp	/^class LZMA2Codec FOLLY_FINAL : public Codec {$/;"	c	namespace:folly::io::__anon64	file:	inherits:Codec
FOLLY_FINAL	.\io\Compression.cpp	/^class NoCompressionCodec FOLLY_FINAL : public Codec {$/;"	c	namespace:folly::io::__anon64	file:	inherits:Codec
FOLLY_FINAL	.\io\Compression.cpp	/^class SnappyCodec FOLLY_FINAL : public Codec {$/;"	c	namespace:folly::io::__anon64	file:	inherits:Codec
FOLLY_FINAL	.\io\Compression.cpp	/^class ZlibCodec FOLLY_FINAL : public Codec {$/;"	c	namespace:folly::io::__anon64	file:	inherits:Codec
FOLLY_FINGERPRINT_H_	.\Fingerprint.h	46;"	d
FOLLY_FORMATARG_H_	.\FormatArg.h	18;"	d
FOLLY_FORMAT_H_	.\Format.h	18;"	d
FOLLY_GEN_BASE_H	.\gen\Base.h	18;"	d
FOLLY_GEN_BENCH_H_	.\gen\test\Bench.h	18;"	d
FOLLY_GEN_COMBINE_H	.\gen\Combine.h	18;"	d
FOLLY_GEN_CORE_H	.\gen\Core.h	18;"	d
FOLLY_GEN_FILE_H	.\gen\File.h	18;"	d
FOLLY_GEN_PARALLELMAP_H	.\gen\ParallelMap.h	18;"	d
FOLLY_GEN_PARALLEL_H_	.\gen\Parallel.h	18;"	d
FOLLY_GEN_STRING_H	.\gen\String.h	18;"	d
FOLLY_GFLAGS_NAMESPACE	.\Portability.h	/^namespace FOLLY_GFLAGS_NAMESPACE { }$/;"	n
FOLLY_GLIBC_2_12	.\ThreadName.h	28;"	d
FOLLY_GLIBC_2_9	.\io\async\EventFDWrapper.h	34;"	d
FOLLY_GROUPVARINT_H_	.\GroupVarint.h	18;"	d
FOLLY_HAS_TRUE_XXX	.\Traits.h	111;"	d
FOLLY_HAS_TRUE_XXX	.\Traits.h	96;"	d
FOLLY_HAVE_PREADV	.\Portability.h	166;"	d
FOLLY_HAVE_PWRITEV	.\Portability.h	167;"	d
FOLLY_HISTOGRAM_DEFS_H_	.\stats\Histogram-defs.h	18;"	d
FOLLY_HISTOGRAM_H_	.\stats\Histogram.h	18;"	d
FOLLY_INDEXEDMEMPOOL_H	.\IndexedMemPool.h	18;"	d
FOLLY_INTRINSIC_CONSTEXPR	.\Bits.h	61;"	d
FOLLY_INTRINSIC_CONSTEXPR	.\Bits.h	64;"	d
FOLLY_INTRUSIVELIST_H_	.\IntrusiveList.h	18;"	d
FOLLY_IO_ASYNCIO_H_	.\experimental\io\AsyncIO.h	18;"	d
FOLLY_IO_COMPRESSION_H_	.\io\Compression.h	18;"	d
FOLLY_IO_FSUTIL_H_	.\experimental\io\FsUtil.h	18;"	d
FOLLY_IO_HUGEPAGES_H_	.\experimental\io\HugePages.h	18;"	d
FOLLY_IO_IOBUF_H_	.\io\IOBuf.h	18;"	d
FOLLY_IO_IOBUF_QUEUE_H	.\io\IOBufQueue.h	18;"	d
FOLLY_IO_RECORDIO_H_	.\io\RecordIO.h	26;"	d
FOLLY_IO_TYPEDIOBUF_H_	.\io\TypedIOBuf.h	18;"	d
FOLLY_IS_TRIVIALLY_COPYABLE	.\Portability.h	211;"	d
FOLLY_IS_TRIVIALLY_COPYABLE	.\Portability.h	215;"	d
FOLLY_JSON_H_	.\json.h	42;"	d
FOLLY_LAZY_H_	.\Lazy.h	17;"	d
FOLLY_LIFOSEM_H	.\LifoSem.h	18;"	d
FOLLY_LOGGING_H_	.\Logging.h	18;"	d
FOLLY_MALLOC_H_	.\FBString.h	38;"	d
FOLLY_MALLOC_H_	.\FBString.h	42;"	d
FOLLY_MALLOC_H_	.\Malloc.h	21;"	d
FOLLY_MAPUTIL_H_	.\MapUtil.h	18;"	d
FOLLY_MEMORYMAPPING_H_	.\MemoryMapping.h	18;"	d
FOLLY_MEMORY_H_	.\Memory.h	18;"	d
FOLLY_MERGE_H_	.\Merge.h	40;"	d
FOLLY_NAMESPACE_STD_BEGIN	.\Portability.h	177;"	d
FOLLY_NAMESPACE_STD_BEGIN	.\Portability.h	180;"	d
FOLLY_NAMESPACE_STD_END	.\Portability.h	178;"	d
FOLLY_NAMESPACE_STD_END	.\Portability.h	181;"	d
FOLLY_NOINLINE	.\Portability.h	88;"	d
FOLLY_NOINLINE	.\Portability.h	90;"	d
FOLLY_NOINLINE	.\Portability.h	92;"	d
FOLLY_NORETURN	.\Portability.h	79;"	d
FOLLY_NORETURN	.\Portability.h	81;"	d
FOLLY_NORETURN	.\Portability.h	83;"	d
FOLLY_OPTIONAL_H_	.\Optional.h	18;"	d
FOLLY_OVERRIDE	.\Portability.h	142;"	d
FOLLY_OVERRIDE	.\Portability.h	145;"	d
FOLLY_OVERRIDE	.\io\Compression.cpp	/^      uint64_t uncompressedLength) FOLLY_OVERRIDE;$/;"	m	class:folly::io::__anon64::FOLLY_FINAL	file:	access:private
FOLLY_OVERRIDE	.\io\Compression.cpp	/^  bool doNeedsUncompressedLength() const FOLLY_OVERRIDE;$/;"	m	class:folly::io::__anon64::FOLLY_FINAL	file:	access:private
FOLLY_OVERRIDE	.\io\Compression.cpp	/^  const char* Peek(size_t* len) FOLLY_OVERRIDE;$/;"	m	class:folly::io::__anon64::FOLLY_FINAL	file:	access:public
FOLLY_OVERRIDE	.\io\Compression.cpp	/^  size_t Available() const FOLLY_OVERRIDE;$/;"	m	class:folly::io::__anon64::FOLLY_FINAL	file:	access:public
FOLLY_OVERRIDE	.\io\Compression.cpp	/^  std::unique_ptr<IOBuf> doCompress(const IOBuf* data) FOLLY_OVERRIDE;$/;"	m	class:folly::io::__anon64::FOLLY_FINAL	file:	access:private
FOLLY_OVERRIDE	.\io\Compression.cpp	/^  uint64_t doMaxUncompressedLength() const FOLLY_OVERRIDE;$/;"	m	class:folly::io::__anon64::FOLLY_FINAL	file:	access:private
FOLLY_OVERRIDE	.\io\Compression.cpp	/^  void Skip(size_t n) FOLLY_OVERRIDE;$/;"	m	class:folly::io::__anon64::FOLLY_FINAL	file:	access:public
FOLLY_PACKEDSYNCPTR_H_	.\PackedSyncPtr.h	18;"	d
FOLLY_PACK_ATTR	.\Portability.h	113;"	d
FOLLY_PACK_ATTR	.\Portability.h	117;"	d
FOLLY_PACK_ATTR	.\Portability.h	121;"	d
FOLLY_PACK_ATTR	.\io\RecordIO-inl.h	/^} FOLLY_PACK_ATTR;$/;"	m	namespace:folly::recordio_helpers::detail	typeref:struct:folly::recordio_helpers::detail::Header
FOLLY_PACK_ATTR	.\test\PackedSyncPtrTest.cpp	/^struct ignore { PackedSyncPtr<int> foo; char c; } FOLLY_PACK_ATTR;$/;"	m	namespace:__anon126	typeref:struct:__anon126::ignore	file:
FOLLY_PACK_ATTR	.\test\SmallLocksTest.cpp	/^  FOLLY_PACK_ATTR;$/;"	m	namespace:__anon131	typeref:struct:__anon131::ignore2	file:
FOLLY_PACK_ATTR	.\test\SmallLocksTest.cpp	/^struct ignore1 { MicroSpinLock msl; int16_t foo; } FOLLY_PACK_ATTR;$/;"	m	namespace:__anon131	typeref:struct:__anon131::ignore1	file:
FOLLY_PACK_POP	.\Portability.h	115;"	d
FOLLY_PACK_POP	.\Portability.h	119;"	d
FOLLY_PACK_POP	.\Portability.h	123;"	d
FOLLY_PACK_PUSH	.\Portability.h	114;"	d
FOLLY_PACK_PUSH	.\Portability.h	118;"	d
FOLLY_PACK_PUSH	.\Portability.h	122;"	d
FOLLY_PADDED_H_	.\Padded.h	18;"	d
FOLLY_PORTABILITY_H_	.\Portability.h	18;"	d
FOLLY_PREPROCESSOR_	.\Preprocessor.h	20;"	d
FOLLY_PRINTF_FORMAT	.\Portability.h	69;"	d
FOLLY_PRINTF_FORMAT	.\Portability.h	72;"	d
FOLLY_PRINTF_FORMAT_ATTR	.\Portability.h	70;"	d
FOLLY_PRINTF_FORMAT_ATTR	.\Portability.h	73;"	d
FOLLY_RANDOM_H_	.\Random.h	18;"	d
FOLLY_RANGE_CHECK	.\Conv.h	1412;"	d
FOLLY_RANGE_CHECK	.\Conv.h	48;"	d
FOLLY_RANGE_CHECK_STRINGIZE	.\Conv.h	1414;"	d
FOLLY_RANGE_CHECK_STRINGIZE	.\Conv.h	45;"	d
FOLLY_RANGE_CHECK_STRINGIZE2	.\Conv.h	1413;"	d
FOLLY_RANGE_CHECK_STRINGIZE2	.\Conv.h	46;"	d
FOLLY_RANGE_H_	.\Range.h	21;"	d
FOLLY_RWSPINLOCK_H_	.\RWSpinLock.h	55;"	d
FOLLY_SAFEASSERT_H_	.\SafeAssert.h	18;"	d
FOLLY_SAFE_CHECK	.\SafeAssert.h	28;"	d
FOLLY_SAFE_DCHECK	.\SafeAssert.h	39;"	d
FOLLY_SAFE_DCHECK	.\SafeAssert.h	41;"	d
FOLLY_SANITIZE_ADDRESS	.\CPortability.h	27;"	d
FOLLY_SANITIZE_ADDRESS	.\CPortability.h	32;"	d
FOLLY_SCOPEGUARD_H_	.\ScopeGuard.h	18;"	d
FOLLY_SMALLLOCKS_H_	.\SmallLocks.h	18;"	d
FOLLY_SMALL_VECTOR_H_	.\small_vector.h	24;"	d
FOLLY_SORTED_VECTOR_TYPES_H_	.\sorted_vector_types.h	61;"	d
FOLLY_SPIN_WAIT	.\AtomicHashArray-inl.h	402;"	d
FOLLY_SPIN_WAIT	.\AtomicHashMap-inl.h	432;"	d
FOLLY_SPIN_WAIT	.\detail\AtomicHashUtils.h	23;"	d
FOLLY_SPIN_WAIT	.\detail\AtomicHashUtils.h	29;"	d
FOLLY_SPOOKYHASHV1_H_	.\SpookyHashV1.h	46;"	d
FOLLY_SPOOKYHASHV2_H_	.\SpookyHashV2.h	47;"	d
FOLLY_STATS_BUCKETEDTIMESERIES_H_	.\stats\BucketedTimeSeries.h	18;"	d
FOLLY_STATS_BUCKETEDTIMESERIES_INL_H_	.\stats\BucketedTimeSeries-defs.h	18;"	d
FOLLY_STATS_MULTILEVELTIMESERIES_DEFS_H_	.\stats\MultiLevelTimeSeries-defs.h	18;"	d
FOLLY_STATS_MULTILEVELTIMESERIES_H_	.\stats\MultiLevelTimeSeries.h	18;"	d
FOLLY_STRING_INL_H_	.\String-inl.h	18;"	d
FOLLY_SUBPROCESS_H_	.\Subprocess.h	55;"	d
FOLLY_SYMBOLIZER_ELFCACHE_H_	.\experimental\symbolizer\ElfCache.h	18;"	d
FOLLY_SYMBOLIZER_LINEREADER_H_	.\experimental\symbolizer\LineReader.h	18;"	d
FOLLY_SYMBOLIZER_SIGNALHANDLER_H_	.\experimental\symbolizer\SignalHandler.h	18;"	d
FOLLY_SYMBOLIZER_STACKTRACE_H_	.\experimental\symbolizer\StackTrace.h	18;"	d
FOLLY_SYMBOLIZER_TEST_SIGNALHANDLERTEST_H_	.\experimental\symbolizer\test\SignalHandlerTest.h	18;"	d
FOLLY_TESTUTIL_H_	.\experimental\TestUtil.h	18;"	d
FOLLY_TEST_SYNCHRONIZEDTESTLIB_H	.\test\SynchronizedTestLib.h	18;"	d
FOLLY_TEST_SYNCHRONIZEDTESTLIB_INL_H	.\test\SynchronizedTestLib-inl.h	18;"	d
FOLLY_THREADCACHEDARENA_H_	.\ThreadCachedArena.h	18;"	d
FOLLY_THREADCACHEDINT_H	.\ThreadCachedInt.h	24;"	d
FOLLY_THREADLOCAL_H_	.\ThreadLocal.h	38;"	d
FOLLY_TIMEOUTQUEUE_H_	.\TimeoutQueue.h	29;"	d
FOLLY_TIMESERIES_HISTOGRAM_DEF_H_	.\stats\TimeseriesHistogram-defs.h	18;"	d
FOLLY_TIMESERIES_HISTOGRAM_H_	.\stats\TimeseriesHistogram.h	18;"	d
FOLLY_TLS	.\Portability.h	155;"	d
FOLLY_TLS	.\Portability.h	157;"	d
FOLLY_UNICODE_H_	.\Unicode.h	20;"	d
FOLLY_URI_H_	.\Uri.h	18;"	d
FOLLY_USE_SIMD_PRNG	.\Random.h	27;"	d
FOLLY_VARINT_H_	.\Varint.h	18;"	d
FOLLY_VERSIONCHECK_H_	.\VersionCheck.h	18;"	d
FOLLY_VERSION_CHECK	.\VersionCheck.h	83;"	d
FOLLY_VERSION_CHECK_PRIORITY	.\VersionCheck.h	73;"	d
FOLLY_VERSION_CHECK_PRIORITY	.\VersionCheck.h	75;"	d
FOLLY_X64	.\Portability.h	106;"	d
FOLLY_X64	.\Portability.h	108;"	d
FOR_EACH	.\Foreach.h	57;"	d
FOR_EACH_ENUMERATE	.\Foreach.h	84;"	d
FOR_EACH_KV	.\Foreach.h	101;"	d
FOR_EACH_R	.\Foreach.h	68;"	d
FOR_EACH_RANGE	.\Foreach.h	214;"	d
FOR_EACH_RANGE_R	.\Foreach.h	228;"	d
FREE	.\SmallLocks.h	/^  enum { FREE = 0, LOCKED = 1 };$/;"	e	enum:folly::MicroSpinLock::__anon87
FULLY_LINKED	.\ConcurrentSkipList-inl.h	/^    FULLY_LINKED = (1 << 2),$/;"	e	enum:folly::detail::SkipListNode::__anon5
Fast	.\experimental\EliasFanoCoding.h	/^struct Fast : public Default {$/;"	s	namespace:folly::compression::instructions	inherits:Default
FastByteSet	.\Range.cpp	/^  FastByteSet() : size_(0) { }  \/\/ no init of arrays required!$/;"	f	class:folly::__anon83::FastByteSet	access:public	signature:()
FastByteSet	.\Range.cpp	/^class FastByteSet {$/;"	c	namespace:folly::__anon83	file:
FatalSignalCallbackRegistry	.\experimental\symbolizer\SignalHandler.cpp	/^  FatalSignalCallbackRegistry();$/;"	p	class:folly::symbolizer::__anon36::FatalSignalCallbackRegistry	file:	access:public	signature:()
FatalSignalCallbackRegistry	.\experimental\symbolizer\SignalHandler.cpp	/^FatalSignalCallbackRegistry::FatalSignalCallbackRegistry()$/;"	f	class:folly::symbolizer::__anon36::FatalSignalCallbackRegistry	signature:()
FatalSignalCallbackRegistry	.\experimental\symbolizer\SignalHandler.cpp	/^class FatalSignalCallbackRegistry {$/;"	c	namespace:folly::symbolizer::__anon36	file:
FdCallback	.\Subprocess.h	/^  typedef std::function<bool(int, int)> FdCallback;$/;"	t	class:folly::Subprocess	access:public
FdMap	.\Subprocess.h	/^    typedef boost::container::flat_map<int, int> FdMap;$/;"	t	class:folly::Subprocess::Options	access:private
FdType	.\io\async\NotificationQueue.h	/^  enum class FdType {$/;"	c	class:folly::NotificationQueue	access:public
FibYielder	.\gen\test\BaseBenchmark.cpp	/^struct FibYielder {$/;"	s	file:
FibYielder::operator ()	.\gen\test\BaseBenchmark.cpp	/^  void operator()(Yield&& yield) const {$/;"	f	struct:FibYielder	access:public	signature:(Yield&& yield) const
Field	.\gen\Base.h	/^  explicit Field(FieldPtr field)$/;"	f	class:folly::gen::Field	access:public	signature:(FieldPtr field)
Field	.\gen\Base.h	/^class Field {$/;"	c	namespace:folly::gen
FieldType	.\gen\Base.h	/^  typedef FieldType (Class::*FieldPtr);$/;"	t	class:folly::gen::Field	access:public
File	.\File.cpp	/^File::File()$/;"	f	class:folly::File	signature:()
File	.\File.cpp	/^File::File(File&& other)$/;"	f	class:folly::File	signature:(File&& other)
File	.\File.cpp	/^File::File(const char* name, int flags, mode_t mode)$/;"	f	class:folly::File	signature:(const char* name, int flags, mode_t mode)
File	.\File.cpp	/^File::File(int fd, bool ownsFd)$/;"	f	class:folly::File	signature:(int fd, bool ownsFd)
File	.\File.h	/^  File();$/;"	p	class:folly::File	access:public	signature:()
File	.\File.h	/^  File(File&&);$/;"	p	class:folly::File	access:public	signature:(File&&)
File	.\File.h	/^  File(const File&) = delete;$/;"	p	class:folly::File	access:private	signature:(const File&)
File	.\File.h	/^  explicit File(const char* name, int flags = O_RDONLY, mode_t mode = 0666);$/;"	p	class:folly::File	access:public	signature:(const char* name, int flags = O_RDONLY, mode_t mode = 0666)
File	.\File.h	/^  explicit File(int fd, bool ownsFd = false);$/;"	p	class:folly::File	access:public	signature:(int fd, bool ownsFd = false)
File	.\File.h	/^class File {$/;"	c	namespace:folly
FileGenBufferedTest	.\gen\test\FileTest.cpp	/^class FileGenBufferedTest : public ::testing::TestWithParam<int> { };$/;"	c	file:	inherits:::testing::TestWithParam
FileName	.\experimental\symbolizer\Dwarf.h	/^    struct FileName {$/;"	s	class:folly::symbolizer::Dwarf::LineNumberVM	access:private
FileReader	.\gen\File-inl.h	/^  FileReader(File file, std::unique_ptr<IOBuf> buffer)$/;"	f	class:folly::gen::detail::FileReader	access:public	signature:(File file, std::unique_ptr<IOBuf> buffer)
FileReader	.\gen\File-inl.h	/^class FileReader : public GenImpl<ByteRange, FileReader> {$/;"	c	namespace:folly::gen::detail	inherits:GenImpl
FileReader	.\gen\File.h	/^class FileReader;$/;"	x
FileUtilTest	.\test\FileUtilTest.cpp	/^  FileUtilTest();$/;"	p	class:folly::test::FileUtilTest	file:	access:protected	signature:()
FileUtilTest	.\test\FileUtilTest.cpp	/^FileUtilTest::FileUtilTest()$/;"	f	class:folly::test::FileUtilTest	signature:()
FileUtilTest	.\test\FileUtilTest.cpp	/^class FileUtilTest : public ::testing::Test {$/;"	c	namespace:folly::test	file:	inherits:::testing::Test
FileWriter	.\gen\File-inl.h	/^  FileWriter(File file, std::unique_ptr<IOBuf> buffer)$/;"	f	class:folly::gen::detail::FileWriter	access:public	signature:(File file, std::unique_ptr<IOBuf> buffer)
FileWriter	.\gen\File-inl.h	/^class FileWriter : public Operator<FileWriter> {$/;"	c	namespace:folly::gen::detail	inherits:Operator
FileWriter	.\gen\File.h	/^class FileWriter;$/;"	x
FillObject	.\test\ThreadLocalTest.cpp	/^  explicit FillObject(uint64_t idx) : idx_(idx) {$/;"	f	class:__anon146::FillObject	access:public	signature:(uint64_t idx)
FillObject	.\test\ThreadLocalTest.cpp	/^class FillObject {$/;"	c	namespace:__anon146	file:
Filter	.\gen\Base-inl.h	/^  Filter() {}$/;"	f	class:folly::gen::detail::Filter	access:public	signature:()
Filter	.\gen\Base-inl.h	/^  explicit Filter(Predicate pred)$/;"	f	class:folly::gen::detail::Filter	access:public	signature:(Predicate pred)
Filter	.\gen\Base-inl.h	/^class Filter : public Operator<Filter<Predicate>> {$/;"	c	namespace:folly::gen::detail	inherits:Operator
Filter	.\gen\Base.h	/^class Filter;$/;"	x
Final	.\SpookyHashV1.cpp	/^void SpookyHashV1::Final(uint64_t *hash1, uint64_t *hash2)$/;"	f	class:folly::hash::SpookyHashV1	signature:(uint64_t *hash1, uint64_t *hash2)
Final	.\SpookyHashV1.h	/^    void Final($/;"	p	class:folly::hash::SpookyHashV1	access:public	signature:( uint64_t *hash1, uint64_t *hash2)
Final	.\SpookyHashV2.cpp	/^void SpookyHashV2::Final(uint64_t *hash1, uint64_t *hash2)$/;"	f	class:folly::hash::SpookyHashV2	signature:(uint64_t *hash1, uint64_t *hash2)
Final	.\SpookyHashV2.h	/^    void Final($/;"	p	class:folly::hash::SpookyHashV2	access:public	signature:( uint64_t *hash1, uint64_t *hash2)
Fingerprint	.\Fingerprint.h	/^  Fingerprint() {$/;"	f	class:folly::Fingerprint	access:public	signature:()
Fingerprint	.\Fingerprint.h	/^class Fingerprint {$/;"	c	namespace:folly
FingerprintPolynomial	.\detail\FingerprintPolynomial.h	/^  FingerprintPolynomial() {$/;"	f	class:folly::detail::FingerprintPolynomial	access:public	signature:()
FingerprintPolynomial	.\detail\FingerprintPolynomial.h	/^  explicit FingerprintPolynomial(const uint64_t* vals) {$/;"	f	class:folly::detail::FingerprintPolynomial	access:public	signature:(const uint64_t* vals)
FingerprintPolynomial	.\detail\FingerprintPolynomial.h	/^class FingerprintPolynomial {$/;"	c	namespace:folly::detail
FingerprintTable	.\Fingerprint.h	/^struct FingerprintTable {$/;"	s	namespace:folly::detail
First	.\gen\Base-inl.h	/^  First() { }$/;"	f	class:folly::gen::detail::First	access:public	signature:()
First	.\gen\Base-inl.h	/^class First : public Operator<First> {$/;"	c	namespace:folly::gen::detail	inherits:Operator
First	.\gen\Base.h	/^class First;$/;"	x
Flags	.\test\stl_tests\StlVectorTest.cpp	/^enum FlagVals : Flags {$/;"	g	file:
Flags	.\test\stl_tests\StlVectorTest.cpp	/^typedef uint32_t Flags;$/;"	t	file:
FoldLeft	.\gen\Base-inl.h	/^  FoldLeft() {}$/;"	f	class:folly::gen::detail::FoldLeft	access:public	signature:()
FoldLeft	.\gen\Base-inl.h	/^  FoldLeft(Seed seed,$/;"	f	class:folly::gen::detail::FoldLeft	access:public	signature:(Seed seed, Fold fold)
FoldLeft	.\gen\Base-inl.h	/^class FoldLeft : public Operator<FoldLeft<Seed, Fold>> {$/;"	c	namespace:folly::gen::detail	inherits:Operator
FoldLeft	.\gen\Base.h	/^class FoldLeft;$/;"	x
Foo	.\test\ArenaSmartPtrTest.cpp	/^  explicit Foo(global_counter& counter):$/;"	f	struct:Foo	access:public	signature:(global_counter& counter)
Foo	.\test\ArenaSmartPtrTest.cpp	/^struct Foo {$/;"	s	file:
Foo	.\test\HasMemberFnTraitsTest.cpp	/^struct Foo {$/;"	s	file:
Foo	.\test\ScopeGuardTest.cpp	/^  Foo() {}$/;"	f	class:Foo	access:public	signature:()
Foo	.\test\ScopeGuardTest.cpp	/^class Foo {$/;"	c	file:
Foo	.\test\ThreadLocalTest.cpp	/^struct Foo {$/;"	s	namespace:__anon145	file:
Foo::Foo	.\test\ArenaSmartPtrTest.cpp	/^  explicit Foo(global_counter& counter):$/;"	f	struct:Foo	access:public	signature:(global_counter& counter)
Foo::Foo	.\test\ScopeGuardTest.cpp	/^  Foo() {}$/;"	f	class:Foo	access:public	signature:()
Foo::counter_	.\test\ArenaSmartPtrTest.cpp	/^  global_counter& counter_;$/;"	m	struct:Foo	file:	access:private
Foo::test	.\test\HasMemberFnTraitsTest.cpp	/^  int test() const;$/;"	p	struct:Foo	file:	access:public	signature:() const
Foo::test	.\test\HasMemberFnTraitsTest.cpp	/^  int test();$/;"	p	struct:Foo	file:	access:public	signature:()
Foo::test	.\test\HasMemberFnTraitsTest.cpp	/^  string test(const string&) const;$/;"	p	struct:Foo	file:	access:public	signature:(const string&) const
Foo::~Foo	.\test\ArenaSmartPtrTest.cpp	/^  ~Foo() {$/;"	f	struct:Foo	access:public	signature:()
Foo::~Foo	.\test\ScopeGuardTest.cpp	/^  ~Foo() {$/;"	f	class:Foo	access:public	signature:()
FormatArg	.\FormatArg.h	/^  explicit FormatArg(StringPiece sp)$/;"	f	struct:folly::FormatArg	access:public	signature:(StringPiece sp)
FormatArg	.\FormatArg.h	/^struct FormatArg {$/;"	s	namespace:folly
FormatValue	.\Format-inl.h	/^  explicit FormatValue(StringPiece val) : val_(val) { }$/;"	f	class:folly::FormatValue	access:public	signature:(StringPiece val)
FormatValue	.\Format-inl.h	/^  explicit FormatValue(T val) : val_(val) { }$/;"	f	class:folly::FormatValue	access:public	signature:(T val)
FormatValue	.\Format-inl.h	/^  explicit FormatValue(T* val) : val_(val) { }$/;"	f	class:folly::FormatValue	access:public	signature:(T* val)
FormatValue	.\Format-inl.h	/^  explicit FormatValue(bool val) : val_(val) { }$/;"	f	class:folly::FormatValue	access:public	signature:(bool val)
FormatValue	.\Format-inl.h	/^  explicit FormatValue(double val) : val_(val) { }$/;"	f	class:folly::FormatValue	access:public	signature:(double val)
FormatValue	.\Format-inl.h	/^  explicit FormatValue(float val) : val_(val) { }$/;"	f	class:folly::FormatValue	access:public	signature:(float val)
FormatValue	.\Format-inl.h	/^  explicit FormatValue(std::nullptr_t) { }$/;"	f	class:folly::FormatValue	access:public	signature:(std::nullptr_t)
FormatValue	.\Format-inl.h	/^class FormatValue<$/;"	c	namespace:folly
FormatValue	.\Format-inl.h	/^class FormatValue<bool> {$/;"	c	namespace:folly
FormatValue	.\Format-inl.h	/^class FormatValue<double> {$/;"	c	namespace:folly
FormatValue	.\Format-inl.h	/^class FormatValue<float> {$/;"	c	namespace:folly
FormatValue	.\Format-inl.h	/^class FormatValue<std::nullptr_t> {$/;"	c	namespace:folly
FormatValue	.\Format.h	/^template <class T, class Enable=void> class FormatValue;$/;"	x
FormatValue	.\dynamic-inl.h	/^  explicit FormatValue($/;"	f	class:folly::FormatValue	access:public	signature:( const detail::DefaultValueWrapper<dynamic, V>& val)
FormatValue	.\dynamic-inl.h	/^  explicit FormatValue(const dynamic& val) : val_(val) { }$/;"	f	class:folly::FormatValue	access:public	signature:(const dynamic& val)
FormatValue	.\dynamic-inl.h	/^class FormatValue<detail::DefaultValueWrapper<dynamic, V>> {$/;"	c	namespace:folly
FormatValue	.\dynamic-inl.h	/^class FormatValue<dynamic> {$/;"	c	namespace:folly
FormatValue	.\test\FormatTest.cpp	/^  explicit FormatValue(const KeyValue& kv) : kv_(kv) { }$/;"	f	class:folly::FormatValue	access:public	signature:(const KeyValue& kv)
FormatValue	.\test\FormatTest.cpp	/^template <> class FormatValue<KeyValue> {$/;"	c	namespace:folly	file:
Formatter	.\Format.h	/^template <bool containerMode, class... Args> class Formatter;$/;"	x
FormatterTag	.\Format.h	/^class FormatterTag {};$/;"	c	namespace:folly::detail
FrameArray	.\experimental\symbolizer\Symbolizer.h	/^  FrameArray() : frameCount(0) { }$/;"	f	struct:folly::symbolizer::FrameArray	access:public	signature:()
FrameArray	.\experimental\symbolizer\Symbolizer.h	/^struct FrameArray {$/;"	s	namespace:folly::symbolizer
FreeFunction	.\io\IOBuf.h	/^  typedef void (*FreeFunction)(void* buf, void* userData);$/;"	t	class:folly::IOBuf	access:public
FullInt	.\RWSpinLock.h	/^  typedef typename detail::RWTicketIntTrait<kBitWidth>::FullInt FullInt;$/;"	t	class:folly::RWTicketSpinLockT	access:private
FullInt	.\RWSpinLock.h	/^  typedef uint32_t FullInt;$/;"	t	struct:folly::detail::RWTicketIntTrait	access:public
FullInt	.\RWSpinLock.h	/^  typedef uint64_t FullInt;$/;"	t	struct:folly::detail::RWTicketIntTrait	access:public
Func	.\detail\CacheLocality.h	/^  typedef int (*Func)(unsigned* cpu, unsigned* node, void* unused);$/;"	t	struct:folly::detail::Getcpu	access:public
Func	.\experimental\wangle\concurrent\Executor.h	/^typedef std::function<void()> Func;$/;"	t	namespace:folly::wangle
Func	.\test\ApplyTupleTest.cpp	/^struct Func {$/;"	s	namespace:__anon104	file:
FunctionLoopCallback	.\io\async\EventBase.cpp	/^  explicit FunctionLoopCallback(Cob&& function)$/;"	f	class:__anon62::FunctionLoopCallback	access:public	signature:(Cob&& function)
FunctionLoopCallback	.\io\async\EventBase.cpp	/^  explicit FunctionLoopCallback(const Cob& function)$/;"	f	class:__anon62::FunctionLoopCallback	access:public	signature:(const Cob& function)
FunctionLoopCallback	.\io\async\EventBase.cpp	/^class FunctionLoopCallback : public EventBase::LoopCallback {$/;"	c	namespace:__anon62	file:	inherits:EventBase::LoopCallback
FunctionRunner	.\io\async\EventBase.cpp	/^class EventBase::FunctionRunner$/;"	c	class:folly::EventBase	file:	inherits:NotificationQueue::Consumer
FunctionRunner	.\io\async\EventBase.h	/^  class FunctionRunner;$/;"	x
Futex	.\detail\Futex.h	/^  explicit Futex(uint32_t init = 0) : Atom<uint32_t>(init) {}$/;"	f	struct:folly::detail::Futex	access:public	signature:(uint32_t init = 0)
Futex	.\detail\Futex.h	/^struct Futex : Atom<uint32_t>, boost::noncopyable {$/;"	s	namespace:folly::detail	inherits:Atom,boost::noncopyable
Futex	.\test\MemoryIdlerTest.cpp	/^struct Futex<MockAtom> {$/;"	s	namespace:folly::detail	file:
FutexResult	.\detail\Futex.h	/^enum class FutexResult {$/;"	c	namespace:folly::detail
Future	.\wangle\Future.h	/^  -> Future<decltype(func())>;$/;"	m	namespace:folly::wangle
Future	.\wangle\Future.h	/^  Future(Future const&) = delete;$/;"	p	class:folly::wangle::Future	access:public	signature:(Future const&)
Future	.\wangle\Future.h	/^  Future(statePtr obj) : state_(obj) {}$/;"	f	class:folly::wangle::Future	access:private	signature:(statePtr obj)
Future	.\wangle\Future.h	/^class Future {$/;"	c	namespace:folly::wangle
Future	.\wangle\Promise.h	/^template <class T> class Future;$/;"	x
FutureAlreadyRetrieved	.\wangle\WangleException.h	/^    explicit FutureAlreadyRetrieved () :$/;"	f	class:folly::wangle::FutureAlreadyRetrieved	access:public	signature:()
FutureAlreadyRetrieved	.\wangle\WangleException.h	/^class FutureAlreadyRetrieved : public WangleException {$/;"	c	namespace:folly::wangle	inherits:WangleException
FutureNotReady	.\wangle\WangleException.h	/^    explicit FutureNotReady() :$/;"	f	class:folly::wangle::FutureNotReady	access:public	signature:()
FutureNotReady	.\wangle\WangleException.h	/^class FutureNotReady : public WangleException {$/;"	c	namespace:folly::wangle	inherits:WangleException
GEN	.\test\EndianTest.cpp	53;"	d	file:
GEN	.\test\EndianTest.cpp	63;"	d	file:
GEN1	.\test\EndianTest.cpp	35;"	d	file:
GEN1	.\test\EndianTest.cpp	64;"	d	file:
GENERATOR	.\gen\Base.h	476;"	d
GEN_CLOSER	.\test\stl_tests\StlVectorTest.cpp	820;"	d	file:
GEN_LOOPER	.\test\stl_tests\StlVectorTest.cpp	817;"	d	file:
GEN_RUNNABLE_TEST	.\test\stl_tests\StlVectorTest.cpp	814;"	d	file:
GEN_TEST	.\test\stl_tests\StlVectorTest.cpp	803;"	d	file:
GEN_TYPE_TEST	.\test\stl_tests\StlVectorTest.cpp	812;"	d	file:
GEN_UMAKER	.\test\stl_tests\StlVectorTest.cpp	819;"	d	file:
GEN_VMAKER	.\test\stl_tests\StlVectorTest.cpp	818;"	d	file:
GETCPU	.\test\CacheLocalityTest.cpp	/^enum class SpreaderType { GETCPU, SHARED, TLS_RR };$/;"	m	class:SpreaderType	file:	access:private
GREEN	.\experimental\symbolizer\Symbolizer.h	/^  enum Color { DEFAULT, RED, GREEN, YELLOW, BLUE, CYAN, WHITE, PURPLE };$/;"	e	enum:folly::symbolizer::SymbolizePrinter::Color
Gaz	.\test\HasMemberFnTraitsTest.cpp	/^struct Gaz {$/;"	s	file:
Gaz::test	.\test\HasMemberFnTraitsTest.cpp	/^  void test() const volatile;$/;"	p	struct:Gaz	file:	access:public	signature:() const volatile
Gaz::test	.\test\HasMemberFnTraitsTest.cpp	/^  void test() const;$/;"	p	struct:Gaz	file:	access:public	signature:() const
Gaz::test	.\test\HasMemberFnTraitsTest.cpp	/^  void test() volatile;$/;"	p	struct:Gaz	file:	access:public	signature:() volatile
Gaz::test	.\test\HasMemberFnTraitsTest.cpp	/^  void test();$/;"	p	struct:Gaz	file:	access:public	signature:()
GenImpl	.\gen\Core-inl.h	/^  GenImpl() = default;$/;"	p	class:folly::gen::GenImpl	access:protected	signature:()
GenImpl	.\gen\Core-inl.h	/^  GenImpl(GenImpl&&) = default;$/;"	p	class:folly::gen::GenImpl	access:protected	signature:(GenImpl&&)
GenImpl	.\gen\Core-inl.h	/^  GenImpl(const GenImpl&) = default;$/;"	p	class:folly::gen::GenImpl	access:protected	signature:(const GenImpl&)
GenImpl	.\gen\Core-inl.h	/^class GenImpl : public FBounded<Self> {$/;"	c	namespace:folly::gen	inherits:FBounded
GenImpl	.\gen\Core.h	/^class GenImpl;$/;"	x
Generator	.\gen\Base-inl.h	/^    Generator(Source source,$/;"	f	class:folly::gen::detail::Distinct::Generator	access:public	signature:(Source source, Selector selector)
Generator	.\gen\Base-inl.h	/^    Generator(Source source,$/;"	f	class:folly::gen::detail::Order::Generator	access:public	signature:(Source source, Selector selector, Comparer comparer)
Generator	.\gen\Base-inl.h	/^    explicit Generator(Source source)$/;"	f	class:folly::gen::detail::Concat::Generator	access:public	signature:(Source source)
Generator	.\gen\Base-inl.h	/^    explicit Generator(Source source)$/;"	f	class:folly::gen::detail::Dereference::Generator	access:public	signature:(Source source)
Generator	.\gen\Base-inl.h	/^    explicit Generator(Source source)$/;"	f	class:folly::gen::detail::RangeConcat::Generator	access:public	signature:(Source source)
Generator	.\gen\Base-inl.h	/^    explicit Generator(Source source, const Predicate& pred)$/;"	f	class:folly::gen::detail::Filter::Generator	access:public	signature:(Source source, const Predicate& pred)
Generator	.\gen\Base-inl.h	/^    explicit Generator(Source source, const Predicate& pred)$/;"	f	class:folly::gen::detail::Map::Generator	access:public	signature:(Source source, const Predicate& pred)
Generator	.\gen\Base-inl.h	/^    explicit Generator(Source source, const Predicate& pred)$/;"	f	class:folly::gen::detail::Until::Generator	access:public	signature:(Source source, const Predicate& pred)
Generator	.\gen\Base-inl.h	/^    explicit Generator(Source source, off_t limit)$/;"	f	class:folly::gen::detail::Cycle::Generator	access:public	signature:(Source source, off_t limit)
Generator	.\gen\Base-inl.h	/^    explicit Generator(Source source, size_t batchSize)$/;"	f	class:folly::gen::detail::Batch::Generator	access:public	signature:(Source source, size_t batchSize)
Generator	.\gen\Base-inl.h	/^    explicit Generator(Source source, size_t count)$/;"	f	class:folly::gen::detail::Skip::Generator	access:public	signature:(Source source, size_t count)
Generator	.\gen\Base-inl.h	/^    explicit Generator(Source source, size_t count)$/;"	f	class:folly::gen::detail::Take::Generator	access:public	signature:(Source source, size_t count)
Generator	.\gen\Base-inl.h	/^    explicit Generator(Source source, size_t count, Random rng)$/;"	f	class:folly::gen::detail::Sample::Generator	access:public	signature:(Source source, size_t count, Random rng)
Generator	.\gen\Base-inl.h	/^    explicit Generator(Source source,$/;"	f	class:folly::gen::detail::GuardImpl::Generator	access:public	signature:(Source source, ErrorHandler handler)
Generator	.\gen\Base-inl.h	/^   Generator(Source source, size_t stride)$/;"	f	class:folly::gen::detail::Stride::Generator	access:public	signature:(Source source, size_t stride)
Generator	.\gen\Base-inl.h	/^  class Generator : public GenImpl<Result, Generator<Value, Source, Result>> {$/;"	c	class:folly::gen::detail::Dereference	inherits:GenImpl	access:public
Generator	.\gen\Base-inl.h	/^  class Generator : public GenImpl<Value, Generator<Value, Source>> {$/;"	c	class:folly::gen::detail::Cycle	inherits:GenImpl	access:public
Generator	.\gen\Base-inl.h	/^  class Generator : public GenImpl<Value, Generator<Value, Source>> {$/;"	c	class:folly::gen::detail::Distinct	inherits:GenImpl	access:public
Generator	.\gen\Base-inl.h	/^  class Generator : public GenImpl<Value, Generator<Value, Source>> {$/;"	c	class:folly::gen::detail::Filter	inherits:GenImpl	access:public
Generator	.\gen\Base-inl.h	/^  class Generator : public GenImpl<Value, Generator<Value, Source>> {$/;"	c	class:folly::gen::detail::GuardImpl	inherits:GenImpl	access:public
Generator	.\gen\Base-inl.h	/^  class Generator : public GenImpl<Value, Generator<Value, Source>> {$/;"	c	class:folly::gen::detail::Stride	inherits:GenImpl	access:public
Generator	.\gen\Base-inl.h	/^  class Generator : public GenImpl<Value, Generator<Value, Source>> {$/;"	c	class:folly::gen::detail::Until	inherits:GenImpl	access:public
Generator	.\gen\Base-inl.h	/^  class Generator :$/;"	c	class:folly::gen::detail::Batch	inherits:GenImpl	access:public
Generator	.\gen\Base-inl.h	/^  class Generator :$/;"	c	class:folly::gen::detail::Concat	inherits:GenImpl	access:public
Generator	.\gen\Base-inl.h	/^  class Generator :$/;"	c	class:folly::gen::detail::Map	inherits:GenImpl	access:public
Generator	.\gen\Base-inl.h	/^  class Generator :$/;"	c	class:folly::gen::detail::Order	inherits:GenImpl	access:public
Generator	.\gen\Base-inl.h	/^  class Generator :$/;"	c	class:folly::gen::detail::Sample	inherits:GenImpl	access:public
Generator	.\gen\Base-inl.h	/^  class Generator :$/;"	c	class:folly::gen::detail::Skip	inherits:GenImpl	access:public
Generator	.\gen\Base-inl.h	/^  class Generator :$/;"	c	class:folly::gen::detail::Take	inherits:GenImpl	access:public
Generator	.\gen\Base-inl.h	/^  class Generator$/;"	c	class:folly::gen::detail::RangeConcat	inherits:GenImpl	access:public
Generator	.\gen\Combine-inl.h	/^    explicit Generator(Source source,$/;"	f	class:folly::gen::detail::Interleave::Generator	access:public	signature:(Source source, const std::shared_ptr<const Container> container)
Generator	.\gen\Combine-inl.h	/^    explicit Generator(Source source,$/;"	f	class:folly::gen::detail::Zip::Generator	access:public	signature:(Source source, const std::shared_ptr<const Container> container)
Generator	.\gen\Combine-inl.h	/^  class Generator : public GenImpl<Result,$/;"	c	class:folly::gen::detail::Zip	inherits:GenImpl	access:public
Generator	.\gen\Combine-inl.h	/^  class Generator : public GenImpl<Value, Generator<Value, Source>> {$/;"	c	class:folly::gen::detail::Interleave	inherits:GenImpl	access:public
Generator	.\gen\Parallel-inl.h	/^    Generator(Source source, Ops ops, size_t threads)$/;"	f	class:folly::gen::detail::Parallel::Generator	access:public	signature:(Source source, Ops ops, size_t threads)
Generator	.\gen\Parallel-inl.h	/^  class Generator : public GenImpl<OutputDecayed&&,$/;"	c	class:folly::gen::detail::Parallel	inherits:GenImpl	access:public
Generator	.\gen\ParallelMap-inl.h	/^    Generator(Source source, const Predicate& pred, size_t nThreads)$/;"	f	class:folly::gen::detail::PMap::Generator	access:public	signature:(Source source, const Predicate& pred, size_t nThreads)
Generator	.\gen\ParallelMap-inl.h	/^  class Generator :$/;"	c	class:folly::gen::detail::PMap	inherits:GenImpl	access:public
Generator	.\gen\String-inl.h	/^    Generator(Source source, char delimiter)$/;"	f	class:folly::gen::detail::StringResplitter::Generator	access:public	signature:(Source source, char delimiter)
Generator	.\gen\String-inl.h	/^  class Generator : public GenImpl<StringPiece, Generator<Source>> {$/;"	c	class:folly::gen::detail::StringResplitter	inherits:GenImpl	access:public
GeneratorBuilder	.\gen\Base-inl.h	/^struct GeneratorBuilder {$/;"	s	namespace:folly::gen::detail
GeneratorBuilder	.\gen\Base.h	/^struct GeneratorBuilder;$/;"	x
GenericThreadGate	.\wangle\GenericThreadGate.h	/^  GenericThreadGate(WestExecutorPtr west,$/;"	f	class:folly::wangle::GenericThreadGate	access:public	signature:(WestExecutorPtr west, EastExecutorPtr east, WaiterPtr waiter = nullptr)
GenericThreadGate	.\wangle\GenericThreadGate.h	/^class GenericThreadGate : public ThreadGate {$/;"	c	namespace:folly::wangle	inherits:ThreadGate
GenericThreadGateFixture	.\wangle\test\ThreadGateTest.cpp	/^  GenericThreadGateFixture() :$/;"	f	struct:GenericThreadGateFixture	access:public	signature:()
GenericThreadGateFixture	.\wangle\test\ThreadGateTest.cpp	/^struct GenericThreadGateFixture : public testing::Test {$/;"	s	file:	inherits:testing::Test
GenericThreadGateFixture::GenericThreadGateFixture	.\wangle\test\ThreadGateTest.cpp	/^  GenericThreadGateFixture() :$/;"	f	struct:GenericThreadGateFixture	access:public	signature:()
GenericThreadGateFixture::done	.\wangle\test\ThreadGateTest.cpp	/^  bool done;$/;"	m	struct:GenericThreadGateFixture	file:	access:public
GenericThreadGateFixture::eastExecutor	.\wangle\test\ThreadGateTest.cpp	/^  shared_ptr<ManualExecutor> eastExecutor;$/;"	m	struct:GenericThreadGateFixture	file:	access:public
GenericThreadGateFixture::t	.\wangle\test\ThreadGateTest.cpp	/^  thread t;$/;"	m	struct:GenericThreadGateFixture	file:	access:public
GenericThreadGateFixture::tg	.\wangle\test\ThreadGateTest.cpp	/^    shared_ptr<ManualWaiter>> tg;$/;"	m	struct:GenericThreadGateFixture	file:	access:public
GenericThreadGateFixture::waiter	.\wangle\test\ThreadGateTest.cpp	/^  shared_ptr<ManualWaiter> waiter;$/;"	m	struct:GenericThreadGateFixture	file:	access:public
GenericThreadGateFixture::westExecutor	.\wangle\test\ThreadGateTest.cpp	/^  shared_ptr<ManualExecutor> westExecutor;$/;"	m	struct:GenericThreadGateFixture	file:	access:public
GenericThreadGateFixture::~GenericThreadGateFixture	.\wangle\test\ThreadGateTest.cpp	/^  ~GenericThreadGateFixture() {$/;"	f	struct:GenericThreadGateFixture	access:public	signature:()
Get	.\gen\Base.h	/^class Get {$/;"	c	namespace:folly::gen
GetAddrImpl	.\dynamic-inl.h	/^template<> struct dynamic::GetAddrImpl<bool> {$/;"	s	class:folly::dynamic
GetAddrImpl	.\dynamic-inl.h	/^template<> struct dynamic::GetAddrImpl<double> {$/;"	s	class:folly::dynamic
GetAddrImpl	.\dynamic-inl.h	/^template<> struct dynamic::GetAddrImpl<dynamic::Array> {$/;"	s	class:folly::dynamic
GetAddrImpl	.\dynamic-inl.h	/^template<> struct dynamic::GetAddrImpl<dynamic::ObjectImpl> {$/;"	s	class:folly::dynamic
GetAddrImpl	.\dynamic-inl.h	/^template<> struct dynamic::GetAddrImpl<fbstring> {$/;"	s	class:folly::dynamic
GetAddrImpl	.\dynamic-inl.h	/^template<> struct dynamic::GetAddrImpl<int64_t> {$/;"	s	class:folly::dynamic
GetAddrImpl	.\dynamic-inl.h	/^template<> struct dynamic::GetAddrImpl<void*> {$/;"	s	class:folly::dynamic
GetAddrImpl	.\dynamic-inl.h	/^template<class T> struct dynamic::GetAddrImpl {};$/;"	s	class:folly::dynamic
GetAddrImpl	.\dynamic.h	/^  template<class T> struct GetAddrImpl;$/;"	x
GetExceptionStackTraceStackType	.\experimental\exception_tracer\ExceptionTracer.cpp	/^typedef StackTraceStack* (*GetExceptionStackTraceStackType)(void);$/;"	t	file:
GetTickCount	.\test\SpookyHashV1Test.cpp	/^static uint64_t GetTickCount() {$/;"	f	file:	signature:()
GetTickCount	.\test\SpookyHashV2Test.cpp	/^static uint64_t GetTickCount() {$/;"	f	file:	signature:()
GetTypeIndex	.\detail\DiscriminatedPtrDetail.h	/^struct GetTypeIndex<T, T, Types...> {$/;"	s	namespace:folly::dptr_detail
GetTypeIndex	.\detail\DiscriminatedPtrDetail.h	/^struct GetTypeIndex<T, U, Types...> {$/;"	s	namespace:folly::dptr_detail
GetTypeIndex	.\detail\DiscriminatedPtrDetail.h	/^template <typename... Types> struct GetTypeIndex;$/;"	x
Getcpu	.\detail\CacheLocality.h	/^struct Getcpu {$/;"	s	namespace:folly::detail
GlobalWatchdog	.\experimental\test\SingletonTest.cpp	/^struct GlobalWatchdog : public Watchdog {};$/;"	s	file:	inherits:Watchdog
GroupVarint	.\GroupVarint.h	/^class GroupVarint;$/;"	x
GroupVarint	.\GroupVarint.h	/^class GroupVarint<uint32_t> : public detail::GroupVarintBase<uint32_t> {$/;"	c	namespace:folly	inherits:detail::GroupVarintBase
GroupVarint	.\GroupVarint.h	/^class GroupVarint<uint64_t> : public detail::GroupVarintBase<uint64_t> {$/;"	c	namespace:folly	inherits:detail::GroupVarintBase
GroupVarint	.\detail\GroupVarintDetail.h	/^class GroupVarint;$/;"	x
GroupVarint32	.\GroupVarint.h	/^typedef GroupVarint<uint32_t> GroupVarint32;$/;"	t	namespace:folly
GroupVarint32Decoder	.\GroupVarint.h	/^typedef GroupVarintDecoder<uint32_t> GroupVarint32Decoder;$/;"	t	namespace:folly
GroupVarint32Decoder	.\test\GroupVarintTest.cpp	/^typedef GroupVarintDecoder<uint32_t> GroupVarint32Decoder;$/;"	t	namespace:__anon121	file:
GroupVarint32Encoder	.\test\GroupVarintTest.cpp	/^typedef GroupVarintEncoder<uint32_t, StringAppender> GroupVarint32Encoder;$/;"	t	namespace:__anon121	file:
GroupVarint64	.\GroupVarint.h	/^typedef GroupVarint<uint64_t> GroupVarint64;$/;"	t	namespace:folly
GroupVarint64Decoder	.\GroupVarint.h	/^typedef GroupVarintDecoder<uint64_t> GroupVarint64Decoder;$/;"	t	namespace:folly
GroupVarint64Decoder	.\test\GroupVarintTest.cpp	/^typedef GroupVarintDecoder<uint32_t> GroupVarint64Decoder;$/;"	t	namespace:__anon121	file:
GroupVarint64Encoder	.\test\GroupVarintTest.cpp	/^typedef GroupVarintEncoder<uint64_t, StringAppender> GroupVarint64Encoder;$/;"	t	namespace:__anon121	file:
GroupVarintBase	.\detail\GroupVarintDetail.h	/^class GroupVarintBase {$/;"	c	namespace:folly::detail
GroupVarintDecoder	.\GroupVarint.h	/^  GroupVarintDecoder() { }$/;"	f	class:folly::GroupVarintDecoder	access:public	signature:()
GroupVarintDecoder	.\GroupVarint.h	/^  explicit GroupVarintDecoder(StringPiece data,$/;"	f	class:folly::GroupVarintDecoder	access:public	signature:(StringPiece data, size_t maxCount = (size_t)-1)
GroupVarintDecoder	.\GroupVarint.h	/^class GroupVarintDecoder {$/;"	c	namespace:folly
GroupVarintEncoder	.\GroupVarint.h	/^  explicit GroupVarintEncoder(Output out)$/;"	f	class:folly::GroupVarintEncoder	access:public	signature:(Output out)
GroupVarintEncoder	.\GroupVarint.h	/^class GroupVarintEncoder {$/;"	c	namespace:folly
GroupVarintTraits	.\detail\GroupVarintDetail.h	/^struct GroupVarintTraits;$/;"	x
GroupVarintTraits	.\detail\GroupVarintDetail.h	/^struct GroupVarintTraits<uint32_t> {$/;"	s	namespace:folly::detail
GroupVarintTraits	.\detail\GroupVarintDetail.h	/^struct GroupVarintTraits<uint64_t> {$/;"	s	namespace:folly::detail
Guard	.\test\AHMIntStressTest.cpp	/^typedef std::lock_guard<std::mutex> Guard;$/;"	t	namespace:__anon102	file:
Guard	.\test\ApplyTupleTest.cpp	/^typedef GuardObjBase const& Guard;$/;"	t	namespace:__anon104	file:
GuardImpl	.\gen\Base-inl.h	/^  explicit GuardImpl(ErrorHandler handler) : handler_(std::move(handler)) {}$/;"	f	class:folly::gen::detail::GuardImpl	access:public	signature:(ErrorHandler handler)
GuardImpl	.\gen\Base-inl.h	/^class GuardImpl : public Operator<GuardImpl<Exception, ErrorHandler>> {$/;"	c	namespace:folly::gen::detail	inherits:Operator
GuardImpl	.\gen\Base.h	/^class GuardImpl;$/;"	x
GuardObj	.\test\ApplyTupleTest.cpp	/^  GuardObj(GuardObj&& g)$/;"	f	struct:__anon104::GuardObj	access:public	signature:(GuardObj&& g)
GuardObj	.\test\ApplyTupleTest.cpp	/^  GuardObj(const GuardObj&) = delete;$/;"	p	struct:__anon104::GuardObj	file:	access:public	signature:(const GuardObj&)
GuardObj	.\test\ApplyTupleTest.cpp	/^  explicit GuardObj(F&& f, Tuple&& args)$/;"	f	struct:__anon104::GuardObj	access:public	signature:(F&& f, Tuple&& args)
GuardObj	.\test\ApplyTupleTest.cpp	/^struct GuardObj : GuardObjBase {$/;"	s	namespace:__anon104	file:	inherits:GuardObjBase
GuardObjBase	.\test\ApplyTupleTest.cpp	/^  GuardObjBase() {}$/;"	f	struct:__anon104::GuardObjBase	access:public	signature:()
GuardObjBase	.\test\ApplyTupleTest.cpp	/^  GuardObjBase(GuardObjBase const&) = delete;$/;"	p	struct:__anon104::GuardObjBase	file:	access:public	signature:(GuardObjBase const&)
GuardObjBase	.\test\ApplyTupleTest.cpp	/^  GuardObjBase(GuardObjBase&&) {}$/;"	f	struct:__anon104::GuardObjBase	access:public	signature:(GuardObjBase&&)
GuardObjBase	.\test\ApplyTupleTest.cpp	/^struct GuardObjBase {$/;"	s	namespace:__anon104	file:
HANDLED_ERROR	.\test\ScopeGuardTest.cpp	/^  HANDLED_ERROR,$/;"	m	class:ErrorBehavior	file:	access:private
HAVE_GROUP_VARINT	.\GroupVarint.h	27;"	d
HHWheelTimer	.\io\async\HHWheelTimer.cpp	/^HHWheelTimer::HHWheelTimer(folly::EventBase* eventBase,$/;"	f	class:folly::HHWheelTimer	signature:(folly::EventBase* eventBase, std::chrono::milliseconds intervalMS)
HHWheelTimer	.\io\async\HHWheelTimer.h	/^    friend class HHWheelTimer;$/;"	x
HHWheelTimer	.\io\async\HHWheelTimer.h	/^  HHWheelTimer(HHWheelTimer const &) = delete;$/;"	p	class:folly::HHWheelTimer	access:private	signature:(HHWheelTimer const &)
HHWheelTimer	.\io\async\HHWheelTimer.h	/^  explicit HHWheelTimer(folly::EventBase* eventBase,$/;"	p	class:folly::HHWheelTimer	access:public	signature:(folly::EventBase* eventBase, std::chrono::milliseconds intervalMS = std::chrono::milliseconds(DEFAULT_TICK_INTERVAL))
HHWheelTimer	.\io\async\HHWheelTimer.h	/^class HHWheelTimer : protected folly::AsyncTimeout,$/;"	c	namespace:folly	inherits:folly::AsyncTimeout,folly::DelayedDestruction
HOUR	.\test\TimeseriesHistogramTest.cpp	/^    HOUR,$/;"	e	enum:IntMHTS::Levels	file:
HOUR	.\test\TimeseriesHistogramTest.cpp	/^    HOUR,$/;"	e	enum:IntMTMHTS::Levels	file:
HOUR	.\test\TimeseriesTest.cpp	/^    HOUR,$/;"	e	enum:IntMHTS::Levels	file:
HalfInt	.\RWSpinLock.h	/^  typedef typename detail::RWTicketIntTrait<kBitWidth>::HalfInt HalfInt;$/;"	t	class:folly::RWTicketSpinLockT	access:private
HalfInt	.\RWSpinLock.h	/^  typedef uint16_t HalfInt;$/;"	t	struct:folly::detail::RWTicketIntTrait	access:public
HalfInt	.\RWSpinLock.h	/^  typedef uint32_t HalfInt;$/;"	t	struct:folly::detail::RWTicketIntTrait	access:public
HasLess	.\Foreach.h	/^class HasLess {$/;"	c	namespace:folly::detail
HasLockUnlock	.\Synchronized.h	/^struct HasLockUnlock {$/;"	s	namespace:folly::detail
HasNoHeap	.\small_vector.h	/^    >::type HasNoHeap;$/;"	t	struct:folly::detail::small_vector_base	access:public
Hash128	.\SpookyHashV1.cpp	/^void SpookyHashV1::Hash128($/;"	f	class:folly::hash::SpookyHashV1	signature:( const void *message, size_t length, uint64_t *hash1, uint64_t *hash2)
Hash128	.\SpookyHashV1.h	/^    static void Hash128($/;"	p	class:folly::hash::SpookyHashV1	access:public	signature:( const void *message, size_t length, uint64_t *hash1, uint64_t *hash2)
Hash128	.\SpookyHashV2.cpp	/^void SpookyHashV2::Hash128($/;"	f	class:folly::hash::SpookyHashV2	signature:( const void *message, size_t length, uint64_t *hash1, uint64_t *hash2)
Hash128	.\SpookyHashV2.h	/^    static void Hash128($/;"	p	class:folly::hash::SpookyHashV2	access:public	signature:( const void *message, size_t length, uint64_t *hash1, uint64_t *hash2)
Hash32	.\SpookyHashV1.h	/^    static uint32_t Hash32($/;"	f	class:folly::hash::SpookyHashV1	access:public	signature:( const void *message, size_t length, uint32_t seed)
Hash32	.\SpookyHashV2.h	/^    static uint32_t Hash32($/;"	f	class:folly::hash::SpookyHashV2	access:public	signature:( const void *message, size_t length, uint32_t seed)
Hash64	.\SpookyHashV1.h	/^    static uint64_t Hash64($/;"	f	class:folly::hash::SpookyHashV1	access:public	signature:( const void *message, size_t length, uint64_t seed)
Hash64	.\SpookyHashV2.h	/^    static uint64_t Hash64($/;"	f	class:folly::hash::SpookyHashV2	access:public	signature:( const void *message, size_t length, uint64_t seed)
Header	.\io\RecordIO-inl.h	/^struct Header {$/;"	s	namespace:folly::recordio_helpers::detail
HeapFullStorage	.\io\IOBuf.cpp	/^struct IOBuf::HeapFullStorage {$/;"	s	class:folly::IOBuf	file:
HeapFullStorage	.\io\IOBuf.h	/^  struct HeapFullStorage;$/;"	x
HeapPrefix	.\io\IOBuf.cpp	/^  HeapPrefix(uint16_t flg)$/;"	f	struct:folly::IOBuf::HeapPrefix	access:public	signature:(uint16_t flg)
HeapPrefix	.\io\IOBuf.cpp	/^struct IOBuf::HeapPrefix {$/;"	s	class:folly::IOBuf	file:
HeapPrefix	.\io\IOBuf.h	/^  struct HeapPrefix;$/;"	x
HeapPtr	.\small_vector.h	/^  struct HeapPtr {$/;"	s	class:folly::small_vector	access:private
HeapPtrWithCapacity	.\small_vector.h	/^  struct HeapPtrWithCapacity {$/;"	s	class:folly::small_vector	access:private
HeapStorage	.\io\IOBuf.cpp	/^struct IOBuf::HeapStorage {$/;"	s	class:folly::IOBuf	file:
HeapStorage	.\io\IOBuf.h	/^  struct HeapStorage;$/;"	x
Histogram	.\stats\Histogram.h	/^  Histogram(ValueType bucketSize, ValueType min, ValueType max)$/;"	f	class:folly::Histogram	access:public	signature:(ValueType bucketSize, ValueType min, ValueType max)
Histogram	.\stats\Histogram.h	/^class Histogram {$/;"	c	namespace:folly
Histogram	.\stats\Instantiations.cpp	/^template class Histogram<int64_t>;$/;"	x	file:
HistogramBuckets	.\stats\Histogram-defs.h	/^HistogramBuckets<T, BucketT>::HistogramBuckets(ValueType bucketSize,$/;"	f	class:folly::detail::HistogramBuckets	signature:(ValueType bucketSize, ValueType min, ValueType max, const BucketType& defaultBucket)
HistogramBuckets	.\stats\Histogram.h	/^  HistogramBuckets(ValueType bucketSize, ValueType min, ValueType max,$/;"	p	class:folly::detail::HistogramBuckets	access:public	signature:(ValueType bucketSize, ValueType min, ValueType max, const BucketType& defaultBucket)
HistogramBuckets	.\stats\Histogram.h	/^class HistogramBuckets {$/;"	c	namespace:folly::detail
HistogramBuckets	.\stats\Instantiations.cpp	/^template class detail::HistogramBuckets<int64_t, Histogram<int64_t>::Bucket>;$/;"	m	class:folly::detail	typeref:class:folly::detail::	file:
HoldsOne	.\test\ThreadLocalTest.cpp	/^  HoldsOne() : value_(1) { }$/;"	f	class:__anon147::HoldsOne	access:public	signature:()
HoldsOne	.\test\ThreadLocalTest.cpp	/^class HoldsOne {$/;"	c	namespace:__anon147	file:
HoldsOneTag	.\test\ThreadLocalTest.cpp	/^struct HoldsOneTag {};$/;"	s	namespace:__anon147	file:
HoldsOneTag2	.\test\ThreadLocalTest.cpp	/^struct HoldsOneTag2 {};$/;"	s	file:
HostAndPort	.\SocketAddress.cpp	/^  HostAndPort(const char* str, bool hostRequired)$/;"	f	struct:__anon90::HostAndPort	access:public	signature:(const char* str, bool hostRequired)
HostAndPort	.\SocketAddress.cpp	/^struct HostAndPort {$/;"	s	namespace:__anon90	file:
HugePageSize	.\experimental\io\HugePages.h	/^  explicit HugePageSize(size_t s) : size(s) { }$/;"	f	struct:folly::HugePageSize	access:public	signature:(size_t s)
HugePageSize	.\experimental\io\HugePages.h	/^struct HugePageSize : private boost::totally_ordered<HugePageSize> {$/;"	s	namespace:folly	inherits:boost::totally_ordered
HugePageSizeVec	.\experimental\io\HugePages.h	/^typedef std::vector<HugePageSize> HugePageSizeVec;$/;"	t	namespace:folly
IBOOST_PP_VARIADIC_SIZE	.\test\stl_tests\StlVectorTest.cpp	787;"	d	file:
IBOOST_PP_VARIADIC_SIZE_I	.\test\stl_tests\StlVectorTest.cpp	792;"	d	file:
IBOOST_PP_VARIADIC_TO_SEQ	.\test\stl_tests\StlVectorTest.cpp	797;"	d	file:
INITIALIZED	.\experimental\io\AsyncIO.h	/^    INITIALIZED,$/;"	m	class:folly::AsyncIOOp::State	access:private
INSTANTIATE_TEST_CASE_P	.\io\test\CompressionTest.cpp	/^INSTANTIATE_TEST_CASE_P($/;"	p	namespace:folly::io::test	file:	signature:( CompressionCorruptionTest, CompressionCorruptionTest, testing::Values( CodecType::SNAPPY, CodecType::ZLIB))
INSTANTIATE_TEST_CASE_P	.\io\test\CompressionTest.cpp	/^INSTANTIATE_TEST_CASE_P($/;"	p	namespace:folly::io::test	file:	signature:( CompressionTest, CompressionTest, testing::Combine( testing::Values(0, 1, 12, 22, 25, 27), testing::Values(CodecType::NO_COMPRESSION, CodecType::LZ4, CodecType::SNAPPY, CodecType::ZLIB, CodecType::LZ4_VARINT_SIZE, CodecType::LZMA2, CodecType::LZMA2_VARINT_SIZE)))
INT	.\FormatArg.h	/^    INT,$/;"	m	class:folly::FormatArg::NextKeyMode	access:private
INT64	.\dynamic.h	/^    INT64,$/;"	e	enum:folly::dynamic::Type
INTEGER	.\FormatArg.h	/^    INTEGER,$/;"	m	class:folly::FormatArg::Type	access:private
INTERFACE_TYPES	.\test\stl_tests\StlVectorTest.cpp	924;"	d	file:
INTERNAL	.\io\async\TimeoutManager.h	/^    INTERNAL,$/;"	m	class:folly::TimeoutManager::InternalEnum	access:private
INTERRUPTED	.\detail\Futex.h	/^  INTERRUPTED,   \/* Spurious wake-up or signal caused futex wait failure *\/$/;"	m	class:folly::detail::FutexResult	access:private
IOBuf	.\io\IOBuf.cpp	/^IOBuf::IOBuf(CopyBufferOp op, ByteRange br,$/;"	f	class:folly::IOBuf	signature:(CopyBufferOp op, ByteRange br, uint64_t headroom, uint64_t minTailroom)
IOBuf	.\io\IOBuf.cpp	/^IOBuf::IOBuf(CopyBufferOp op, const void* buf, uint64_t size,$/;"	f	class:folly::IOBuf	signature:(CopyBufferOp op, const void* buf, uint64_t size, uint64_t headroom, uint64_t minTailroom)
IOBuf	.\io\IOBuf.cpp	/^IOBuf::IOBuf(CreateOp, uint64_t capacity)$/;"	f	class:folly::IOBuf	signature:(CreateOp, uint64_t capacity)
IOBuf	.\io\IOBuf.cpp	/^IOBuf::IOBuf(InternalConstructor,$/;"	f	class:folly::IOBuf	signature:(InternalConstructor, uintptr_t flagsAndSharedInfo, uint8_t* buf, uint64_t capacity, uint8_t* data, uint64_t length)
IOBuf	.\io\IOBuf.cpp	/^IOBuf::IOBuf(TakeOwnershipOp, void* buf, uint64_t capacity, uint64_t length,$/;"	f	class:folly::IOBuf	signature:(TakeOwnershipOp, void* buf, uint64_t capacity, uint64_t length, FreeFunction freeFn, void* userData, bool freeOnError)
IOBuf	.\io\IOBuf.cpp	/^IOBuf::IOBuf(WrapBufferOp op, ByteRange br)$/;"	f	class:folly::IOBuf	signature:(WrapBufferOp op, ByteRange br)
IOBuf	.\io\IOBuf.cpp	/^IOBuf::IOBuf(WrapBufferOp, const void* buf, uint64_t capacity)$/;"	f	class:folly::IOBuf	signature:(WrapBufferOp, const void* buf, uint64_t capacity)
IOBuf	.\io\IOBuf.h	/^  IOBuf(CopyBufferOp op, ByteRange br,$/;"	p	class:folly::IOBuf	access:public	signature:(CopyBufferOp op, ByteRange br, uint64_t headroom=0, uint64_t minTailroom=0)
IOBuf	.\io\IOBuf.h	/^  IOBuf(CopyBufferOp op, const std::string& buf,$/;"	f	class:folly::IOBuf	access:public	signature:(CopyBufferOp op, const std::string& buf, uint64_t headroom=0, uint64_t minTailroom=0)
IOBuf	.\io\IOBuf.h	/^  IOBuf(CopyBufferOp op, const void* buf, uint64_t size,$/;"	p	class:folly::IOBuf	access:public	signature:(CopyBufferOp op, const void* buf, uint64_t size, uint64_t headroom=0, uint64_t minTailroom=0)
IOBuf	.\io\IOBuf.h	/^  IOBuf(CreateOp, uint64_t capacity);$/;"	p	class:folly::IOBuf	access:public	signature:(CreateOp, uint64_t capacity)
IOBuf	.\io\IOBuf.h	/^  IOBuf(IOBuf const &);$/;"	p	class:folly::IOBuf	access:private	signature:(IOBuf const &)
IOBuf	.\io\IOBuf.h	/^  IOBuf(InternalConstructor, uintptr_t flagsAndSharedInfo,$/;"	p	class:folly::IOBuf	access:private	signature:(InternalConstructor, uintptr_t flagsAndSharedInfo, uint8_t* buf, uint64_t capacity, uint8_t* data, uint64_t length)
IOBuf	.\io\IOBuf.h	/^  IOBuf(TakeOwnershipOp op, void* buf, uint64_t capacity,$/;"	f	class:folly::IOBuf	access:public	signature:(TakeOwnershipOp op, void* buf, uint64_t capacity, FreeFunction freeFn = nullptr, void* userData = nullptr, bool freeOnError = true)
IOBuf	.\io\IOBuf.h	/^  IOBuf(TakeOwnershipOp, void* buf, uint64_t capacity, uint64_t length,$/;"	p	class:folly::IOBuf	access:public	signature:(TakeOwnershipOp, void* buf, uint64_t capacity, uint64_t length, FreeFunction freeFn = nullptr, void* userData = nullptr, bool freeOnError = true)
IOBuf	.\io\IOBuf.h	/^  IOBuf(WrapBufferOp op, ByteRange br);$/;"	p	class:folly::IOBuf	access:public	signature:(WrapBufferOp op, ByteRange br)
IOBuf	.\io\IOBuf.h	/^  IOBuf(WrapBufferOp op, const void* buf, uint64_t capacity);$/;"	p	class:folly::IOBuf	access:public	signature:(WrapBufferOp op, const void* buf, uint64_t capacity)
IOBuf	.\io\IOBuf.h	/^class IOBuf {$/;"	c	namespace:folly
IOBufEqual	.\io\IOBuf.h	/^struct IOBufEqual {$/;"	s	namespace:folly
IOBufHash	.\io\IOBuf.h	/^struct IOBufHash {$/;"	s	namespace:folly
IOBufQueue	.\io\IOBufQueue.cpp	/^IOBufQueue::IOBufQueue(IOBufQueue&& other)$/;"	f	class:folly::IOBufQueue	signature:(IOBufQueue&& other)
IOBufQueue	.\io\IOBufQueue.cpp	/^IOBufQueue::IOBufQueue(const Options& options)$/;"	f	class:folly::IOBufQueue	signature:(const Options& options)
IOBufQueue	.\io\IOBufQueue.h	/^  IOBufQueue(IOBufQueue&&);$/;"	p	class:folly::IOBufQueue	access:public	signature:(IOBufQueue&&)
IOBufQueue	.\io\IOBufQueue.h	/^  IOBufQueue(const IOBufQueue&) = delete;$/;"	p	class:folly::IOBufQueue	access:private	signature:(const IOBufQueue&)
IOBufQueue	.\io\IOBufQueue.h	/^  explicit IOBufQueue(const Options& options = Options());$/;"	p	class:folly::IOBufQueue	access:public	signature:(const Options& options = Options())
IOBufQueue	.\io\IOBufQueue.h	/^class IOBufQueue {$/;"	c	namespace:folly
IOBufSnappySource	.\io\Compression.cpp	/^  explicit IOBufSnappySource(const IOBuf* data);$/;"	p	class:folly::io::__anon64::FOLLY_FINAL	file:	access:public	signature:(const IOBuf* data)
IOBufSnappySource	.\io\Compression.cpp	/^IOBufSnappySource::IOBufSnappySource(const IOBuf* data)$/;"	f	class:folly::io::__anon64::IOBufSnappySource	signature:(const IOBuf* data)
IOThread	.\experimental\wangle\concurrent\IOThreadPoolExecutor.h	/^    IOThread() : shouldRun(true), outstandingTasks(0) {};$/;"	f	struct:folly::wangle::IOThreadPoolExecutor::IOThread	access:public	signature:()
IOThread	.\experimental\wangle\concurrent\IOThreadPoolExecutor.h	/^  struct FOLLY_ALIGN_TO_AVOID_FALSE_SHARING IOThread : public Thread {$/;"	s	class:folly::wangle::IOThreadPoolExecutor	inherits:Thread	access:private
IOThreadPoolExecutor	.\experimental\wangle\concurrent\IOThreadPoolExecutor.cpp	/^IOThreadPoolExecutor::IOThreadPoolExecutor($/;"	f	class:folly::wangle::IOThreadPoolExecutor	signature:( size_t numThreads, std::unique_ptr<ThreadFactory> threadFactory)
IOThreadPoolExecutor	.\experimental\wangle\concurrent\IOThreadPoolExecutor.h	/^  explicit IOThreadPoolExecutor($/;"	p	class:folly::wangle::IOThreadPoolExecutor	access:public	signature:( size_t numThreads, std::unique_ptr<ThreadFactory> threadFactory = folly::make_unique<NamedThreadFactory>())
IOThreadPoolExecutor	.\experimental\wangle\concurrent\IOThreadPoolExecutor.h	/^class IOThreadPoolExecutor : public ThreadPoolExecutor {$/;"	c	namespace:folly::wangle	inherits:ThreadPoolExecutor
IPAddress	.\IPAddress.cpp	/^IPAddress::IPAddress()$/;"	f	class:folly::IPAddress	signature:()
IPAddress	.\IPAddress.cpp	/^IPAddress::IPAddress(StringPiece addr)$/;"	f	class:folly::IPAddress	signature:(StringPiece addr)
IPAddress	.\IPAddress.cpp	/^IPAddress::IPAddress(const IPAddressV4 ipV4Addr)$/;"	f	class:folly::IPAddress	signature:(const IPAddressV4 ipV4Addr)
IPAddress	.\IPAddress.cpp	/^IPAddress::IPAddress(const IPAddressV6& ipV6Addr)$/;"	f	class:folly::IPAddress	signature:(const IPAddressV6& ipV6Addr)
IPAddress	.\IPAddress.cpp	/^IPAddress::IPAddress(const in6_addr& ipV6Addr)$/;"	f	class:folly::IPAddress	signature:(const in6_addr& ipV6Addr)
IPAddress	.\IPAddress.cpp	/^IPAddress::IPAddress(const in_addr ipV4Addr)$/;"	f	class:folly::IPAddress	signature:(const in_addr ipV4Addr)
IPAddress	.\IPAddress.cpp	/^IPAddress::IPAddress(const sockaddr* addr)$/;"	f	class:folly::IPAddress	signature:(const sockaddr* addr)
IPAddress	.\IPAddress.h	/^  IPAddress();$/;"	p	class:folly::IPAddress	access:public	signature:()
IPAddress	.\IPAddress.h	/^  \/* implicit *\/ IPAddress(const IPAddressV4 ipV4Addr);$/;"	p	class:folly::IPAddress	access:public	signature:(const IPAddressV4 ipV4Addr)
IPAddress	.\IPAddress.h	/^  \/* implicit *\/ IPAddress(const IPAddressV6& ipV6Addr);$/;"	p	class:folly::IPAddress	access:public	signature:(const IPAddressV6& ipV6Addr)
IPAddress	.\IPAddress.h	/^  \/* implicit *\/ IPAddress(const in6_addr& addr);$/;"	p	class:folly::IPAddress	access:public	signature:(const in6_addr& addr)
IPAddress	.\IPAddress.h	/^  \/* implicit *\/ IPAddress(const in_addr addr);$/;"	p	class:folly::IPAddress	access:public	signature:(const in_addr addr)
IPAddress	.\IPAddress.h	/^  explicit IPAddress(StringPiece ip);$/;"	p	class:folly::IPAddress	access:public	signature:(StringPiece ip)
IPAddress	.\IPAddress.h	/^  explicit IPAddress(const sockaddr* addr);$/;"	p	class:folly::IPAddress	access:public	signature:(const sockaddr* addr)
IPAddress	.\IPAddress.h	/^class IPAddress : boost::totally_ordered<IPAddress> {$/;"	c	namespace:folly	inherits:boost::totally_ordered
IPAddress	.\IPAddress.h	/^class IPAddress;$/;"	x
IPAddress	.\IPAddressV4.h	/^class IPAddress;$/;"	x
IPAddress	.\IPAddressV6.h	/^class IPAddress;$/;"	x
IPAddress	.\test\IPAddressTest.h	/^class IPAddress;$/;"	x
IPAddressBitAccessorTest	.\test\IPAddressTest.h	/^struct IPAddressBitAccessorTest:$/;"	s	namespace:folly	inherits:::testing::TestWithParam
IPAddressByteAccessorTest	.\test\IPAddressTest.h	/^struct IPAddressByteAccessorTest:$/;"	s	namespace:folly	inherits:::testing::TestWithParam
IPAddressCtorBinaryTest	.\test\IPAddressTest.h	/^struct IPAddressCtorBinaryTest : public ::testing::TestWithParam<ByteVector> {};$/;"	s	namespace:folly	inherits:::testing::TestWithParam
IPAddressCtorTest	.\test\IPAddressTest.h	/^struct IPAddressCtorTest : public ::testing::TestWithParam<std::string> {};$/;"	s	namespace:folly	inherits:::testing::TestWithParam
IPAddressFlagTest	.\test\IPAddressTest.h	/^struct IPAddressFlagTest : public ::testing::TestWithParam<AddressFlags> {};$/;"	s	namespace:folly	inherits:::testing::TestWithParam
IPAddressFormatException	.\IPAddressException.h	/^  explicit IPAddressFormatException(Args&&... args)$/;"	f	class:folly::IPAddressFormatException	access:public	signature:(Args&&.... args)
IPAddressFormatException	.\IPAddressException.h	/^  explicit IPAddressFormatException(const std::string& msg)$/;"	f	class:folly::IPAddressFormatException	access:public	signature:(const std::string& msg)
IPAddressFormatException	.\IPAddressException.h	/^class IPAddressFormatException : public std::exception {$/;"	c	namespace:folly	inherits:std::exception
IPAddressMappedTest	.\test\IPAddressTest.h	/^struct IPAddressMappedTest :$/;"	s	namespace:folly	inherits:::testing::TestWithParam
IPAddressMaskBoundaryTest	.\test\IPAddressTest.h	/^struct IPAddressMaskBoundaryTest :$/;"	s	namespace:folly	inherits:::testing::TestWithParam
IPAddressMaskTest	.\test\IPAddressTest.h	/^struct IPAddressMaskTest : public ::testing::TestWithParam<MaskData> {};$/;"	s	namespace:folly	inherits:::testing::TestWithParam
IPAddressSerializeTest	.\test\IPAddressTest.h	/^struct IPAddressSerializeTest :$/;"	s	namespace:folly	inherits:::testing::TestWithParam
IPAddressTest	.\test\IPAddressTest.h	/^struct IPAddressTest : public ::testing::TestWithParam<AddressData> {$/;"	s	namespace:folly	inherits:::testing::TestWithParam
IPAddressV4	.\IPAddressV4.cpp	/^IPAddressV4::IPAddressV4() {$/;"	f	class:folly::IPAddressV4	signature:()
IPAddressV4	.\IPAddressV4.cpp	/^IPAddressV4::IPAddressV4(StringPiece addr)$/;"	f	class:folly::IPAddressV4	signature:(StringPiece addr)
IPAddressV4	.\IPAddressV4.cpp	/^IPAddressV4::IPAddressV4(const ByteArray4& src)$/;"	f	class:folly::IPAddressV4	signature:(const ByteArray4& src)
IPAddressV4	.\IPAddressV4.cpp	/^IPAddressV4::IPAddressV4(const in_addr src)$/;"	f	class:folly::IPAddressV4	signature:(const in_addr src)
IPAddressV4	.\IPAddressV4.h	/^  IPAddressV4();$/;"	p	class:folly::IPAddressV4	access:public	signature:()
IPAddressV4	.\IPAddressV4.h	/^  explicit IPAddressV4(StringPiece ip);$/;"	p	class:folly::IPAddressV4	access:public	signature:(StringPiece ip)
IPAddressV4	.\IPAddressV4.h	/^  explicit IPAddressV4(const ByteArray4& src);$/;"	p	class:folly::IPAddressV4	access:public	signature:(const ByteArray4& src)
IPAddressV4	.\IPAddressV4.h	/^  explicit IPAddressV4(const in_addr src);$/;"	p	class:folly::IPAddressV4	access:public	signature:(const in_addr src)
IPAddressV4	.\IPAddressV4.h	/^class IPAddressV4 : boost::totally_ordered<IPAddressV4> {$/;"	c	namespace:folly	inherits:boost::totally_ordered
IPAddressV4	.\IPAddressV4.h	/^class IPAddressV4;$/;"	x
IPAddressV4	.\IPAddressV6.h	/^class IPAddressV4;$/;"	x
IPAddressV46	.\IPAddress.h	/^    IPAddressV46() {$/;"	f	union:folly::IPAddress::IPAddressV46	access:public	signature:()
IPAddressV46	.\IPAddress.h	/^    explicit IPAddressV46(const IPAddressV4& addr): ipV4Addr(addr) {}$/;"	f	union:folly::IPAddress::IPAddressV46	access:public	signature:(const IPAddressV4& addr)
IPAddressV46	.\IPAddress.h	/^    explicit IPAddressV46(const IPAddressV6& addr): ipV6Addr(addr) {}$/;"	f	union:folly::IPAddress::IPAddressV46	access:public	signature:(const IPAddressV6& addr)
IPAddressV46	.\IPAddress.h	/^  typedef union IPAddressV46 {$/;"	u	class:folly::IPAddress	access:private
IPAddressV46	.\IPAddress.h	/^  } IPAddressV46;$/;"	t	class:folly::IPAddress	typeref:union:folly::IPAddress::IPAddressV46	access:private
IPAddressV6	.\IPAddressV4.h	/^class IPAddressV6;$/;"	x
IPAddressV6	.\IPAddressV6.cpp	/^IPAddressV6::IPAddressV6() {$/;"	f	class:folly::IPAddressV6	signature:()
IPAddressV6	.\IPAddressV6.cpp	/^IPAddressV6::IPAddressV6(LinkLocalTag, MacAddress mac)$/;"	f	class:folly::IPAddressV6	signature:(LinkLocalTag, MacAddress mac)
IPAddressV6	.\IPAddressV6.cpp	/^IPAddressV6::IPAddressV6(StringPiece addr) {$/;"	f	class:folly::IPAddressV6	signature:(StringPiece addr)
IPAddressV6	.\IPAddressV6.cpp	/^IPAddressV6::IPAddressV6(const ByteArray16& src)$/;"	f	class:folly::IPAddressV6	signature:(const ByteArray16& src)
IPAddressV6	.\IPAddressV6.cpp	/^IPAddressV6::IPAddressV6(const in6_addr& src)$/;"	f	class:folly::IPAddressV6	signature:(const in6_addr& src)
IPAddressV6	.\IPAddressV6.cpp	/^IPAddressV6::IPAddressV6(const sockaddr_in6& src)$/;"	f	class:folly::IPAddressV6	signature:(const sockaddr_in6& src)
IPAddressV6	.\IPAddressV6.h	/^  IPAddressV6();$/;"	p	class:folly::IPAddressV6	access:public	signature:()
IPAddressV6	.\IPAddressV6.h	/^  IPAddressV6(LinkLocalTag tag, MacAddress mac);$/;"	p	class:folly::IPAddressV6	access:public	signature:(LinkLocalTag tag, MacAddress mac)
IPAddressV6	.\IPAddressV6.h	/^  explicit IPAddressV6(StringPiece ip);$/;"	p	class:folly::IPAddressV6	access:public	signature:(StringPiece ip)
IPAddressV6	.\IPAddressV6.h	/^  explicit IPAddressV6(const ByteArray16& src);$/;"	p	class:folly::IPAddressV6	access:public	signature:(const ByteArray16& src)
IPAddressV6	.\IPAddressV6.h	/^  explicit IPAddressV6(const in6_addr& src);$/;"	p	class:folly::IPAddressV6	access:public	signature:(const in6_addr& src)
IPAddressV6	.\IPAddressV6.h	/^  explicit IPAddressV6(const sockaddr_in6& src);$/;"	p	class:folly::IPAddressV6	access:public	signature:(const sockaddr_in6& src)
IPAddressV6	.\IPAddressV6.h	/^class IPAddressV6 : boost::totally_ordered<IPAddressV6> {$/;"	c	namespace:folly	inherits:boost::totally_ordered
IPAddressV6	.\IPAddressV6.h	/^class IPAddressV6;$/;"	x
IPAddressV6	.\MacAddress.h	/^class IPAddressV6;$/;"	x
IS_HEAD_NODE	.\ConcurrentSkipList-inl.h	/^    IS_HEAD_NODE = 1,$/;"	e	enum:folly::detail::SkipListNode::__anon5
IS_LINK_LOCAL	.\test\IPAddressTest.cpp	/^static const uint8_t IS_LINK_LOCAL =$/;"	v	file:
IS_LINK_LOCAL	.\test\IPAddressTest.h	/^  static const uint8_t IS_LINK_LOCAL = 1 << 4;$/;"	m	struct:folly::AddressFlags	access:public
IS_LINK_LOCAL_BROADCAST	.\test\IPAddressTest.cpp	/^static const uint8_t IS_LINK_LOCAL_BROADCAST =$/;"	v	file:
IS_LINK_LOCAL_BROADCAST	.\test\IPAddressTest.h	/^  static const uint8_t IS_LINK_LOCAL_BROADCAST = 1 << 6;$/;"	m	struct:folly::AddressFlags	access:public
IS_LOCAL	.\test\IPAddressTest.cpp	/^static const uint8_t IS_LOCAL = AddressFlags::IS_LOCAL;$/;"	v	file:
IS_LOCAL	.\test\IPAddressTest.h	/^  static const uint8_t IS_LOCAL = 1 << 0;$/;"	m	struct:folly::AddressFlags	access:public
IS_MULTICAST	.\test\IPAddressTest.cpp	/^static const uint8_t IS_MULTICAST = AddressFlags::IS_MULTICAST;$/;"	v	file:
IS_MULTICAST	.\test\IPAddressTest.h	/^  static const uint8_t IS_MULTICAST = 1 << 5;$/;"	m	struct:folly::AddressFlags	access:public
IS_NONROUTABLE	.\test\IPAddressTest.cpp	/^static const uint8_t IS_NONROUTABLE = AddressFlags::IS_NONROUTABLE;$/;"	v	file:
IS_NONROUTABLE	.\test\IPAddressTest.h	/^  static const uint8_t IS_NONROUTABLE = 1 << 1;$/;"	m	struct:folly::AddressFlags	access:public
IS_PRIVATE	.\test\IPAddressTest.cpp	/^static const uint8_t IS_PRIVATE = AddressFlags::IS_PRIVATE;$/;"	v	file:
IS_PRIVATE	.\test\IPAddressTest.h	/^  static const uint8_t IS_PRIVATE = 1 << 2;$/;"	m	struct:folly::AddressFlags	access:public
IS_PVT_NONROUTE	.\test\IPAddressTest.cpp	/^static const uint8_t IS_PVT_NONROUTE = IS_NONROUTABLE | IS_PRIVATE;$/;"	v	file:
IS_RELOCATABLE	.\test\stl_tests\StlVectorTest.cpp	/^  IS_RELOCATABLE$/;"	e	enum:Flags	file:
IS_ZERO	.\test\IPAddressTest.cpp	/^static const uint8_t IS_ZERO = AddressFlags::IS_ZERO;$/;"	v	file:
IS_ZERO	.\test\IPAddressTest.h	/^  static const uint8_t IS_ZERO = 1 << 3;$/;"	m	struct:folly::AddressFlags	access:public
Id	.\TimeoutQueue.h	/^  typedef int64_t Id;$/;"	t	class:folly::TimeoutQueue	access:public
Identity	.\gen\Base.h	/^class Identity {$/;"	c	namespace:folly::gen
Impl	.\FBVector.h	/^    Impl() : Allocator(), b_(nullptr), e_(nullptr), z_(nullptr) {}$/;"	f	struct:folly::fbvector::Impl	access:public	signature:()
Impl	.\FBVector.h	/^    \/* implicit *\/ Impl(Allocator&& a)$/;"	f	struct:folly::fbvector::Impl	access:public	signature:(Allocator&& a)
Impl	.\FBVector.h	/^    \/* implicit *\/ Impl(const Allocator& a)$/;"	f	struct:folly::fbvector::Impl	access:public	signature:(const Allocator& a)
Impl	.\FBVector.h	/^    \/* implicit *\/ Impl(size_type n, const Allocator& a = Allocator())$/;"	f	struct:folly::fbvector::Impl	access:public	signature:(size_type n, const Allocator& a = Allocator())
Impl	.\FBVector.h	/^  struct Impl : public Allocator {$/;"	s	class:folly::fbvector	inherits:Allocator	access:private
Implementations	.\test\RWSpinLockTest.cpp	/^> Implementations;$/;"	t	namespace:__anon130	file:
InQueue	.\gen\Parallel-inl.h	/^    typedef ClosableMPMCQueue<InputDecayed> InQueue;$/;"	t	class:folly::gen::detail::Parallel::Generator	access:private
IncompleteType	.\test\TraitsTest.cpp	/^struct IncompleteType;$/;"	x	file:
IndexedMemPool	.\IndexedMemPool.h	/^  explicit IndexedMemPool(uint32_t capacity)$/;"	f	struct:folly::IndexedMemPool	access:public	signature:(uint32_t capacity)
IndexedMemPool	.\IndexedMemPool.h	/^struct IndexedMemPool : boost::noncopyable {$/;"	s	namespace:folly	inherits:boost::noncopyable
IndexedMemPoolRecycler	.\IndexedMemPool.h	/^  explicit IndexedMemPoolRecycler(Pool* pool) : pool(pool) {}$/;"	f	struct:detail::IndexedMemPoolRecycler	access:public	signature:(Pool* pool)
IndexedMemPoolRecycler	.\IndexedMemPool.h	/^struct IndexedMemPoolRecycler {$/;"	s	namespace:detail
IndexedMemPoolRecycler	.\IndexedMemPool.h	/^struct IndexedMemPoolRecycler;$/;"	x
InfiniteImpl	.\gen\Base-inl.h	/^class InfiniteImpl {$/;"	c	namespace:folly::gen::detail
InfiniteImpl	.\gen\Base.h	/^class InfiniteImpl;$/;"	x
Init	.\SpookyHashV1.cpp	/^void SpookyHashV1::Init(uint64_t seed1, uint64_t seed2)$/;"	f	class:folly::hash::SpookyHashV1	signature:(uint64_t seed1, uint64_t seed2)
Init	.\SpookyHashV1.h	/^    void Init($/;"	p	class:folly::hash::SpookyHashV1	access:public	signature:( uint64_t seed1, uint64_t seed2)
Init	.\SpookyHashV2.cpp	/^void SpookyHashV2::Init(uint64_t seed1, uint64_t seed2)$/;"	f	class:folly::hash::SpookyHashV2	signature:(uint64_t seed1, uint64_t seed2)
Init	.\SpookyHashV2.h	/^    void Init($/;"	p	class:folly::hash::SpookyHashV2	access:public	signature:( uint64_t seed1, uint64_t seed2)
Init	.\test\SpookyHashV1Test.cpp	/^    inline void Init( uint64_t seed)$/;"	f	class:Random	access:public	signature:( uint64_t seed)
Init	.\test\SpookyHashV2Test.cpp	/^    inline void Init( uint64_t seed)$/;"	f	class:Random	access:public	signature:( uint64_t seed)
InitFlags	.\MemoryMapping.h	/^  enum InitFlags {$/;"	g	class:folly::MemoryMapping	access:private
Initializer	.\Subprocess.cpp	/^  Initializer() {$/;"	f	class:folly::__anon100::Initializer	access:public	signature:()
Initializer	.\Subprocess.cpp	/^class Initializer {$/;"	c	namespace:folly::__anon100	file:
Initializer	.\experimental\exception_tracer\ExceptionTracerLib.cpp	/^  Initializer() {$/;"	f	struct:__anon27::Initializer	access:public	signature:()
Initializer	.\experimental\exception_tracer\ExceptionTracerLib.cpp	/^struct Initializer {$/;"	s	namespace:__anon27	file:
Initializer	.\io\test\IOBufQueueTest.cpp	/^  Initializer() {$/;"	f	struct:__anon70::Initializer	access:public	signature:()
Initializer	.\io\test\IOBufQueueTest.cpp	/^struct Initializer {$/;"	s	namespace:__anon70	file:
InlineExecutor	.\wangle\InlineExecutor.h	/^  class InlineExecutor : public Executor {$/;"	c	namespace:folly::wangle	inherits:Executor
InlineStorageType	.\small_vector.h	/^  >::type InlineStorageType;$/;"	t	class:folly::small_vector	access:private
InlineStorageType	.\small_vector.h	/^  typedef unsigned char InlineStorageType[sizeof(value_type) * MaxInline];$/;"	t	class:folly::small_vector	access:private
Input	.\json.cpp	/^  Input(Input const&) = delete;$/;"	p	struct:folly::json::__anon75::Input	file:	access:public	signature:(Input const&)
Input	.\json.cpp	/^  explicit Input(StringPiece range, json::serialization_opts const* opts)$/;"	f	struct:folly::json::__anon75::Input	access:public	signature:(StringPiece range, json::serialization_opts const* opts)
Input	.\json.cpp	/^struct Input {$/;"	s	namespace:folly::json::__anon75	file:
IntAdaptor	.\test\PaddedTest.cpp	/^  typedef padded::Adaptor<IntNodeVec> IntAdaptor;$/;"	t	class:IntAdaptorTest	file:	access:protected
IntAdaptorTest	.\test\PaddedTest.cpp	/^class IntAdaptorTest : public IntPaddedConstTest {$/;"	c	file:	inherits:IntPaddedConstTest
IntAdaptorTest::IntAdaptor	.\test\PaddedTest.cpp	/^  typedef padded::Adaptor<IntNodeVec> IntAdaptor;$/;"	t	class:IntAdaptorTest	file:	access:protected
IntAdaptorTest::a_	.\test\PaddedTest.cpp	/^  IntAdaptor a_;$/;"	m	class:IntAdaptorTest	file:	access:protected
IntCache	.\ThreadCachedInt.h	/^    explicit IntCache(ThreadCachedInt& parent)$/;"	f	struct:folly::ThreadCachedInt::IntCache	access:public	signature:(ThreadCachedInt& parent)
IntCache	.\ThreadCachedInt.h	/^  struct IntCache {$/;"	s	class:folly::ThreadCachedInt	access:private
IntCache	.\ThreadCachedInt.h	/^  struct IntCache;$/;"	x
IntException	.\test\ExceptionWrapperTest.cpp	/^  explicit IntException(int i)$/;"	f	class:IntException	access:public	signature:(int i)
IntException	.\test\ExceptionWrapperTest.cpp	/^class IntException : public AbstractIntException {$/;"	c	file:	inherits:AbstractIntException
IntException::IntException	.\test\ExceptionWrapperTest.cpp	/^  explicit IntException(int i)$/;"	f	class:IntException	access:public	signature:(int i)
IntException::getInt	.\test\ExceptionWrapperTest.cpp	/^  virtual int getInt() const { return i_; }$/;"	f	class:IntException	access:public	signature:() const
IntException::i_	.\test\ExceptionWrapperTest.cpp	/^  int i_;$/;"	m	class:IntException	file:	access:private
IntException::what_	.\test\ExceptionWrapperTest.cpp	/^  mutable std::string what_;$/;"	m	class:IntException	file:	access:private
IntFBVector	.\test\FBVectorBenchmark.cpp	/^typedef fbvector<int> IntFBVector;$/;"	t	file:
IntMHTS	.\test\TimeseriesHistogramTest.cpp	/^namespace IntMHTS {$/;"	n	file:
IntMHTS	.\test\TimeseriesTest.cpp	/^namespace IntMHTS {$/;"	n	file:
IntMHTS::ALLTIME	.\test\TimeseriesHistogramTest.cpp	/^    ALLTIME,$/;"	e	enum:IntMHTS::Levels	file:
IntMHTS::ALLTIME	.\test\TimeseriesTest.cpp	/^    ALLTIME,$/;"	e	enum:IntMHTS::Levels	file:
IntMHTS::HOUR	.\test\TimeseriesHistogramTest.cpp	/^    HOUR,$/;"	e	enum:IntMHTS::Levels	file:
IntMHTS::HOUR	.\test\TimeseriesTest.cpp	/^    HOUR,$/;"	e	enum:IntMHTS::Levels	file:
IntMHTS::Levels	.\test\TimeseriesHistogramTest.cpp	/^  enum Levels {$/;"	g	namespace:IntMHTS	file:
IntMHTS::Levels	.\test\TimeseriesTest.cpp	/^  enum Levels {$/;"	g	namespace:IntMHTS	file:
IntMHTS::MINUTE	.\test\TimeseriesHistogramTest.cpp	/^    MINUTE,$/;"	e	enum:IntMHTS::Levels	file:
IntMHTS::MINUTE	.\test\TimeseriesTest.cpp	/^    MINUTE,$/;"	e	enum:IntMHTS::Levels	file:
IntMHTS::NUM_LEVELS	.\test\TimeseriesHistogramTest.cpp	/^    NUM_LEVELS,$/;"	e	enum:IntMHTS::Levels	file:
IntMHTS::NUM_LEVELS	.\test\TimeseriesTest.cpp	/^    NUM_LEVELS,$/;"	e	enum:IntMHTS::Levels	file:
IntMHTS::kDurations	.\test\TimeseriesHistogramTest.cpp	/^  const seconds kDurations[] = {$/;"	m	namespace:IntMHTS	file:
IntMHTS::kMinuteHourDurations	.\test\TimeseriesTest.cpp	/^  const seconds kMinuteHourDurations[] = {$/;"	m	namespace:IntMHTS	file:
IntMTMHTS	.\test\TimeseriesHistogramTest.cpp	/^namespace IntMTMHTS {$/;"	n	file:
IntMTMHTS::ALLTIME	.\test\TimeseriesHistogramTest.cpp	/^    ALLTIME,$/;"	e	enum:IntMTMHTS::Levels	file:
IntMTMHTS::HOUR	.\test\TimeseriesHistogramTest.cpp	/^    HOUR,$/;"	e	enum:IntMTMHTS::Levels	file:
IntMTMHTS::Levels	.\test\TimeseriesHistogramTest.cpp	/^  enum Levels {$/;"	g	namespace:IntMTMHTS	file:
IntMTMHTS::MINUTE	.\test\TimeseriesHistogramTest.cpp	/^    MINUTE,$/;"	e	enum:IntMTMHTS::Levels	file:
IntMTMHTS::NUM_LEVELS	.\test\TimeseriesHistogramTest.cpp	/^    NUM_LEVELS,$/;"	e	enum:IntMTMHTS::Levels	file:
IntMTMHTS::TEN_MINUTE	.\test\TimeseriesHistogramTest.cpp	/^    TEN_MINUTE,$/;"	e	enum:IntMTMHTS::Levels	file:
IntMTMHTS::kDurations	.\test\TimeseriesHistogramTest.cpp	/^  const seconds kDurations[] = {$/;"	m	namespace:IntMTMHTS	file:
IntNode	.\test\PaddedTest.cpp	/^  typedef padded::Node<uint32_t, 64> IntNode;$/;"	t	class:IntPaddedTestBase	file:	access:protected
IntNodeVec	.\test\PaddedTest.cpp	/^  typedef std::vector<IntNode> IntNodeVec;$/;"	t	class:IntPaddedTestBase	file:	access:protected
IntPaddedConstTest	.\test\PaddedTest.cpp	/^class IntPaddedConstTest : public IntPaddedTestBase {$/;"	c	file:	inherits:IntPaddedTestBase
IntPaddedConstTest::SetUp	.\test\PaddedTest.cpp	/^  void SetUp() {$/;"	f	class:IntPaddedConstTest	access:protected	signature:()
IntPaddedNonConstTest	.\test\PaddedTest.cpp	/^class IntPaddedNonConstTest : public IntPaddedTestBase {$/;"	c	file:	inherits:IntPaddedTestBase
IntPaddedTestBase	.\test\PaddedTest.cpp	/^class IntPaddedTestBase : public ::testing::Test {$/;"	c	file:	inherits:::testing::Test
IntPaddedTestBase::IntNode	.\test\PaddedTest.cpp	/^  typedef padded::Node<uint32_t, 64> IntNode;$/;"	t	class:IntPaddedTestBase	file:	access:protected
IntPaddedTestBase::IntNodeVec	.\test\PaddedTest.cpp	/^  typedef std::vector<IntNode> IntNodeVec;$/;"	t	class:IntPaddedTestBase	file:	access:protected
IntPaddedTestBase::n_	.\test\PaddedTest.cpp	/^  int n_;$/;"	m	class:IntPaddedTestBase	file:	access:protected
IntPaddedTestBase::v_	.\test\PaddedTest.cpp	/^  IntNodeVec v_;$/;"	m	class:IntPaddedTestBase	file:	access:protected
IntTraitType	.\RWSpinLock.h	/^  typedef detail::RWTicketIntTrait<kBitWidth> IntTraitType;$/;"	t	class:folly::RWTicketSpinLockT	access:private
IntVector	.\test\FBVectorBenchmark.cpp	/^typedef vector<int> IntVector;$/;"	t	file:
Integer	.\test\AtomicHashMapTest.cpp	/^  explicit Integer(KeyT v = 0) : v_(v) {}$/;"	f	class:Integer	access:public	signature:(KeyT v = 0)
Integer	.\test\AtomicHashMapTest.cpp	/^class Integer {$/;"	c	file:
Integer::Integer	.\test\AtomicHashMapTest.cpp	/^  explicit Integer(KeyT v = 0) : v_(v) {}$/;"	f	class:Integer	access:public	signature:(KeyT v = 0)
Integer::operator =	.\test\AtomicHashMapTest.cpp	/^  Integer& operator=(const Integer& a) {$/;"	f	class:Integer	access:public	signature:(const Integer& a)
Integer::operator ==	.\test\AtomicHashMapTest.cpp	/^  bool operator==(const Integer& a) const { return v_ == a.v_; }$/;"	f	class:Integer	access:public	signature:(const Integer& a) const
Integer::v_	.\test\AtomicHashMapTest.cpp	/^  KeyT v_;$/;"	m	class:Integer	file:	access:private
IntegralSizePolicy	.\small_vector.h	/^    IntegralSizePolicy() : size_(0) {}$/;"	f	struct:folly::detail::IntegralSizePolicy	access:public	signature:()
IntegralSizePolicy	.\small_vector.h	/^  struct IntegralSizePolicy {$/;"	s	namespace:folly::detail
Integrals	.\small_vector.h	/^    >::type Integrals;$/;"	t	struct:folly::detail::small_vector_base	access:public
Interleave	.\gen\Combine-inl.h	/^  explicit Interleave(Container container)$/;"	f	class:folly::gen::detail::Interleave	access:public	signature:(Container container)
Interleave	.\gen\Combine-inl.h	/^class Interleave : public Operator<Interleave<Container>> {$/;"	c	namespace:folly::gen::detail	inherits:Operator
Interleave	.\gen\Combine.h	/^class Interleave;$/;"	x
InternalConstructor	.\io\IOBuf.h	/^  struct InternalConstructor {};  \/\/ avoid conflicts$/;"	s	class:folly::IOBuf	access:private
InternalDoNotUse	.\Synchronized.h	/^enum InternalDoNotUse {};$/;"	g	namespace:folly::detail
InternalEnum	.\io\async\AsyncTimeout.h	/^  typedef TimeoutManager::InternalEnum InternalEnum;$/;"	t	class:folly::AsyncTimeout	access:public
InternalEnum	.\io\async\TimeoutManager.h	/^  enum class InternalEnum {$/;"	c	class:folly::TimeoutManager	access:public
InternalSizeType	.\small_vector.h	/^    typedef SizeType InternalSizeType;$/;"	t	struct:folly::detail::IntegralSizePolicy	access:public
InternalSizeType	.\small_vector.h	/^  typedef typename BaseType::InternalSizeType InternalSizeType;$/;"	t	class:folly::small_vector	access:private
IntrusiveList	.\IntrusiveList.h	/^class IntrusiveList : public boost::intrusive::list<$/;"	c	namespace:folly	inherits:boost::intrusive::list
IntrusiveListHook	.\IntrusiveList.h	/^        IntrusiveListHook;$/;"	t	namespace:folly
InvalidAddressFamilyException	.\IPAddressException.h	/^  explicit InvalidAddressFamilyException(Args&&... args)$/;"	f	class:folly::InvalidAddressFamilyException	access:public	signature:(Args&&.... args)
InvalidAddressFamilyException	.\IPAddressException.h	/^  explicit InvalidAddressFamilyException(const std::string& msg)$/;"	f	class:folly::InvalidAddressFamilyException	access:public	signature:(const std::string& msg)
InvalidAddressFamilyException	.\IPAddressException.h	/^  explicit InvalidAddressFamilyException(sa_family_t family)$/;"	f	class:folly::InvalidAddressFamilyException	access:public	signature:(sa_family_t family)
InvalidAddressFamilyException	.\IPAddressException.h	/^class InvalidAddressFamilyException : public IPAddressFormatException {$/;"	c	namespace:folly	inherits:IPAddressFormatException
IovecBuffers	.\test\FileUtilTest.cpp	/^  explicit IovecBuffers(std::initializer_list<size_t> sizes);$/;"	p	class:folly::test::IovecBuffers	file:	access:public	signature:(std::initializer_list<size_t> sizes)
IovecBuffers	.\test\FileUtilTest.cpp	/^IovecBuffers::IovecBuffers(std::initializer_list<size_t> sizes) {$/;"	f	class:folly::test::IovecBuffers	signature:(std::initializer_list<size_t> sizes)
IovecBuffers	.\test\FileUtilTest.cpp	/^class IovecBuffers {$/;"	c	namespace:folly::test	file:
IsArenaAllocator	.\Arena.h	/^struct IsArenaAllocator<Arena<Alloc>> : std::true_type { };$/;"	s	namespace:folly	inherits:std::true_type
IsArenaAllocator	.\Arena.h	/^struct IsArenaAllocator<SysArena> : std::true_type { };$/;"	s	namespace:folly	inherits:std::true_type
IsArenaAllocator	.\Memory.h	/^template <class T> struct IsArenaAllocator : std::false_type { };$/;"	s	namespace:folly	inherits:std::false_type
IsArenaAllocator	.\ThreadCachedArena.h	/^struct IsArenaAllocator<ThreadCachedArena> : std::true_type { };$/;"	s	namespace:folly	inherits:std::true_type
IsCompatibleSignature	.\gen\Core-inl.h	/^class IsCompatibleSignature {$/;"	c	namespace:folly::gen
IsCompatibleSignature	.\gen\Core-inl.h	/^class IsCompatibleSignature<Candidate, ExpectedReturn(ArgTypes...)> {$/;"	c	namespace:folly::gen
IsFormatter	.\Format.h	/^  typedef detail::FormatterTag IsFormatter;$/;"	t	class:folly::BaseFormatter	access:public
IsNodeIdxShift	.\LifoSem.h	/^    IsNodeIdxShift = 32,$/;"	e	enum:folly::detail::LifoSemHead::__anon76
IsOneOf	.\Traits.h	/^struct IsOneOf {$/;"	s	namespace:folly
IsOneOf	.\Traits.h	/^struct IsOneOf<T, T1, Ts...> {$/;"	s	namespace:folly
IsRelocatable	.\Traits.h	/^struct IsRelocatable<  std::pair<T, U> >$/;"	s	namespace:folly	inherits:::boost::mpl::and_
IsRelocatable	.\Traits.h	/^template <class T> struct IsRelocatable$/;"	s	namespace:folly	inherits:std::integral_constant
IsRelocatable	.\test\MPMCQueueTest.cpp	/^  typedef R IsRelocatable;$/;"	t	struct:Lifecycle	file:	access:public
IsRelocatable	.\test\TraitsTest.cpp	/^  template <> struct IsRelocatable<T1> : std::true_type {};$/;"	s	namespace:folly	file:	inherits:std::true_type
IsRelocatable	.\test\TraitsTest.cpp	/^struct F2 { typedef int IsRelocatable; };$/;"	t	struct:F2	file:	access:public
IsRelocatable	.\test\TraitsTest.cpp	/^struct F3 : T3 { typedef std::false_type IsRelocatable; };$/;"	t	struct:F3	file:	access:public
IsRelocatable	.\test\TraitsTest.cpp	/^struct T3 { typedef std::true_type IsRelocatable; };$/;"	t	struct:T3	file:	access:public
IsRelocatable	.\test\stl_tests\StlVectorTest.cpp	/^struct IsRelocatable<Data<f, pad>>$/;"	s	namespace:folly	file:	inherits:std::integral_constant
IsSameType	.\detail\DiscriminatedPtrDetail.h	/^struct IsSameType;$/;"	x
IsSameType	.\detail\DiscriminatedPtrDetail.h	/^struct IsSameType<> {$/;"	s	namespace:folly::dptr_detail
IsSameType	.\detail\DiscriminatedPtrDetail.h	/^struct IsSameType<T, U, Types...> {$/;"	s	namespace:folly::dptr_detail
IsSameType	.\detail\DiscriminatedPtrDetail.h	/^struct IsSameType<T> {$/;"	s	namespace:folly::dptr_detail
IsShutdownShift	.\LifoSem.h	/^    IsShutdownShift = 33,$/;"	e	enum:folly::detail::LifoSemHead::__anon76
IsSizableString	.\String-inl.h	/^template <class T> struct IsSizableString {$/;"	s	namespace:folly::detail
IsSizableStringContainerIterator	.\String-inl.h	/^struct IsSizableStringContainerIterator :$/;"	s	namespace:folly::detail	inherits:IsSizableString
IsSomeString	.\Conv.h	/^template <class T> struct IsSomeString {$/;"	s	namespace:folly
IsTriviallyCopyable	.\Traits.h	/^template <class T> struct IsTriviallyCopyable$/;"	s	namespace:folly	inherits:std::integral_constant
IsTriviallyCopyable	.\detail\MemoryIdler.h	/^struct IsTriviallyCopyable<std::chrono::steady_clock::duration>$/;"	s	namespace:folly	inherits:std::true_type
IsTriviallyCopyable	.\test\TraitsTest.cpp	/^struct T4 { typedef std::true_type IsTriviallyCopyable; };$/;"	t	struct:T4	file:	access:public
IsUniquePtrToSL	.\io\IOBuf.h	/^struct IsUniquePtrToSL<$/;"	s	namespace:folly::detail	inherits:std::true_type
IsUniquePtrToSL	.\io\IOBuf.h	/^template <class T, class Enable=void> struct IsUniquePtrToSL$/;"	s	namespace:folly::detail	inherits:std::false_type
IsZeroInitializable	.\Traits.h	/^template <class T> struct IsZeroInitializable$/;"	s	namespace:folly	inherits:std::integral_constant
IterableProxy	.\dynamic-inl.h	/^  \/* implicit *\/ IterableProxy(const dynamic::ObjectImpl* o) : o_(o) { }$/;"	f	struct:folly::dynamic::IterableProxy	access:public	signature:(const dynamic::ObjectImpl* o)
IterableProxy	.\dynamic-inl.h	/^struct dynamic::IterableProxy {$/;"	s	class:folly::dynamic
IterableProxy	.\dynamic.h	/^  template <class T> struct IterableProxy;$/;"	x
Iterator	.\ThreadLocal.h	/^      explicit Iterator(const Accessor* accessor)$/;"	f	class:folly::ThreadLocalPtr::Accessor::Iterator	access:private	signature:(const Accessor* accessor)
Iterator	.\ThreadLocal.h	/^    class Iterator : public boost::iterator_facade<$/;"	c	class:folly::ThreadLocalPtr::Accessor	inherits:boost::iterator_facade	access:public
Iterator	.\ThreadLocal.h	/^    class Iterator;$/;"	x
Iterator	.\ThreadLocal.h	/^    friend class Iterator;$/;"	x
Iterator	.\io\IOBuf.h	/^  class Iterator;$/;"	x
Iterator	.\io\IOBuf.h	/^  explicit Iterator(const IOBuf* pos, const IOBuf* end)$/;"	f	class:folly::IOBuf::Iterator	access:public	signature:(const IOBuf* pos, const IOBuf* end)
Iterator	.\io\IOBuf.h	/^class IOBuf::Iterator : public boost::iterator_facade<$/;"	c	class:folly::IOBuf	inherits:boost::iterator_facade
Iterator	.\io\RecordIO-inl.h	/^  Iterator(ByteRange range, uint32_t fileId, off_t pos);$/;"	p	class:folly::RecordIOReader::Iterator	access:private	signature:(ByteRange range, uint32_t fileId, off_t pos)
Iterator	.\io\RecordIO-inl.h	/^class RecordIOReader::Iterator : public boost::iterator_facade<$/;"	c	class:folly::RecordIOReader	inherits:boost::iterator_facade
Iterator	.\io\RecordIO.cpp	/^RecordIOReader::Iterator::Iterator(ByteRange range, uint32_t fileId, off_t pos)$/;"	f	class:folly::RecordIOReader::Iterator	signature:(ByteRange range, uint32_t fileId, off_t pos)
Iterator	.\io\RecordIO.h	/^  class Iterator;$/;"	x
Just	.\gen\Base-inl.h	/^  explicit Just(Value value) : value_(std::forward<Value>(value)) {}$/;"	f	class:folly::gen::detail::Just	access:public	signature:(Value value)
Just	.\gen\Base-inl.h	/^class Just : public GenImpl<const Value&, Just<Value>> {$/;"	c	namespace:folly::gen::detail	inherits:GenImpl
Just	.\gen\Base.h	/^class Just;$/;"	x
KILLED	.\Subprocess.h	/^    KILLED$/;"	e	enum:folly::ProcessReturnCode::State
Key	.\experimental\EventCount.h	/^  class Key {$/;"	c	class:folly::EventCount	access:public
KeyHasher	.\EvictingCacheMap.h	/^  struct KeyHasher {$/;"	s	class:folly::EvictingCacheMap	access:private
KeyStorageType	.\gen\Base-inl.h	/^    typedef typename std::decay<KeyType>::type KeyStorageType;$/;"	t	class:folly::gen::detail::Distinct::Generator	access:private
KeyT	.\test\AtomicHashMapTest.cpp	/^typedef int32_t     KeyT;$/;"	t	file:
KeyTBig	.\test\AtomicHashMapTest.cpp	/^typedef int64_t     KeyTBig;$/;"	t	file:
KeyType	.\gen\Base-inl.h	/^    typedef typename std::result_of<Selector(ParamType)>::type KeyType;$/;"	t	class:folly::gen::detail::Distinct::Generator	access:private
KeyValue	.\test\FormatTest.cpp	/^struct KeyValue {$/;"	s	namespace:__anon119	file:
KeyValueEqual	.\EvictingCacheMap.h	/^  struct KeyValueEqual {$/;"	s	class:folly::EvictingCacheMap	access:private
LARGEST_SLOT	.\io\async\HHWheelTimer.h	/^  static constexpr uint32_t LARGEST_SLOT = 0xffffffffUL;$/;"	m	class:folly::HHWheelTimer	access:private
LATE_DELIVERY	.\Baton.h	/^    LATE_DELIVERY = 3,$/;"	m	struct:folly::Baton	typeref:enum:folly::Baton::	access:private
LEFT	.\FormatArg.h	/^    LEFT,$/;"	m	class:folly::FormatArg::Align	access:private
LF	.\test\AtomicHashMapTest.cpp	/^const double LF = FLAGS_maxLoadFactor \/ FLAGS_targetLoadFactor;$/;"	v
LIFECYCLE_STEP	.\test\MPMCQueueTest.cpp	465;"	d	file:
LIFOSEM_DECLARE_POOL	.\LifoSem.h	139;"	d
LIKELY	.\Likely.h	27;"	d
LIKELY	.\Likely.h	31;"	d
LIKELY	.\Likely.h	34;"	d
LINK_LOCAL	.\IPAddressV6.h	/^    LINK_LOCAL,$/;"	e	enum:folly::IPAddressV6::LinkLocalTag
LOCKED	.\SmallLocks.h	/^  enum { FREE = 0, LOCKED = 1 };$/;"	e	enum:folly::MicroSpinLock::__anon87
LOG_VALUE	.\test\HasMemberFnTraitsTest.cpp	73;"	d	file:
LOOPER_a	.\test\stl_tests\StlVectorTest.cpp	1108;"	d	file:
LOOPER_b	.\test\stl_tests\StlVectorTest.cpp	1119;"	d	file:
LOOPER_i	.\test\stl_tests\StlVectorTest.cpp	1161;"	d	file:
LOOPER_j	.\test\stl_tests\StlVectorTest.cpp	1167;"	d	file:
LOOPER_m	.\test\stl_tests\StlVectorTest.cpp	1267;"	d	file:
LOOPER_n	.\test\stl_tests\StlVectorTest.cpp	1148;"	d	file:
LOOPER_p	.\test\stl_tests\StlVectorTest.cpp	1221;"	d	file:
LOOPER_q	.\test\stl_tests\StlVectorTest.cpp	1231;"	d	file:
LOOPER_t	.\test\stl_tests\StlVectorTest.cpp	1246;"	d	file:
LOOPER_ticks	.\test\stl_tests\StlVectorTest.cpp	1039;"	d	file:
LOOPER_z	.\test\stl_tests\StlVectorTest.cpp	1020;"	d	file:
LZ4	.\io\Compression.h	/^  LZ4 = 2,$/;"	m	class:folly::io::CodecType	access:private
LZ4Codec	.\io\Compression.cpp	/^  explicit LZ4Codec(int level, CodecType type);$/;"	p	class:folly::io::__anon64::FOLLY_FINAL	file:	access:public	signature:(int level, CodecType type)
LZ4Codec	.\io\Compression.cpp	/^LZ4Codec::LZ4Codec(int level, CodecType type) : Codec(type) {$/;"	f	class:folly::io::__anon64::LZ4Codec	signature:(int level, CodecType type)
LZ4_MAX_INPUT_SIZE	.\io\Compression.cpp	224;"	d	file:
LZ4_VARINT_SIZE	.\io\Compression.h	/^  LZ4_VARINT_SIZE = 5,$/;"	m	class:folly::io::CodecType	access:private
LZMA2	.\io\Compression.h	/^  LZMA2 = 6,$/;"	m	class:folly::io::CodecType	access:private
LZMA2Codec	.\io\Compression.cpp	/^  explicit LZMA2Codec(int level, CodecType type);$/;"	p	class:folly::io::__anon64::FOLLY_FINAL	file:	access:public	signature:(int level, CodecType type)
LZMA2Codec	.\io\Compression.cpp	/^LZMA2Codec::LZMA2Codec(int level, CodecType type) : Codec(type) {$/;"	f	class:folly::io::__anon64::LZMA2Codec	signature:(int level, CodecType type)
LZMA2_VARINT_SIZE	.\io\Compression.h	/^  LZMA2_VARINT_SIZE = 7,$/;"	m	class:folly::io::CodecType	access:private
LatencyQueueType	.\test\ProducerConsumerQueueBenchmark.cpp	/^typedef ProducerConsumerQueue<LatencyType> LatencyQueueType;$/;"	t	namespace:__anon127	file:
LatencyTest	.\test\ProducerConsumerQueueBenchmark.cpp	/^  explicit LatencyTest(size_t size, int iters, int cpu0, int cpu1)$/;"	f	struct:__anon127::LatencyTest	access:public	signature:(size_t size, int iters, int cpu0, int cpu1)
LatencyTest	.\test\ProducerConsumerQueueBenchmark.cpp	/^struct LatencyTest {$/;"	s	namespace:__anon127	file:
LatencyType	.\test\ProducerConsumerQueueBenchmark.cpp	/^typedef long LatencyType;$/;"	t	namespace:__anon127	file:
Later	.\wangle\Later-inl.h	/^Later<T>::Later() {$/;"	f	class:folly::wangle::Later	signature:()
Later	.\wangle\Later-inl.h	/^Later<T>::Later(E const& e) :$/;"	f	class:folly::wangle::Later	signature:(E const& e)
Later	.\wangle\Later-inl.h	/^Later<T>::Later(Future<T>&& f) {$/;"	f	class:folly::wangle::Later	signature:(Future<T>&& f)
Later	.\wangle\Later-inl.h	/^Later<T>::Later(Promise<void>&& starter)$/;"	f	class:folly::wangle::Later	signature:(Promise<void>&& starter)
Later	.\wangle\Later-inl.h	/^Later<T>::Later(U&& input) {$/;"	f	class:folly::wangle::Later	signature:(U&& input)
Later	.\wangle\Later-inl.h	/^Later<T>::Later(std::exception_ptr const& eptr) {$/;"	f	class:folly::wangle::Later	signature:(std::exception_ptr const& eptr)
Later	.\wangle\Later-inl.h	/^Later<T>::Later(std::function<void(std::function<void(U&&)>&&)>&& fn) {$/;"	f	class:folly::wangle::Later	signature:(std::function<void(std::function<void(U&&)>&&)>&& fn)
Later	.\wangle\Later.h	/^  Later();$/;"	p	class:folly::wangle::Later	access:public	signature:()
Later	.\wangle\Later.h	/^  \/* implicit *\/ Later(Future<T>&& f);$/;"	p	class:folly::wangle::Later	access:public	signature:(Future<T>&& f)
Later	.\wangle\Later.h	/^  explicit Later(E const& e);$/;"	p	class:folly::wangle::Later	access:public	signature:(E const& e)
Later	.\wangle\Later.h	/^  explicit Later(Promise<void>&& starter);$/;"	p	class:folly::wangle::Later	access:private	signature:(Promise<void>&& starter)
Later	.\wangle\Later.h	/^  explicit Later(U&& input);$/;"	p	class:folly::wangle::Later	access:public	signature:(U&& input)
Later	.\wangle\Later.h	/^  explicit Later(std::exception_ptr const&);$/;"	p	class:folly::wangle::Later	access:public	signature:(std::exception_ptr const&)
Later	.\wangle\Later.h	/^  explicit Later(std::function<void(std::function<void(U&&)>&&)>&& fn);$/;"	p	class:folly::wangle::Later	access:public	signature:(std::function<void(std::function<void(U&&)>&&)>&& fn)
Later	.\wangle\Later.h	/^  friend class Later;$/;"	x
Later	.\wangle\Later.h	/^class Later {$/;"	c	namespace:folly::wangle
LaterFixture	.\wangle\test\LaterTest.cpp	/^  LaterFixture() :$/;"	f	struct:LaterFixture	access:public	signature:()
LaterFixture	.\wangle\test\LaterTest.cpp	/^struct LaterFixture : public testing::Test {$/;"	s	file:	inherits:testing::Test
LaterFixture::LaterFixture	.\wangle\test\LaterTest.cpp	/^  LaterFixture() :$/;"	f	struct:LaterFixture	access:public	signature:()
LaterFixture::addAsync	.\wangle\test\LaterTest.cpp	/^  void addAsync(int a, int b, std::function<void(int&&)>&& cob) {$/;"	f	struct:LaterFixture	access:public	signature:(int a, int b, std::function<void(int&&)>&& cob)
LaterFixture::done	.\wangle\test\LaterTest.cpp	/^  bool done;$/;"	m	struct:LaterFixture	file:	access:public
LaterFixture::eastExecutor	.\wangle\test\LaterTest.cpp	/^  std::shared_ptr<ManualExecutor> eastExecutor;$/;"	m	struct:LaterFixture	file:	access:public
LaterFixture::inlineExecutor	.\wangle\test\LaterTest.cpp	/^  InlineExecutor inlineExecutor;$/;"	m	struct:LaterFixture	file:	access:public
LaterFixture::later	.\wangle\test\LaterTest.cpp	/^  Later<void> later;$/;"	m	struct:LaterFixture	file:	access:public
LaterFixture::t	.\wangle\test\LaterTest.cpp	/^  std::thread t;$/;"	m	struct:LaterFixture	file:	access:public
LaterFixture::waiter	.\wangle\test\LaterTest.cpp	/^  std::shared_ptr<ManualWaiter> waiter;$/;"	m	struct:LaterFixture	file:	access:public
LaterFixture::westExecutor	.\wangle\test\LaterTest.cpp	/^  std::shared_ptr<ManualExecutor> westExecutor;$/;"	m	struct:LaterFixture	file:	access:public
LaterFixture::~LaterFixture	.\wangle\test\LaterTest.cpp	/^  ~LaterFixture() {$/;"	f	struct:LaterFixture	access:public	signature:()
Lazy	.\Lazy.h	/^  Lazy(Lazy&& o)$/;"	f	struct:folly::detail::Lazy	access:public	signature:(Lazy&& o)
Lazy	.\Lazy.h	/^  Lazy(const Lazy&) = delete;$/;"	p	struct:folly::detail::Lazy	access:public	signature:(const Lazy&)
Lazy	.\Lazy.h	/^  explicit Lazy(Func& f)  : func_(f) {}$/;"	f	struct:folly::detail::Lazy	access:public	signature:(Func& f)
Lazy	.\Lazy.h	/^  explicit Lazy(Func&& f) : func_(std::move(f)) {}$/;"	f	struct:folly::detail::Lazy	access:public	signature:(Func&& f)
Lazy	.\Lazy.h	/^struct Lazy {$/;"	s	namespace:folly::detail
Less	.\gen\Base.h	/^class Less {$/;"	c	namespace:folly::gen
Level	.\stats\MultiLevelTimeSeries.h	/^  typedef folly::BucketedTimeSeries<ValueType, TimeType> Level;$/;"	t	class:folly::MultiLevelTimeSeries	access:public
Levels	.\test\TimeseriesHistogramTest.cpp	/^  enum Levels {$/;"	g	namespace:IntMHTS	file:
Levels	.\test\TimeseriesHistogramTest.cpp	/^  enum Levels {$/;"	g	namespace:IntMTMHTS	file:
Levels	.\test\TimeseriesTest.cpp	/^  enum Levels {$/;"	g	namespace:IntMHTS	file:
Lifecycle	.\test\MPMCQueueTest.cpp	/^struct Lifecycle {$/;"	s	file:
Lifecycle::IsRelocatable	.\test\MPMCQueueTest.cpp	/^  typedef R IsRelocatable;$/;"	t	struct:Lifecycle	file:	access:public
Lifecycle::constructed	.\test\MPMCQueueTest.cpp	/^  bool constructed;$/;"	m	struct:Lifecycle	file:	access:public
Lifecycle::noexcept	.\test\MPMCQueueTest.cpp	/^  Lifecycle() noexcept : constructed(true) {$/;"	m	struct:Lifecycle	file:	access:public
LifecycleEvent	.\test\MPMCQueueTest.cpp	/^enum LifecycleEvent {$/;"	g	file:
LifoSem	.\LifoSem.h	/^typedef LifoSemImpl<> LifoSem;$/;"	t	namespace:folly
LifoSemBase	.\LifoSem.h	/^  explicit LifoSemBase(uint32_t initialValue = 0)$/;"	f	struct:folly::detail::LifoSemBase	access:public	signature:(uint32_t initialValue = 0)
LifoSemBase	.\LifoSem.h	/^struct LifoSemBase : boost::noncopyable {$/;"	s	namespace:folly::detail	inherits:boost::noncopyable
LifoSemHead	.\LifoSem.h	/^class LifoSemHead {$/;"	c	namespace:folly::detail
LifoSemImpl	.\LifoSem.h	/^  explicit LifoSemImpl(uint32_t v = 0)$/;"	f	struct:folly::LifoSemImpl	access:public	signature:(uint32_t v = 0)
LifoSemImpl	.\LifoSem.h	/^struct LifoSemImpl : public detail::LifoSemBase<BatonType, Atom> {$/;"	s	namespace:folly	inherits:detail::LifoSemBase
LifoSemImpl	.\LifoSem.h	/^struct LifoSemImpl;$/;"	x
LifoSemMPMCQueue	.\experimental\wangle\concurrent\LifoSemMPMCQueue.h	/^  explicit LifoSemMPMCQueue(size_t capacity) : queue_(capacity) {}$/;"	f	class:folly::wangle::LifoSemMPMCQueue	access:public	signature:(size_t capacity)
LifoSemMPMCQueue	.\experimental\wangle\concurrent\LifoSemMPMCQueue.h	/^class LifoSemMPMCQueue : public BlockingQueue<T> {$/;"	c	namespace:folly::wangle	inherits:BlockingQueue
LifoSemNode	.\LifoSem.h	/^struct LifoSemNode : public LifoSemRawNode<Atom> {$/;"	s	namespace:folly::detail	inherits:LifoSemRawNode
LifoSemNodeRecycler	.\LifoSem.h	/^struct LifoSemNodeRecycler {$/;"	s	namespace:folly::detail
LifoSemRawNode	.\LifoSem.h	/^struct LifoSemRawNode {$/;"	s	namespace:folly::detail
LineNumberVM	.\experimental\symbolizer\Dwarf.cpp	/^Dwarf::LineNumberVM::LineNumberVM(folly::StringPiece data,$/;"	f	class:folly::symbolizer::Dwarf::LineNumberVM	signature:(folly::StringPiece data, folly::StringPiece compilationDirectory)
LineNumberVM	.\experimental\symbolizer\Dwarf.h	/^    LineNumberVM(folly::StringPiece data,$/;"	p	class:folly::symbolizer::Dwarf::LineNumberVM	access:public	signature:(folly::StringPiece data, folly::StringPiece compilationDirectory)
LineNumberVM	.\experimental\symbolizer\Dwarf.h	/^  class LineNumberVM {$/;"	c	class:folly::symbolizer::Dwarf	access:private
LineReader	.\experimental\symbolizer\LineReader.cpp	/^LineReader::LineReader(int fd, char* buf, size_t bufSize)$/;"	f	class:folly::symbolizer::LineReader	signature:(int fd, char* buf, size_t bufSize)
LineReader	.\experimental\symbolizer\LineReader.h	/^  LineReader(int fd, char* buf, size_t bufSize);$/;"	p	class:folly::symbolizer::LineReader	access:public	signature:(int fd, char* buf, size_t bufSize)
LineReader	.\experimental\symbolizer\LineReader.h	/^class LineReader : private boost::noncopyable {$/;"	c	namespace:folly::symbolizer	inherits:boost::noncopyable
LineSplitter	.\Subprocess.h	/^    typedef gen::StreamSplitter<StreamSplitterCallback> LineSplitter;$/;"	t	class:folly::Subprocess::ReadLinesCallback	access:private
LinkLocalTag	.\IPAddressV6.h	/^  enum LinkLocalTag {$/;"	g	class:folly::IPAddressV6	access:public
List	.\io\async\EventBase.h	/^      boost::intrusive::constant_time_size<false> > List;$/;"	t	class:folly::EventBase::CobTimeout	access:public
List	.\io\async\EventBase.h	/^      boost::intrusive::constant_time_size<false> > List;$/;"	t	class:folly::EventBase::LoopCallback	access:private
List	.\io\async\HHWheelTimer.h	/^      boost::intrusive::constant_time_size<false> > List;$/;"	t	class:folly::HHWheelTimer::Callback	access:private
ListHook	.\io\async\EventBase.h	/^      boost::intrusive::link_mode<boost::intrusive::auto_unlink> > ListHook;$/;"	t	class:folly::EventBase::CobTimeout	access:public
ListHook	.\io\async\EventBase.h	/^      boost::intrusive::link_mode<boost::intrusive::auto_unlink> > ListHook;$/;"	t	class:folly::EventBase::LoopCallback	access:private
ListHook	.\io\async\HHWheelTimer.h	/^      boost::intrusive::link_mode<boost::intrusive::auto_unlink> > ListHook;$/;"	t	class:folly::HHWheelTimer::Callback	access:private
Living	.\experimental\Singleton.h	/^    Living,$/;"	m	class:folly::SingletonVault::SingletonEntryState	access:private
LocalInstancePRNG	.\Random.cpp	/^  LocalInstancePRNG() : rng(Random::create()) { }$/;"	f	class:folly::ThreadLocalPRNG::LocalInstancePRNG	access:public	signature:()
LocalInstancePRNG	.\Random.cpp	/^class ThreadLocalPRNG::LocalInstancePRNG {$/;"	c	class:folly::ThreadLocalPRNG	file:
LocalInstancePRNG	.\Random.h	/^  class LocalInstancePRNG;$/;"	x
LocalList	.\IndexedMemPool.h	/^    LocalList() : head(TaggedPtr{}) {}$/;"	f	struct:folly::LocalList	access:public	signature:()
LocalList	.\IndexedMemPool.h	/^  struct FOLLY_ALIGN_TO_AVOID_FALSE_SHARING LocalList {$/;"	s	namespace:folly
LocalListLimit	.\IndexedMemPool.h	/^    LocalListLimit = LocalListLimit_$/;"	e	enum:folly::IndexedMemPool::__anon61
LocationInfo	.\experimental\symbolizer\Dwarf.h	/^    LocationInfo() : hasMainFile(false), hasFileAndLine(false), line(0) { }$/;"	f	struct:folly::symbolizer::Dwarf::LocationInfo	access:public	signature:()
LocationInfo	.\experimental\symbolizer\Dwarf.h	/^  struct LocationInfo {$/;"	s	class:folly::symbolizer::Dwarf	access:public
Locations	.\test\stl_tests\StlVectorTest.cpp	/^  static std::map<const Tracker*, int> Locations;$/;"	m	struct:Tracker	file:	access:public
Locations	.\test\stl_tests\StlVectorTest.cpp	/^std::map<const Tracker*, int> Tracker::Locations;$/;"	m	class:Tracker	file:
LockMode	.\MemoryMapping.h	/^  enum class LockMode {$/;"	c	class:folly::MemoryMapping	access:public
LockedPtr	.\Synchronized.h	/^    LockedPtr() = delete;$/;"	p	struct:folly::Synchronized::LockedPtr	access:public	signature:()
LockedPtr	.\Synchronized.h	/^    LockedPtr(Synchronized* parent, detail::InternalDoNotUse)$/;"	f	struct:folly::Synchronized::LockedPtr	access:public	signature:(Synchronized* parent, detail::InternalDoNotUse)
LockedPtr	.\Synchronized.h	/^    LockedPtr(Synchronized* parent, unsigned int milliseconds) {$/;"	f	struct:folly::Synchronized::LockedPtr	access:public	signature:(Synchronized* parent, unsigned int milliseconds)
LockedPtr	.\Synchronized.h	/^    LockedPtr(const LockedPtr& rhs) : parent_(rhs.parent_) {$/;"	f	struct:folly::Synchronized::LockedPtr	access:public	signature:(const LockedPtr& rhs)
LockedPtr	.\Synchronized.h	/^    explicit LockedPtr(Synchronized* parent) : parent_(parent) {$/;"	f	struct:folly::Synchronized::LockedPtr	access:public	signature:(Synchronized* parent)
LockedPtr	.\Synchronized.h	/^  struct LockedPtr {$/;"	s	struct:folly::Synchronized	access:public
LockedVal	.\test\SmallLocksTest.cpp	/^  LockedVal() {$/;"	f	struct:__anon131::LockedVal	access:public	signature:()
LockedVal	.\test\SmallLocksTest.cpp	/^struct LockedVal {$/;"	s	namespace:__anon131	file:
LoopCallback	.\io\async\EventBase.h	/^  class LoopCallback {$/;"	c	class:folly::EventBase	access:public
LoopCallbackList	.\io\async\EventBase.h	/^  typedef LoopCallback::List LoopCallbackList;$/;"	t	class:folly::EventBase	access:private
LruLink	.\experimental\symbolizer\ElfCache.h	/^  typedef boost::intrusive::list_member_hook<> LruLink;$/;"	t	class:folly::symbolizer::ElfCache	access:private
LruList	.\experimental\symbolizer\ElfCache.h	/^      boost::intrusive::constant_time_size<false>> LruList;$/;"	t	class:folly::symbolizer::ElfCache	access:private
MAKE_MT_CACHE_SIZE_BM	.\test\ThreadCachedIntTest.cpp	119;"	d	file:
MAKE_TEST	.\test\stl_tests\StlVectorTest.cpp	825;"	d	file:
MALLOCX_LG_ALIGN	.\Malloc.h	29;"	d
MALLOCX_ZERO	.\Malloc.h	32;"	d
MAP_ANONYMOUS	.\Portability.h	47;"	d
MAP_ANONYMOUS	.\test\AtomicHashArrayTest.cpp	30;"	d	file:
MAP_POPULATE	.\MemoryMapping.cpp	36;"	d	file:
MARKED_FOR_REMOVAL	.\ConcurrentSkipList-inl.h	/^    MARKED_FOR_REMOVAL = (1 << 1),$/;"	e	enum:folly::detail::SkipListNode::__anon5
MAX_ALLOC_SIZE	.\io\IOBufQueue.cpp	/^const size_t MAX_ALLOC_SIZE = 8000;$/;"	m	namespace:__anon67	file:
MAX_LIFECYCLE_EVENT	.\test\MPMCQueueTest.cpp	/^  MAX_LIFECYCLE_EVENT$/;"	e	enum:LifecycleEvent	file:
MAX_PACK_COPY	.\io\IOBufQueue.cpp	/^const size_t MAX_PACK_COPY = 4096;$/;"	m	namespace:__anon67	file:
MA_DELETE	.\test\stl_tests\StlVectorTest.cpp	/^  MA_DELETE   = 0x80000,$/;"	e	enum:Flags	file:
MA_NOEXCEPT	.\test\stl_tests\StlVectorTest.cpp	/^  MA_NOEXCEPT = 0x400,$/;"	e	enum:Flags	file:
MA_THROW	.\test\stl_tests\StlVectorTest.cpp	/^  MA_THROW    = 0x800,$/;"	e	enum:Flags	file:
MC_DELETE	.\test\stl_tests\StlVectorTest.cpp	/^  MC_DELETE   = 0x20000,$/;"	e	enum:Flags	file:
MC_NOEXCEPT	.\test\stl_tests\StlVectorTest.cpp	/^  MC_NOEXCEPT = 0x10,$/;"	e	enum:Flags	file:
MC_THROW	.\test\stl_tests\StlVectorTest.cpp	/^  MC_THROW    = 0x20,$/;"	e	enum:Flags	file:
MEASURES	.\test\SpookyHashV1Test.cpp	384;"	d	file:
MEASURES	.\test\SpookyHashV1Test.cpp	465;"	d	file:
MEASURES	.\test\SpookyHashV2Test.cpp	310;"	d	file:
MEASURES	.\test\SpookyHashV2Test.cpp	391;"	d	file:
MINUS	.\FormatArg.h	/^    MINUS,$/;"	m	class:folly::FormatArg::Sign	access:private
MINUTE	.\test\TimeseriesHistogramTest.cpp	/^    MINUTE,$/;"	e	enum:IntMHTS::Levels	file:
MINUTE	.\test\TimeseriesHistogramTest.cpp	/^    MINUTE,$/;"	e	enum:IntMTMHTS::Levels	file:
MINUTE	.\test\TimeseriesTest.cpp	/^    MINUTE,$/;"	e	enum:IntMHTS::Levels	file:
MIN_ALLOC_SIZE	.\io\IOBufQueue.cpp	/^const size_t MIN_ALLOC_SIZE = 2000;$/;"	m	namespace:__anon67	file:
MOCK_METHOD0	.\test\MemoryIdlerTest.cpp	/^  MOCK_METHOD0(nowImpl, time_point(void));$/;"	p	struct:MockClock	file:	access:public	signature:(nowImpl, time_point(void))
MOCK_METHOD2	.\test\MemoryIdlerTest.cpp	/^  MOCK_METHOD2(futexWait, bool(uint32_t, uint32_t));$/;"	p	struct:folly::detail::Futex	file:	access:public	signature:(futexWait, bool(uint32_t, uint32_t))
MOCK_METHOD3	.\test\MemoryIdlerTest.cpp	/^  MOCK_METHOD3(futexWaitUntil,$/;"	p	struct:folly::detail::Futex	file:	access:public	signature:(futexWaitUntil, FutexResult(uint32_t, const MockClock::time_point&, uint32_t))
MOVE_CONSTRUCTOR	.\test\MPMCQueueTest.cpp	/^  MOVE_CONSTRUCTOR,$/;"	e	enum:LifecycleEvent	file:
MOVE_OPERATOR	.\test\MPMCQueueTest.cpp	/^  MOVE_OPERATOR,$/;"	e	enum:LifecycleEvent	file:
MPMCPipeline	.\MPMCPipeline.h	/^    friend class MPMCPipeline;$/;"	x
MPMCPipeline	.\MPMCPipeline.h	/^  MPMCPipeline() { }$/;"	f	class:folly::MPMCPipeline	access:public	signature:()
MPMCPipeline	.\MPMCPipeline.h	/^  explicit MPMCPipeline(Sizes... sizes) : stages_(sizes...) { }$/;"	f	class:folly::MPMCPipeline	access:public	signature:(Sizes.... sizes)
MPMCPipeline	.\MPMCPipeline.h	/^template <class In, class... Stages> class MPMCPipeline {$/;"	c	namespace:folly
MPMCPipeline	.\detail\MPMCPipelineDetail.h	/^  template <class U, class... Stages> friend class MPMCPipeline;$/;"	x
MPMCPipeline	.\detail\MPMCPipelineDetail.h	/^template <class T, class... Stages> class MPMCPipeline;$/;"	x
MPMCPipelineStage	.\MPMCPipeline.h	/^template <class T, size_t Amp> class MPMCPipelineStage;$/;"	x
MPMCPipelineStage	.\detail\MPMCPipelineDetail.h	/^template <class T, size_t Amp> class MPMCPipelineStage {$/;"	c	namespace:folly
MPMCPipelineStageImpl	.\MPMCQueue.h	/^template <typename T> class MPMCPipelineStageImpl;$/;"	x
MPMCPipelineStageImpl	.\detail\MPMCPipelineDetail.h	/^  MPMCPipelineStageImpl() { }$/;"	f	class:folly::detail::MPMCPipelineStageImpl	access:public	signature:()
MPMCPipelineStageImpl	.\detail\MPMCPipelineDetail.h	/^  \/* implicit *\/ MPMCPipelineStageImpl(size_t capacity) : queue_(capacity) { }$/;"	f	class:folly::detail::MPMCPipelineStageImpl	access:public	signature:(size_t capacity)
MPMCPipelineStageImpl	.\detail\MPMCPipelineDetail.h	/^class MPMCPipelineStageImpl {$/;"	c	namespace:folly::detail
MPMCQueue	.\MPMCQueue.h	/^  explicit MPMCQueue(size_t queueCapacity)$/;"	f	class:folly::MPMCQueue	access:public	signature:(size_t queueCapacity)
MPMCQueue	.\MPMCQueue.h	/^class MPMCQueue : boost::noncopyable {$/;"	c	namespace:folly	inherits:boost::noncopyable
MSLGuard	.\SmallLocks.h	/^typedef std::lock_guard<MicroSpinLock> MSLGuard;$/;"	t	namespace:folly
M_relocate	.\FBVector.h	/^  void M_relocate(T* newB) {$/;"	f	signature:(T* newB)
M_uninitialized_copy_e	.\FBVector.h	/^  void M_uninitialized_copy_e(It first, It last) {$/;"	f	signature:(It first, It last)
M_uninitialized_fill_n_e	.\FBVector.h	/^  void M_uninitialized_fill_n_e(size_type sz) {$/;"	f	signature:(size_type sz)
M_uninitialized_fill_n_e	.\FBVector.h	/^  void M_uninitialized_fill_n_e(size_type sz, VT value) {$/;"	f	signature:(size_type sz, VT value)
M_uninitialized_move_e	.\FBVector.h	/^  void M_uninitialized_move_e(It first, It last) {$/;"	f	signature:(It first, It last)
MacAddress	.\IPAddressV6.h	/^class MacAddress;$/;"	x
MacAddress	.\MacAddress.cpp	/^MacAddress::MacAddress(StringPiece str) {$/;"	f	class:folly::MacAddress	signature:(StringPiece str)
MacAddress	.\MacAddress.h	/^  MacAddress() {$/;"	f	class:folly::MacAddress	access:public	signature:()
MacAddress	.\MacAddress.h	/^  explicit MacAddress(StringPiece str);$/;"	p	class:folly::MacAddress	access:public	signature:(StringPiece str)
MacAddress	.\MacAddress.h	/^  explicit MacAddress(uint64_t valueNBO) {$/;"	f	class:folly::MacAddress	access:private	signature:(uint64_t valueNBO)
MacAddress	.\MacAddress.h	/^class MacAddress : private boost::totally_ordered<MacAddress> {$/;"	c	namespace:folly	inherits:boost::totally_ordered
ManagedBuffer	.\experimental\io\test\AsyncIOTest.cpp	/^typedef std::unique_ptr<char, void(*)(void*)> ManagedBuffer;$/;"	t	namespace:__anon32	file:
ManagedConnection	.\experimental\wangle\ManagedConnection.cpp	/^ManagedConnection::ManagedConnection()$/;"	f	class:folly::wangle::ManagedConnection	signature:()
ManagedConnection	.\experimental\wangle\ManagedConnection.h	/^  ManagedConnection();$/;"	p	class:folly::wangle::ManagedConnection	access:public	signature:()
ManagedConnection	.\experimental\wangle\ManagedConnection.h	/^class ManagedConnection:$/;"	c	namespace:folly::wangle	inherits:folly::HHWheelTimer::Callback,folly::DelayedDestruction
ManualExecutor	.\wangle\ManualExecutor.cpp	/^ManualExecutor::ManualExecutor() {$/;"	f	class:folly::wangle::ManualExecutor	signature:()
ManualExecutor	.\wangle\ManualExecutor.h	/^    ManualExecutor();$/;"	p	class:folly::wangle::ManualExecutor	access:public	signature:()
ManualExecutor	.\wangle\ManualExecutor.h	/^  class ManualExecutor : public Executor {$/;"	c	namespace:folly::wangle	inherits:Executor
ManualWaiter	.\wangle\test\LaterTest.cpp	/^  explicit ManualWaiter(std::shared_ptr<ManualExecutor> ex) : ex(ex) {}$/;"	f	struct:ManualWaiter	access:public	signature:(std::shared_ptr<ManualExecutor> ex)
ManualWaiter	.\wangle\test\LaterTest.cpp	/^struct ManualWaiter {$/;"	s	file:
ManualWaiter	.\wangle\test\ThreadGateTest.cpp	/^  explicit ManualWaiter(shared_ptr<ManualExecutor> ex) : ex(ex) {}$/;"	f	struct:ManualWaiter	access:public	signature:(shared_ptr<ManualExecutor> ex)
ManualWaiter	.\wangle\test\ThreadGateTest.cpp	/^struct ManualWaiter {$/;"	s	file:
ManualWaiter::ManualWaiter	.\wangle\test\LaterTest.cpp	/^  explicit ManualWaiter(std::shared_ptr<ManualExecutor> ex) : ex(ex) {}$/;"	f	struct:ManualWaiter	access:public	signature:(std::shared_ptr<ManualExecutor> ex)
ManualWaiter::ManualWaiter	.\wangle\test\ThreadGateTest.cpp	/^  explicit ManualWaiter(shared_ptr<ManualExecutor> ex) : ex(ex) {}$/;"	f	struct:ManualWaiter	access:public	signature:(shared_ptr<ManualExecutor> ex)
ManualWaiter::ex	.\wangle\test\LaterTest.cpp	/^  std::shared_ptr<ManualExecutor> ex;$/;"	m	struct:ManualWaiter	file:	access:public
ManualWaiter::ex	.\wangle\test\ThreadGateTest.cpp	/^  shared_ptr<ManualExecutor> ex;$/;"	m	struct:ManualWaiter	file:	access:public
ManualWaiter::makeProgress	.\wangle\test\LaterTest.cpp	/^  void makeProgress() {$/;"	f	struct:ManualWaiter	access:public	signature:()
ManualWaiter::makeProgress	.\wangle\test\ThreadGateTest.cpp	/^  void makeProgress() {$/;"	f	struct:ManualWaiter	access:public	signature:()
Map	.\gen\Base-inl.h	/^  Map() {}$/;"	f	class:folly::gen::detail::Map	access:public	signature:()
Map	.\gen\Base-inl.h	/^  explicit Map(Predicate pred)$/;"	f	class:folly::gen::detail::Map	access:public	signature:(Predicate pred)
Map	.\gen\Base-inl.h	/^class Map : public Operator<Map<Predicate>> {$/;"	c	namespace:folly::gen::detail	inherits:Operator
Map	.\gen\Base.h	/^class Map;$/;"	x
Map	.\test\PackedSyncPtrTest.cpp	/^typedef std::unordered_map<int64_t, VecT> Map;$/;"	t	file:
MaskBoundaryData	.\test\IPAddressTest.h	/^  MaskBoundaryData(const std::string& addr, uint8_t mask,$/;"	f	struct:folly::MaskBoundaryData	access:public	signature:(const std::string& addr, uint8_t mask, const std::string& subnet, bool inSubnet)
MaskBoundaryData	.\test\IPAddressTest.h	/^struct MaskBoundaryData : MaskData {$/;"	s	namespace:folly	inherits:MaskData
MaskData	.\test\IPAddressTest.h	/^  MaskData(const std::string& addr, uint8_t mask,$/;"	f	struct:folly::MaskData	access:public	signature:(const std::string& addr, uint8_t mask, const std::string& subnet)
MaskData	.\test\IPAddressTest.h	/^struct MaskData {$/;"	s	namespace:folly
MaxAlign	.\Portability.h	/^struct MaxAlign { char c; } __attribute__((__aligned__));$/;"	s
MaxAlign::c	.\Portability.h	/^struct MaxAlign { char c; } __attribute__((__aligned__));$/;"	m	struct:MaxAlign	access:public
MaxInline	.\small_vector.h	/^    MaxInline = boost::mpl::max<$/;"	e	enum:folly::small_vector::__anon89
MaybeThrow	.\test\small_vector_test.cpp	/^void MaybeThrow() {$/;"	f	namespace:__anon132	signature:()
MemberFunction	.\gen\Base.h	/^  explicit MemberFunction(MemberPtr member)$/;"	f	class:folly::gen::MemberFunction	access:public	signature:(MemberPtr member)
MemberFunction	.\gen\Base.h	/^class MemberFunction {$/;"	c	namespace:folly::gen
MemberPtr	.\gen\Base.h	/^  typedef Result (Class::*MemberPtr)();$/;"	t	class:folly::gen::MemberFunction	access:public
MemberType	.\gen\Base.h	/^enum MemberType {$/;"	g	namespace:folly::gen
MemchrNeedleFinder	.\test\RangeTest.cpp	/^struct MemchrNeedleFinder {$/;"	s	file:
MemchrNeedleFinder::find_first_byte_of	.\test\RangeTest.cpp	/^  static size_t find_first_byte_of(StringPiece haystack, StringPiece needles) {$/;"	f	struct:MemchrNeedleFinder	access:public	signature:(StringPiece haystack, StringPiece needles)
MemoryIdler	.\detail\MemoryIdler.h	/^struct MemoryIdler {$/;"	s	namespace:folly::detail
MemoryMapping	.\MemoryMapping.cpp	/^MemoryMapping::MemoryMapping(AnonymousType, off_t length, Options options)$/;"	f	class:folly::MemoryMapping	signature:(AnonymousType, off_t length, Options options)
MemoryMapping	.\MemoryMapping.cpp	/^MemoryMapping::MemoryMapping(File file, off_t offset, off_t length,$/;"	f	class:folly::MemoryMapping	signature:(File file, off_t offset, off_t length, Options options)
MemoryMapping	.\MemoryMapping.cpp	/^MemoryMapping::MemoryMapping(MemoryMapping&& other) {$/;"	f	class:folly::MemoryMapping	signature:(MemoryMapping&& other)
MemoryMapping	.\MemoryMapping.cpp	/^MemoryMapping::MemoryMapping(const char* name, off_t offset, off_t length,$/;"	f	class:folly::MemoryMapping	signature:(const char* name, off_t offset, off_t length, Options options)
MemoryMapping	.\MemoryMapping.cpp	/^MemoryMapping::MemoryMapping(int fd, off_t offset, off_t length,$/;"	f	class:folly::MemoryMapping	signature:(int fd, off_t offset, off_t length, Options options)
MemoryMapping	.\MemoryMapping.h	/^  MemoryMapping();$/;"	p	class:folly::MemoryMapping	access:private	signature:()
MemoryMapping	.\MemoryMapping.h	/^  MemoryMapping(AnonymousType, off_t length, Options options=Options());$/;"	p	class:folly::MemoryMapping	access:public	signature:(AnonymousType, off_t length, Options options=Options())
MemoryMapping	.\MemoryMapping.h	/^  MemoryMapping(MemoryMapping&&);$/;"	p	class:folly::MemoryMapping	access:public	signature:(MemoryMapping&&)
MemoryMapping	.\MemoryMapping.h	/^  explicit MemoryMapping(File file,$/;"	p	class:folly::MemoryMapping	access:public	signature:(File file, off_t offset=0, off_t length=-1, Options options=Options())
MemoryMapping	.\MemoryMapping.h	/^  explicit MemoryMapping(const char* name,$/;"	p	class:folly::MemoryMapping	access:public	signature:(const char* name, off_t offset=0, off_t length=-1, Options options=Options())
MemoryMapping	.\MemoryMapping.h	/^  explicit MemoryMapping(int fd,$/;"	p	class:folly::MemoryMapping	access:public	signature:(int fd, off_t offset=0, off_t length=-1, Options options=Options())
MemoryMapping	.\MemoryMapping.h	/^class MemoryMapping : boost::noncopyable {$/;"	c	namespace:folly	inherits:boost::noncopyable
MergeTuples	.\gen\Combine-inl.h	/^class MergeTuples {$/;"	c	namespace:folly::gen::detail
MicroSpinLock	.\SmallLocks.h	/^struct MicroSpinLock {$/;"	s	namespace:folly
Min	.\gen\Base-inl.h	/^  Min() {}$/;"	f	class:folly::gen::detail::Min	access:public	signature:()
Min	.\gen\Base-inl.h	/^  Min(Selector selector,$/;"	f	class:folly::gen::detail::Min	access:public	signature:(Selector selector, Comparer comparer)
Min	.\gen\Base-inl.h	/^  explicit Min(Selector selector)$/;"	f	class:folly::gen::detail::Min	access:public	signature:(Selector selector)
Min	.\gen\Base-inl.h	/^class Min : public Operator<Min<Selector, Comparer>> {$/;"	c	namespace:folly::gen::detail	inherits:Operator
Min	.\gen\Base.h	/^class Min;$/;"	x
Mix	.\SpookyHashV1.h	/^    static inline void Mix($/;"	f	class:folly::hash::SpookyHashV1	access:public	signature:( const uint64_t *data, uint64_t &s0, uint64_t &s1, uint64_t &s2, uint64_t &s3, uint64_t &s4, uint64_t &s5, uint64_t &s6, uint64_t &s7, uint64_t &s8, uint64_t &s9, uint64_t &s10,uint64_t &s11)
Mix	.\SpookyHashV2.h	/^    static inline void Mix($/;"	f	class:folly::hash::SpookyHashV2	access:public	signature:( const uint64_t *data, uint64_t &s0, uint64_t &s1, uint64_t &s2, uint64_t &s3, uint64_t &s4, uint64_t &s5, uint64_t &s6, uint64_t &s7, uint64_t &s8, uint64_t &s9, uint64_t &s10,uint64_t &s11)
MixedNewlines	.\gen\String.h	/^class MixedNewlines {};$/;"	c	namespace:folly::gen
MmapAllocator	.\test\AtomicHashArrayTest.cpp	/^class MmapAllocator {$/;"	c	file:
MmapAllocator::address	.\test\AtomicHashArrayTest.cpp	/^  T* address(T& x) const {$/;"	f	class:MmapAllocator	access:public	signature:(T& x) const
MmapAllocator::address	.\test\AtomicHashArrayTest.cpp	/^  const T* address(const T& x) const {$/;"	f	class:MmapAllocator	access:public	signature:(const T& x) const
MmapAllocator::allocate	.\test\AtomicHashArrayTest.cpp	/^  T *allocate(size_t n) {$/;"	f	class:MmapAllocator	access:public	signature:(size_t n)
MmapAllocator::const_pointer	.\test\AtomicHashArrayTest.cpp	/^  typedef const T* const_pointer;$/;"	t	class:MmapAllocator	file:	access:public
MmapAllocator::const_reference	.\test\AtomicHashArrayTest.cpp	/^  typedef const T& const_reference;$/;"	t	class:MmapAllocator	file:	access:public
MmapAllocator::construct	.\test\AtomicHashArrayTest.cpp	/^  void construct(T* p, Args&&... args) {$/;"	f	class:MmapAllocator	access:public	signature:(T* p, Args&&... args)
MmapAllocator::deallocate	.\test\AtomicHashArrayTest.cpp	/^  void deallocate(T *p, size_t n) {$/;"	f	class:MmapAllocator	access:public	signature:(T *p, size_t n)
MmapAllocator::destroy	.\test\AtomicHashArrayTest.cpp	/^  void destroy(T* p) {$/;"	f	class:MmapAllocator	access:public	signature:(T* p)
MmapAllocator::difference_type	.\test\AtomicHashArrayTest.cpp	/^  typedef ptrdiff_t difference_type;$/;"	t	class:MmapAllocator	file:	access:public
MmapAllocator::max_size	.\test\AtomicHashArrayTest.cpp	/^  size_t max_size() const {$/;"	f	class:MmapAllocator	access:public	signature:() const
MmapAllocator::operator !=	.\test\AtomicHashArrayTest.cpp	/^  bool operator!=(const MmapAllocator<T>& other) const {$/;"	f	class:MmapAllocator	access:public	signature:(const MmapAllocator<T>& other) const
MmapAllocator::operator ==	.\test\AtomicHashArrayTest.cpp	/^  bool operator==(const MmapAllocator<T>& other) const {$/;"	f	class:MmapAllocator	access:public	signature:(const MmapAllocator<T>& other) const
MmapAllocator::pointer	.\test\AtomicHashArrayTest.cpp	/^  typedef T* pointer;$/;"	t	class:MmapAllocator	file:	access:public
MmapAllocator::rebind	.\test\AtomicHashArrayTest.cpp	/^  template <class U> struct rebind {$/;"	s	class:MmapAllocator	file:	access:public
MmapAllocator::rebind::other	.\test\AtomicHashArrayTest.cpp	/^    typedef MmapAllocator<U> other;$/;"	t	struct:MmapAllocator::rebind	file:	access:public
MmapAllocator::reference	.\test\AtomicHashArrayTest.cpp	/^  typedef T& reference;$/;"	t	class:MmapAllocator	file:	access:public
MmapAllocator::size_type	.\test\AtomicHashArrayTest.cpp	/^  typedef size_t size_type;$/;"	t	class:MmapAllocator	file:	access:public
MmapAllocator::value_type	.\test\AtomicHashArrayTest.cpp	/^  typedef T value_type;$/;"	t	class:MmapAllocator	file:	access:public
MockAtom	.\test\MemoryIdlerTest.cpp	/^  explicit MockAtom(T init = 0) : std::atomic<T>(init) {}$/;"	f	struct:MockAtom	access:public	signature:(T init = 0)
MockAtom	.\test\MemoryIdlerTest.cpp	/^struct MockAtom : public std::atomic<T> {$/;"	s	file:	inherits:std::atomic
MockAtom::MockAtom	.\test\MemoryIdlerTest.cpp	/^  explicit MockAtom(T init = 0) : std::atomic<T>(init) {}$/;"	f	struct:MockAtom	access:public	signature:(T init = 0)
MockClock	.\test\MemoryIdlerTest.cpp	/^struct MockClock {$/;"	s	file:
MockClock::MOCK_METHOD0	.\test\MemoryIdlerTest.cpp	/^  MOCK_METHOD0(nowImpl, time_point(void));$/;"	p	struct:MockClock	file:	access:public	signature:(nowImpl, time_point(void))
MockClock::duration	.\test\MemoryIdlerTest.cpp	/^  typedef std::chrono::steady_clock::duration duration;$/;"	t	struct:MockClock	file:	access:public
MockClock::now	.\test\MemoryIdlerTest.cpp	/^  static time_point now() {$/;"	f	struct:MockClock	access:public	signature:()
MockClock::s_mockClockInstance	.\test\MemoryIdlerTest.cpp	/^  static std::weak_ptr<StrictMock<MockClock>> s_mockClockInstance;$/;"	m	struct:MockClock	file:	access:public
MockClock::s_mockClockInstance	.\test\MemoryIdlerTest.cpp	/^std::weak_ptr<StrictMock<MockClock>> MockClock::s_mockClockInstance;$/;"	m	class:MockClock	file:
MockClock::setup	.\test\MemoryIdlerTest.cpp	/^  static std::shared_ptr<StrictMock<MockClock>> setup() {$/;"	f	struct:MockClock	access:public	signature:()
MockClock::time_point	.\test\MemoryIdlerTest.cpp	/^  typedef std::chrono::steady_clock::time_point time_point;$/;"	t	struct:MockClock	file:	access:public
Move	.\gen\Base.h	/^class Move {$/;"	c	namespace:folly::gen
MoveTester	.\test\OptionalTest.cpp	/^  MoveTester(const MoveTester&) = default;$/;"	p	class:folly::MoveTester	file:	access:public	signature:(const MoveTester&)
MoveTester	.\test\OptionalTest.cpp	/^  \/* implicit *\/ MoveTester(const char* s) : s_(s) {}$/;"	f	class:folly::MoveTester	access:public	signature:(const char* s)
MoveTester	.\test\OptionalTest.cpp	/^class MoveTester {$/;"	c	namespace:folly	file:
MoveToFbStringTest	.\io\test\IOBufTest.cpp	/^class MoveToFbStringTest$/;"	c	file:	inherits:::testing::TestWithParam
MoveToFbStringTest::SetUp	.\io\test\IOBufTest.cpp	/^  void SetUp() {$/;"	f	class:MoveToFbStringTest	access:protected	signature:()
MoveToFbStringTest::buf2_	.\io\test\IOBufTest.cpp	/^  std::unique_ptr<IOBuf> buf2_;$/;"	m	class:MoveToFbStringTest	file:	access:protected
MoveToFbStringTest::buf_	.\io\test\IOBufTest.cpp	/^  std::unique_ptr<IOBuf> buf_;$/;"	m	class:MoveToFbStringTest	file:	access:protected
MoveToFbStringTest::check	.\io\test\IOBufTest.cpp	/^  void check(std::unique_ptr<IOBuf>& buf) {$/;"	f	class:MoveToFbStringTest	access:protected	signature:(std::unique_ptr<IOBuf>& buf)
MoveToFbStringTest::elementCount_	.\io\test\IOBufTest.cpp	/^  int elementCount_;$/;"	m	class:MoveToFbStringTest	file:	access:protected
MoveToFbStringTest::elementSize_	.\io\test\IOBufTest.cpp	/^  int elementSize_;$/;"	m	class:MoveToFbStringTest	file:	access:protected
MoveToFbStringTest::makeBuf	.\io\test\IOBufTest.cpp	/^  std::unique_ptr<IOBuf> makeBuf() {$/;"	f	class:MoveToFbStringTest	access:protected	signature:()
MoveToFbStringTest::ownedBuffers_	.\io\test\IOBufTest.cpp	/^  std::vector<std::unique_ptr<uint8_t[]>> ownedBuffers_;$/;"	m	class:MoveToFbStringTest	file:	access:protected
MoveToFbStringTest::shared_	.\io\test\IOBufTest.cpp	/^  bool shared_;$/;"	m	class:MoveToFbStringTest	file:	access:protected
MoveToFbStringTest::type_	.\io\test\IOBufTest.cpp	/^  BufType type_;$/;"	m	class:MoveToFbStringTest	file:	access:protected
MoveWrapper	.\MoveWrapper.h	/^  MoveWrapper() = default;$/;"	p	class:folly::MoveWrapper	access:public	signature:()
MoveWrapper	.\MoveWrapper.h	/^  MoveWrapper(MoveWrapper&& other) : value(std::move(other.value)) {}$/;"	f	class:folly::MoveWrapper	access:public	signature:(MoveWrapper&& other)
MoveWrapper	.\MoveWrapper.h	/^  MoveWrapper(T&& t) : value(std::move(t)) {}$/;"	f	class:folly::MoveWrapper	access:public	signature:(T&& t)
MoveWrapper	.\MoveWrapper.h	/^  MoveWrapper(const MoveWrapper& other) : value(std::move(other.value)) {}$/;"	f	class:folly::MoveWrapper	access:public	signature:(const MoveWrapper& other)
MoveWrapper	.\MoveWrapper.h	/^class MoveWrapper {$/;"	c	namespace:folly
Mover	.\test\ApplyTupleTest.cpp	/^  Mover() {}$/;"	f	struct:__anon104::Mover	access:public	signature:()
Mover	.\test\ApplyTupleTest.cpp	/^  Mover(Mover&&) {}$/;"	f	struct:__anon104::Mover	access:public	signature:(Mover&&)
Mover	.\test\ApplyTupleTest.cpp	/^  Mover(const Mover&) = delete;$/;"	p	struct:__anon104::Mover	file:	access:public	signature:(const Mover&)
Mover	.\test\ApplyTupleTest.cpp	/^struct Mover {$/;"	s	namespace:__anon104	file:
MultiLevelTimeSeries	.\stats\Instantiations.cpp	/^template class MultiLevelTimeSeries<int64_t>;$/;"	x	file:
MultiLevelTimeSeries	.\stats\MultiLevelTimeSeries-defs.h	/^MultiLevelTimeSeries<VT, TT>::MultiLevelTimeSeries($/;"	f	class:folly::MultiLevelTimeSeries	signature:( size_t nBuckets, size_t nLevels, const TimeType levelDurations[])
MultiLevelTimeSeries	.\stats\MultiLevelTimeSeries.h	/^  MultiLevelTimeSeries(size_t numBuckets,$/;"	p	class:folly::MultiLevelTimeSeries	access:public	signature:(size_t numBuckets, size_t numLevels, const TimeType levelDurations[])
MultiLevelTimeSeries	.\stats\MultiLevelTimeSeries.h	/^class MultiLevelTimeSeries {$/;"	c	namespace:folly
Mutable	.\gen\Base.h	/^  Mutable$/;"	e	enum:folly::gen::MemberType
MutableByteRange	.\Range.h	/^typedef Range<unsigned char*> MutableByteRange;$/;"	t	namespace:folly
MutableStringPiece	.\Range.h	/^typedef Range<char*> MutableStringPiece;$/;"	t	namespace:folly
MyFunctor	.\test\ScopeGuardTest.cpp	/^  explicit MyFunctor(int* ptr) : ptr_(ptr) {}$/;"	f	class:MyFunctor	access:public	signature:(int* ptr)
MyFunctor	.\test\ScopeGuardTest.cpp	/^class MyFunctor {$/;"	c	file:
MyFunctor::MyFunctor	.\test\ScopeGuardTest.cpp	/^  explicit MyFunctor(int* ptr) : ptr_(ptr) {}$/;"	f	class:MyFunctor	access:public	signature:(int* ptr)
MyFunctor::operator ()	.\test\ScopeGuardTest.cpp	/^  void operator()() {$/;"	f	class:MyFunctor	access:public	signature:()
MyFunctor::ptr_	.\test\ScopeGuardTest.cpp	/^  int* ptr_;$/;"	m	class:MyFunctor	file:	access:private
MyMap	.\test\AHMIntStressTest.cpp	/^typedef folly::AtomicHashMap<int,std::shared_ptr<MyObject>> MyMap;$/;"	t	namespace:__anon102	file:
MyObject	.\test\AHMIntStressTest.cpp	/^  explicit MyObject(int i) : i(i) {}$/;"	f	struct:__anon102::MyObject	access:public	signature:(int i)
MyObject	.\test\AHMIntStressTest.cpp	/^struct MyObject {$/;"	s	namespace:__anon102	file:
MyObjectDirectory	.\test\AHMIntStressTest.cpp	/^  MyObjectDirectory()$/;"	f	struct:__anon102::MyObjectDirectory	access:public	signature:()
MyObjectDirectory	.\test\AHMIntStressTest.cpp	/^struct MyObjectDirectory {$/;"	s	namespace:__anon102	file:
NONE	.\FormatArg.h	/^    NONE,$/;"	m	class:folly::FormatArg::NextKeyMode	access:private
NONE	.\io\async\EventHandler.h	/^    NONE = 0,$/;"	e	enum:folly::EventHandler::EventFlags
NORMAL	.\IPAddressV6.h	/^    TEREDO, T6TO4, NORMAL,$/;"	e	enum:folly::IPAddressV6::Type
NOTHING	.\test\MPMCQueueTest.cpp	/^  NOTHING = -1,$/;"	e	enum:LifecycleEvent	file:
NOTHING	.\wangle\Try.h	/^    NOTHING,$/;"	m	class:folly::wangle::Try::Contains	access:private
NOT_POLLABLE	.\experimental\io\AsyncIO.h	/^    NOT_POLLABLE,$/;"	e	enum:folly::AsyncIO::PollMode
NOT_STARTED	.\Subprocess.h	/^    NOT_STARTED,$/;"	e	enum:folly::ProcessReturnCode::State
NO_COMPRESSION	.\io\Compression.h	/^  NO_COMPRESSION = 1,$/;"	m	class:folly::io::CodecType	access:private
NO_FILE_AND_LINE	.\experimental\symbolizer\Symbolizer.h	/^    NO_FILE_AND_LINE = 1 << 0,$/;"	e	enum:folly::symbolizer::SymbolizePrinter::Options
NULLT	.\dynamic.h	/^    NULLT,$/;"	e	enum:folly::dynamic::Type
NUMBUF	.\test\SpookyHashV1Test.cpp	260;"	d	file:
NUMBUF	.\test\SpookyHashV1Test.cpp	317;"	d	file:
NUMBUF	.\test\SpookyHashV2Test.cpp	186;"	d	file:
NUMBUF	.\test\SpookyHashV2Test.cpp	243;"	d	file:
NUMITER	.\test\SpookyHashV1Test.cpp	322;"	d	file:
NUMITER	.\test\SpookyHashV2Test.cpp	248;"	d	file:
NUM_CODEC_TYPES	.\io\Compression.h	/^  NUM_CODEC_TYPES = 8,$/;"	m	class:folly::io::CodecType	access:private
NUM_LEVELS	.\test\TimeseriesHistogramTest.cpp	/^    NUM_LEVELS,$/;"	e	enum:IntMHTS::Levels	file:
NUM_LEVELS	.\test\TimeseriesHistogramTest.cpp	/^    NUM_LEVELS,$/;"	e	enum:IntMTMHTS::Levels	file:
NUM_LEVELS	.\test\TimeseriesTest.cpp	/^    NUM_LEVELS,$/;"	e	enum:IntMHTS::Levels	file:
NamedThreadFactory	.\experimental\wangle\concurrent\NamedThreadFactory.h	/^  explicit NamedThreadFactory(folly::StringPiece prefix)$/;"	f	class:folly::wangle::NamedThreadFactory	access:public	signature:(folly::StringPiece prefix)
NamedThreadFactory	.\experimental\wangle\concurrent\NamedThreadFactory.h	/^class NamedThreadFactory : public ThreadFactory {$/;"	c	namespace:folly::wangle	inherits:ThreadFactory
NanosecondsSpent	.\Benchmark.h	/^  typedef uint64_t NanosecondsSpent;$/;"	t	struct:folly::BenchmarkSuspender	access:public
NeededSingleton	.\experimental\test\SingletonTest.cpp	/^struct NeededSingleton {};$/;"	s	file:
NeedleFinderTest	.\test\RangeTest.cpp	/^class NeedleFinderTest : public ::testing::Test {$/;"	c	file:	inherits:::testing::Test
NeedleFinderTest::find_first_byte_of	.\test\RangeTest.cpp	/^  static size_t find_first_byte_of(StringPiece haystack, StringPiece needles) {$/;"	f	class:NeedleFinderTest	access:public	signature:(StringPiece haystack, StringPiece needles)
NeedleFinders	.\test\RangeTest.cpp	/^                         ByteSetNeedleFinder> NeedleFinders;$/;"	t	file:
NeedySingleton	.\experimental\test\SingletonTest.cpp	/^  NeedySingleton() {$/;"	f	struct:NeedySingleton	access:public	signature:()
NeedySingleton	.\experimental\test\SingletonTest.cpp	/^struct NeedySingleton {$/;"	s	file:
NeedySingleton::NeedySingleton	.\experimental\test\SingletonTest.cpp	/^  NeedySingleton() {$/;"	f	struct:NeedySingleton	access:public	signature:()
NewTag	.\test\ThreadLocalTest.cpp	/^  class NewTag;$/;"	x	file:
NextKeyMode	.\FormatArg.h	/^  enum class NextKeyMode {$/;"	c	struct:folly::FormatArg	access:private
NoCV	.\test\HasMemberFnTraitsTest.cpp	/^struct NoCV {$/;"	s	file:
NoCV::test	.\test\HasMemberFnTraitsTest.cpp	/^  void test();$/;"	p	struct:NoCV	file:	access:public	signature:()
NoCompressionCodec	.\io\Compression.cpp	/^  explicit NoCompressionCodec(int level, CodecType type);$/;"	p	class:folly::io::__anon64::FOLLY_FINAL	file:	access:public	signature:(int level, CodecType type)
NoCompressionCodec	.\io\Compression.cpp	/^NoCompressionCodec::NoCompressionCodec(int level, CodecType type)$/;"	f	class:folly::io::__anon64::NoCompressionCodec	signature:(int level, CodecType type)
NoDefault	.\test\OptionalTest.cpp	/^  NoDefault(int, int) {}$/;"	f	struct:folly::NoDefault	access:public	signature:(int, int)
NoDefault	.\test\OptionalTest.cpp	/^struct NoDefault {$/;"	s	namespace:folly	file:
NoHeap	.\small_vector.h	/^struct NoHeap;$/;"	x
NoSseNeedleFinder	.\test\RangeTest.cpp	/^struct NoSseNeedleFinder {$/;"	s	file:
NoSseNeedleFinder::find_first_byte_of	.\test\RangeTest.cpp	/^  static size_t find_first_byte_of(StringPiece haystack, StringPiece needles) {$/;"	f	struct:NoSseNeedleFinder	access:public	signature:(StringPiece haystack, StringPiece needles)
NoState	.\wangle\WangleException.h	/^    explicit NoState() : WangleException("No state") { }$/;"	f	class:folly::wangle::NoState	access:public	signature:()
NoState	.\wangle\WangleException.h	/^class NoState : public WangleException {$/;"	c	namespace:folly::wangle	inherits:WangleException
Node	.\EvictingCacheMap.h	/^    Node(const TKey& key, TValue&& value)$/;"	f	struct:folly::EvictingCacheMap::Node	access:public	signature:(const TKey& key, TValue&& value)
Node	.\EvictingCacheMap.h	/^  struct Node$/;"	s	class:folly::EvictingCacheMap	inherits:boost::intrusive::unordered_set_base_hook,boost::intrusive::list_base_hook	access:private
Node	.\EvictingCacheMap.h	/^  struct Node;$/;"	x
Node	.\Padded.h	/^  typedef typename Container::value_type Node;$/;"	t	class:folly::Adaptor	access:public
Node	.\Padded.h	/^class Node;$/;"	x
Node	.\experimental\exception_tracer\StackTrace.cpp	/^  Node() : next(nullptr) { }$/;"	f	class:folly::exception_tracer::StackTraceStack::Node	file:	access:private	signature:()
Node	.\experimental\exception_tracer\StackTrace.cpp	/^class StackTraceStack::Node : public StackTrace {$/;"	c	class:folly::exception_tracer::StackTraceStack	file:	inherits:StackTrace
Node	.\experimental\exception_tracer\StackTrace.h	/^  class Node;$/;"	x
NodeList	.\EvictingCacheMap.h	/^  typedef boost::intrusive::list<Node> NodeList;$/;"	t	class:folly::EvictingCacheMap	access:private
NodeMap	.\EvictingCacheMap.h	/^  typedef boost::intrusive::unordered_set<Node> NodeMap;$/;"	t	class:folly::EvictingCacheMap	access:private
NodeRecycler	.\ConcurrentSkipList-inl.h	/^  explicit NodeRecycler(const NodeAlloc& alloc) : alloc_(alloc) { }$/;"	f	class:folly::detail::NodeRecycler	access:public	signature:(const NodeAlloc& alloc)
NodeRecycler	.\ConcurrentSkipList-inl.h	/^  explicit NodeRecycler(const NodeAlloc& alloc)$/;"	f	class:folly::detail::NodeRecycler	access:public	signature:(const NodeAlloc& alloc)
NodeRecycler	.\ConcurrentSkipList-inl.h	/^class NodeRecycler;$/;"	x
NodeRecycler	.\ConcurrentSkipList-inl.h	/^class NodeRecycler<NodeType, NodeAlloc, typename std::enable_if<$/;"	c	namespace:folly::detail
NodeType	.\ConcurrentSkipList.h	/^  typedef detail::SkipListNode<T> NodeType;$/;"	t	class:folly::ConcurrentSkipList	access:public
NodeType	.\ConcurrentSkipList.h	/^  typedef detail::SkipListNode<T> NodeType;$/;"	t	class:folly::ConcurrentSkipList::Accessor	access:private
NodeType	.\ConcurrentSkipList.h	/^  typedef detail::SkipListNode<T> NodeType;$/;"	t	class:folly::ConcurrentSkipList::Skipper	access:private
NodeValid	.\Padded.h	/^template <class T, size_t NS, class Enable=void> struct NodeValid;$/;"	x
NoncopyableCounter	.\test\small_vector_test.cpp	/^  NoncopyableCounter() {$/;"	f	struct:__anon132::NoncopyableCounter	access:public	signature:()
NoncopyableCounter	.\test\small_vector_test.cpp	/^  NoncopyableCounter(NoncopyableCounter const&) = delete;$/;"	p	struct:__anon132::NoncopyableCounter	file:	access:public	signature:(NoncopyableCounter const&)
NoncopyableCounter	.\test\small_vector_test.cpp	/^  NoncopyableCounter(NoncopyableCounter&&) { ++alive; }$/;"	f	struct:__anon132::NoncopyableCounter	access:public	signature:(NoncopyableCounter&&)
NoncopyableCounter	.\test\small_vector_test.cpp	/^struct NoncopyableCounter {$/;"	s	namespace:__anon132	file:
None	.\Optional.h	/^typedef int detail::NoneHelper::*None;$/;"	t	class:folly::detail::NoneHelper
NoneHelper	.\Optional.h	/^namespace detail { struct NoneHelper {}; }$/;"	s	namespace:folly::detail
NontrivialType	.\test\small_vector_test.cpp	/^  NontrivialType(NontrivialType const& s) {$/;"	f	struct:__anon132::NontrivialType	access:public	signature:(NontrivialType const& s)
NontrivialType	.\test\small_vector_test.cpp	/^  \/* implicit *\/ NontrivialType(int a) : a(a) {$/;"	f	struct:__anon132::NontrivialType	access:public	signature:(int a)
NontrivialType	.\test\small_vector_test.cpp	/^  explicit NontrivialType() : a(0) {}$/;"	f	struct:__anon132::NontrivialType	access:public	signature:()
NontrivialType	.\test\small_vector_test.cpp	/^struct NontrivialType {$/;"	s	namespace:__anon132	file:
NotificationCallback	.\experimental\io\AsyncIO.h	/^  typedef std::function<void(AsyncIOOp*)> NotificationCallback;$/;"	t	class:folly::AsyncIOOp	access:public
NotificationQueue	.\io\async\EventBase.h	/^class NotificationQueue;$/;"	x
NotificationQueue	.\io\async\NotificationQueue.h	/^  NotificationQueue(NotificationQueue const &) = delete;$/;"	p	class:folly::NotificationQueue	access:private	signature:(NotificationQueue const &)
NotificationQueue	.\io\async\NotificationQueue.h	/^  explicit NotificationQueue(uint32_t maxSize = 0,$/;"	f	class:folly::NotificationQueue	access:public	signature:(uint32_t maxSize = 0, FdType fdType = FdType::EVENTFD)
NotificationQueue	.\io\async\NotificationQueue.h	/^class NotificationQueue {$/;"	c	namespace:folly
Num2String	.\test\FBStringBenchmark.cpp	/^void Num2String(String& str, Integral n) {$/;"	f	signature:(String& str, Integral n)
Num2String	.\test\FBStringTest.cpp	/^void Num2String(String& str, Integral n) {$/;"	f	signature:(String& str, Integral n)
Num2String	.\test\FBVectorBenchmark.cpp	/^void Num2String(String& str, Integral n) {$/;"	f	signature:(String& str, Integral n)
Num2String	.\test\FBVectorTest.cpp	/^void Num2String(String& str, Integral n) {$/;"	f	signature:(String& str, Integral n)
NumLocalLists	.\IndexedMemPool.h	/^    NumLocalLists = NumLocalLists_,$/;"	e	enum:folly::IndexedMemPool::__anon61
OBJECT	.\dynamic.h	/^    OBJECT,$/;"	e	enum:folly::dynamic::Type
OC_NOEXCEPT	.\test\stl_tests\StlVectorTest.cpp	/^  OC_NOEXCEPT = 0x40,$/;"	e	enum:Flags	file:
OC_THROW	.\test\stl_tests\StlVectorTest.cpp	/^  OC_THROW    = 0x80,$/;"	e	enum:Flags	file:
OStreamSymbolizePrinter	.\experimental\symbolizer\Symbolizer.cpp	/^OStreamSymbolizePrinter::OStreamSymbolizePrinter(std::ostream& out, int options)$/;"	f	class:folly::symbolizer::OStreamSymbolizePrinter	signature:(std::ostream& out, int options)
OStreamSymbolizePrinter	.\experimental\symbolizer\Symbolizer.h	/^  explicit OStreamSymbolizePrinter(std::ostream& out, int options=0);$/;"	p	class:folly::symbolizer::OStreamSymbolizePrinter	access:public	signature:(std::ostream& out, int options=0)
OStreamSymbolizePrinter	.\experimental\symbolizer\Symbolizer.h	/^class OStreamSymbolizePrinter : public SymbolizePrinter {$/;"	c	namespace:folly::symbolizer	inherits:SymbolizePrinter
OUTPUT_FILE	.\build\generate_escape_tables.py	/^OUTPUT_FILE = "EscapeTables.cpp"$/;"	v
OUTPUT_FILE	.\build\generate_format_tables.py	/^OUTPUT_FILE = "FormatTables.cpp"$/;"	v
OUTPUT_FILE	.\build\generate_varint_tables.py	/^OUTPUT_FILE = "GroupVarintTables.cpp"$/;"	v
ObjectImpl	.\dynamic-inl.h	/^struct dynamic::ObjectImpl : std::unordered_map<dynamic, dynamic> {};$/;"	s	class:folly::dynamic	inherits:std::unordered_map
ObjectImpl	.\dynamic.h	/^  struct ObjectImpl;$/;"	x
ObjectMaker	.\dynamic-inl.h	/^  ObjectMaker(ObjectMaker const&) = delete;$/;"	p	struct:folly::dynamic::ObjectMaker	access:public	signature:(ObjectMaker const&)
ObjectMaker	.\dynamic-inl.h	/^  ObjectMaker(ObjectMaker&&) = default;$/;"	p	struct:folly::dynamic::ObjectMaker	access:public	signature:(ObjectMaker&&)
ObjectMaker	.\dynamic-inl.h	/^  explicit ObjectMaker() : val_(dynamic::object) {}$/;"	f	struct:folly::dynamic::ObjectMaker	access:public	signature:()
ObjectMaker	.\dynamic-inl.h	/^  explicit ObjectMaker(dynamic const& key, dynamic val)$/;"	f	struct:folly::dynamic::ObjectMaker	access:public	signature:(dynamic const& key, dynamic val)
ObjectMaker	.\dynamic-inl.h	/^  explicit ObjectMaker(dynamic&& key, dynamic val)$/;"	f	struct:folly::dynamic::ObjectMaker	access:public	signature:(dynamic&& key, dynamic val)
ObjectMaker	.\dynamic-inl.h	/^struct dynamic::ObjectMaker {$/;"	s	class:folly::dynamic
ObjectMaker	.\dynamic.h	/^  struct ObjectMaker;$/;"	x
OnThreadExit	.\test\ThreadLocalTest.cpp	/^  static void OnThreadExit(void* obj) {$/;"	f	class:PThreadGetSpecific	access:public	signature:(void* obj)
OneAtATimePolicy	.\test\sorted_vector_test.cpp	/^struct OneAtATimePolicy {$/;"	s	namespace:__anon133	file:
Op	.\experimental\io\AsyncIO.h	/^  typedef AsyncIOOp Op;$/;"	t	class:folly::AsyncIO	access:public
OpFactory	.\experimental\io\AsyncIO.h	/^  typedef std::function<AsyncIOOp*()> OpFactory;$/;"	t	class:folly::AsyncIOQueue	access:public
Opaque	.\test\FormatTest.cpp	/^struct Opaque {$/;"	s	namespace:__anon120	file:
OpaqueCallbackLaterShunt	.\wangle\OpaqueCallbackShunt.h	/^  OpaqueCallbackLaterShunt(T&& obj, std::function<void(T&&)>&& fn)$/;"	f	class:folly::wangle::OpaqueCallbackLaterShunt	access:public	signature:(T&& obj, std::function<void(T&&)>&& fn)
OpaqueCallbackLaterShunt	.\wangle\OpaqueCallbackShunt.h	/^class OpaqueCallbackLaterShunt {$/;"	c	namespace:folly::wangle
OpaqueCallbackShunt	.\wangle\OpaqueCallbackShunt.h	/^  explicit OpaqueCallbackShunt(T&& obj)$/;"	f	class:folly::wangle::OpaqueCallbackShunt	access:public	signature:(T&& obj)
OpaqueCallbackShunt	.\wangle\OpaqueCallbackShunt.h	/^class OpaqueCallbackShunt {$/;"	c	namespace:folly::wangle
Operator	.\gen\Core-inl.h	/^  Operator() = default;$/;"	p	class:folly::gen::Operator	access:protected	signature:()
Operator	.\gen\Core-inl.h	/^  Operator(const Operator&) = default;$/;"	p	class:folly::gen::Operator	access:protected	signature:(const Operator&)
Operator	.\gen\Core-inl.h	/^class Operator : public FBounded<Self> {$/;"	c	namespace:folly::gen	inherits:FBounded
Operator	.\gen\Core.h	/^class Operator;$/;"	x
OptionParser	.\build\generate_escape_tables.py	/^from optparse import OptionParser$/;"	i
OptionParser	.\build\generate_format_tables.py	/^from optparse import OptionParser$/;"	i
OptionParser	.\build\generate_varint_tables.py	/^from optparse import OptionParser$/;"	i
Optional	.\Optional.h	/^  Optional()$/;"	f	class:folly::Optional	access:public	signature:()
Optional	.\Optional.h	/^class Optional {$/;"	c	namespace:folly
Options	.\MemoryMapping.h	/^    Options() { }$/;"	f	struct:folly::MemoryMapping::Options	access:public	signature:()
Options	.\MemoryMapping.h	/^  struct Options {$/;"	s	class:folly::MemoryMapping	access:public
Options	.\Subprocess.h	/^    Options()$/;"	f	class:folly::Subprocess::Options	access:public	signature:()
Options	.\Subprocess.h	/^  class Options : private boost::orable<Options> {$/;"	c	class:folly::Subprocess	inherits:boost::orable	access:public
Options	.\experimental\symbolizer\Symbolizer.h	/^  enum Options {$/;"	g	class:folly::symbolizer::SymbolizePrinter	access:public
Options	.\io\IOBufQueue.h	/^    Options() : cacheChainLength(false) { }$/;"	f	struct:folly::IOBufQueue::Options	access:public	signature:()
Options	.\io\IOBufQueue.h	/^  struct Options {$/;"	s	class:folly::IOBufQueue	access:public
Order	.\gen\Base-inl.h	/^  Order() {}$/;"	f	class:folly::gen::detail::Order	access:public	signature:()
Order	.\gen\Base-inl.h	/^  Order(Selector selector,$/;"	f	class:folly::gen::detail::Order	access:public	signature:(Selector selector, Comparer comparer)
Order	.\gen\Base-inl.h	/^  explicit Order(Selector selector)$/;"	f	class:folly::gen::detail::Order	access:public	signature:(Selector selector)
Order	.\gen\Base-inl.h	/^class Order : public Operator<Order<Selector, Comparer>> {$/;"	c	namespace:folly::gen::detail	inherits:Operator
Order	.\gen\Base.h	/^class Order;$/;"	x
OutQueue	.\gen\Parallel-inl.h	/^    typedef ClosableMPMCQueue<OutputDecayed> OutQueue;$/;"	t	class:folly::gen::detail::Parallel::Generator	access:private
OutputConverter	.\String-inl.h	/^template<> struct OutputConverter<StringPiece> {$/;"	s	namespace:folly::detail
OutputConverter	.\String-inl.h	/^template<> struct OutputConverter<fbstring> {$/;"	s	namespace:folly::detail
OutputConverter	.\String-inl.h	/^template<> struct OutputConverter<std::string> {$/;"	s	namespace:folly::detail
OutputConverter	.\String-inl.h	/^template<class OutStringT> struct OutputConverter {};$/;"	s	namespace:folly::detail
Overloaded	.\test\ApplyTupleTest.cpp	/^struct Overloaded {$/;"	s	namespace:__anon104	file:
Owner	.\test\stl_tests\StlVectorTest.cpp	/^  static map<void*, int> Owner;$/;"	m	struct:AllocTracker	file:	access:public
Owner	.\test\stl_tests\StlVectorTest.cpp	/^map<void*, int> AllocTracker::Owner;$/;"	m	class:AllocTracker	file:
OwnershipTestClass	.\io\test\IOBufTest.cpp	/^  explicit OwnershipTestClass(int v = 0) : val(v) { }$/;"	f	struct:__anon71::OwnershipTestClass	access:public	signature:(int v = 0)
OwnershipTestClass	.\io\test\IOBufTest.cpp	/^struct OwnershipTestClass {$/;"	s	namespace:__anon71	file:
P	.\test\MemoryTest.cpp	/^template <std::size_t> struct P {};$/;"	s	file:
P1	.\experimental\symbolizer\Elf.cpp	150;"	d	file:
P1	.\experimental\symbolizer\Elf.cpp	156;"	d	file:
P2	.\experimental\symbolizer\Elf.cpp	151;"	d	file:
P2	.\experimental\symbolizer\Elf.cpp	157;"	d	file:
PAD_AFTER_SIGN	.\FormatArg.h	/^    PAD_AFTER_SIGN,$/;"	m	class:folly::FormatArg::Align	access:private
PAGE_FOR	.\Range.cpp	72;"	d	file:
PATH	.\String.h	/^  PATH = 2$/;"	m	class:folly::UriEscapeMode	access:private
PC_BENCH	.\test\MPMCQueueTest.cpp	349;"	d	file:
PENDING	.\experimental\io\AsyncIO.h	/^    PENDING,$/;"	m	class:folly::AsyncIOOp::State	access:private
PERMANENT	.\experimental\TestUtil.h	/^    PERMANENT,$/;"	m	class:folly::test::TemporaryDirectory::Scope	access:private
PERMANENT	.\experimental\TestUtil.h	/^    PERMANENT,$/;"	m	class:folly::test::TemporaryFile::Scope	access:private
PERSIST	.\io\async\EventHandler.h	/^    PERSIST = EV_PERSIST$/;"	e	enum:folly::EventHandler::EventFlags
PIPE	.\Subprocess.h	/^  static const int PIPE = -2;$/;"	m	class:folly::Subprocess	access:public
PIPE_IN	.\Subprocess.h	/^  static const int PIPE_IN = -3;$/;"	m	class:folly::Subprocess	access:public
PIPE_OUT	.\Subprocess.h	/^  static const int PIPE_OUT = -4;$/;"	m	class:folly::Subprocess	access:public
PLUS_OR_MINUS	.\FormatArg.h	/^    PLUS_OR_MINUS,$/;"	m	class:folly::FormatArg::Sign	access:private
PMap	.\gen\ParallelMap-inl.h	/^  PMap() {}$/;"	f	class:folly::gen::detail::PMap	access:public	signature:()
PMap	.\gen\ParallelMap-inl.h	/^  PMap(Predicate pred, size_t nThreads)$/;"	f	class:folly::gen::detail::PMap	access:public	signature:(Predicate pred, size_t nThreads)
PMap	.\gen\ParallelMap-inl.h	/^class PMap : public Operator<PMap<Predicate>> {$/;"	c	namespace:folly::gen::detail	inherits:Operator
PMap	.\gen\ParallelMap.h	/^class PMap;$/;"	x
POLLABLE	.\experimental\io\AsyncIO.h	/^    POLLABLE$/;"	e	enum:folly::AsyncIO::PollMode
PREFIX_6TO4	.\IPAddressV6.cpp	/^const uint32_t IPAddressV6::PREFIX_6TO4 = 0x2002;$/;"	m	class:folly::IPAddressV6	file:
PREFIX_6TO4	.\IPAddressV6.h	/^  static const uint32_t PREFIX_6TO4;$/;"	m	class:folly::IPAddressV6	access:public
PREFIX_TEREDO	.\IPAddressV6.cpp	/^const uint32_t IPAddressV6::PREFIX_TEREDO = 0x20010000;$/;"	m	class:folly::IPAddressV6	file:
PREFIX_TEREDO	.\IPAddressV6.h	/^  static const uint32_t PREFIX_TEREDO;$/;"	m	class:folly::IPAddressV6	access:public
PRETTY_BYTES	.\String.h	/^  PRETTY_BYTES = PRETTY_BYTES_BINARY,$/;"	e	enum:folly::UriEscapeMode::PrettyType
PRETTY_BYTES_BINARY	.\String.h	/^  PRETTY_BYTES_BINARY,$/;"	e	enum:folly::UriEscapeMode::PrettyType
PRETTY_BYTES_BINARY_IEC	.\String.h	/^  PRETTY_BYTES_BINARY_IEC,$/;"	e	enum:folly::UriEscapeMode::PrettyType
PRETTY_BYTES_IEC	.\String.h	/^  PRETTY_BYTES_IEC = PRETTY_BYTES_BINARY_IEC,$/;"	e	enum:folly::UriEscapeMode::PrettyType
PRETTY_BYTES_METRIC	.\String.h	/^  PRETTY_BYTES_METRIC,$/;"	e	enum:folly::UriEscapeMode::PrettyType
PRETTY_NUM_TYPES	.\String.h	/^  PRETTY_NUM_TYPES,$/;"	e	enum:folly::UriEscapeMode::PrettyType
PRETTY_SI	.\String.h	/^  PRETTY_SI,$/;"	e	enum:folly::UriEscapeMode::PrettyType
PRETTY_TIME	.\String.h	/^  PRETTY_TIME,$/;"	e	enum:folly::UriEscapeMode::PrettyType
PRETTY_UNITS_BINARY	.\String.h	/^  PRETTY_UNITS_BINARY,$/;"	e	enum:folly::UriEscapeMode::PrettyType
PRETTY_UNITS_BINARY_IEC	.\String.h	/^  PRETTY_UNITS_BINARY_IEC,$/;"	e	enum:folly::UriEscapeMode::PrettyType
PRETTY_UNITS_METRIC	.\String.h	/^  PRETTY_UNITS_METRIC,$/;"	e	enum:folly::UriEscapeMode::PrettyType
PRIVATE	.\io\Cursor.h	/^  PRIVATE,$/;"	m	class:folly::io::CursorAccess	access:private
PRODUCER_CONSUMER_QUEUE_H_	.\ProducerConsumerQueue.h	21;"	d
PROP_COPY	.\test\stl_tests\StlVectorTest.cpp	/^  PROP_COPY = 0x100000,$/;"	e	enum:Flags	file:
PROP_MOVE	.\test\stl_tests\StlVectorTest.cpp	/^  PROP_MOVE = 0x200000,$/;"	e	enum:Flags	file:
PROP_SWAP	.\test\stl_tests\StlVectorTest.cpp	/^  PROP_SWAP = 0x400000,$/;"	e	enum:Flags	file:
PThreadGetSpecific	.\test\ThreadLocalTest.cpp	/^  PThreadGetSpecific() : key_(0) {$/;"	f	class:PThreadGetSpecific	access:public	signature:()
PThreadGetSpecific	.\test\ThreadLocalTest.cpp	/^class PThreadGetSpecific {$/;"	c	file:
PThreadGetSpecific::OnThreadExit	.\test\ThreadLocalTest.cpp	/^  static void OnThreadExit(void* obj) {$/;"	f	class:PThreadGetSpecific	access:public	signature:(void* obj)
PThreadGetSpecific::PThreadGetSpecific	.\test\ThreadLocalTest.cpp	/^  PThreadGetSpecific() : key_(0) {$/;"	f	class:PThreadGetSpecific	access:public	signature:()
PThreadGetSpecific::get	.\test\ThreadLocalTest.cpp	/^  T* get() const {$/;"	f	class:PThreadGetSpecific	access:public	signature:() const
PThreadGetSpecific::key_	.\test\ThreadLocalTest.cpp	/^  pthread_key_t key_;$/;"	m	class:PThreadGetSpecific	file:	access:private
PThreadGetSpecific::reset	.\test\ThreadLocalTest.cpp	/^  void reset(T* t) {$/;"	f	class:PThreadGetSpecific	access:public	signature:(T* t)
PURPLE	.\experimental\symbolizer\Symbolizer.h	/^  enum Color { DEFAULT, RED, GREEN, YELLOW, BLUE, CYAN, WHITE, PURPLE };$/;"	e	enum:folly::symbolizer::SymbolizePrinter::Color
PUSH	.\LifoSem.h	/^    PUSH,$/;"	m	class:folly::detail::LifoSemBase::WaitResult	access:private
PackedSyncPtr	.\PackedSyncPtr.h	/^class PackedSyncPtr {$/;"	c	namespace:folly
PaddedSpinLock	.\SmallLocks.h	/^    PaddedSpinLock() : lock() { }$/;"	f	struct:folly::SpinLockArray::PaddedSpinLock	access:public	signature:()
PaddedSpinLock	.\SmallLocks.h	/^  struct PaddedSpinLock {$/;"	s	struct:folly::SpinLockArray	access:private
Parallel	.\gen\Parallel-inl.h	/^  Parallel(Ops ops, size_t threads) : ops_(std::move(ops)), threads_(threads) {}$/;"	f	class:folly::gen::detail::Parallel	access:public	signature:(Ops ops, size_t threads)
Parallel	.\gen\Parallel-inl.h	/^class Parallel : public Operator<Parallel<Ops>> {$/;"	c	namespace:folly::gen::detail	inherits:Operator
Parallel	.\gen\Parallel.h	/^class Parallel;$/;"	x
ParamType	.\gen\Base-inl.h	/^    typedef const StorageType& ParamType;$/;"	t	class:folly::gen::detail::Distinct::Generator	access:private
ParseError	.\json.h	/^    explicit ParseError(int line)$/;"	f	struct:folly::json::ParseError	access:public	signature:(int line)
ParseError	.\json.h	/^    explicit ParseError(int line, std::string const& context,$/;"	f	struct:folly::json::ParseError	access:public	signature:(int line, std::string const& context, std::string const& expected)
ParseError	.\json.h	/^    explicit ParseError(std::string const& msg)$/;"	f	struct:folly::json::ParseError	access:public	signature:(std::string const& msg)
ParseError	.\json.h	/^  struct ParseError : std::runtime_error {$/;"	s	namespace:folly::json	inherits:std::runtime_error
Path	.\experimental\symbolizer\Dwarf.cpp	/^Dwarf::Path::Path(folly::StringPiece baseDir, folly::StringPiece subDir,$/;"	f	class:folly::symbolizer::Dwarf::Path	signature:(folly::StringPiece baseDir, folly::StringPiece subDir, folly::StringPiece file)
Path	.\experimental\symbolizer\Dwarf.h	/^    Path() { }$/;"	f	class:folly::symbolizer::Dwarf::Path	access:public	signature:()
Path	.\experimental\symbolizer\Dwarf.h	/^    Path(folly::StringPiece baseDir, folly::StringPiece subDir,$/;"	p	class:folly::symbolizer::Dwarf::Path	access:public	signature:(folly::StringPiece baseDir, folly::StringPiece subDir, folly::StringPiece file)
Path	.\experimental\symbolizer\Dwarf.h	/^  class Path {$/;"	c	class:folly::symbolizer::Dwarf	access:public
Path	.\experimental\symbolizer\ElfCache.h	/^    explicit Path(StringPiece s) {$/;"	f	class:folly::symbolizer::SignalSafeElfCache::Path	access:public	signature:(StringPiece s)
Path	.\experimental\symbolizer\ElfCache.h	/^  class Path : private boost::totally_ordered<Path> {$/;"	c	class:folly::symbolizer::SignalSafeElfCache	inherits:boost::totally_ordered	access:private
Peek	.\io\Compression.cpp	/^const char* IOBufSnappySource::Peek(size_t* len) {$/;"	f	class:folly::io::__anon64::IOBufSnappySource	signature:(size_t* len)
PerfTest	.\test\ProducerConsumerQueueTest.cpp	/^  explicit PerfTest() : queue_(Size), done_(false) {}$/;"	f	struct:__anon128::PerfTest	access:public	signature:()
PerfTest	.\test\ProducerConsumerQueueTest.cpp	/^struct PerfTest {$/;"	s	namespace:__anon128	file:
PicoSpinLock	.\SmallLocks.h	/^struct PicoSpinLock {$/;"	s	namespace:folly
PipeHandler	.\io\test\EventBaseTest.cpp	/^  PipeHandler(EventBase* eventBase, int fd)$/;"	f	class:PipeHandler	access:public	signature:(EventBase* eventBase, int fd)
PipeHandler	.\io\test\EventBaseTest.cpp	/^class PipeHandler : public EventHandler {$/;"	c	file:	inherits:EventHandler
PipeHandler::PipeHandler	.\io\test\EventBaseTest.cpp	/^  PipeHandler(EventBase* eventBase, int fd)$/;"	f	class:PipeHandler	access:public	signature:(EventBase* eventBase, int fd)
PipeInfo	.\Subprocess.h	/^  struct PipeInfo : private boost::totally_ordered<PipeInfo> {$/;"	s	class:folly::Subprocess	inherits:boost::totally_ordered	access:private
PipelineStageInfo	.\detail\MPMCPipelineDetail.h	/^struct PipelineStageInfo<MPMCPipelineStage<T, Amp>> {$/;"	s	namespace:folly::detail
PipelineStageInfo	.\detail\MPMCPipelineDetail.h	/^template <class T> struct PipelineStageInfo {$/;"	s	namespace:folly::detail
Point	.\test\PaddedTest.cpp	/^  struct Point {$/;"	s	class:StructPaddedTestBase	file:	access:protected
PointNode	.\test\PaddedTest.cpp	/^  typedef padded::Node<Point, 64> PointNode;$/;"	t	class:StructPaddedTestBase	file:	access:protected
PointNodeVec	.\test\PaddedTest.cpp	/^  typedef std::vector<PointNode> PointNodeVec;$/;"	t	class:StructPaddedTestBase	file:	access:protected
Pointer	.\io\IOBuf.h	/^    typedef typename UniquePtr::pointer Pointer;$/;"	t	struct:folly::IOBuf::UniquePtrDeleter	access:public
PolicyList	.\small_vector.h	/^    typedef mpl::vector<InPolicyA,InPolicyB,InPolicyC> PolicyList;$/;"	t	struct:folly::detail::small_vector_base	access:public
PollMode	.\experimental\io\AsyncIO.h	/^  enum PollMode {$/;"	g	class:folly::AsyncIO	access:public
Pool	.\LifoSem.h	/^  typedef folly::IndexedMemPool<LifoSemRawNode<Atom>,32,200,Atom> Pool;$/;"	t	struct:folly::detail::LifoSemRawNode	access:public
PreBlockAttempts	.\Baton.h	/^    PreBlockAttempts = 300,$/;"	e	enum:folly::Baton::__anon2
PrettySuffix	.\String.cpp	/^struct PrettySuffix {$/;"	s	namespace:folly::__anon94	file:
PrettyTestCase	.\test\StringTest.cpp	/^struct PrettyTestCase{$/;"	s	file:
PrettyTestCase::prettyString	.\test\StringTest.cpp	/^  std::string prettyString;$/;"	m	struct:PrettyTestCase	file:	access:public
PrettyTestCase::prettyType	.\test\StringTest.cpp	/^  PrettyType prettyType;$/;"	m	struct:PrettyTestCase	file:	access:public
PrettyTestCase::realValue	.\test\StringTest.cpp	/^  double realValue;$/;"	m	struct:PrettyTestCase	file:	access:public
PrettyType	.\String.h	/^enum PrettyType {$/;"	g	class:folly::UriEscapeMode	access:private
PrettyType	.\test\stl_tests\StlVectorTest.cpp	/^struct PrettyType {$/;"	s	file:
PrettyType	.\test\stl_tests\StlVectorTest.cpp	/^struct PrettyType<Alloc<T>> {$/;"	s	file:
PrettyType	.\test\stl_tests\StlVectorTest.cpp	/^struct PrettyType<Data<f, pad>> {$/;"	s	file:
PrettyType	.\test\stl_tests\StlVectorTest.cpp	/^struct PrettyType<std::allocator<T>> {$/;"	s	file:
PrettyType::operator ()	.\test\stl_tests\StlVectorTest.cpp	/^  string operator()() {$/;"	f	struct:PrettyType	access:public	signature:()
Print	.\test\stl_tests\StlVectorTest.cpp	/^  static bool Print;$/;"	m	struct:Tracker	file:	access:public
Print	.\test\stl_tests\StlVectorTest.cpp	/^bool Tracker::Print = false;$/;"	m	class:Tracker	file:
PrintImpl	.\dynamic-inl.h	/^struct dynamic::PrintImpl {$/;"	s	class:folly::dynamic
PrintImpl	.\dynamic-inl.h	/^struct dynamic::PrintImpl<dynamic::Array> {$/;"	s	class:folly::dynamic
PrintImpl	.\dynamic-inl.h	/^struct dynamic::PrintImpl<dynamic::ObjectImpl> {$/;"	s	class:folly::dynamic
PrintImpl	.\dynamic.h	/^  template<class T> struct PrintImpl;$/;"	x
Printer	.\json.cpp	/^  explicit Printer(fbstring& out,$/;"	f	struct:folly::json::__anon75::Printer	access:public	signature:(fbstring& out, unsigned* indentLevel, serialization_opts const* opts)
Printer	.\json.cpp	/^struct Printer {$/;"	s	namespace:folly::json::__anon75	file:
ProcessReturnCode	.\Subprocess.h	/^  explicit ProcessReturnCode(int rv) : rawStatus_(rv) { }$/;"	f	class:folly::ProcessReturnCode	access:private	signature:(int rv)
ProcessReturnCode	.\Subprocess.h	/^class ProcessReturnCode {$/;"	c	namespace:folly
ProducerConsumerQueue	.\ProducerConsumerQueue.h	/^  explicit ProducerConsumerQueue(uint32_t size)$/;"	f	struct:folly::ProducerConsumerQueue	access:public	signature:(uint32_t size)
ProducerConsumerQueue	.\ProducerConsumerQueue.h	/^struct ProducerConsumerQueue : private boost::noncopyable {$/;"	s	namespace:folly	inherits:boost::noncopyable
Promise	.\wangle\Future.h	/^  friend class Promise<T>;$/;"	x
Promise	.\wangle\Promise-inl.h	/^Promise<T>::Promise() : retrieved_(false), state_(new detail::State<T>())$/;"	f	class:folly::wangle::Promise	signature:()
Promise	.\wangle\Promise-inl.h	/^Promise<T>::Promise(Promise<T>&& other) : state_(nullptr) {$/;"	f	class:folly::wangle::Promise	signature:(Promise<T>&& other)
Promise	.\wangle\Promise.h	/^  Promise();$/;"	p	class:folly::wangle::Promise	access:public	signature:()
Promise	.\wangle\Promise.h	/^  Promise(Promise const&) = delete;$/;"	p	class:folly::wangle::Promise	access:public	signature:(Promise const&)
Promise	.\wangle\Promise.h	/^  Promise(Promise<T>&&);$/;"	p	class:folly::wangle::Promise	access:public	signature:(Promise<T>&&)
Promise	.\wangle\Promise.h	/^class Promise {$/;"	c	namespace:folly::wangle
PromiseAlreadySatisfied	.\wangle\WangleException.h	/^    explicit PromiseAlreadySatisfied() :$/;"	f	class:folly::wangle::PromiseAlreadySatisfied	access:public	signature:()
PromiseAlreadySatisfied	.\wangle\WangleException.h	/^class PromiseAlreadySatisfied : public WangleException {$/;"	c	namespace:folly::wangle	inherits:WangleException
PruneHookCall	.\EvictingCacheMap.h	/^  typedef std::function<void(TKey, TValue&&)> PruneHookCall;$/;"	t	class:folly::EvictingCacheMap	access:public
PslTest	.\test\SmallLocksTest.cpp	/^  PslTest() { lock.init(); }$/;"	f	struct:__anon131::PslTest	access:public	signature:()
PslTest	.\test\SmallLocksTest.cpp	/^template<class T> struct PslTest {$/;"	s	namespace:__anon131	file:
Puller	.\gen\Parallel-inl.h	/^      explicit Puller(InQueue* queue) : queue_(queue) {}$/;"	f	class:folly::gen::detail::Parallel::Generator::Puller	access:public	signature:(InQueue* queue)
Puller	.\gen\Parallel-inl.h	/^    class Puller : public GenImpl<InputDecayed&&, Puller> {$/;"	c	class:folly::gen::detail::Parallel::Generator	inherits:GenImpl	access:private
Pusher	.\gen\Parallel-inl.h	/^      explicit Pusher(OutQueue* queue) : queue_(queue) {}$/;"	f	class:folly::gen::detail::Parallel::Generator::Pusher	access:public	signature:(OutQueue* queue)
Pusher	.\gen\Parallel-inl.h	/^    class Pusher : public Operator<Pusher<all>> {$/;"	c	class:folly::gen::detail::Parallel::Generator	inherits:Operator	access:private
QUERY	.\String.h	/^  QUERY = 1,$/;"	m	class:folly::UriEscapeMode	access:private
QuarterInt	.\RWSpinLock.h	/^    QuarterInt;$/;"	t	class:folly::RWTicketSpinLockT	access:private
QuarterInt	.\RWSpinLock.h	/^  typedef uint16_t QuarterInt;$/;"	t	struct:folly::detail::RWTicketIntTrait	access:public
QuarterInt	.\RWSpinLock.h	/^  typedef uint8_t QuarterInt;$/;"	t	struct:folly::detail::RWTicketIntTrait	access:public
QueueAppender	.\io\Cursor.h	/^  QueueAppender(IOBufQueue* queue, uint64_t growth) {$/;"	f	class:folly::io::QueueAppender	access:public	signature:(IOBufQueue* queue, uint64_t growth)
QueueAppender	.\io\Cursor.h	/^class QueueAppender : public detail::Writable<QueueAppender> {$/;"	c	namespace:folly::io	inherits:detail::Writable
QueuedImmediateExecutor	.\wangle\QueuedImmediateExecutor.h	/^class QueuedImmediateExecutor : public Executor {$/;"	c	namespace:folly::wangle	inherits:Executor
READ	.\io\async\EventHandler.h	/^    READ = EV_READ,$/;"	e	enum:folly::EventHandler::EventFlags
READ_TEST	.\experimental\test\BitsTest.cpp	291;"	d	file:
READ_TEST	.\experimental\test\BitsTest.cpp	300;"	d	file:
READ_WRITE	.\io\async\EventHandler.h	/^    READ_WRITE = (READ | WRITE),$/;"	e	enum:folly::EventHandler::EventFlags
RED	.\experimental\symbolizer\Symbolizer.h	/^  enum Color { DEFAULT, RED, GREEN, YELLOW, BLUE, CYAN, WHITE, PURPLE };$/;"	e	enum:folly::symbolizer::SymbolizePrinter::Color
REG	.\test\ThreadLocalTest.cpp	548;"	d	file:
REG_BASELINE	.\test\ThreadCachedIntTest.cpp	135;"	d	file:
REQUIRE_ERRNO	.\test\SocketAddressTest.cpp	607;"	d	file:
RIGHT	.\FormatArg.h	/^    RIGHT,$/;"	m	class:folly::FormatArg::Align	access:private
RUNNING	.\Subprocess.h	/^    RUNNING,$/;"	e	enum:folly::ProcessReturnCode::State
RV_NOT_STARTED	.\Subprocess.h	/^  static const int RV_NOT_STARTED = ProcessReturnCode::RV_NOT_STARTED;$/;"	m	class:folly::Subprocess	access:private
RV_NOT_STARTED	.\Subprocess.h	/^  static constexpr int RV_NOT_STARTED = -2;$/;"	m	class:folly::ProcessReturnCode	access:private
RV_RUNNING	.\Subprocess.h	/^  static const int RV_RUNNING = ProcessReturnCode::RV_RUNNING;$/;"	m	class:folly::Subprocess	access:private
RV_RUNNING	.\Subprocess.h	/^  static constexpr int RV_RUNNING = -1;$/;"	m	class:folly::ProcessReturnCode	access:private
RWCursor	.\io\Cursor.h	/^  explicit RWCursor(IOBuf* buf)$/;"	f	class:folly::io::RWCursor	access:public	signature:(IOBuf* buf)
RWCursor	.\io\Cursor.h	/^  explicit RWCursor(const detail::CursorBase<OtherDerived, OtherBuf>& cursor)$/;"	f	class:folly::io::RWCursor	access:public	signature:(const detail::CursorBase<OtherDerived, OtherBuf>& cursor)
RWCursor	.\io\Cursor.h	/^class RWCursor$/;"	c	namespace:folly::io	inherits:detail::CursorBase,detail::Writable
RWPrivateCursor	.\io\Cursor.h	/^typedef RWCursor<CursorAccess::PRIVATE> RWPrivateCursor;$/;"	t	namespace:folly::io
RWSpinLock	.\RWSpinLock.h	/^  RWSpinLock() : bits_(0) {}$/;"	f	class:folly::RWSpinLock	access:public	signature:()
RWSpinLock	.\RWSpinLock.h	/^  typedef RWTicketSpinLockT<kBitWidth, kFavorWriter> RWSpinLock;$/;"	t	class:folly::RWTicketSpinLockT	access:public
RWSpinLock	.\RWSpinLock.h	/^class RWSpinLock : boost::noncopyable {$/;"	c	namespace:folly	inherits:boost::noncopyable
RWSpinLockTest	.\test\RWSpinLockTest.cpp	/^template<typename RWSpinLockT> struct RWSpinLockTest: public testing::Test {$/;"	s	namespace:__anon130	file:	inherits:testing::Test
RWSpinLockType	.\test\RWSpinLockTest.cpp	/^  typedef RWSpinLockT RWSpinLockType;$/;"	t	struct:__anon130::RWSpinLockTest	file:	access:public
RWTicket	.\RWSpinLock.h	/^  union RWTicket {$/;"	u	class:folly::RWTicketSpinLockT	access:private
RWTicketIntTrait	.\RWSpinLock.h	/^struct RWTicketIntTrait<32> {$/;"	s	namespace:folly::detail
RWTicketIntTrait	.\RWSpinLock.h	/^struct RWTicketIntTrait<64> {$/;"	s	namespace:folly::detail
RWTicketIntTrait	.\RWSpinLock.h	/^template <size_t kBitWidth> struct RWTicketIntTrait {$/;"	s	namespace:folly::detail
RWTicketSpinLock32	.\RWSpinLock.h	/^typedef RWTicketSpinLockT<32> RWTicketSpinLock32;$/;"	t	namespace:folly
RWTicketSpinLock64	.\RWSpinLock.h	/^typedef RWTicketSpinLockT<64> RWTicketSpinLock64;$/;"	t	namespace:folly
RWTicketSpinLockT	.\RWSpinLock.h	/^  RWTicketSpinLockT() {$/;"	f	class:folly::RWTicketSpinLockT	access:public	signature:()
RWTicketSpinLockT	.\RWSpinLock.h	/^class RWTicketSpinLockT : boost::noncopyable {$/;"	c	namespace:folly	inherits:boost::noncopyable
RWUnshareCursor	.\io\Cursor.h	/^typedef RWCursor<CursorAccess::UNSHARE> RWUnshareCursor;$/;"	t	namespace:folly::io
RW_SPINLOCK_USE_X86_INTRINSIC_	.\RWSpinLock.h	114;"	d
RW_SPINLOCK_USE_X86_INTRINSIC_	.\RWSpinLock.h	117;"	d
RW_SPINLOCK_USE_X86_INTRINSIC_	.\RWSpinLock.h	743;"	d
Random	.\Random.h	/^  friend class Random;$/;"	x
Random	.\Random.h	/^class Random {$/;"	c	namespace:folly
Random	.\test\SpookyHashV1Test.cpp	/^class Random$/;"	c	file:
Random	.\test\SpookyHashV2Test.cpp	/^class Random$/;"	c	file:
Random::Init	.\test\SpookyHashV1Test.cpp	/^    inline void Init( uint64_t seed)$/;"	f	class:Random	access:public	signature:( uint64_t seed)
Random::Init	.\test\SpookyHashV2Test.cpp	/^    inline void Init( uint64_t seed)$/;"	f	class:Random	access:public	signature:( uint64_t seed)
Random::Rot64	.\test\SpookyHashV1Test.cpp	/^    static inline uint64_t Rot64(uint64_t x, int k)$/;"	f	class:Random	file:	access:private	signature:(uint64_t x, int k)
Random::Rot64	.\test\SpookyHashV2Test.cpp	/^    static inline uint64_t Rot64(uint64_t x, int k)$/;"	f	class:Random	file:	access:private	signature:(uint64_t x, int k)
Random::Value	.\test\SpookyHashV1Test.cpp	/^    inline uint64_t Value()$/;"	f	class:Random	access:public	signature:()
Random::Value	.\test\SpookyHashV2Test.cpp	/^    inline uint64_t Value()$/;"	f	class:Random	access:public	signature:()
Random::m_a	.\test\SpookyHashV1Test.cpp	/^    uint64_t m_a;$/;"	m	class:Random	file:	access:private
Random::m_a	.\test\SpookyHashV2Test.cpp	/^    uint64_t m_a;$/;"	m	class:Random	file:	access:private
Random::m_b	.\test\SpookyHashV1Test.cpp	/^    uint64_t m_b;$/;"	m	class:Random	file:	access:private
Random::m_b	.\test\SpookyHashV2Test.cpp	/^    uint64_t m_b;$/;"	m	class:Random	file:	access:private
Random::m_c	.\test\SpookyHashV1Test.cpp	/^    uint64_t m_c;$/;"	m	class:Random	file:	access:private
Random::m_c	.\test\SpookyHashV2Test.cpp	/^    uint64_t m_c;$/;"	m	class:Random	file:	access:private
Random::m_d	.\test\SpookyHashV1Test.cpp	/^    uint64_t m_d;$/;"	m	class:Random	file:	access:private
Random::m_d	.\test\SpookyHashV2Test.cpp	/^    uint64_t m_d;$/;"	m	class:Random	file:	access:private
RandomDataHolder	.\io\test\CompressionTest.cpp	/^  explicit RandomDataHolder(size_t sizeLog2);$/;"	p	class:folly::io::test::RandomDataHolder	file:	access:public	signature:(size_t sizeLog2)
RandomDataHolder	.\io\test\CompressionTest.cpp	/^RandomDataHolder::RandomDataHolder(size_t sizeLog2)$/;"	f	class:folly::io::test::RandomDataHolder	signature:(size_t sizeLog2)
RandomDataHolder	.\io\test\CompressionTest.cpp	/^class RandomDataHolder : public DataHolder {$/;"	c	namespace:folly::io::test	file:	inherits:DataHolder
RandomInt32	.\test\TimeseriesHistogramTest.cpp	/^typedef std::mt19937 RandomInt32;$/;"	t	file:
RandomList	.\test\FBStringBenchmark.cpp	/^std::list<char> RandomList(unsigned int maxSize) {$/;"	f	signature:(unsigned int maxSize)
RandomList	.\test\FBStringTest.cpp	/^std::list<char> RandomList(unsigned int maxSize) {$/;"	f	signature:(unsigned int maxSize)
RandomList	.\test\FBVectorBenchmark.cpp	/^std::list<char> RandomList(unsigned int maxSize) {$/;"	f	signature:(unsigned int maxSize)
RandomList	.\test\FBVectorTest.cpp	/^std::list<char> RandomList(unsigned int maxSize) {$/;"	f	signature:(unsigned int maxSize)
RandomT	.\test\FBStringBenchmark.cpp	/^typedef boost::mt19937 RandomT;$/;"	t	file:
RandomT	.\test\FBStringTest.cpp	/^typedef boost::mt19937 RandomT;$/;"	t	file:
RandomT	.\test\FBVectorBenchmark.cpp	/^typedef boost::mt19937 RandomT;$/;"	t	file:
RandomT	.\test\FBVectorTest.cpp	/^typedef boost::mt19937 RandomT;$/;"	t	file:
RandomT	.\test\SynchronizedTestLib-inl.h	/^typedef std::mt19937 RandomT;$/;"	t
Range	.\Range.h	/^  Range(const Range<Iter>& str,$/;"	f	class:folly::Range	access:public	signature:(const Range<Iter>& str, size_t startFrom, size_t size)
Range	.\Range.h	/^  Range(const fbstring& str, fbstring::size_type startFrom) {$/;"	f	class:folly::Range	access:public	signature:(const fbstring& str, fbstring::size_type startFrom)
Range	.\Range.h	/^  Range(const fbstring& str, fbstring::size_type startFrom,$/;"	f	class:folly::Range	access:public	signature:(const fbstring& str, fbstring::size_type startFrom, fbstring::size_type size)
Range	.\Range.h	/^  Range(const std::string& str, std::string::size_type startFrom) {$/;"	f	class:folly::Range	access:public	signature:(const std::string& str, std::string::size_type startFrom)
Range	.\Range.h	/^  Range(const std::string& str,$/;"	f	class:folly::Range	access:public	signature:(const std::string& str, std::string::size_type startFrom, std::string::size_type size)
Range	.\Range.h	/^  \/* implicit *\/ Range(Iter str)$/;"	f	class:folly::Range	access:public	signature:(Iter str)
Range	.\Range.h	/^  \/* implicit *\/ Range(const Range<OtherIter>& other)$/;"	f	class:folly::Range	access:public	signature:(const Range<OtherIter>& other)
Range	.\Range.h	/^  \/* implicit *\/ Range(const fbstring& str)$/;"	f	class:folly::Range	access:public	signature:(const fbstring& str)
Range	.\Range.h	/^  \/* implicit *\/ Range(const std::string& str)$/;"	f	class:folly::Range	access:public	signature:(const std::string& str)
Range	.\Range.h	/^  constexpr Range() : b_(), e_() {$/;"	f	class:folly::Range	access:public	signature:()
Range	.\Range.h	/^  constexpr Range(Iter start, Iter end) : b_(start), e_(end) {$/;"	f	class:folly::Range	access:public	signature:(Iter start, Iter end)
Range	.\Range.h	/^  constexpr Range(Iter start, size_t size)$/;"	f	class:folly::Range	access:public	signature:(Iter start, size_t size)
Range	.\Range.h	/^  constexpr \/* implicit *\/ Range(Iter str)$/;"	f	class:folly::Range	access:public	signature:(Iter str)
Range	.\Range.h	/^  constexpr \/* implicit *\/ Range(const Range<OtherIter>& other)$/;"	f	class:folly::Range	access:public	signature:(const Range<OtherIter>& other)
Range	.\Range.h	/^  constexpr explicit Range(const Range<OtherIter>& other)$/;"	f	class:folly::Range	access:public	signature:(const Range<OtherIter>& other)
Range	.\Range.h	/^  explicit Range(const Range<OtherIter>& other)$/;"	f	class:folly::Range	access:public	signature:(const Range<OtherIter>& other)
Range	.\Range.h	/^class Range : private boost::totally_ordered<Range<Iter> > {$/;"	c	namespace:folly	inherits:boost::totally_ordered
Range	.\Range.h	/^template <class T> class Range;$/;"	x
RangeConcat	.\gen\Base-inl.h	/^  RangeConcat() { }$/;"	f	class:folly::gen::detail::RangeConcat	access:public	signature:()
RangeConcat	.\gen\Base-inl.h	/^class RangeConcat : public Operator<RangeConcat> {$/;"	c	namespace:folly::gen::detail	inherits:Operator
RangeConcat	.\gen\Base.h	/^class RangeConcat;$/;"	x
RangeImpl	.\gen\Base-inl.h	/^  explicit RangeImpl(Value end) : end_(std::move(end)) { }$/;"	f	class:folly::gen::detail::RangeImpl	access:public	signature:(Value end)
RangeImpl	.\gen\Base-inl.h	/^class RangeImpl {$/;"	c	namespace:folly::gen::detail
RangeImpl	.\gen\Base.h	/^class RangeImpl;$/;"	x
RangeSource	.\gen\Base-inl.h	/^  RangeSource() {}$/;"	f	class:folly::gen::detail::RangeSource	access:public	signature:()
RangeSource	.\gen\Base-inl.h	/^  explicit RangeSource(Range<Iterator> range)$/;"	f	class:folly::gen::detail::RangeSource	access:public	signature:(Range<Iterator> range)
RangeSource	.\gen\Base-inl.h	/^class RangeSource : public GenImpl<typename Range<Iterator>::reference,$/;"	c	namespace:folly::gen::detail	inherits:GenImpl
RangeWithStepImpl	.\gen\Base-inl.h	/^  explicit RangeWithStepImpl(Value end, Distance step)$/;"	f	class:folly::gen::detail::RangeWithStepImpl	access:public	signature:(Value end, Distance step)
RangeWithStepImpl	.\gen\Base-inl.h	/^class RangeWithStepImpl {$/;"	c	namespace:folly::gen::detail
RangeWithStepImpl	.\gen\Base.h	/^class RangeWithStepImpl;$/;"	x
ReadHolder	.\RWSpinLock.h	/^    ReadHolder(ReadHolder&& other) : lock_(other.lock_) {$/;"	f	class:folly::RWSpinLock::ReadHolder	access:public	signature:(ReadHolder&& other)
ReadHolder	.\RWSpinLock.h	/^    explicit ReadHolder(RWSpinLock &lock) : lock_ (&lock) {$/;"	f	class:folly::RWTicketSpinLockT::ReadHolder	access:public	signature:(RWSpinLock &lock)
ReadHolder	.\RWSpinLock.h	/^    explicit ReadHolder(RWSpinLock *lock = nullptr) :$/;"	f	class:folly::RWTicketSpinLockT::ReadHolder	access:public	signature:(RWSpinLock *lock = nullptr)
ReadHolder	.\RWSpinLock.h	/^    explicit ReadHolder(RWSpinLock& lock) : lock_(&lock) {$/;"	f	class:folly::RWSpinLock::ReadHolder	access:public	signature:(RWSpinLock& lock)
ReadHolder	.\RWSpinLock.h	/^    explicit ReadHolder(RWSpinLock* lock = nullptr) : lock_(lock) {$/;"	f	class:folly::RWSpinLock::ReadHolder	access:public	signature:(RWSpinLock* lock = nullptr)
ReadHolder	.\RWSpinLock.h	/^    explicit ReadHolder(UpgradedHolder&& upgraded) : lock_(upgraded.lock_) {$/;"	f	class:folly::RWSpinLock::ReadHolder	access:public	signature:(UpgradedHolder&& upgraded)
ReadHolder	.\RWSpinLock.h	/^    explicit ReadHolder(WriteHolder *writer) : lock_(nullptr) {$/;"	f	class:folly::RWTicketSpinLockT::ReadHolder	access:public	signature:(WriteHolder *writer)
ReadHolder	.\RWSpinLock.h	/^    explicit ReadHolder(WriteHolder&& writer) : lock_(writer.lock_) {$/;"	f	class:folly::RWSpinLock::ReadHolder	access:public	signature:(WriteHolder&& writer)
ReadHolder	.\RWSpinLock.h	/^    friend class ReadHolder;$/;"	x
ReadHolder	.\RWSpinLock.h	/^  class ReadHolder : boost::noncopyable {$/;"	c	class:folly::RWTicketSpinLockT	inherits:boost::noncopyable	access:public
ReadHolder	.\RWSpinLock.h	/^  class ReadHolder {$/;"	c	class:folly::RWSpinLock	access:public
ReadHolder	.\RWSpinLock.h	/^  class ReadHolder;$/;"	x
ReadLinesCallback	.\Subprocess.h	/^    explicit ReadLinesCallback($/;"	f	class:folly::Subprocess::ReadLinesCallback	access:public	signature:( Callback&& fdLineCb, uint64_t maxLineLength = 0, char delimiter = , uint64_t bufSize = 1024 )
ReadLinesCallback	.\Subprocess.h	/^  class ReadLinesCallback {$/;"	c	class:folly::Subprocess	access:public
ReadTSC	.\test\stl_tests\StlVectorTest.cpp	/^uint64_t ReadTSC() {$/;"	f	signature:()
Reader	.\experimental\test\EliasFanoCodingTest.cpp	/^typedef EliasFanoReader<Encoder> Reader;$/;"	t	namespace:bm	file:
Reader	.\test\FileUtilTest.cpp	/^  Reader(off_t offset, StringPiece data, std::deque<ssize_t> spec);$/;"	p	class:folly::test::__anon117::Reader	file:	access:public	signature:(off_t offset, StringPiece data, std::deque<ssize_t> spec)
Reader	.\test\FileUtilTest.cpp	/^Reader::Reader(off_t offset, StringPiece data, std::deque<ssize_t> spec)$/;"	f	class:folly::test::__anon117::Reader	signature:(off_t offset, StringPiece data, std::deque<ssize_t> spec)
Reader	.\test\FileUtilTest.cpp	/^class Reader {$/;"	c	namespace:folly::test::__anon117	file:
RecordIOReader	.\io\RecordIO-inl.h	/^  friend class RecordIOReader;$/;"	x
RecordIOReader	.\io\RecordIO.cpp	/^RecordIOReader::RecordIOReader(File file, uint32_t fileId)$/;"	f	class:folly::RecordIOReader	signature:(File file, uint32_t fileId)
RecordIOReader	.\io\RecordIO.h	/^  explicit RecordIOReader(File file, uint32_t fileId = 0);$/;"	p	class:folly::RecordIOReader	access:public	signature:(File file, uint32_t fileId = 0)
RecordIOReader	.\io\RecordIO.h	/^class RecordIOReader {$/;"	c	namespace:folly
RecordIOWriter	.\io\RecordIO.cpp	/^RecordIOWriter::RecordIOWriter(File file, uint32_t fileId)$/;"	f	class:folly::RecordIOWriter	signature:(File file, uint32_t fileId)
RecordIOWriter	.\io\RecordIO.h	/^  explicit RecordIOWriter(File file, uint32_t fileId = 1);$/;"	p	class:folly::RecordIOWriter	access:public	signature:(File file, uint32_t fileId = 1)
RecordIOWriter	.\io\RecordIO.h	/^class RecordIOWriter {$/;"	c	namespace:folly
RecordInfo	.\io\RecordIO.h	/^struct RecordInfo {$/;"	s	namespace:folly::recordio_helpers
RecordT	.\test\AtomicHashMapTest.cpp	/^typedef AHMapT::value_type RecordT;$/;"	t	file:
Reduce	.\gen\Base-inl.h	/^  Reduce() {}$/;"	f	class:folly::gen::detail::Reduce	access:public	signature:()
Reduce	.\gen\Base-inl.h	/^  explicit Reduce(Reducer reducer)$/;"	f	class:folly::gen::detail::Reduce	access:public	signature:(Reducer reducer)
Reduce	.\gen\Base-inl.h	/^class Reduce : public Operator<Reduce<Reducer>> {$/;"	c	namespace:folly::gen::detail	inherits:Operator
Reduce	.\gen\Base.h	/^class Reduce;$/;"	x
RefCounted	.\test\MPMCQueueTest.cpp	/^  RefCounted() : rc(0) {}$/;"	f	struct:RefCounted	access:public	signature:()
RefCounted	.\test\MPMCQueueTest.cpp	/^struct RefCounted {$/;"	s	file:
RefCounted::RefCounted	.\test\MPMCQueueTest.cpp	/^  RefCounted() : rc(0) {}$/;"	f	struct:RefCounted	access:public	signature:()
RefCounted::rc	.\test\MPMCQueueTest.cpp	/^  mutable std::atomic<int> rc;$/;"	m	struct:RefCounted	file:	access:public
RefType	.\gen\Base.h	/^    RefType;$/;"	t	struct:folly::gen::detail::ValueTypeOfRange	access:public
ReferencedSource	.\gen\Base-inl.h	/^  explicit ReferencedSource(Container* container)$/;"	f	class:folly::gen::detail::ReferencedSource	access:public	signature:(Container* container)
ReferencedSource	.\gen\Base-inl.h	/^class ReferencedSource :$/;"	c	namespace:folly::gen::detail	inherits:GenImpl
ReferencedSource	.\gen\Base.h	/^class ReferencedSource;$/;"	x
Registering	.\experimental\Singleton.h	/^    Registering,$/;"	m	class:folly::SingletonVault::SingletonVaultState	access:private
RequestContext	.\io\async\AsyncTimeout.h	/^class RequestContext;$/;"	x
RequestContext	.\io\async\Request.h	/^class RequestContext {$/;"	c	namespace:folly
RequestContext	.\io\async\Request.h	/^class RequestContext;$/;"	x
RequestContextGuard	.\io\async\Request.h	/^  explicit RequestContextGuard(std::shared_ptr<RequestContext> ctx) {$/;"	f	class:folly::RequestContextGuard	access:public	signature:(std::shared_ptr<RequestContext> ctx)
RequestContextGuard	.\io\async\Request.h	/^class RequestContextGuard {$/;"	c	namespace:folly
RequestData	.\io\async\Request.h	/^class RequestData {$/;"	c	namespace:folly
RethrowExceptionType	.\experimental\exception_tracer\ExceptionTracerLib.cpp	/^FOLLY_NORETURN typedef void (*RethrowExceptionType)(std::exception_ptr);$/;"	t	namespace:__anon25	file:
Return	.\gen\Base.h	/^member(Return (Class::*member)() const) {$/;"	f	namespace:folly::gen	signature:(Class::*member) const
Return	.\gen\Base.h	/^member(Return (Class::*member)()) {$/;"	f	namespace:folly::gen	signature:(Class::*member)
Rot64	.\SpookyHashV1.h	/^    static inline uint64_t Rot64(uint64_t x, int k)$/;"	f	class:folly::hash::SpookyHashV1	access:public	signature:(uint64_t x, int k)
Rot64	.\SpookyHashV2.h	/^    static inline uint64_t Rot64(uint64_t x, int k)$/;"	f	class:folly::hash::SpookyHashV2	access:public	signature:(uint64_t x, int k)
Rot64	.\test\SpookyHashV1Test.cpp	/^    static inline uint64_t Rot64(uint64_t x, int k)$/;"	f	class:Random	file:	access:private	signature:(uint64_t x, int k)
Rot64	.\test\SpookyHashV2Test.cpp	/^    static inline uint64_t Rot64(uint64_t x, int k)$/;"	f	class:Random	file:	access:private	signature:(uint64_t x, int k)
RunInLoopCallback	.\io\async\EventBase.cpp	/^EventBase::RunInLoopCallback::RunInLoopCallback(void (*fn)(void*), void* arg)$/;"	f	class:folly::EventBase::RunInLoopCallback	signature:(void (*fn)(void*), void* arg)
RunInLoopCallback	.\io\async\EventBase.h	/^    RunInLoopCallback(void (*fn)(void*), void* arg);$/;"	p	class:folly::EventBase::RunInLoopCallback	access:public	signature:(void (*fn)(void*), void* arg)
RunInLoopCallback	.\io\async\EventBase.h	/^  class RunInLoopCallback : public LoopCallback {$/;"	c	class:folly::EventBase	inherits:LoopCallback	access:private
Running	.\experimental\Singleton.h	/^    Running,$/;"	m	class:folly::SingletonVault::SingletonVaultState	access:private
S	.\test\MemoryTest.cpp	/^template <std::size_t> struct S {};$/;"	s	file:
SCL	.\io\test\IOBufQueueTest.cpp	35;"	d	file:
SCOPE_EXIT	.\ScopeGuard.h	218;"	d
SCOPE_FAIL	.\ScopeGuard.h	224;"	d
SCOPE_SUCCESS	.\ScopeGuard.h	228;"	d
SETUP	.\test\stl_tests\StlVectorTest.cpp	1010;"	d	file:
SHARED	.\test\CacheLocalityTest.cpp	/^enum class SpreaderType { GETCPU, SHARED, TLS_RR };$/;"	m	class:SpreaderType	file:	access:private
SHUTDOWN	.\LifoSem.h	/^    SHUTDOWN,$/;"	m	class:folly::detail::LifoSemBase::WaitResult	access:private
SIZE	.\MacAddress.h	/^  static constexpr size_t SIZE = 6;$/;"	m	class:folly::MacAddress	access:public
SNAPPY	.\io\Compression.h	/^  SNAPPY = 3,$/;"	m	class:folly::io::CodecType	access:private
SPACE_OR_MINUS	.\FormatArg.h	/^    SPACE_OR_MINUS,$/;"	m	class:folly::FormatArg::Sign	access:private
STL_TEST	.\test\stl_tests\StlVectorTest.cpp	881;"	d	file:
STL_TEST_I	.\test\stl_tests\StlVectorTest.cpp	875;"	d	file:
STRING	.\FormatArg.h	/^    STRING,$/;"	m	class:folly::FormatArg::NextKeyMode	access:private
STRING	.\dynamic.h	/^    STRING,$/;"	e	enum:folly::dynamic::Type
STRING	.\test\FBStringBenchmark.cpp	88;"	d	file:
STRING	.\test\FBStringBenchmark.cpp	90;"	d	file:
STRING	.\test\FBStringBenchmark.cpp	91;"	d	file:
STRING	.\test\FBStringBenchmark.cpp	93;"	d	file:
SUCCESS	.\test\ScopeGuardTest.cpp	/^  SUCCESS,$/;"	m	class:ErrorBehavior	file:	access:private
SYNCHRONIZED	.\Synchronized.h	639;"	d
SYNCHRONIZED_CONST	.\Synchronized.h	660;"	d
SYNCHRONIZED_DUAL	.\Synchronized.h	701;"	d
SYNCHRONIZED_H_	.\Synchronized.h	25;"	d
S_copy_n	.\FBVector.h	/^  S_copy_n(T* dest, std::move_iterator<T*> mIt, size_type n) {$/;"	f	signature:(T* dest, std::move_iterator<T*> mIt, size_type n)
S_copy_n	.\FBVector.h	/^  static It S_copy_n(T* dest, It first, size_type n) {$/;"	f	signature:(T* dest, It first, size_type n)
S_copy_n	.\FBVector.h	/^  static const T* S_copy_n(T* dest, const T* first, size_type n) {$/;"	f	signature:(T* dest, const T* first, size_type n)
S_uninitialized_copy	.\FBVector.h	/^  static void S_uninitialized_copy(T* dest, It first, It last) {$/;"	f	signature:(T* dest, It first, It last)
S_uninitialized_copy_a	.\FBVector.h	/^  S_uninitialized_copy_a(Allocator& a, T* dest, It first, It last) {$/;"	f	signature:(Allocator& a, T* dest, It first, It last)
S_uninitialized_copy_bits	.\FBVector.h	/^  S_uninitialized_copy_bits(T* dest, It first, It last) {$/;"	f	signature:(T* dest, It first, It last)
S_uninitialized_copy_bits	.\FBVector.h	/^  S_uninitialized_copy_bits(T* dest, const T* first, const T* last) {$/;"	f	signature:(T* dest, const T* first, const T* last)
S_uninitialized_copy_bits	.\FBVector.h	/^  S_uninitialized_copy_bits(T* dest, std::move_iterator<T*> first,$/;"	f	signature:(T* dest, std::move_iterator<T*> first, std::move_iterator<T*> last)
S_uninitialized_fill_n	.\FBVector.h	/^  static void S_uninitialized_fill_n(T* dest, size_type n) {$/;"	f	signature:(T* dest, size_type n)
S_uninitialized_fill_n	.\FBVector.h	/^  static void S_uninitialized_fill_n(T* dest, size_type n, const T& value) {$/;"	f	signature:(T* dest, size_type n, const T& value)
S_uninitialized_fill_n_a	.\FBVector.h	/^  static void S_uninitialized_fill_n_a(Allocator& a, T* dest,$/;"	f	signature:(Allocator& a, T* dest, size_type sz, Args&&... args)
SafeIntrusiveListHook	.\IntrusiveList.h	/^        SafeIntrusiveListHook;$/;"	t	namespace:folly
SameType	.\detail\DiscriminatedPtrDetail.h	/^struct SameType;$/;"	x
SameType	.\detail\DiscriminatedPtrDetail.h	/^struct SameType<T, Types...> {$/;"	s	namespace:folly::dptr_detail
Sample	.\gen\Base-inl.h	/^  explicit Sample(size_t count, Random rng)$/;"	f	class:folly::gen::detail::Sample	access:public	signature:(size_t count, Random rng)
Sample	.\gen\Base-inl.h	/^class Sample : public Operator<Sample<Random>> {$/;"	c	namespace:folly::gen::detail	inherits:Operator
Sample	.\gen\Base.h	/^class Sample;$/;"	x
ScaleInfo	.\Benchmark.cpp	/^struct ScaleInfo {$/;"	s	namespace:folly	file:
ScheduledAction	.\wangle\ManualExecutor.h	/^      ScheduledAction(TimePoint const& t, Action&& a)$/;"	f	struct:folly::wangle::ManualExecutor::ScheduledAction	access:public	signature:(TimePoint const& t, Action&& a)
ScheduledAction	.\wangle\ManualExecutor.h	/^    struct ScheduledAction {$/;"	s	class:folly::wangle::ManualExecutor	access:private
Scope	.\experimental\TestUtil.h	/^  enum class Scope {$/;"	c	class:folly::test::TemporaryDirectory	access:public
Scope	.\experimental\TestUtil.h	/^  enum class Scope {$/;"	c	class:folly::test::TemporaryFile	access:public
ScopeGuard	.\ScopeGuard.h	/^typedef ScopeGuardImplBase&& ScopeGuard;$/;"	t	namespace:folly
ScopeGuardForNewException	.\ScopeGuard.h	/^  ScopeGuardForNewException(ScopeGuardForNewException&& other)$/;"	f	class:folly::detail::ScopeGuardForNewException	access:public	signature:(ScopeGuardForNewException&& other)
ScopeGuardForNewException	.\ScopeGuard.h	/^  explicit ScopeGuardForNewException(FunctionType&& fn)$/;"	f	class:folly::detail::ScopeGuardForNewException	access:public	signature:(FunctionType&& fn)
ScopeGuardForNewException	.\ScopeGuard.h	/^  explicit ScopeGuardForNewException(const FunctionType& fn)$/;"	f	class:folly::detail::ScopeGuardForNewException	access:public	signature:(const FunctionType& fn)
ScopeGuardForNewException	.\ScopeGuard.h	/^class ScopeGuardForNewException {$/;"	c	namespace:folly::detail
ScopeGuardImpl	.\ScopeGuard.h	/^  ScopeGuardImpl(ScopeGuardImpl&& other)$/;"	f	class:folly::ScopeGuardImpl	access:public	signature:(ScopeGuardImpl&& other)
ScopeGuardImpl	.\ScopeGuard.h	/^  explicit ScopeGuardImpl(FunctionType&& fn)$/;"	f	class:folly::ScopeGuardImpl	access:public	signature:(FunctionType&& fn)
ScopeGuardImpl	.\ScopeGuard.h	/^  explicit ScopeGuardImpl(const FunctionType& fn)$/;"	f	class:folly::ScopeGuardImpl	access:public	signature:(const FunctionType& fn)
ScopeGuardImpl	.\ScopeGuard.h	/^class ScopeGuardImpl : public ScopeGuardImplBase {$/;"	c	namespace:folly	inherits:ScopeGuardImplBase
ScopeGuardImplBase	.\ScopeGuard.h	/^  ScopeGuardImplBase()$/;"	f	class:folly::ScopeGuardImplBase	access:protected	signature:()
ScopeGuardImplBase	.\ScopeGuard.h	/^  ScopeGuardImplBase(ScopeGuardImplBase&& other)$/;"	f	class:folly::ScopeGuardImplBase	access:protected	signature:(ScopeGuardImplBase&& other)
ScopeGuardImplBase	.\ScopeGuard.h	/^class ScopeGuardImplBase {$/;"	c	namespace:folly
ScopeGuardOnExit	.\ScopeGuard.h	/^enum class ScopeGuardOnExit {};$/;"	c	namespace:folly::detail
ScopeGuardOnFail	.\ScopeGuard.h	/^enum class ScopeGuardOnFail {};$/;"	c	namespace:folly::detail
ScopeGuardOnSuccess	.\ScopeGuard.h	/^enum class ScopeGuardOnSuccess {};$/;"	c	namespace:folly::detail
ScopedAddrInfo	.\SocketAddress.cpp	/^  explicit ScopedAddrInfo(struct addrinfo* info) : info(info) {}$/;"	f	struct:__anon90::ScopedAddrInfo	access:public	signature:(struct addrinfo* info)
ScopedAddrInfo	.\SocketAddress.cpp	/^struct ScopedAddrInfo {$/;"	s	namespace:__anon90	file:
ScopedLocker	.\ConcurrentSkipList.h	/^  typedef std::unique_lock<folly::MicroSpinLock> ScopedLocker;$/;"	t	class:folly::ConcurrentSkipList	access:private
Section	.\experimental\symbolizer\Dwarf.cpp	/^Dwarf::Section::Section(folly::StringPiece d) : is64Bit_(false), data_(d) {$/;"	f	class:folly::symbolizer::Dwarf::Section	signature:(folly::StringPiece d)
Section	.\experimental\symbolizer\Dwarf.h	/^    Section() : is64Bit_(false) { }$/;"	f	class:folly::symbolizer::Dwarf::Section	access:public	signature:()
Section	.\experimental\symbolizer\Dwarf.h	/^    explicit Section(folly::StringPiece d);$/;"	p	class:folly::symbolizer::Dwarf::Section	access:public	signature:(folly::StringPiece d)
Section	.\experimental\symbolizer\Dwarf.h	/^  class Section {$/;"	c	class:folly::symbolizer::Dwarf	access:private
SeedData	.\Random-inl.h	/^  SeedData() {$/;"	f	struct:folly::detail::SeedData	access:public	signature:()
SeedData	.\Random-inl.h	/^struct SeedData {$/;"	s	namespace:folly::detail
SelfNeedySingleton	.\experimental\test\SingletonTest.cpp	/^  SelfNeedySingleton() {$/;"	f	struct:SelfNeedySingleton	access:public	signature:()
SelfNeedySingleton	.\experimental\test\SingletonTest.cpp	/^struct SelfNeedySingleton {$/;"	s	file:
SelfNeedySingleton::SelfNeedySingleton	.\experimental\test\SingletonTest.cpp	/^  SelfNeedySingleton() {$/;"	f	struct:SelfNeedySingleton	access:public	signature:()
Semaphore	.\experimental\test\EventCountTest.cpp	/^  explicit Semaphore(int v=0) : value_(v) { }$/;"	f	class:__anon46::Semaphore	access:public	signature:(int v=0)
Semaphore	.\experimental\test\EventCountTest.cpp	/^class Semaphore {$/;"	c	namespace:__anon46	file:
SeqImpl	.\gen\Base-inl.h	/^  explicit SeqImpl(Value end) : end_(std::move(end)) { }$/;"	f	class:folly::gen::detail::SeqImpl	access:public	signature:(Value end)
SeqImpl	.\gen\Base-inl.h	/^class SeqImpl {$/;"	c	namespace:folly::gen::detail
SeqImpl	.\gen\Base.h	/^class SeqImpl;$/;"	x
SeqShift	.\LifoSem.h	/^    SeqShift = 34,$/;"	e	enum:folly::detail::LifoSemHead::__anon76
SeqWithStepImpl	.\gen\Base-inl.h	/^  explicit SeqWithStepImpl(Value end, Distance step)$/;"	f	class:folly::gen::detail::SeqWithStepImpl	access:public	signature:(Value end, Distance step)
SeqWithStepImpl	.\gen\Base-inl.h	/^class SeqWithStepImpl {$/;"	c	namespace:folly::gen::detail
SeqWithStepImpl	.\gen\Base.h	/^class SeqWithStepImpl;$/;"	x
Sequence	.\gen\Base-inl.h	/^  explicit Sequence(Value start, SequenceImpl impl)$/;"	f	class:folly::gen::detail::Sequence	access:public	signature:(Value start, SequenceImpl impl)
Sequence	.\gen\Base-inl.h	/^class Sequence : public GenImpl<const Value&, Sequence<Value, SequenceImpl>> {$/;"	c	namespace:folly::gen::detail	inherits:GenImpl
Sequence	.\gen\Base.h	/^class Sequence;$/;"	x
SequentialThreadId	.\detail\CacheLocality.h	/^struct SequentialThreadId {$/;"	s	namespace:folly::detail
SerializeData	.\test\IPAddressTest.h	/^  SerializeData(const std::string& addr, const ByteVector& bytes)$/;"	f	struct:folly::SerializeData	access:public	signature:(const std::string& addr, const ByteVector& bytes)
SerializeData	.\test\IPAddressTest.h	/^struct SerializeData {$/;"	s	namespace:folly
Set	.\TimeoutQueue.h	/^  > Set;$/;"	t	class:folly::TimeoutQueue	access:private
SetType	.\test\ConcurrentSkipListBenchmark.cpp	/^typedef std::set<ValueType> SetType;$/;"	t	namespace:__anon113	file:
SetType	.\test\ConcurrentSkipListTest.cpp	/^typedef std::set<ValueType> SetType;$/;"	t	namespace:__anon114	file:
SetUp	.\experimental\symbolizer\test\SymbolizerTest.cpp	/^  void SetUp();$/;"	p	class:folly::symbolizer::test::ElfCacheTest	file:	access:protected	signature:()
SetUp	.\experimental\symbolizer\test\SymbolizerTest.cpp	/^void ElfCacheTest::SetUp() {$/;"	f	class:folly::symbolizer::test::ElfCacheTest	signature:()
SetUp	.\io\test\CompressionTest.cpp	/^   void SetUp() {$/;"	f	class:folly::io::test::CompressionTest	access:protected	signature:()
SetUp	.\io\test\CompressionTest.cpp	/^  void SetUp() {$/;"	f	class:folly::io::test::CompressionCorruptionTest	access:protected	signature:()
SetUp	.\io\test\IOBufTest.cpp	/^  void SetUp() {$/;"	f	class:MoveToFbStringTest	access:protected	signature:()
SetUp	.\test\PaddedTest.cpp	/^  void SetUp() {$/;"	f	class:IntPaddedConstTest	access:protected	signature:()
SetUp	.\test\PaddedTest.cpp	/^  void SetUp() {$/;"	f	class:StructPaddedConstTest	access:protected	signature:()
ShardedAtomicInt	.\test\ThreadCachedIntTest.cpp	/^struct ShardedAtomicInt {$/;"	s	file:
ShardedAtomicInt::inc	.\test\ThreadCachedIntTest.cpp	/^  inline void inc(int64_t val = 1) {$/;"	f	struct:ShardedAtomicInt	access:public	signature:(int64_t val = 1)
ShardedAtomicInt::ints_	.\test\ThreadCachedIntTest.cpp	/^  std::atomic<int64_t> ints_[kBuckets_];$/;"	m	struct:ShardedAtomicInt	file:	access:public
ShardedAtomicInt::kBuckets_	.\test\ThreadCachedIntTest.cpp	/^  static const int64_t kBuckets_ = 2048;$/;"	m	struct:ShardedAtomicInt	file:	access:public
ShardedAtomicInt::readFast	.\test\ThreadCachedIntTest.cpp	/^  int64_t readFast() {$/;"	f	struct:ShardedAtomicInt	access:public	signature:()
ShardedAtomicInt::readFull	.\test\ThreadCachedIntTest.cpp	/^  int64_t readFull() {$/;"	f	struct:ShardedAtomicInt	access:public	signature:()
SharedInfo	.\io\IOBuf.cpp	/^IOBuf::SharedInfo::SharedInfo()$/;"	f	class:folly::IOBuf::SharedInfo	signature:()
SharedInfo	.\io\IOBuf.cpp	/^IOBuf::SharedInfo::SharedInfo(FreeFunction fn, void* arg)$/;"	f	class:folly::IOBuf::SharedInfo	signature:(FreeFunction fn, void* arg)
SharedInfo	.\io\IOBuf.h	/^    SharedInfo();$/;"	p	struct:folly::IOBuf::SharedInfo	access:public	signature:()
SharedInfo	.\io\IOBuf.h	/^    SharedInfo(FreeFunction fn, void* arg);$/;"	p	struct:folly::IOBuf::SharedInfo	access:public	signature:(FreeFunction fn, void* arg)
SharedInfo	.\io\IOBuf.h	/^  struct SharedInfo {$/;"	s	class:folly::IOBuf	access:private
Short	.\SpookyHashV1.cpp	/^void SpookyHashV1::Short($/;"	f	class:folly::hash::SpookyHashV1	signature:( const void *message, size_t length, uint64_t *hash1, uint64_t *hash2)
Short	.\SpookyHashV1.h	/^    static void Short($/;"	p	class:folly::hash::SpookyHashV1	access:private	signature:( const void *message, size_t length, uint64_t *hash1, uint64_t *hash2)
Short	.\SpookyHashV2.cpp	/^void SpookyHashV2::Short($/;"	f	class:folly::hash::SpookyHashV2	signature:( const void *message, size_t length, uint64_t *hash1, uint64_t *hash2)
Short	.\SpookyHashV2.h	/^    static void Short($/;"	p	class:folly::hash::SpookyHashV2	access:private	signature:( const void *message, size_t length, uint64_t *hash1, uint64_t *hash2)
ShortEnd	.\SpookyHashV1.h	/^    static inline void ShortEnd(uint64_t &h0, uint64_t &h1, uint64_t &h2, uint64_t &h3)$/;"	f	class:folly::hash::SpookyHashV1	access:public	signature:(uint64_t &h0, uint64_t &h1, uint64_t &h2, uint64_t &h3)
ShortEnd	.\SpookyHashV2.h	/^    static inline void ShortEnd(uint64_t &h0, uint64_t &h1, uint64_t &h2, uint64_t &h3)$/;"	f	class:folly::hash::SpookyHashV2	access:public	signature:(uint64_t &h0, uint64_t &h1, uint64_t &h2, uint64_t &h3)
ShortMix	.\SpookyHashV1.h	/^    static inline void ShortMix(uint64_t &h0, uint64_t &h1, uint64_t &h2, uint64_t &h3)$/;"	f	class:folly::hash::SpookyHashV1	access:public	signature:(uint64_t &h0, uint64_t &h1, uint64_t &h2, uint64_t &h3)
ShortMix	.\SpookyHashV2.h	/^    static inline void ShortMix(uint64_t &h0, uint64_t &h1, uint64_t &h2, uint64_t &h3)$/;"	f	class:folly::hash::SpookyHashV2	access:public	signature:(uint64_t &h0, uint64_t &h1, uint64_t &h2, uint64_t &h3)
ShutdownAction	.\experimental\wangle\ConnectionManager.h	/^  enum class ShutdownAction : uint8_t {$/;"	c	class:folly::wangle::ConnectionManager	inherits:uint8_t	access:private
ShutdownSemError	.\LifoSem.cpp	/^ShutdownSemError::ShutdownSemError(const std::string& msg)$/;"	f	class:folly::ShutdownSemError	signature:(const std::string& msg)
ShutdownSemError	.\LifoSem.h	/^  explicit ShutdownSemError(const std::string& msg);$/;"	p	struct:folly::ShutdownSemError	access:public	signature:(const std::string& msg)
ShutdownSemError	.\LifoSem.h	/^struct ShutdownSemError : public std::runtime_error {$/;"	s	namespace:folly	inherits:std::runtime_error
Sign	.\FormatArg.h	/^  enum class Sign : uint8_t {$/;"	c	struct:folly::FormatArg	inherits:uint8_t	access:public
SignalCallback	.\experimental\symbolizer\SignalHandler.h	/^typedef void (*SignalCallback)(void);$/;"	t	namespace:folly::symbolizer
SignalSafeElfCache	.\experimental\symbolizer\ElfCache.cpp	/^SignalSafeElfCache::SignalSafeElfCache(size_t capacity) {$/;"	f	class:folly::symbolizer::SignalSafeElfCache	signature:(size_t capacity)
SignalSafeElfCache	.\experimental\symbolizer\ElfCache.h	/^  explicit SignalSafeElfCache(size_t capacity);$/;"	p	class:folly::symbolizer::SignalSafeElfCache	access:public	signature:(size_t capacity)
SignalSafeElfCache	.\experimental\symbolizer\ElfCache.h	/^class SignalSafeElfCache : public ElfCacheBase {$/;"	c	namespace:folly::symbolizer	inherits:ElfCacheBase
SimpleDeleter	.\detail\ThreadLocalDetail.h	/^class SimpleDeleter : public DeleterBase {$/;"	c	namespace:folly::threadlocal_detail	inherits:DeleterBase
SimpleRetT	.\AtomicHashArray.h	/^    SimpleRetT() {}$/;"	f	struct:folly::AtomicHashArray::SimpleRetT	access:public	signature:()
SimpleRetT	.\AtomicHashArray.h	/^    SimpleRetT(size_t i, bool s) : idx(i), success(s) {}$/;"	f	struct:folly::AtomicHashArray::SimpleRetT	access:public	signature:(size_t i, bool s)
SimpleRetT	.\AtomicHashArray.h	/^  struct SimpleRetT { size_t idx; bool success;$/;"	s	class:folly::AtomicHashArray	access:private
SimpleRetT	.\AtomicHashMap.h	/^    SimpleRetT() {}$/;"	f	struct:folly::AtomicHashMap::SimpleRetT	access:public	signature:()
SimpleRetT	.\AtomicHashMap.h	/^    SimpleRetT(uint32_t ii, size_t jj, bool s) : i(ii), j(jj), success(s) {}$/;"	f	struct:folly::AtomicHashMap::SimpleRetT	access:public	signature:(uint32_t ii, size_t jj, bool s)
SimpleRetT	.\AtomicHashMap.h	/^  struct SimpleRetT { uint32_t i; size_t j; bool success;$/;"	s	class:folly::AtomicHashMap	access:private
SimpleThreadCachedInt	.\test\ThreadLocalTest.cpp	/^class SimpleThreadCachedInt {$/;"	c	file:
SimpleThreadCachedInt::NewTag	.\test\ThreadLocalTest.cpp	/^  class NewTag;$/;"	x	file:
SimpleThreadCachedInt::add	.\test\ThreadLocalTest.cpp	/^  void add(int val) {$/;"	f	class:SimpleThreadCachedInt	access:public	signature:(int val)
SimpleThreadCachedInt::read	.\test\ThreadLocalTest.cpp	/^  int read() {$/;"	f	class:SimpleThreadCachedInt	access:public	signature:()
SimpleThreadCachedInt::val_	.\test\ThreadLocalTest.cpp	/^  ThreadLocal<int,NewTag> val_;$/;"	m	class:SimpleThreadCachedInt	file:	access:private
SingleElementQueue	.\MPMCQueue.h	/^class SingleElementQueue;$/;"	x
SingleElementQueue	.\MPMCQueue.h	/^struct SingleElementQueue {$/;"	s	namespace:folly
Singleton	.\experimental\Singleton.h	/^  explicit Singleton(Singleton::CreateFunc c = nullptr,$/;"	f	class:folly::Singleton	access:public	signature:(Singleton::CreateFunc c = nullptr, Singleton::TeardownFunc t = nullptr, SingletonVault* vault = nullptr )
Singleton	.\experimental\Singleton.h	/^  explicit Singleton(const char* name,$/;"	f	class:folly::Singleton	access:public	signature:(const char* name, Singleton::CreateFunc c = nullptr, Singleton::TeardownFunc t = nullptr, SingletonVault* vault = nullptr )
Singleton	.\experimental\Singleton.h	/^  explicit Singleton(detail::TypeDescriptor type,$/;"	f	class:folly::Singleton	access:private	signature:(detail::TypeDescriptor type, Singleton::CreateFunc c = nullptr, Singleton::TeardownFunc t = nullptr, SingletonVault* vault = nullptr )
Singleton	.\experimental\Singleton.h	/^class Singleton {$/;"	c	namespace:folly
SingletonEntry	.\experimental\Singleton.h	/^    SingletonEntry() = default;$/;"	p	struct:folly::SingletonVault::SingletonEntry	access:public	signature:()
SingletonEntry	.\experimental\Singleton.h	/^    SingletonEntry(SingletonEntry&&) = delete;$/;"	p	struct:folly::SingletonVault::SingletonEntry	access:public	signature:(SingletonEntry&&)
SingletonEntry	.\experimental\Singleton.h	/^    SingletonEntry(const SingletonEntry&) = delete;$/;"	p	struct:folly::SingletonVault::SingletonEntry	access:public	signature:(const SingletonEntry&)
SingletonEntry	.\experimental\Singleton.h	/^  struct SingletonEntry {$/;"	s	class:folly::SingletonVault	access:private
SingletonEntryPtr	.\experimental\Singleton.h	/^  typedef std::unique_ptr<SingletonEntry> SingletonEntryPtr;$/;"	t	class:folly::SingletonVault	access:private
SingletonEntryState	.\experimental\Singleton.h	/^  enum class SingletonEntryState {$/;"	c	class:folly::SingletonVault	access:private
SingletonVault	.\experimental\Singleton.h	/^  explicit SingletonVault(Type type = Type::Relaxed) : type_(type) {}$/;"	f	class:folly::SingletonVault	access:public	signature:(Type type = Type::Relaxed)
SingletonVault	.\experimental\Singleton.h	/^class SingletonVault {$/;"	c	namespace:folly
SingletonVaultState	.\experimental\Singleton.h	/^  enum class SingletonVaultState {$/;"	c	class:folly::SingletonVault	access:private
SizeMask	.\IndexedMemPool.h	/^        SizeMask = (1U << SizeBits) - 1,$/;"	m	struct:folly::IndexedMemPool::TaggedPtr	typeref:enum:folly::IndexedMemPool::TaggedPtr::	access:public
SizeType	.\small_vector.h	/^    >::type SizeType;$/;"	t	struct:folly::detail::small_vector_base	access:public
Skip	.\gen\Base-inl.h	/^  explicit Skip(size_t count)$/;"	f	class:folly::gen::detail::Skip	access:public	signature:(size_t count)
Skip	.\gen\Base-inl.h	/^class Skip : public Operator<Skip> {$/;"	c	namespace:folly::gen::detail	inherits:Operator
Skip	.\gen\Base.h	/^class Skip;$/;"	x
Skip	.\io\Compression.cpp	/^void IOBufSnappySource::Skip(size_t n) {$/;"	f	class:folly::io::__anon64::IOBufSnappySource	signature:(size_t n)
SkipListAccessor	.\test\ConcurrentSkipListBenchmark.cpp	/^typedef SkipListType::Accessor SkipListAccessor;$/;"	t	namespace:__anon113	file:
SkipListAccessor	.\test\ConcurrentSkipListTest.cpp	/^typedef SkipListType::Accessor SkipListAccessor;$/;"	t	namespace:__anon114	file:
SkipListNode	.\ConcurrentSkipList-inl.h	/^  SkipListNode(uint8_t height, U&& data, bool isHead) :$/;"	f	class:folly::detail::SkipListNode	access:private	signature:(uint8_t height, U&& data, bool isHead)
SkipListNode	.\ConcurrentSkipList-inl.h	/^class SkipListNode : private boost::noncopyable {$/;"	c	namespace:folly::detail	inherits:boost::noncopyable
SkipListNodeType	.\test\ConcurrentSkipListTest.cpp	/^typedef detail::SkipListNode<ValueType> SkipListNodeType;$/;"	t	namespace:__anon114	file:
SkipListRandomHeight	.\ConcurrentSkipList-inl.h	/^  SkipListRandomHeight() { initLookupTable(); }$/;"	f	class:folly::detail::SkipListRandomHeight	access:private	signature:()
SkipListRandomHeight	.\ConcurrentSkipList-inl.h	/^class SkipListRandomHeight {$/;"	c	namespace:folly::detail
SkipListType	.\ConcurrentSkipList.h	/^  typedef ConcurrentSkipList<T, Comp, NodeAlloc, MAX_HEIGHT> SkipListType;$/;"	t	class:folly::ConcurrentSkipList	access:private
SkipListType	.\ConcurrentSkipList.h	/^  typedef ConcurrentSkipList<T, Comp, NodeAlloc, MAX_HEIGHT> SkipListType;$/;"	t	class:folly::ConcurrentSkipList::Accessor	access:private
SkipListType	.\ConcurrentSkipList.h	/^  typedef ConcurrentSkipList<T, Comp, NodeAlloc, MAX_HEIGHT> SkipListType;$/;"	t	class:folly::ConcurrentSkipList::Skipper	access:private
SkipListType	.\test\ConcurrentSkipListBenchmark.cpp	/^typedef ConcurrentSkipList<ValueType> SkipListType;$/;"	t	namespace:__anon113	file:
SkipListType	.\test\ConcurrentSkipListTest.cpp	/^typedef ConcurrentSkipList<ValueType> SkipListType;$/;"	t	namespace:__anon114	file:
SkipValueType	.\experimental\EliasFanoCoding.h	/^  typedef SkipValue SkipValueType;$/;"	t	struct:folly::compression::EliasFanoEncoder	access:public
SkipValueType	.\experimental\EliasFanoCoding.h	/^  typedef typename Encoder::SkipValueType SkipValueType;$/;"	t	class:folly::compression::detail::UpperBitsReader	access:private
Skipper	.\ConcurrentSkipList.h	/^  Skipper(const Accessor& accessor) : accessor_(accessor) {$/;"	f	class:folly::ConcurrentSkipList::Skipper	access:public	signature:(const Accessor& accessor)
Skipper	.\ConcurrentSkipList.h	/^  Skipper(const std::shared_ptr<SkipListType>& skipList) :$/;"	f	class:folly::ConcurrentSkipList::Skipper	access:public	signature:(const std::shared_ptr<SkipListType>& skipList)
Skipper	.\ConcurrentSkipList.h	/^  class Skipper;$/;"	x
Skipper	.\ConcurrentSkipList.h	/^  typedef typename SkipListType::Skipper Skipper;$/;"	t	class:folly::ConcurrentSkipList::Accessor	access:public
Skipper	.\ConcurrentSkipList.h	/^class ConcurrentSkipList<T, Comp, NodeAlloc, MAX_HEIGHT>::Skipper {$/;"	c	class:folly::ConcurrentSkipList
Sleeper	.\SmallLocks.h	/^    Sleeper() : spinCount(0) {}$/;"	f	class:folly::detail::Sleeper	access:public	signature:()
Sleeper	.\SmallLocks.h	/^  class Sleeper {$/;"	c	namespace:folly::detail
Slot	.\IndexedMemPool.h	/^    Slot() : localNext{}, globalNext{} {}$/;"	f	struct:folly::IndexedMemPool::Slot	access:public	signature:()
Slot	.\IndexedMemPool.h	/^  struct Slot {$/;"	s	struct:folly::IndexedMemPool	access:private
SlowFingerprint	.\detail\SlowFingerprint.h	/^  SlowFingerprint()$/;"	f	class:folly::detail::SlowFingerprint	access:public	signature:()
SlowFingerprint	.\detail\SlowFingerprint.h	/^class SlowFingerprint {$/;"	c	namespace:folly::detail
Slowpoke	.\experimental\test\SingletonTest.cpp	/^  Slowpoke() { std::this_thread::sleep_for(std::chrono::seconds(1)); }$/;"	f	class:Slowpoke	access:public	signature:()
Slowpoke	.\experimental\test\SingletonTest.cpp	/^class Slowpoke {$/;"	c	file:
Slowpoke::Slowpoke	.\experimental\test\SingletonTest.cpp	/^  Slowpoke() { std::this_thread::sleep_for(std::chrono::seconds(1)); }$/;"	f	class:Slowpoke	access:public	signature:()
SmartPtr	.\AtomicHashArray.h	/^  typedef std::unique_ptr<AtomicHashArray, Deleter> SmartPtr;$/;"	t	class:folly::AtomicHashArray	access:public
SmoothLoopTime	.\io\async\EventBase.h	/^    explicit SmoothLoopTime(uint64_t timeInterval)$/;"	f	class:folly::EventBase::SmoothLoopTime	access:public	signature:(uint64_t timeInterval)
SmoothLoopTime	.\io\async\EventBase.h	/^  class SmoothLoopTime {$/;"	c	class:folly::EventBase	access:public
SnappyCodec	.\io\Compression.cpp	/^  explicit SnappyCodec(int level, CodecType type);$/;"	p	class:folly::io::__anon64::FOLLY_FINAL	file:	access:public	signature:(int level, CodecType type)
SnappyCodec	.\io\Compression.cpp	/^SnappyCodec::SnappyCodec(int level, CodecType type) : Codec(type) {$/;"	f	class:folly::io::__anon64::SnappyCodec	signature:(int level, CodecType type)
SocketAddress	.\SocketAddress.h	/^  SocketAddress() {$/;"	f	class:folly::SocketAddress	access:public	signature:()
SocketAddress	.\SocketAddress.h	/^  SocketAddress(SocketAddress&& addr) {$/;"	f	class:folly::SocketAddress	access:public	signature:(SocketAddress&& addr)
SocketAddress	.\SocketAddress.h	/^  SocketAddress(const SocketAddress& addr) {$/;"	f	class:folly::SocketAddress	access:public	signature:(const SocketAddress& addr)
SocketAddress	.\SocketAddress.h	/^  SocketAddress(const char* host, uint16_t port,$/;"	f	class:folly::SocketAddress	access:public	signature:(const char* host, uint16_t port, bool allowNameLookup = false)
SocketAddress	.\SocketAddress.h	/^  SocketAddress(const std::string& host, uint16_t port,$/;"	f	class:folly::SocketAddress	access:public	signature:(const std::string& host, uint16_t port, bool allowNameLookup = false)
SocketAddress	.\SocketAddress.h	/^class SocketAddress {$/;"	c	namespace:folly
SomeClass	.\wangle\test\Thens.h	/^class SomeClass {$/;"	c
SomeClass::aMethod	.\wangle\test\Thens.h	/^  Ret aMethod(Params...);$/;"	p	class:SomeClass	access:public	signature:(Params....)
SomeClass::aMethod	.\wangle\test\Thens.h	/^  aMethod(Params...) {$/;"	f	class:SomeClass	access:public	signature:(Params....)
SomeClass::aStaticMethod	.\wangle\test\Thens.h	/^  aStaticMethod(Params...) {$/;"	f	class:SomeClass	access:public	signature:(Params....)
SomeClass::aStaticMethod	.\wangle\test\Thens.h	/^  static Ret aStaticMethod(Params...);$/;"	p	class:SomeClass	access:public	signature:(Params....)
SomeClass::b	.\wangle\test\Thens.h	/^  B b;$/;"	m	class:SomeClass	access:private
SpinLockArray	.\SmallLocks.h	/^struct SpinLockArray {$/;"	s	namespace:folly
SplitStringSource	.\gen\String-inl.h	/^  SplitStringSource(const StringPiece& source,$/;"	f	class:folly::gen::detail::SplitStringSource	access:public	signature:(const StringPiece& source, DelimiterType delimiter)
SplitStringSource	.\gen\String-inl.h	/^class SplitStringSource$/;"	c	namespace:folly::gen::detail	inherits:GenImpl
SplitStringSource	.\gen\String.h	/^class SplitStringSource;$/;"	x
SplitTo	.\gen\String-inl.h	/^  explicit SplitTo(Delimiter delimiter)$/;"	f	class:folly::gen::detail::SplitTo	access:public	signature:(Delimiter delimiter)
SplitTo	.\gen\String-inl.h	/^class SplitTo {$/;"	c	namespace:folly::gen::detail
SplitTo	.\gen\String.h	/^class SplitTo;$/;"	x
SpookyHashV1	.\SpookyHashV1.h	/^class SpookyHashV1$/;"	c	namespace:folly::hash
SpookyHashV2	.\SpookyHashV2.h	/^class SpookyHashV2$/;"	c	namespace:folly::hash
SpreaderType	.\test\CacheLocalityTest.cpp	/^enum class SpreaderType { GETCPU, SHARED, TLS_RR };$/;"	c	file:
SpreaderType::GETCPU	.\test\CacheLocalityTest.cpp	/^enum class SpreaderType { GETCPU, SHARED, TLS_RR };$/;"	m	class:SpreaderType	file:	access:private
SpreaderType::SHARED	.\test\CacheLocalityTest.cpp	/^enum class SpreaderType { GETCPU, SHARED, TLS_RR };$/;"	m	class:SpreaderType	file:	access:private
SseNeedleFinder	.\test\RangeTest.cpp	/^struct SseNeedleFinder {$/;"	s	file:
SseNeedleFinder::find_first_byte_of	.\test\RangeTest.cpp	/^  static size_t find_first_byte_of(StringPiece haystack, StringPiece needles) {$/;"	f	struct:SseNeedleFinder	access:public	signature:(StringPiece haystack, StringPiece needles)
StackTrace	.\experimental\exception_tracer\StackTrace.h	/^  StackTrace() : frameCount(0) { }$/;"	f	struct:folly::exception_tracer::StackTrace	access:public	signature:()
StackTrace	.\experimental\exception_tracer\StackTrace.h	/^struct StackTrace {$/;"	s	namespace:folly::exception_tracer
StackTraceStack	.\experimental\exception_tracer\StackTrace.h	/^class StackTraceStack {$/;"	c	namespace:folly::exception_tracer
StageInfos	.\MPMCPipeline.h	/^  typedef std::tuple<detail::PipelineStageInfo<Stages>...> StageInfos;$/;"	t	class:folly::MPMCPipeline	access:private
StageTuple	.\MPMCPipeline.h	/^    StageTuple;$/;"	t	class:folly::MPMCPipeline	access:private
State	.\Baton.h	/^  enum State : uint32_t {$/;"	x
State	.\Subprocess.h	/^  enum State {$/;"	g	class:folly::ProcessReturnCode	access:public
State	.\experimental\io\AsyncIO.h	/^  enum class State {$/;"	c	class:folly::AsyncIOOp	access:public
State	.\experimental\symbolizer\LineReader.h	/^  enum State {$/;"	g	class:folly::symbolizer::LineReader	access:public
State	.\wangle\detail\State.h	/^  State() = default;$/;"	p	class:folly::wangle::detail::State	access:public	signature:()
State	.\wangle\detail\State.h	/^  State(State const&) = delete;$/;"	p	class:folly::wangle::detail::State	access:public	signature:(State const&)
State	.\wangle\detail\State.h	/^class State {$/;"	c	namespace:folly::wangle::detail
StateSize	.\Random-inl.h	/^struct StateSize<__gnu_cxx::simd_fast_mersenne_twister_engine<$/;"	s	namespace:folly::detail
StateSize	.\Random-inl.h	/^struct StateSize<std::linear_congruential_engine<UIntType, a, c, m>> {$/;"	s	namespace:folly::detail
StateSize	.\Random-inl.h	/^struct StateSize<std::mersenne_twister_engine<UIntType, w, n, m, r,$/;"	s	namespace:folly::detail
StateSize	.\Random-inl.h	/^struct StateSize<std::subtract_with_carry_engine<UIntType, w, s, r>> {$/;"	s	namespace:folly::detail
StateSize	.\Random-inl.h	/^template <class RNG> struct StateSize {$/;"	s	namespace:folly::detail
StaticMeta	.\detail\ThreadLocalDetail.h	/^  StaticMeta() : nextId_(1) {$/;"	f	struct:folly::threadlocal_detail::StaticMeta	access:public	signature:()
StaticMeta	.\detail\ThreadLocalDetail.h	/^struct StaticMeta {$/;"	s	namespace:folly::threadlocal_detail
StdHasher	.\Hash.h	/^class StdHasher {$/;"	c	namespace:folly::hash
StepResult	.\experimental\symbolizer\Dwarf.h	/^    enum StepResult {$/;"	g	class:folly::symbolizer::Dwarf::LineNumberVM	access:private
StlAllocator	.\Memory.h	/^  StlAllocator() : alloc_(nullptr) { }$/;"	f	class:folly::StlAllocator	access:public	signature:()
StlAllocator	.\Memory.h	/^  explicit StlAllocator(Alloc* a) : alloc_(a) { }$/;"	f	class:folly::StlAllocator	access:public	signature:(Alloc* a)
StlAllocator	.\Memory.h	/^  template <class U> StlAllocator(const StlAllocator<Alloc, U>& other)$/;"	f	class:folly::StlAllocator	access:public	signature:(const StlAllocator<Alloc, U>& other)
StlAllocator	.\Memory.h	/^class StlAllocator {$/;"	c	namespace:folly
StlAllocator	.\Memory.h	/^template <class Alloc, class T> class StlAllocator;$/;"	x
StlAllocator	.\Memory.h	/^template <class Alloc> class StlAllocator<Alloc, void> {$/;"	c	namespace:folly
StoppedThreadQueue	.\experimental\wangle\concurrent\ThreadPoolExecutor.h	/^  class StoppedThreadQueue : public BlockingQueue<ThreadPtr> {$/;"	c	class:folly::wangle::ThreadPoolExecutor	inherits:BlockingQueue	access:protected
StorageType	.\gen\Base-inl.h	/^    typedef typename std::decay<Value>::type StorageType;$/;"	t	class:folly::gen::detail::Distinct::Generator	access:private
StorageType	.\gen\Base.h	/^    StorageType;$/;"	t	struct:folly::gen::detail::ValueTypeOfRange	access:public
StorageType	.\gen\Core-inl.h	/^  typedef typename std::decay<Value>::type StorageType;$/;"	t	class:folly::gen::GenImpl	access:public
StreamSplitter	.\gen\String.h	/^  StreamSplitter(char delimiter,$/;"	f	class:folly::gen::StreamSplitter	access:public	signature:(char delimiter, Callback&& pieceCb, uint64_t maxLength = 0, uint64_t initialCapacity = 0)
StreamSplitter	.\gen\String.h	/^class StreamSplitter {$/;"	c	namespace:folly::gen
StreamSplitterCallback	.\Subprocess.h	/^      StreamSplitterCallback(Callback& cb, int fd) : cb_(cb), fd_(fd) { }$/;"	f	struct:folly::Subprocess::ReadLinesCallback::StreamSplitterCallback	access:public	signature:(Callback& cb, int fd)
StreamSplitterCallback	.\Subprocess.h	/^    struct StreamSplitterCallback {$/;"	s	class:folly::Subprocess::ReadLinesCallback	access:private
Strict	.\experimental\Singleton.h	/^  enum class Type { Strict, Relaxed };$/;"	m	class:folly::SingletonVault::Type	access:private
Stride	.\gen\Base-inl.h	/^  explicit Stride(size_t stride) : stride_(stride) {$/;"	f	class:folly::gen::detail::Stride	access:public	signature:(size_t stride)
Stride	.\gen\Base-inl.h	/^class Stride : public Operator<Stride> {$/;"	c	namespace:folly::gen::detail	inherits:Operator
Stride	.\gen\Base.h	/^class Stride;$/;"	x
StringAppender	.\test\GroupVarintTest.cpp	/^  \/* implicit *\/ StringAppender(std::string& s) : s_(s) { }$/;"	f	class:__anon121::StringAppender	access:public	signature:(std::string& s)
StringAppender	.\test\GroupVarintTest.cpp	/^class StringAppender {$/;"	c	namespace:__anon121	file:
StringIdenticalToBM	.\test\ConvTest.cpp	/^  StringIdenticalToBM() {}$/;"	f	struct:StringIdenticalToBM	access:public	signature:()
StringIdenticalToBM	.\test\ConvTest.cpp	/^struct StringIdenticalToBM {$/;"	s	file:
StringIdenticalToBM::StringIdenticalToBM	.\test\ConvTest.cpp	/^  StringIdenticalToBM() {}$/;"	f	struct:StringIdenticalToBM	access:public	signature:()
StringIdenticalToBM::operator ()	.\test\ConvTest.cpp	/^  void operator()(unsigned int n, size_t len) const {$/;"	f	struct:StringIdenticalToBM	access:public	signature:(unsigned int n, size_t len) const
StringPiece	.\Range.h	/^typedef Range<const char*> StringPiece;$/;"	t	namespace:folly
StringPieceHash	.\Range.h	/^struct StringPieceHash {$/;"	s	namespace:folly
StringResplitter	.\gen\String-inl.h	/^  explicit StringResplitter(char delimiter) : delimiter_(delimiter) { }$/;"	f	class:folly::gen::detail::StringResplitter	access:public	signature:(char delimiter)
StringResplitter	.\gen\String-inl.h	/^class StringResplitter : public Operator<StringResplitter> {$/;"	c	namespace:folly::gen::detail	inherits:Operator
StringResplitter	.\gen\String.h	/^class StringResplitter;$/;"	x
StringSymbolizePrinter	.\experimental\symbolizer\Symbolizer.h	/^  explicit StringSymbolizePrinter(int options=0) : SymbolizePrinter(options) { }$/;"	f	class:folly::symbolizer::StringSymbolizePrinter	access:public	signature:(int options=0)
StringSymbolizePrinter	.\experimental\symbolizer\Symbolizer.h	/^class StringSymbolizePrinter : public SymbolizePrinter {$/;"	c	namespace:folly::symbolizer	inherits:SymbolizePrinter
StringUnsplit_Gen	.\gen\test\StringBenchmark.cpp	/^void StringUnsplit_Gen(size_t iters, size_t joinSize) {$/;"	f	signature:(size_t iters, size_t joinSize)
StringVariadicToBM	.\test\ConvTest.cpp	/^  StringVariadicToBM() {}$/;"	f	struct:StringVariadicToBM	access:public	signature:()
StringVariadicToBM	.\test\ConvTest.cpp	/^struct StringVariadicToBM {$/;"	s	file:
StringVariadicToBM::StringVariadicToBM	.\test\ConvTest.cpp	/^  StringVariadicToBM() {}$/;"	f	struct:StringVariadicToBM	access:public	signature:()
StringVariadicToBM::operator ()	.\test\ConvTest.cpp	/^  void operator()(unsigned int n, size_t len) const {$/;"	f	struct:StringVariadicToBM	access:public	signature:(unsigned int n, size_t len) const
StructPaddedConstTest	.\test\PaddedTest.cpp	/^class StructPaddedConstTest : public StructPaddedTestBase {$/;"	c	file:	inherits:StructPaddedTestBase
StructPaddedConstTest::SetUp	.\test\PaddedTest.cpp	/^  void SetUp() {$/;"	f	class:StructPaddedConstTest	access:protected	signature:()
StructPaddedTestBase	.\test\PaddedTest.cpp	/^class StructPaddedTestBase : public ::testing::Test {$/;"	c	file:	inherits:::testing::Test
StructPaddedTestBase::Point	.\test\PaddedTest.cpp	/^  struct Point {$/;"	s	class:StructPaddedTestBase	file:	access:protected
StructPaddedTestBase::Point::x	.\test\PaddedTest.cpp	/^    uint8_t x;$/;"	m	struct:StructPaddedTestBase::Point	file:	access:public
StructPaddedTestBase::Point::y	.\test\PaddedTest.cpp	/^    uint8_t y;$/;"	m	struct:StructPaddedTestBase::Point	file:	access:public
StructPaddedTestBase::Point::z	.\test\PaddedTest.cpp	/^    uint8_t z;$/;"	m	struct:StructPaddedTestBase::Point	file:	access:public
StructPaddedTestBase::PointNode	.\test\PaddedTest.cpp	/^  typedef padded::Node<Point, 64> PointNode;$/;"	t	class:StructPaddedTestBase	file:	access:protected
StructPaddedTestBase::PointNodeVec	.\test\PaddedTest.cpp	/^  typedef std::vector<PointNode> PointNodeVec;$/;"	t	class:StructPaddedTestBase	file:	access:protected
StructPaddedTestBase::n_	.\test\PaddedTest.cpp	/^  int n_;$/;"	m	class:StructPaddedTestBase	file:	access:protected
StructPaddedTestBase::v_	.\test\PaddedTest.cpp	/^  PointNodeVec v_;$/;"	m	class:StructPaddedTestBase	file:	access:protected
Sub	.\gen\Parallel-inl.h	/^  explicit Sub(Sink sink) : sink_(sink) {}$/;"	f	class:folly::gen::detail::Sub	access:public	signature:(Sink sink)
Sub	.\gen\Parallel-inl.h	/^class Sub : public Operator<Sub<Sink>> {$/;"	c	namespace:folly::gen::detail	inherits:Operator
Sub	.\gen\Parallel.h	/^class Sub;$/;"	x
SubMap	.\AtomicHashMap.h	/^  typedef AtomicHashArray<KeyT, ValueT, HashFcn, EqualFcn, Allocator> SubMap;$/;"	t	class:folly::AtomicHashMap	access:private
Subprocess	.\Subprocess.cpp	/^Subprocess::Subprocess($/;"	f	class:folly::Subprocess	signature:( const std::string& cmd, const Options& options, const std::vector<std::string>* env)
Subprocess	.\Subprocess.cpp	/^Subprocess::Subprocess($/;"	f	class:folly::Subprocess	signature:( const std::vector<std::string>& argv, const Options& options, const char* executable, const std::vector<std::string>* env)
Subprocess	.\Subprocess.h	/^    friend class Subprocess;$/;"	x
Subprocess	.\Subprocess.h	/^  explicit Subprocess($/;"	p	class:folly::Subprocess	access:public	signature:( const std::string& cmd, const Options& options = Options(), const std::vector<std::string>* env = nullptr)
Subprocess	.\Subprocess.h	/^  explicit Subprocess($/;"	p	class:folly::Subprocess	access:public	signature:( const std::vector<std::string>& argv, const Options& options = Options(), const char* executable = nullptr, const std::vector<std::string>* env = nullptr)
Subprocess	.\Subprocess.h	/^  friend class Subprocess;$/;"	x
Subprocess	.\Subprocess.h	/^class Subprocess : private boost::noncopyable {$/;"	c	namespace:folly	inherits:boost::noncopyable
Subprocess	.\Subprocess.h	/^class Subprocess;$/;"	x
SubprocessError	.\Subprocess.h	/^class SubprocessError : public std::exception {};$/;"	c	namespace:folly	inherits:std::exception
SubprocessSpawnError	.\Subprocess.cpp	/^SubprocessSpawnError::SubprocessSpawnError(const char* executable,$/;"	f	class:folly::SubprocessSpawnError	signature:(const char* executable, int errCode, int errnoValue)
SubprocessSpawnError	.\Subprocess.h	/^  SubprocessSpawnError(const char* executable, int errCode, int errnoValue);$/;"	p	class:folly::SubprocessSpawnError	access:public	signature:(const char* executable, int errCode, int errnoValue)
SubprocessSpawnError	.\Subprocess.h	/^class SubprocessSpawnError : public SubprocessError {$/;"	c	namespace:folly	inherits:SubprocessError
Sum	.\gen\Base-inl.h	/^  Sum() : Operator<Sum>() {}$/;"	f	class:folly::gen::detail::Sum	access:public	signature:()
Sum	.\gen\Base-inl.h	/^class Sum : public Operator<Sum> {$/;"	c	namespace:folly::gen::detail	inherits:Operator
Sum	.\gen\Base.h	/^class Sum;$/;"	x
Symbol	.\experimental\symbolizer\Elf.h	/^  typedef std::pair<const ElfW(Shdr)*, const ElfW(Sym)*> Symbol;$/;"	t	class:folly::symbolizer::ElfFile	access:public
SymbolizePrinter	.\experimental\symbolizer\Symbolizer.h	/^  explicit SymbolizePrinter(int options, bool isTty = false)$/;"	f	class:folly::symbolizer::SymbolizePrinter	access:protected	signature:(int options, bool isTty = false)
SymbolizePrinter	.\experimental\symbolizer\Symbolizer.h	/^class SymbolizePrinter {$/;"	c	namespace:folly::symbolizer
SymbolizedFrame	.\experimental\symbolizer\Symbolizer.h	/^  SymbolizedFrame() : found(false), name(nullptr) { }$/;"	f	struct:folly::symbolizer::SymbolizedFrame	access:public	signature:()
SymbolizedFrame	.\experimental\symbolizer\Symbolizer.h	/^struct SymbolizedFrame {$/;"	s	namespace:folly::symbolizer
Symbolizer	.\experimental\symbolizer\Symbolizer.cpp	/^Symbolizer::Symbolizer(ElfCacheBase* cache)$/;"	f	class:folly::symbolizer::Symbolizer	signature:(ElfCacheBase* cache)
Symbolizer	.\experimental\symbolizer\Symbolizer.h	/^  explicit Symbolizer(ElfCacheBase* cache = nullptr);$/;"	p	class:folly::symbolizer::Symbolizer	access:public	signature:(ElfCacheBase* cache = nullptr)
Symbolizer	.\experimental\symbolizer\Symbolizer.h	/^class Symbolizer {$/;"	c	namespace:folly::symbolizer
Symbolizer	.\experimental\symbolizer\Symbolizer.h	/^class Symbolizer;$/;"	x
SyncVec	.\test\PackedSyncPtrTest.cpp	/^  SyncVec() { base.init(); }$/;"	f	struct:SyncVec	access:public	signature:()
SyncVec	.\test\PackedSyncPtrTest.cpp	/^struct SyncVec {$/;"	s	file:
SyncVec::SyncVec	.\test\PackedSyncPtrTest.cpp	/^  SyncVec() { base.init(); }$/;"	f	struct:SyncVec	access:public	signature:()
SyncVec::base	.\test\PackedSyncPtrTest.cpp	/^  PackedSyncPtr<T> base;$/;"	m	struct:SyncVec	file:	access:public
SyncVec::begin	.\test\PackedSyncPtrTest.cpp	/^  T* begin() const { return base.get(); }$/;"	f	struct:SyncVec	access:public	signature:() const
SyncVec::end	.\test\PackedSyncPtrTest.cpp	/^  T* end() const { return base.get() + base.extra(); }$/;"	f	struct:SyncVec	access:public	signature:() const
SyncVec::lock	.\test\PackedSyncPtrTest.cpp	/^  void lock() {$/;"	f	struct:SyncVec	access:public	signature:()
SyncVec::push_back	.\test\PackedSyncPtrTest.cpp	/^  void push_back(const T& t) {$/;"	f	struct:SyncVec	access:public	signature:(const T& t)
SyncVec::unlock	.\test\PackedSyncPtrTest.cpp	/^  void unlock() {$/;"	f	struct:SyncVec	access:public	signature:()
Synchronized	.\Synchronized.h	/^  Synchronized() = default;$/;"	p	struct:folly::Synchronized	access:public	signature:()
Synchronized	.\Synchronized.h	/^struct Synchronized {$/;"	s	namespace:folly
SysAlloc	.\Memory.h	/^class SysAlloc {$/;"	c	namespace:folly
SysArena	.\Arena.h	/^  explicit SysArena(size_t minBlockSize = kDefaultMinBlockSize,$/;"	f	class:folly::SysArena	access:public	signature:(size_t minBlockSize = kDefaultMinBlockSize, size_t sizeLimit = kNoSizeLimit, size_t maxAlign = kDefaultMaxAlign)
SysArena	.\Arena.h	/^class SysArena : public Arena<SysAlloc> {$/;"	c	namespace:folly	inherits:Arena
T	.\test\MemoryTest.cpp	/^template <std::size_t> struct T {};$/;"	s	file:
T	.\test\ProducerConsumerQueueTest.cpp	/^  typedef typename QueueType::value_type T;$/;"	t	struct:__anon128::CorrectnessTest	file:	access:public
T	.\test\ProducerConsumerQueueTest.cpp	/^  typedef typename QueueType::value_type T;$/;"	t	struct:__anon128::PerfTest	file:	access:public
T1	.\test\TraitsTest.cpp	/^struct T1 {}; \/\/ old-style IsRelocatable, below$/;"	s	file:
T2	.\test\TraitsTest.cpp	/^struct T2 {}; \/\/ old-style IsRelocatable, below$/;"	s	file:
T3	.\test\TraitsTest.cpp	/^struct T3 { typedef std::true_type IsRelocatable; };$/;"	s	file:
T3::IsRelocatable	.\test\TraitsTest.cpp	/^struct T3 { typedef std::true_type IsRelocatable; };$/;"	t	struct:T3	file:	access:public
T4	.\test\TraitsTest.cpp	/^struct T4 { typedef std::true_type IsTriviallyCopyable; };$/;"	s	file:
T4::IsTriviallyCopyable	.\test\TraitsTest.cpp	/^struct T4 { typedef std::true_type IsTriviallyCopyable; };$/;"	t	struct:T4	file:	access:public
T5	.\test\TraitsTest.cpp	/^struct T5 : T3 {};$/;"	s	file:	inherits:T3
T6TO4	.\IPAddressV6.h	/^    TEREDO, T6TO4, NORMAL,$/;"	e	enum:folly::IPAddressV6::Type
TAKE_OWNERSHIP	.\io\IOBuf.h	/^  enum TakeOwnershipOp { TAKE_OWNERSHIP };$/;"	e	enum:folly::IOBuf::TakeOwnershipOp
TAKE_OWNERSHIP_CUSTOM	.\io\test\IOBufTest.cpp	/^  TAKE_OWNERSHIP_CUSTOM,$/;"	e	enum:BufType	file:
TAKE_OWNERSHIP_MALLOC	.\io\test\IOBufTest.cpp	/^  TAKE_OWNERSHIP_MALLOC,$/;"	e	enum:BufType	file:
TEARDOWN	.\test\stl_tests\StlVectorTest.cpp	1011;"	d	file:
TEN_MINUTE	.\test\TimeseriesHistogramTest.cpp	/^    TEN_MINUTE,$/;"	e	enum:IntMTMHTS::Levels	file:
TEREDO	.\IPAddressV6.h	/^    TEREDO, T6TO4, NORMAL,$/;"	e	enum:folly::IPAddressV6::Type
TERSE	.\experimental\symbolizer\Symbolizer.h	/^    TERSE = 1 << 1,$/;"	e	enum:folly::symbolizer::SymbolizePrinter::Options
TEST	.\experimental\io\test\AsyncIOTest.cpp	/^TEST(AsyncIO, ManyAsyncDataNotPollable) {$/;"	f	signature:(AsyncIO, ManyAsyncDataNotPollable)
TEST	.\experimental\io\test\AsyncIOTest.cpp	/^TEST(AsyncIO, ManyAsyncDataPollable) {$/;"	f	signature:(AsyncIO, ManyAsyncDataPollable)
TEST	.\experimental\io\test\AsyncIOTest.cpp	/^TEST(AsyncIO, MultipleAsyncDataNotPollable) {$/;"	f	signature:(AsyncIO, MultipleAsyncDataNotPollable)
TEST	.\experimental\io\test\AsyncIOTest.cpp	/^TEST(AsyncIO, MultipleAsyncDataPollable) {$/;"	f	signature:(AsyncIO, MultipleAsyncDataPollable)
TEST	.\experimental\io\test\AsyncIOTest.cpp	/^TEST(AsyncIO, NonBlockingWait) {$/;"	f	signature:(AsyncIO, NonBlockingWait)
TEST	.\experimental\io\test\AsyncIOTest.cpp	/^TEST(AsyncIO, SingleAsyncDataNotPollable) {$/;"	f	signature:(AsyncIO, SingleAsyncDataNotPollable)
TEST	.\experimental\io\test\AsyncIOTest.cpp	/^TEST(AsyncIO, SingleAsyncDataPollable) {$/;"	f	signature:(AsyncIO, SingleAsyncDataPollable)
TEST	.\experimental\io\test\AsyncIOTest.cpp	/^TEST(AsyncIO, ZeroAsyncDataNotPollable) {$/;"	f	signature:(AsyncIO, ZeroAsyncDataNotPollable)
TEST	.\experimental\io\test\AsyncIOTest.cpp	/^TEST(AsyncIO, ZeroAsyncDataPollable) {$/;"	f	signature:(AsyncIO, ZeroAsyncDataPollable)
TEST	.\experimental\io\test\FsUtilTest.cpp	/^TEST(Simple, CanonicalizeParent) {$/;"	f	signature:(Simple, CanonicalizeParent)
TEST	.\experimental\io\test\FsUtilTest.cpp	/^TEST(Simple, Path) {$/;"	f	signature:(Simple, Path)
TEST	.\experimental\symbolizer\test\LineReaderTest.cpp	/^TEST(LineReader, Simple) {$/;"	f	namespace:folly::symbolizer::test	signature:(LineReader, Simple)
TEST	.\experimental\symbolizer\test\SignalHandlerTest.cpp	/^TEST(SignalHandler, Simple) {$/;"	f	namespace:folly::symbolizer::test	signature:(SignalHandler, Simple)
TEST	.\experimental\symbolizer\test\StackTraceTest.cpp	/^TEST(StackTraceTest, Signal) {$/;"	f	signature:(StackTraceTest, Signal)
TEST	.\experimental\symbolizer\test\StackTraceTest.cpp	/^TEST(StackTraceTest, Simple) {$/;"	f	signature:(StackTraceTest, Simple)
TEST	.\experimental\symbolizer\test\SymbolizerTest.cpp	/^TEST(Symbolizer, Single) {$/;"	f	namespace:folly::symbolizer::test	signature:(Symbolizer, Single)
TEST	.\experimental\test\BitsTest.cpp	/^TEST(Bits, ConcatenationAligned) {$/;"	f	signature:(Bits, ConcatenationAligned)
TEST	.\experimental\test\BitsTest.cpp	/^TEST(Bits, ConcatenationUnalignedUnsigned) { testConcatenation<false>(); }$/;"	f	signature:(Bits, ConcatenationUnalignedUnsigned)
TEST	.\experimental\test\BitsTest.cpp	/^TEST(Bits, MultiBit64) {$/;"	f	signature:(Bits, MultiBit64)
TEST	.\experimental\test\BitsTest.cpp	/^TEST(Bits, MultiBit8) {$/;"	f	signature:(Bits, MultiBit8)
TEST	.\experimental\test\BitsTest.cpp	/^TEST(Bits, MultiBitSigned64) {$/;"	f	signature:(Bits, MultiBitSigned64)
TEST	.\experimental\test\BitsTest.cpp	/^TEST(Bits, MultiBitUnaligned64) {$/;"	f	signature:(Bits, MultiBitUnaligned64)
TEST	.\experimental\test\BitsTest.cpp	/^TEST(Bits, MultiBitUnaligned8) {$/;"	f	signature:(Bits, MultiBitUnaligned8)
TEST	.\experimental\test\BitsTest.cpp	/^TEST(Bits, SignedMultiBit8) {$/;"	f	signature:(Bits, SignedMultiBit8)
TEST	.\experimental\test\BitsTest.cpp	/^TEST(Bits, Simple64) {$/;"	f	signature:(Bits, Simple64)
TEST	.\experimental\test\BitsTest.cpp	/^TEST(Bits, Simple8) {$/;"	f	signature:(Bits, Simple8)
TEST	.\experimental\test\BitsTest.cpp	/^TEST(Bits, SimpleUnaligned64) {$/;"	f	signature:(Bits, SimpleUnaligned64)
TEST	.\experimental\test\BitsTest.cpp	/^TEST(Bits, SimpleUnaligned8) {$/;"	f	signature:(Bits, SimpleUnaligned8)
TEST	.\experimental\test\EventCountTest.cpp	/^TEST(EventCount, Simple) {$/;"	f	signature:(EventCount, Simple)
TEST	.\experimental\test\SingletonTest.cpp	/^TEST(Singleton, BasicGlobalUsage) {$/;"	f	signature:(Singleton, BasicGlobalUsage)
TEST	.\experimental\test\SingletonTest.cpp	/^TEST(Singleton, BasicUsage) {$/;"	f	signature:(Singleton, BasicUsage)
TEST	.\experimental\test\SingletonTest.cpp	/^TEST(Singleton, DirectUsage) {$/;"	f	signature:(Singleton, DirectUsage)
TEST	.\experimental\test\SingletonTest.cpp	/^TEST(Singleton, MissingSingleton) {$/;"	f	signature:(Singleton, MissingSingleton)
TEST	.\experimental\test\SingletonTest.cpp	/^TEST(Singleton, NamedUsage) {$/;"	f	signature:(Singleton, NamedUsage)
TEST	.\experimental\test\SingletonTest.cpp	/^TEST(Singleton, NaughtyUsage) {$/;"	f	signature:(Singleton, NaughtyUsage)
TEST	.\experimental\test\SingletonTest.cpp	/^TEST(Singleton, SharedPtrUsage) {$/;"	f	signature:(Singleton, SharedPtrUsage)
TEST	.\experimental\test\SingletonTest.cpp	/^TEST(Singleton, SingletonConcurrency) {$/;"	f	signature:(Singleton, SingletonConcurrency)
TEST	.\experimental\test\SingletonTest.cpp	/^TEST(Singleton, SingletonDependencies) {$/;"	f	signature:(Singleton, SingletonDependencies)
TEST	.\experimental\test\TestUtilTest.cpp	/^TEST(TemporaryDirectory, DeleteOnDestruction) {$/;"	f	signature:(TemporaryDirectory, DeleteOnDestruction)
TEST	.\experimental\test\TestUtilTest.cpp	/^TEST(TemporaryDirectory, Permanent) {$/;"	f	signature:(TemporaryDirectory, Permanent)
TEST	.\experimental\test\TestUtilTest.cpp	/^TEST(TemporaryFile, NoSuchPath) {$/;"	f	signature:(TemporaryFile, NoSuchPath)
TEST	.\experimental\test\TestUtilTest.cpp	/^TEST(TemporaryFile, PathPrefix) {$/;"	f	signature:(TemporaryFile, PathPrefix)
TEST	.\experimental\test\TestUtilTest.cpp	/^TEST(TemporaryFile, Prefix) {$/;"	f	signature:(TemporaryFile, Prefix)
TEST	.\experimental\test\TestUtilTest.cpp	/^TEST(TemporaryFile, Simple) {$/;"	f	signature:(TemporaryFile, Simple)
TEST	.\experimental\wangle\concurrent\test\ThreadPoolExecutorTest.cpp	/^TEST(IOThreadPoolExecutorTest, IOBasic) {$/;"	f	signature:(IOThreadPoolExecutorTest, IOBasic)
TEST	.\experimental\wangle\concurrent\test\ThreadPoolExecutorTest.cpp	/^TEST(ThreadPoolExecutorTest, CPUBasic) {$/;"	f	signature:(ThreadPoolExecutorTest, CPUBasic)
TEST	.\experimental\wangle\concurrent\test\ThreadPoolExecutorTest.cpp	/^TEST(ThreadPoolExecutorTest, CPUJoin) {$/;"	f	signature:(ThreadPoolExecutorTest, CPUJoin)
TEST	.\experimental\wangle\concurrent\test\ThreadPoolExecutorTest.cpp	/^TEST(ThreadPoolExecutorTest, CPUResize) {$/;"	f	signature:(ThreadPoolExecutorTest, CPUResize)
TEST	.\experimental\wangle\concurrent\test\ThreadPoolExecutorTest.cpp	/^TEST(ThreadPoolExecutorTest, CPUResizeUnderLoad) {$/;"	f	signature:(ThreadPoolExecutorTest, CPUResizeUnderLoad)
TEST	.\experimental\wangle\concurrent\test\ThreadPoolExecutorTest.cpp	/^TEST(ThreadPoolExecutorTest, CPUStop) {$/;"	f	signature:(ThreadPoolExecutorTest, CPUStop)
TEST	.\experimental\wangle\concurrent\test\ThreadPoolExecutorTest.cpp	/^TEST(ThreadPoolExecutorTest, IOJoin) {$/;"	f	signature:(ThreadPoolExecutorTest, IOJoin)
TEST	.\experimental\wangle\concurrent\test\ThreadPoolExecutorTest.cpp	/^TEST(ThreadPoolExecutorTest, IOResize) {$/;"	f	signature:(ThreadPoolExecutorTest, IOResize)
TEST	.\experimental\wangle\concurrent\test\ThreadPoolExecutorTest.cpp	/^TEST(ThreadPoolExecutorTest, IOResizeUnderLoad) {$/;"	f	signature:(ThreadPoolExecutorTest, IOResizeUnderLoad)
TEST	.\experimental\wangle\concurrent\test\ThreadPoolExecutorTest.cpp	/^TEST(ThreadPoolExecutorTest, IOStop) {$/;"	f	signature:(ThreadPoolExecutorTest, IOStop)
TEST	.\gen\test\BaseTest.cpp	/^TEST(Gen, All) {$/;"	f	signature:(Gen, All)
TEST	.\gen\test\BaseTest.cpp	/^TEST(Gen, Any) {$/;"	f	signature:(Gen, Any)
TEST	.\gen\test\BaseTest.cpp	/^TEST(Gen, Append) {$/;"	f	signature:(Gen, Append)
TEST	.\gen\test\BaseTest.cpp	/^TEST(Gen, Batch) {$/;"	f	signature:(Gen, Batch)
TEST	.\gen\test\BaseTest.cpp	/^TEST(Gen, BatchMove) {$/;"	f	signature:(Gen, BatchMove)
TEST	.\gen\test\BaseTest.cpp	/^TEST(Gen, Chain) {$/;"	f	signature:(Gen, Chain)
TEST	.\gen\test\BaseTest.cpp	/^TEST(Gen, Collect) {$/;"	f	signature:(Gen, Collect)
TEST	.\gen\test\BaseTest.cpp	/^TEST(Gen, Composed) {$/;"	f	signature:(Gen, Composed)
TEST	.\gen\test\BaseTest.cpp	/^TEST(Gen, Concat) {$/;"	f	signature:(Gen, Concat)
TEST	.\gen\test\BaseTest.cpp	/^TEST(Gen, ConcatAlt) {$/;"	f	signature:(Gen, ConcatAlt)
TEST	.\gen\test\BaseTest.cpp	/^TEST(Gen, ConcatGen) {$/;"	f	signature:(Gen, ConcatGen)
TEST	.\gen\test\BaseTest.cpp	/^TEST(Gen, Contains) {$/;"	f	signature:(Gen, Contains)
TEST	.\gen\test\BaseTest.cpp	/^TEST(Gen, CopyCount) {$/;"	f	signature:(Gen, CopyCount)
TEST	.\gen\test\BaseTest.cpp	/^TEST(Gen, Count) {$/;"	f	signature:(Gen, Count)
TEST	.\gen\test\BaseTest.cpp	/^TEST(Gen, CustomType) {$/;"	f	signature:(Gen, CustomType)
TEST	.\gen\test\BaseTest.cpp	/^TEST(Gen, Cycle) {$/;"	f	signature:(Gen, Cycle)
TEST	.\gen\test\BaseTest.cpp	/^TEST(Gen, Dereference) {$/;"	f	signature:(Gen, Dereference)
TEST	.\gen\test\BaseTest.cpp	/^TEST(Gen, Distinct) {$/;"	f	signature:(Gen, Distinct)
TEST	.\gen\test\BaseTest.cpp	/^TEST(Gen, DistinctBy) {   \/\/  0  1  4  9  6  5  6  9  4  1  0$/;"	f	signature:(Gen, DistinctBy)
TEST	.\gen\test\BaseTest.cpp	/^TEST(Gen, DistinctMove) {   \/\/  0  1  4  9  6  5  6  9  4  1  0$/;"	f	signature:(Gen, DistinctMove)
TEST	.\gen\test\BaseTest.cpp	/^TEST(Gen, Dynamic) {$/;"	f	signature:(Gen, Dynamic)
TEST	.\gen\test\BaseTest.cpp	/^TEST(Gen, DynamicObject) {$/;"	f	signature:(Gen, DynamicObject)
TEST	.\gen\test\BaseTest.cpp	/^TEST(Gen, Field) {$/;"	f	signature:(Gen, Field)
TEST	.\gen\test\BaseTest.cpp	/^TEST(Gen, Filter) {$/;"	f	signature:(Gen, Filter)
TEST	.\gen\test\BaseTest.cpp	/^TEST(Gen, First) {$/;"	f	signature:(Gen, First)
TEST	.\gen\test\BaseTest.cpp	/^TEST(Gen, Foldl) {$/;"	f	signature:(Gen, Foldl)
TEST	.\gen\test\BaseTest.cpp	/^TEST(Gen, Foreach) {$/;"	f	signature:(Gen, Foreach)
TEST	.\gen\test\BaseTest.cpp	/^TEST(Gen, FromArray) {$/;"	f	signature:(Gen, FromArray)
TEST	.\gen\test\BaseTest.cpp	/^TEST(Gen, FromCopy) {$/;"	f	signature:(Gen, FromCopy)
TEST	.\gen\test\BaseTest.cpp	/^TEST(Gen, FromIterators) {$/;"	f	signature:(Gen, FromIterators)
TEST	.\gen\test\BaseTest.cpp	/^TEST(Gen, FromMap) {$/;"	f	signature:(Gen, FromMap)
TEST	.\gen\test\BaseTest.cpp	/^TEST(Gen, FromRValue) {$/;"	f	signature:(Gen, FromRValue)
TEST	.\gen\test\BaseTest.cpp	/^TEST(Gen, FromStdArray) {$/;"	f	signature:(Gen, FromStdArray)
TEST	.\gen\test\BaseTest.cpp	/^TEST(Gen, Get) {$/;"	f	signature:(Gen, Get)
TEST	.\gen\test\BaseTest.cpp	/^TEST(Gen, Guard) {$/;"	f	signature:(Gen, Guard)
TEST	.\gen\test\BaseTest.cpp	/^TEST(Gen, Map) {$/;"	f	signature:(Gen, Map)
TEST	.\gen\test\BaseTest.cpp	/^TEST(Gen, MapYielders) {$/;"	f	signature:(Gen, MapYielders)
TEST	.\gen\test\BaseTest.cpp	/^TEST(Gen, MaxBy) {$/;"	f	signature:(Gen, MaxBy)
TEST	.\gen\test\BaseTest.cpp	/^TEST(Gen, Member) {$/;"	f	signature:(Gen, Member)
TEST	.\gen\test\BaseTest.cpp	/^TEST(Gen, MinBy) {$/;"	f	signature:(Gen, MinBy)
TEST	.\gen\test\BaseTest.cpp	/^TEST(Gen, Moves) {$/;"	f	signature:(Gen, Moves)
TEST	.\gen\test\BaseTest.cpp	/^TEST(Gen, NestedYield) {$/;"	f	signature:(Gen, NestedYield)
TEST	.\gen\test\BaseTest.cpp	/^TEST(Gen, NoGeneratorCopies) {$/;"	f	signature:(Gen, NoGeneratorCopies)
TEST	.\gen\test\BaseTest.cpp	/^TEST(Gen, NoNeedlessCopies) {$/;"	f	signature:(Gen, NoNeedlessCopies)
TEST	.\gen\test\BaseTest.cpp	/^TEST(Gen, Order) {$/;"	f	signature:(Gen, Order)
TEST	.\gen\test\BaseTest.cpp	/^TEST(Gen, OrderBy) {$/;"	f	signature:(Gen, OrderBy)
TEST	.\gen\test\BaseTest.cpp	/^TEST(Gen, OrderMoved) {$/;"	f	signature:(Gen, OrderMoved)
TEST	.\gen\test\BaseTest.cpp	/^TEST(Gen, OrderTake) {$/;"	f	signature:(Gen, OrderTake)
TEST	.\gen\test\BaseTest.cpp	/^TEST(Gen, Range) {$/;"	f	signature:(Gen, Range)
TEST	.\gen\test\BaseTest.cpp	/^TEST(Gen, RangeWithStep) {$/;"	f	signature:(Gen, RangeWithStep)
TEST	.\gen\test\BaseTest.cpp	/^TEST(Gen, Reduce) {$/;"	f	signature:(Gen, Reduce)
TEST	.\gen\test\BaseTest.cpp	/^TEST(Gen, ReduceBad) {$/;"	f	signature:(Gen, ReduceBad)
TEST	.\gen\test\BaseTest.cpp	/^TEST(Gen, Sample) {$/;"	f	signature:(Gen, Sample)
TEST	.\gen\test\BaseTest.cpp	/^TEST(Gen, Seq) {$/;"	f	signature:(Gen, Seq)
TEST	.\gen\test\BaseTest.cpp	/^TEST(Gen, SeqWithStep) {$/;"	f	signature:(Gen, SeqWithStep)
TEST	.\gen\test\BaseTest.cpp	/^TEST(Gen, SeqWithStepArray) {$/;"	f	signature:(Gen, SeqWithStepArray)
TEST	.\gen\test\BaseTest.cpp	/^TEST(Gen, Skip) {$/;"	f	signature:(Gen, Skip)
TEST	.\gen\test\BaseTest.cpp	/^TEST(Gen, Stride) {$/;"	f	signature:(Gen, Stride)
TEST	.\gen\test\BaseTest.cpp	/^TEST(Gen, StringConcat) {$/;"	f	signature:(Gen, StringConcat)
TEST	.\gen\test\BaseTest.cpp	/^TEST(Gen, Sum) {$/;"	f	signature:(Gen, Sum)
TEST	.\gen\test\BaseTest.cpp	/^TEST(Gen, Take) {$/;"	f	signature:(Gen, Take)
TEST	.\gen\test\BaseTest.cpp	/^TEST(Gen, Until) {$/;"	f	signature:(Gen, Until)
TEST	.\gen\test\BaseTest.cpp	/^TEST(Gen, VirtualGen) {$/;"	f	signature:(Gen, VirtualGen)
TEST	.\gen\test\BaseTest.cpp	/^TEST(Gen, Yielders) {$/;"	f	signature:(Gen, Yielders)
TEST	.\gen\test\CombineTest.cpp	/^TEST(CombineGen, Interleave) {$/;"	f	signature:(CombineGen, Interleave)
TEST	.\gen\test\CombineTest.cpp	/^TEST(CombineGen, TupleFlatten) {$/;"	f	signature:(CombineGen, TupleFlatten)
TEST	.\gen\test\CombineTest.cpp	/^TEST(CombineGen, Zip) {$/;"	f	signature:(CombineGen, Zip)
TEST	.\gen\test\FileTest.cpp	/^TEST(FileGen, ByLine) {$/;"	f	signature:(FileGen, ByLine)
TEST	.\gen\test\ParallelMapTest.cpp	/^TEST(Pmap, Empty) {$/;"	f	signature:(Pmap, Empty)
TEST	.\gen\test\ParallelMapTest.cpp	/^TEST(Pmap, InfiniteEquivalent) {$/;"	f	signature:(Pmap, InfiniteEquivalent)
TEST	.\gen\test\ParallelMapTest.cpp	/^TEST(Pmap, Rvalues) {$/;"	f	signature:(Pmap, Rvalues)
TEST	.\gen\test\ParallelTest.cpp	/^TEST(ParallelTest, ComputeBound64) {$/;"	f	signature:(ParallelTest, ComputeBound64)
TEST	.\gen\test\ParallelTest.cpp	/^TEST(ParallelTest, PSum) {$/;"	f	signature:(ParallelTest, PSum)
TEST	.\gen\test\ParallelTest.cpp	/^TEST(ParallelTest, Serial) {$/;"	f	signature:(ParallelTest, Serial)
TEST	.\gen\test\ParallelTest.cpp	/^TEST(ParallelTest, Take) {$/;"	f	signature:(ParallelTest, Take)
TEST	.\gen\test\ParallelTest.cpp	/^TEST(ParallelTest, Unique) {$/;"	f	signature:(ParallelTest, Unique)
TEST	.\gen\test\StringTest.cpp	/^TEST(StringGen, EachToPair) {$/;"	f	signature:(StringGen, EachToPair)
TEST	.\gen\test\StringTest.cpp	/^TEST(StringGen, EachToTuple) {$/;"	f	signature:(StringGen, EachToTuple)
TEST	.\gen\test\StringTest.cpp	/^TEST(StringGen, EmptyResplit) {$/;"	f	signature:(StringGen, EmptyResplit)
TEST	.\gen\test\StringTest.cpp	/^TEST(StringGen, EmptySplit) {$/;"	f	signature:(StringGen, EmptySplit)
TEST	.\gen\test\StringTest.cpp	/^TEST(StringGen, Resplit) {$/;"	f	signature:(StringGen, Resplit)
TEST	.\gen\test\StringTest.cpp	/^TEST(StringGen, ResplitMaxLength) {$/;"	f	signature:(StringGen, ResplitMaxLength)
TEST	.\gen\test\StringTest.cpp	/^TEST(StringGen, Split) {$/;"	f	signature:(StringGen, Split)
TEST	.\gen\test\StringTest.cpp	/^TEST(StringGen, SplitByNewLine) {$/;"	f	signature:(StringGen, SplitByNewLine)
TEST	.\gen\test\StringTest.cpp	/^TEST(StringGen, Unsplit) {$/;"	f	signature:(StringGen, Unsplit)
TEST	.\io\test\CompressionTest.cpp	/^TEST(CompressionTestNeedsUncompressedLength, Simple) {$/;"	f	namespace:folly::io::test	signature:(CompressionTestNeedsUncompressedLength, Simple)
TEST	.\io\test\EventBaseTest.cpp	/^TEST(EventBase, StopBeforeLoop) {$/;"	f	signature:(EventBase, StopBeforeLoop)
TEST	.\io\test\IOBufCursorTest.cpp	/^TEST(IOBuf, Appender) {$/;"	f	signature:(IOBuf, Appender)
TEST	.\io\test\IOBufCursorTest.cpp	/^TEST(IOBuf, Cursor) {$/;"	f	signature:(IOBuf, Cursor)
TEST	.\io\test\IOBufCursorTest.cpp	/^TEST(IOBuf, CursorOperators) {$/;"	f	signature:(IOBuf, CursorOperators)
TEST	.\io\test\IOBufCursorTest.cpp	/^TEST(IOBuf, Gather) {$/;"	f	signature:(IOBuf, Gather)
TEST	.\io\test\IOBufCursorTest.cpp	/^TEST(IOBuf, PullAndPeek) {$/;"	f	signature:(IOBuf, PullAndPeek)
TEST	.\io\test\IOBufCursorTest.cpp	/^TEST(IOBuf, QueueAppender) {$/;"	f	signature:(IOBuf, QueueAppender)
TEST	.\io\test\IOBufCursorTest.cpp	/^TEST(IOBuf, RWCursor) {$/;"	f	signature:(IOBuf, RWCursor)
TEST	.\io\test\IOBufCursorTest.cpp	/^TEST(IOBuf, StringOperations) {$/;"	f	signature:(IOBuf, StringOperations)
TEST	.\io\test\IOBufCursorTest.cpp	/^TEST(IOBuf, UnshareCursor) {$/;"	f	signature:(IOBuf, UnshareCursor)
TEST	.\io\test\IOBufCursorTest.cpp	/^TEST(IOBuf, arithmetic) {$/;"	f	signature:(IOBuf, arithmetic)
TEST	.\io\test\IOBufCursorTest.cpp	/^TEST(IOBuf, cloneAndInsert) {$/;"	f	signature:(IOBuf, cloneAndInsert)
TEST	.\io\test\IOBufCursorTest.cpp	/^TEST(IOBuf, copy_assign_convert) {$/;"	f	signature:(IOBuf, copy_assign_convert)
TEST	.\io\test\IOBufCursorTest.cpp	/^TEST(IOBuf, endian) {$/;"	f	signature:(IOBuf, endian)
TEST	.\io\test\IOBufCursorTest.cpp	/^TEST(IOBuf, reset) {$/;"	f	signature:(IOBuf, reset)
TEST	.\io\test\IOBufCursorTest.cpp	/^TEST(IOBuf, skip) {$/;"	f	signature:(IOBuf, skip)
TEST	.\io\test\IOBufQueueTest.cpp	/^TEST(IOBufQueue, Append) {$/;"	f	signature:(IOBufQueue, Append)
TEST	.\io\test\IOBufQueueTest.cpp	/^TEST(IOBufQueue, Append2) {$/;"	f	signature:(IOBufQueue, Append2)
TEST	.\io\test\IOBufQueueTest.cpp	/^TEST(IOBufQueue, AppendStringPiece) {$/;"	f	signature:(IOBufQueue, AppendStringPiece)
TEST	.\io\test\IOBufQueueTest.cpp	/^TEST(IOBufQueue, PopFirst) {$/;"	f	signature:(IOBufQueue, PopFirst)
TEST	.\io\test\IOBufQueueTest.cpp	/^TEST(IOBufQueue, Preallocate) {$/;"	f	signature:(IOBufQueue, Preallocate)
TEST	.\io\test\IOBufQueueTest.cpp	/^TEST(IOBufQueue, Prepend) {$/;"	f	signature:(IOBufQueue, Prepend)
TEST	.\io\test\IOBufQueueTest.cpp	/^TEST(IOBufQueue, Simple) {$/;"	f	signature:(IOBufQueue, Simple)
TEST	.\io\test\IOBufQueueTest.cpp	/^TEST(IOBufQueue, Split) {$/;"	f	signature:(IOBufQueue, Split)
TEST	.\io\test\IOBufQueueTest.cpp	/^TEST(IOBufQueue, Trim) {$/;"	f	signature:(IOBufQueue, Trim)
TEST	.\io\test\IOBufQueueTest.cpp	/^TEST(IOBufQueue, TrimPack) {$/;"	f	signature:(IOBufQueue, TrimPack)
TEST	.\io\test\IOBufQueueTest.cpp	/^TEST(IOBufQueue, Wrap) {$/;"	f	signature:(IOBufQueue, Wrap)
TEST	.\io\test\IOBufTest.cpp	/^TEST(IOBuf, Alignment) {$/;"	f	signature:(IOBuf, Alignment)
TEST	.\io\test\IOBufTest.cpp	/^TEST(IOBuf, AllocSizes) {$/;"	f	signature:(IOBuf, AllocSizes)
TEST	.\io\test\IOBufTest.cpp	/^TEST(IOBuf, Chaining) {$/;"	f	signature:(IOBuf, Chaining)
TEST	.\io\test\IOBufTest.cpp	/^TEST(IOBuf, CreateCombined) {$/;"	f	signature:(IOBuf, CreateCombined)
TEST	.\io\test\IOBufTest.cpp	/^TEST(IOBuf, HashAndEqual) {$/;"	f	signature:(IOBuf, HashAndEqual)
TEST	.\io\test\IOBufTest.cpp	/^TEST(IOBuf, Reserve) {$/;"	f	signature:(IOBuf, Reserve)
TEST	.\io\test\IOBufTest.cpp	/^TEST(IOBuf, Simple) {$/;"	f	signature:(IOBuf, Simple)
TEST	.\io\test\IOBufTest.cpp	/^TEST(IOBuf, TakeOwnership) {$/;"	f	signature:(IOBuf, TakeOwnership)
TEST	.\io\test\IOBufTest.cpp	/^TEST(IOBuf, WrapBuffer) {$/;"	f	signature:(IOBuf, WrapBuffer)
TEST	.\io\test\IOBufTest.cpp	/^TEST(IOBuf, copyBuffer) {$/;"	f	signature:(IOBuf, copyBuffer)
TEST	.\io\test\IOBufTest.cpp	/^TEST(IOBuf, getIov) {$/;"	f	signature:(IOBuf, getIov)
TEST	.\io\test\IOBufTest.cpp	/^TEST(IOBuf, maybeCopyBuffer) {$/;"	f	signature:(IOBuf, maybeCopyBuffer)
TEST	.\io\test\IOBufTest.cpp	/^TEST(IOBuf, move) {$/;"	f	signature:(IOBuf, move)
TEST	.\io\test\IOBufTest.cpp	/^TEST(IOBuf, takeOwnershipUniquePtr) {$/;"	f	signature:(IOBuf, takeOwnershipUniquePtr)
TEST	.\io\test\IOBufTest.cpp	/^TEST(TypedIOBuf, Simple) {$/;"	f	signature:(TypedIOBuf, Simple)
TEST	.\io\test\RecordIOTest.cpp	/^TEST(RecordIOTest, ExtraMagic) {$/;"	f	namespace:folly::test	signature:(RecordIOTest, ExtraMagic)
TEST	.\io\test\RecordIOTest.cpp	/^TEST(RecordIOTest, MultipleFileIds) {$/;"	f	namespace:folly::test	signature:(RecordIOTest, MultipleFileIds)
TEST	.\io\test\RecordIOTest.cpp	/^TEST(RecordIOTest, Randomized) {$/;"	f	namespace:folly::test	signature:(RecordIOTest, Randomized)
TEST	.\io\test\RecordIOTest.cpp	/^TEST(RecordIOTest, Simple) {$/;"	f	namespace:folly::test	signature:(RecordIOTest, Simple)
TEST	.\io\test\RecordIOTest.cpp	/^TEST(RecordIOTest, SmallRecords) {$/;"	f	namespace:folly::test	signature:(RecordIOTest, SmallRecords)
TEST	.\test\AHMIntStressTest.cpp	/^TEST(AHMIntStressTest, Test) {$/;"	f	signature:(AHMIntStressTest, Test)
TEST	.\test\ApplyTupleTest.cpp	/^TEST(ApplyTuple, Test) {$/;"	f	signature:(ApplyTuple, Test)
TEST	.\test\ArenaSmartPtrTest.cpp	/^TEST(ArenaSmartPtr, shared_ptr_StlAlloc_SysArena) {$/;"	f	signature:(ArenaSmartPtr, shared_ptr_StlAlloc_SysArena)
TEST	.\test\ArenaSmartPtrTest.cpp	/^TEST(ArenaSmartPtr, shared_ptr_SysArena) {$/;"	f	signature:(ArenaSmartPtr, shared_ptr_SysArena)
TEST	.\test\ArenaSmartPtrTest.cpp	/^TEST(ArenaSmartPtr, unique_ptr_StlAlloc_SysArena) {$/;"	f	signature:(ArenaSmartPtr, unique_ptr_StlAlloc_SysArena)
TEST	.\test\ArenaSmartPtrTest.cpp	/^TEST(ArenaSmartPtr, unique_ptr_SysArena) {$/;"	f	signature:(ArenaSmartPtr, unique_ptr_SysArena)
TEST	.\test\ArenaTest.cpp	/^TEST(Arena, BytesUsedSanity) {$/;"	f	signature:(Arena, BytesUsedSanity)
TEST	.\test\ArenaTest.cpp	/^TEST(Arena, SizeLimit) {$/;"	f	signature:(Arena, SizeLimit)
TEST	.\test\ArenaTest.cpp	/^TEST(Arena, SizeSanity) {$/;"	f	signature:(Arena, SizeSanity)
TEST	.\test\ArenaTest.cpp	/^TEST(Arena, Vector) {$/;"	f	signature:(Arena, Vector)
TEST	.\test\AsciiCaseInsensitiveTest.cpp	/^TEST(CaseInsensitiveMatch, CompareWithLegacy) {$/;"	f	signature:(CaseInsensitiveMatch, CompareWithLegacy)
TEST	.\test\AtomicBitSetTest.cpp	/^TEST(AtomicBitSet, Simple) {$/;"	f	namespace:folly::test	signature:(AtomicBitSet, Simple)
TEST	.\test\AtomicHashArrayTest.cpp	/^TEST(Aha, InsertErase_i32_i32) {$/;"	f	signature:(Aha, InsertErase_i32_i32)
TEST	.\test\AtomicHashArrayTest.cpp	/^TEST(Aha, InsertErase_i32_i64) {$/;"	f	signature:(Aha, InsertErase_i32_i64)
TEST	.\test\AtomicHashArrayTest.cpp	/^TEST(Aha, InsertErase_i32_str) {$/;"	f	signature:(Aha, InsertErase_i32_str)
TEST	.\test\AtomicHashArrayTest.cpp	/^TEST(Aha, InsertErase_i64_i32) {$/;"	f	signature:(Aha, InsertErase_i64_i32)
TEST	.\test\AtomicHashArrayTest.cpp	/^TEST(Aha, InsertErase_i64_i64) {$/;"	f	signature:(Aha, InsertErase_i64_i64)
TEST	.\test\AtomicHashArrayTest.cpp	/^TEST(Aha, InsertErase_i64_str) {$/;"	f	signature:(Aha, InsertErase_i64_str)
TEST	.\test\AtomicHashMapTest.cpp	/^TEST(Ahm, BasicNoncopyable) {$/;"	f	signature:(Ahm, BasicNoncopyable)
TEST	.\test\AtomicHashMapTest.cpp	/^TEST(Ahm, BasicStrings) {$/;"	f	signature:(Ahm, BasicStrings)
TEST	.\test\AtomicHashMapTest.cpp	/^TEST(Ahm, atomic_hash_array_insert_race) {$/;"	f	signature:(Ahm, atomic_hash_array_insert_race)
TEST	.\test\AtomicHashMapTest.cpp	/^TEST(Ahm, basicErase) {$/;"	f	signature:(Ahm, basicErase)
TEST	.\test\AtomicHashMapTest.cpp	/^TEST(Ahm, collision_test) {$/;"	f	signature:(Ahm, collision_test)
TEST	.\test\AtomicHashMapTest.cpp	/^TEST(Ahm, counter) {$/;"	f	signature:(Ahm, counter)
TEST	.\test\AtomicHashMapTest.cpp	/^TEST(Ahm, grow) {$/;"	f	signature:(Ahm, grow)
TEST	.\test\AtomicHashMapTest.cpp	/^TEST(Ahm, iterator) {$/;"	f	signature:(Ahm, iterator)
TEST	.\test\AtomicHashMapTest.cpp	/^TEST(Ahm, map_exception_safety) {$/;"	f	signature:(Ahm, map_exception_safety)
TEST	.\test\AtomicHashMapTest.cpp	/^TEST(Ahm, race_insert_iterate_thread_test) {$/;"	f	signature:(Ahm, race_insert_iterate_thread_test)
TEST	.\test\AtomicHashMapTest.cpp	/^TEST(Ahm, thread_erase_insert_race) {$/;"	f	signature:(Ahm, thread_erase_insert_race)
TEST	.\test\AtomicStructTest.cpp	/^TEST(AtomicStruct, size_selection) {$/;"	f	signature:(AtomicStruct, size_selection)
TEST	.\test\AtomicStructTest.cpp	/^TEST(AtomicStruct, two_by_32) {$/;"	f	signature:(AtomicStruct, two_by_32)
TEST	.\test\BatonTest.cpp	/^TEST(Baton, basic) {$/;"	f	signature:(Baton, basic)
TEST	.\test\BatonTest.cpp	/^TEST(Baton, pingpong) {$/;"	f	signature:(Baton, pingpong)
TEST	.\test\BatonTest.cpp	/^TEST(Baton, timed_wait) {$/;"	f	signature:(Baton, timed_wait)
TEST	.\test\BatonTest.cpp	/^TEST(Baton, timed_wait_basic) {$/;"	f	signature:(Baton, timed_wait_basic)
TEST	.\test\BatonTest.cpp	/^TEST(Baton, timed_wait_timeout) {$/;"	f	signature:(Baton, timed_wait_timeout)
TEST	.\test\BatonTest.cpp	/^TEST(Baton, try_wait) {$/;"	f	signature:(Baton, try_wait)
TEST	.\test\BitIteratorTest.cpp	/^TEST(BitIterator, Const) {$/;"	f	signature:(BitIterator, Const)
TEST	.\test\BitIteratorTest.cpp	/^TEST(BitIterator, FindFirstSet) {$/;"	f	signature:(BitIterator, FindFirstSet)
TEST	.\test\BitIteratorTest.cpp	/^TEST(BitIterator, Simple) {$/;"	f	signature:(BitIterator, Simple)
TEST	.\test\BitIteratorTest.cpp	/^TEST(BitIterator, SimpleFindFirstSet) {$/;"	f	signature:(BitIterator, SimpleFindFirstSet)
TEST	.\test\BitsTest.cpp	/^TEST(Bits, FindFirstSet) {$/;"	f	signature:(Bits, FindFirstSet)
TEST	.\test\BitsTest.cpp	/^TEST(Bits, FindLastSet) {$/;"	f	signature:(Bits, FindLastSet)
TEST	.\test\BitsTest.cpp	/^TEST(Bits, isPowTwo) {$/;"	f	signature:(Bits, isPowTwo)
TEST	.\test\BitsTest.cpp	/^TEST(Bits, nextPowTwoClz) {$/;"	f	signature:(Bits, nextPowTwoClz)
TEST	.\test\BitsTest.cpp	/^TEST(Bits, popcount) {$/;"	f	signature:(Bits, popcount)
TEST	.\test\CacheLocalityTest.cpp	/^TEST(AccessSpreader, Default) {$/;"	f	signature:(AccessSpreader, Default)
TEST	.\test\CacheLocalityTest.cpp	/^TEST(AccessSpreader, Shared) {$/;"	f	signature:(AccessSpreader, Shared)
TEST	.\test\CacheLocalityTest.cpp	/^TEST(AccessSpreader, Statics) {$/;"	f	signature:(AccessSpreader, Statics)
TEST	.\test\CacheLocalityTest.cpp	/^TEST(AccessSpreader, Stubbed) {$/;"	f	signature:(AccessSpreader, Stubbed)
TEST	.\test\CacheLocalityTest.cpp	/^TEST(AccessSpreader, Wrapping) {$/;"	f	signature:(AccessSpreader, Wrapping)
TEST	.\test\CacheLocalityTest.cpp	/^TEST(CacheLocality, FakeSysfs) {$/;"	f	signature:(CacheLocality, FakeSysfs)
TEST	.\test\CacheLocalityTest.cpp	/^TEST(Getcpu, VdsoGetcpu) {$/;"	f	signature:(Getcpu, VdsoGetcpu)
TEST	.\test\CacheLocalityTest.cpp	/^TEST(SequentialThreadId, Simple) {$/;"	f	signature:(SequentialThreadId, Simple)
TEST	.\test\ChecksumTest.cpp	/^TEST(Checksum, crc32c_autodetect) {$/;"	f	signature:(Checksum, crc32c_autodetect)
TEST	.\test\ChecksumTest.cpp	/^TEST(Checksum, crc32c_continuation_autodetect) {$/;"	f	signature:(Checksum, crc32c_continuation_autodetect)
TEST	.\test\ChecksumTest.cpp	/^TEST(Checksum, crc32c_continuation_hardware) {$/;"	f	signature:(Checksum, crc32c_continuation_hardware)
TEST	.\test\ChecksumTest.cpp	/^TEST(Checksum, crc32c_continuation_software) {$/;"	f	signature:(Checksum, crc32c_continuation_software)
TEST	.\test\ChecksumTest.cpp	/^TEST(Checksum, crc32c_hardware) {$/;"	f	signature:(Checksum, crc32c_hardware)
TEST	.\test\ChecksumTest.cpp	/^TEST(Checksum, crc32c_software) {$/;"	f	signature:(Checksum, crc32c_software)
TEST	.\test\ConcurrentSkipListTest.cpp	/^TEST(ConcurrentSkipList, ConcurrentAccess) {$/;"	f	namespace:__anon114	signature:(ConcurrentSkipList, ConcurrentAccess)
TEST	.\test\ConcurrentSkipListTest.cpp	/^TEST(ConcurrentSkipList, ConcurrentAdd) {$/;"	f	namespace:__anon114	signature:(ConcurrentSkipList, ConcurrentAdd)
TEST	.\test\ConcurrentSkipListTest.cpp	/^TEST(ConcurrentSkipList, ConcurrentRemove) {$/;"	f	namespace:__anon114	signature:(ConcurrentSkipList, ConcurrentRemove)
TEST	.\test\ConcurrentSkipListTest.cpp	/^TEST(ConcurrentSkipList, SequentialAccess) {$/;"	f	namespace:__anon114	signature:(ConcurrentSkipList, SequentialAccess)
TEST	.\test\ConcurrentSkipListTest.cpp	/^TEST(ConcurrentSkipList, TestMovableData) {$/;"	f	namespace:__anon114	signature:(ConcurrentSkipList, TestMovableData)
TEST	.\test\ConcurrentSkipListTest.cpp	/^TEST(ConcurrentSkipList, TestStringType) {$/;"	f	namespace:__anon114	signature:(ConcurrentSkipList, TestStringType)
TEST	.\test\ConvTest.cpp	/^TEST(Conv, BadStringToIntegral) {$/;"	f	signature:(Conv, BadStringToIntegral)
TEST	.\test\ConvTest.cpp	/^TEST(Conv, CorruptedStringToInt) {$/;"	f	signature:(Conv, CorruptedStringToInt)
TEST	.\test\ConvTest.cpp	/^TEST(Conv, DoubleToInt) {$/;"	f	signature:(Conv, DoubleToInt)
TEST	.\test\ConvTest.cpp	/^TEST(Conv, DoubleToString) {$/;"	f	signature:(Conv, DoubleToString)
TEST	.\test\ConvTest.cpp	/^TEST(Conv, EmptyStringToDouble) {$/;"	f	signature:(Conv, EmptyStringToDouble)
TEST	.\test\ConvTest.cpp	/^TEST(Conv, EmptyStringToInt) {$/;"	f	signature:(Conv, EmptyStringToInt)
TEST	.\test\ConvTest.cpp	/^TEST(Conv, EnumClassToString) {$/;"	f	signature:(Conv, EnumClassToString)
TEST	.\test\ConvTest.cpp	/^TEST(Conv, EnumToInt) {$/;"	f	signature:(Conv, EnumToInt)
TEST	.\test\ConvTest.cpp	/^TEST(Conv, EnumToString) {$/;"	f	signature:(Conv, EnumToString)
TEST	.\test\ConvTest.cpp	/^TEST(Conv, FBStringToString) {$/;"	f	signature:(Conv, FBStringToString)
TEST	.\test\ConvTest.cpp	/^TEST(Conv, Floating2Floating) {$/;"	f	signature:(Conv, Floating2Floating)
TEST	.\test\ConvTest.cpp	/^TEST(Conv, IntToDouble) {$/;"	f	signature:(Conv, IntToDouble)
TEST	.\test\ConvTest.cpp	/^TEST(Conv, IntToEnum) {$/;"	f	signature:(Conv, IntToEnum)
TEST	.\test\ConvTest.cpp	/^TEST(Conv, Integral2Integral) {$/;"	f	signature:(Conv, Integral2Integral)
TEST	.\test\ConvTest.cpp	/^TEST(Conv, Integral2String) {$/;"	f	signature:(Conv, Integral2String)
TEST	.\test\ConvTest.cpp	/^TEST(Conv, NewUint64ToString) {$/;"	f	signature:(Conv, NewUint64ToString)
TEST	.\test\ConvTest.cpp	/^TEST(Conv, NullString) {$/;"	f	signature:(Conv, NullString)
TEST	.\test\ConvTest.cpp	/^TEST(Conv, String2Integral) {$/;"	f	signature:(Conv, String2Integral)
TEST	.\test\ConvTest.cpp	/^TEST(Conv, StringPiece2Integral) {$/;"	f	signature:(Conv, StringPiece2Integral)
TEST	.\test\ConvTest.cpp	/^TEST(Conv, StringPieceAppend) {$/;"	f	signature:(Conv, StringPieceAppend)
TEST	.\test\ConvTest.cpp	/^TEST(Conv, StringPieceToDouble) {$/;"	f	signature:(Conv, StringPieceToDouble)
TEST	.\test\ConvTest.cpp	/^TEST(Conv, StringToBool) {$/;"	f	signature:(Conv, StringToBool)
TEST	.\test\ConvTest.cpp	/^TEST(Conv, UnsignedEnum) {$/;"	f	signature:(Conv, UnsignedEnum)
TEST	.\test\ConvTest.cpp	/^TEST(Conv, UnsignedEnumClass) {$/;"	f	signature:(Conv, UnsignedEnumClass)
TEST	.\test\ConvTest.cpp	/^TEST(Conv, VariadicTo) {$/;"	f	signature:(Conv, VariadicTo)
TEST	.\test\ConvTest.cpp	/^TEST(Conv, VariadicToDelim) {$/;"	f	signature:(Conv, VariadicToDelim)
TEST	.\test\CpuIdTest.cpp	/^TEST(CpuId, Simple) {$/;"	f	signature:(CpuId, Simple)
TEST	.\test\DeterministicScheduleTest.cpp	/^TEST(DeterministicSchedule, uniform) {$/;"	f	signature:(DeterministicSchedule, uniform)
TEST	.\test\DeterministicScheduleTest.cpp	/^TEST(DeterministicSchedule, uniformSubset) {$/;"	f	signature:(DeterministicSchedule, uniformSubset)
TEST	.\test\DiscriminatedPtrTest.cpp	/^TEST(DiscriminatedPtr, Apply) {$/;"	f	signature:(DiscriminatedPtr, Apply)
TEST	.\test\DiscriminatedPtrTest.cpp	/^TEST(DiscriminatedPtr, ApplyVoid) {$/;"	f	signature:(DiscriminatedPtr, ApplyVoid)
TEST	.\test\DiscriminatedPtrTest.cpp	/^TEST(DiscriminatedPtr, Basic) {$/;"	f	signature:(DiscriminatedPtr, Basic)
TEST	.\test\DynamicConverterTest.cpp	/^TEST(DynamicConverter, arithmetic_types) {$/;"	f	signature:(DynamicConverter, arithmetic_types)
TEST	.\test\DynamicConverterTest.cpp	/^TEST(DynamicConverter, construct) {$/;"	f	signature:(DynamicConverter, construct)
TEST	.\test\DynamicConverterTest.cpp	/^TEST(DynamicConverter, consts) {$/;"	f	signature:(DynamicConverter, consts)
TEST	.\test\DynamicConverterTest.cpp	/^TEST(DynamicConverter, crazy) {$/;"	f	signature:(DynamicConverter, crazy)
TEST	.\test\DynamicConverterTest.cpp	/^TEST(DynamicConverter, custom_class) {$/;"	f	signature:(DynamicConverter, custom_class)
TEST	.\test\DynamicConverterTest.cpp	/^TEST(DynamicConverter, errors) {$/;"	f	signature:(DynamicConverter, errors)
TEST	.\test\DynamicConverterTest.cpp	/^TEST(DynamicConverter, example) {$/;"	f	signature:(DynamicConverter, example)
TEST	.\test\DynamicConverterTest.cpp	/^TEST(DynamicConverter, map_keyed_by_string) {$/;"	f	signature:(DynamicConverter, map_keyed_by_string)
TEST	.\test\DynamicConverterTest.cpp	/^TEST(DynamicConverter, map_to_vector_of_pairs) {$/;"	f	signature:(DynamicConverter, map_to_vector_of_pairs)
TEST	.\test\DynamicConverterTest.cpp	/^TEST(DynamicConverter, nested_containers) {$/;"	f	signature:(DynamicConverter, nested_containers)
TEST	.\test\DynamicConverterTest.cpp	/^TEST(DynamicConverter, simple_builtins) {$/;"	f	signature:(DynamicConverter, simple_builtins)
TEST	.\test\DynamicConverterTest.cpp	/^TEST(DynamicConverter, simple_container) {$/;"	f	signature:(DynamicConverter, simple_container)
TEST	.\test\DynamicConverterTest.cpp	/^TEST(DynamicConverter, simple_fbvector) {$/;"	f	signature:(DynamicConverter, simple_fbvector)
TEST	.\test\DynamicConverterTest.cpp	/^TEST(DynamicConverter, simple_map) {$/;"	f	signature:(DynamicConverter, simple_map)
TEST	.\test\DynamicConverterTest.cpp	/^TEST(DynamicConverter, template_metaprogramming) {$/;"	f	signature:(DynamicConverter, template_metaprogramming)
TEST	.\test\DynamicTest.cpp	/^TEST(Dynamic, ArrayBasics) {$/;"	f	signature:(Dynamic, ArrayBasics)
TEST	.\test\DynamicTest.cpp	/^TEST(Dynamic, ArrayErase) {$/;"	f	signature:(Dynamic, ArrayErase)
TEST	.\test\DynamicTest.cpp	/^TEST(Dynamic, ArrayGenerator) {$/;"	f	signature:(Dynamic, ArrayGenerator)
TEST	.\test\DynamicTest.cpp	/^TEST(Dynamic, Conversions) {$/;"	f	signature:(Dynamic, Conversions)
TEST	.\test\DynamicTest.cpp	/^TEST(Dynamic, DeepCopy) {$/;"	f	signature:(Dynamic, DeepCopy)
TEST	.\test\DynamicTest.cpp	/^TEST(Dynamic, FormattedIO) {$/;"	f	signature:(Dynamic, FormattedIO)
TEST	.\test\DynamicTest.cpp	/^TEST(Dynamic, GetPtr) {$/;"	f	signature:(Dynamic, GetPtr)
TEST	.\test\DynamicTest.cpp	/^TEST(Dynamic, GetSetDefaultTest) {$/;"	f	signature:(Dynamic, GetSetDefaultTest)
TEST	.\test\DynamicTest.cpp	/^TEST(Dynamic, ObjectBasics) {$/;"	f	signature:(Dynamic, ObjectBasics)
TEST	.\test\DynamicTest.cpp	/^TEST(Dynamic, ObjectErase) {$/;"	f	signature:(Dynamic, ObjectErase)
TEST	.\test\DynamicTest.cpp	/^TEST(Dynamic, ObjectForwarding) {$/;"	f	signature:(Dynamic, ObjectForwarding)
TEST	.\test\DynamicTest.cpp	/^TEST(Dynamic, Operator) {$/;"	f	signature:(Dynamic, Operator)
TEST	.\test\DynamicTest.cpp	/^TEST(Dynamic, StringBasics) {$/;"	f	signature:(Dynamic, StringBasics)
TEST	.\test\DynamicTest.cpp	/^TEST(Dynamic, StringPtrs) {$/;"	f	signature:(Dynamic, StringPtrs)
TEST	.\test\EndianTest.cpp	/^TEST(Endian, Basic) {$/;"	f	signature:(Endian, Basic)
TEST	.\test\EvictingCacheMapTest.cpp	/^TEST(EvictingCacheMap, DestructorInvocationTest) {$/;"	f	signature:(EvictingCacheMap, DestructorInvocationTest)
TEST	.\test\EvictingCacheMapTest.cpp	/^TEST(EvictingCacheMap, FindTest) {$/;"	f	signature:(EvictingCacheMap, FindTest)
TEST	.\test\EvictingCacheMapTest.cpp	/^TEST(EvictingCacheMap, FindWithoutPromotionTest) {$/;"	f	signature:(EvictingCacheMap, FindWithoutPromotionTest)
TEST	.\test\EvictingCacheMapTest.cpp	/^TEST(EvictingCacheMap, IteratorOrderingTest) {$/;"	f	signature:(EvictingCacheMap, IteratorOrderingTest)
TEST	.\test\EvictingCacheMapTest.cpp	/^TEST(EvictingCacheMap, IteratorSanityTest) {$/;"	f	signature:(EvictingCacheMap, IteratorSanityTest)
TEST	.\test\EvictingCacheMapTest.cpp	/^TEST(EvictingCacheMap, LruNoPromotionTest) {$/;"	f	signature:(EvictingCacheMap, LruNoPromotionTest)
TEST	.\test\EvictingCacheMapTest.cpp	/^TEST(EvictingCacheMap, LruPromotionTest) {$/;"	f	signature:(EvictingCacheMap, LruPromotionTest)
TEST	.\test\EvictingCacheMapTest.cpp	/^TEST(EvictingCacheMap, LruSanityTest) {$/;"	f	signature:(EvictingCacheMap, LruSanityTest)
TEST	.\test\EvictingCacheMapTest.cpp	/^TEST(EvictingCacheMap, PruneHookTest) {$/;"	f	signature:(EvictingCacheMap, PruneHookTest)
TEST	.\test\EvictingCacheMapTest.cpp	/^TEST(EvictingCacheMap, PruneTest) {$/;"	f	signature:(EvictingCacheMap, PruneTest)
TEST	.\test\EvictingCacheMapTest.cpp	/^TEST(EvictingCacheMap, SanityTest) {$/;"	f	signature:(EvictingCacheMap, SanityTest)
TEST	.\test\EvictingCacheMapTest.cpp	/^TEST(EvictingCacheMap, SetClearSize) {$/;"	f	signature:(EvictingCacheMap, SetClearSize)
TEST	.\test\EvictingCacheMapTest.cpp	/^TEST(EvictingCacheMap, SetMaxSize) {$/;"	f	signature:(EvictingCacheMap, SetMaxSize)
TEST	.\test\ExceptionTest.cpp	/^TEST(ExceptionTest, Simple) {$/;"	f	namespace:folly::test	signature:(ExceptionTest, Simple)
TEST	.\test\ExceptionWrapperTest.cpp	/^TEST(ExceptionWrapper, boolean) {$/;"	f	signature:(ExceptionWrapper, boolean)
TEST	.\test\ExceptionWrapperTest.cpp	/^TEST(ExceptionWrapper, equals) {$/;"	f	signature:(ExceptionWrapper, equals)
TEST	.\test\ExceptionWrapperTest.cpp	/^TEST(ExceptionWrapper, non_std_exception_test) {$/;"	f	signature:(ExceptionWrapper, non_std_exception_test)
TEST	.\test\ExceptionWrapperTest.cpp	/^TEST(ExceptionWrapper, not_equals) {$/;"	f	signature:(ExceptionWrapper, not_equals)
TEST	.\test\ExceptionWrapperTest.cpp	/^TEST(ExceptionWrapper, throw_test) {$/;"	f	signature:(ExceptionWrapper, throw_test)
TEST	.\test\ExceptionWrapperTest.cpp	/^TEST(ExceptionWrapper, try_and_catch_test) {$/;"	f	signature:(ExceptionWrapper, try_and_catch_test)
TEST	.\test\ExceptionWrapperTest.cpp	/^TEST(ExceptionWrapper, with_exception_test) {$/;"	f	signature:(ExceptionWrapper, with_exception_test)
TEST	.\test\FBStringTest.cpp	/^TEST(FBString, findWithNpos) {$/;"	f	signature:(FBString, findWithNpos)
TEST	.\test\FBStringTest.cpp	/^TEST(FBString, iomanip) {$/;"	f	signature:(FBString, iomanip)
TEST	.\test\FBStringTest.cpp	/^TEST(FBString, moveTerminator) {$/;"	f	signature:(FBString, moveTerminator)
TEST	.\test\FBStringTest.cpp	/^TEST(FBString, noexcept) {$/;"	f	signature:(FBString, noexcept)
TEST	.\test\FBStringTest.cpp	/^TEST(FBString, rvalueIterators) {$/;"	f	signature:(FBString, rvalueIterators)
TEST	.\test\FBStringTest.cpp	/^TEST(FBString, testAllClauses) {$/;"	f	signature:(FBString, testAllClauses)
TEST	.\test\FBStringTest.cpp	/^TEST(FBString, testConstructionFromLiteralZero) {$/;"	f	signature:(FBString, testConstructionFromLiteralZero)
TEST	.\test\FBStringTest.cpp	/^TEST(FBString, testFixedBugs) {$/;"	f	signature:(FBString, testFixedBugs)
TEST	.\test\FBStringTest.cpp	/^TEST(FBString, testFrontBack) {$/;"	f	signature:(FBString, testFrontBack)
TEST	.\test\FBStringTest.cpp	/^TEST(FBString, testGetline) {$/;"	f	signature:(FBString, testGetline)
TEST	.\test\FBStringTest.cpp	/^TEST(FBString, testHash) {$/;"	f	signature:(FBString, testHash)
TEST	.\test\FBStringTest.cpp	/^TEST(FBString, testMoveAssign) {$/;"	f	signature:(FBString, testMoveAssign)
TEST	.\test\FBStringTest.cpp	/^TEST(FBString, testMoveCtor) {$/;"	f	signature:(FBString, testMoveCtor)
TEST	.\test\FBStringTest.cpp	/^TEST(FBString, testMoveOperatorPlusLhs) {$/;"	f	signature:(FBString, testMoveOperatorPlusLhs)
TEST	.\test\FBStringTest.cpp	/^TEST(FBString, testMoveOperatorPlusRhs) {$/;"	f	signature:(FBString, testMoveOperatorPlusRhs)
TEST	.\test\FBVectorTest.cpp	/^TEST(FBVector, move_iterator) {$/;"	f	signature:(FBVector, move_iterator)
TEST	.\test\FBVectorTest.cpp	/^TEST(FBVector, reserve_consistency) {$/;"	f	signature:(FBVector, reserve_consistency)
TEST	.\test\FBVectorTest.cpp	/^TEST(FBVector, task858056) {$/;"	f	signature:(FBVector, task858056)
TEST	.\test\FBVectorTest.cpp	/^TEST(FBVector, vector_of_maps) {$/;"	f	signature:(FBVector, vector_of_maps)
TEST	.\test\FBVectorTest.cpp	/^TEST(fbvector, clause_23_3_6_1_11_ambiguity) {$/;"	f	signature:(fbvector, clause_23_3_6_1_11_ambiguity)
TEST	.\test\FBVectorTest.cpp	/^TEST(fbvector, clause_23_3_6_1_3_ambiguity) {$/;"	f	signature:(fbvector, clause_23_3_6_1_3_ambiguity)
TEST	.\test\FBVectorTest.cpp	/^TEST(fbvector, clause_23_3_6_2_6) {$/;"	f	signature:(fbvector, clause_23_3_6_2_6)
TEST	.\test\FBVectorTest.cpp	/^TEST(fbvector, clause_23_3_6_4_ambiguity) {$/;"	f	signature:(fbvector, clause_23_3_6_4_ambiguity)
TEST	.\test\FBVectorTest.cpp	/^TEST(fbvector, composition) {$/;"	f	signature:(fbvector, composition)
TEST	.\test\FBVectorTest.cpp	/^TEST(fbvector, emplace) {$/;"	f	signature:(fbvector, emplace)
TEST	.\test\FBVectorTest.cpp	/^TEST(fbvector, initializer_lists) {$/;"	f	signature:(fbvector, initializer_lists)
TEST	.\test\FBVectorTest.cpp	/^TEST(fbvector, move_construction) {$/;"	f	signature:(fbvector, move_construction)
TEST	.\test\FBVectorTest.cpp	/^TEST(fbvector, unique_ptr) {$/;"	f	signature:(fbvector, unique_ptr)
TEST	.\test\FBVectorTest.cpp	/^TEST(fbvector, works_with_std_string) {$/;"	f	signature:(fbvector, works_with_std_string)
TEST	.\test\FBVectorTest.cpp	/^TEST(fbvector, works_with_user_defined_type) {$/;"	f	signature:(fbvector, works_with_user_defined_type)
TEST	.\test\FileTest.cpp	/^TEST(File, Locks) {$/;"	f	signature:(File, Locks)
TEST	.\test\FileTest.cpp	/^TEST(File, OwnsFd) {$/;"	f	signature:(File, OwnsFd)
TEST	.\test\FileTest.cpp	/^TEST(File, Release) {$/;"	f	signature:(File, Release)
TEST	.\test\FileTest.cpp	/^TEST(File, Simple) {$/;"	f	signature:(File, Simple)
TEST	.\test\FileTest.cpp	/^TEST(File, Truthy) {$/;"	f	signature:(File, Truthy)
TEST	.\test\FileTest.cpp	/^TEST(File, UsefulError) {$/;"	f	signature:(File, UsefulError)
TEST	.\test\FileUtilTest.cpp	/^TEST(String, readFile) {$/;"	f	namespace:folly::test	signature:(String, readFile)
TEST	.\test\FingerprintTest.cpp	/^TEST(Fingerprint, Alignment) {$/;"	f	signature:(Fingerprint, Alignment)
TEST	.\test\FingerprintTest.cpp	/^TEST(Fingerprint, BroderOptimization) {$/;"	f	signature:(Fingerprint, BroderOptimization)
TEST	.\test\FingerprintTest.cpp	/^TEST(Fingerprint, MultiByteUpdate) {$/;"	f	signature:(Fingerprint, MultiByteUpdate)
TEST	.\test\ForeachTest.cpp	/^TEST(Foreach, ForEachEnumerate) {$/;"	f	signature:(Foreach, ForEachEnumerate)
TEST	.\test\ForeachTest.cpp	/^TEST(Foreach, ForEachEnumerateBreak) {$/;"	f	signature:(Foreach, ForEachEnumerateBreak)
TEST	.\test\ForeachTest.cpp	/^TEST(Foreach, ForEachKV) {$/;"	f	signature:(Foreach, ForEachKV)
TEST	.\test\ForeachTest.cpp	/^TEST(Foreach, ForEachKVBreak) {$/;"	f	signature:(Foreach, ForEachKVBreak)
TEST	.\test\ForeachTest.cpp	/^TEST(Foreach, ForEachKvWithMultiMap) {$/;"	f	signature:(Foreach, ForEachKvWithMultiMap)
TEST	.\test\ForeachTest.cpp	/^TEST(Foreach, ForEachRangeR) {$/;"	f	signature:(Foreach, ForEachRangeR)
TEST	.\test\ForeachTest.cpp	/^TEST(Foreach, ForEachRvalue) {$/;"	f	signature:(Foreach, ForEachRvalue)
TEST	.\test\FormatTest.cpp	/^TEST(Format, BogusFormatString) {$/;"	f	signature:(Format, BogusFormatString)
TEST	.\test\FormatTest.cpp	/^TEST(Format, Custom) {$/;"	f	signature:(Format, Custom)
TEST	.\test\FormatTest.cpp	/^TEST(Format, Extending) {$/;"	f	signature:(Format, Extending)
TEST	.\test\FormatTest.cpp	/^TEST(Format, Float) {$/;"	f	signature:(Format, Float)
TEST	.\test\FormatTest.cpp	/^TEST(Format, MultiLevel) {$/;"	f	signature:(Format, MultiLevel)
TEST	.\test\FormatTest.cpp	/^TEST(Format, Nested) {$/;"	f	signature:(Format, Nested)
TEST	.\test\FormatTest.cpp	/^TEST(Format, OutOfBounds) {$/;"	f	signature:(Format, OutOfBounds)
TEST	.\test\FormatTest.cpp	/^TEST(Format, Simple) {$/;"	f	signature:(Format, Simple)
TEST	.\test\FormatTest.cpp	/^TEST(Format, Unformatted) {$/;"	f	signature:(Format, Unformatted)
TEST	.\test\FormatTest.cpp	/^TEST(Format, dynamic) {$/;"	f	signature:(Format, dynamic)
TEST	.\test\FormatTest.cpp	/^TEST(Format, uintToBinary) {$/;"	f	signature:(Format, uintToBinary)
TEST	.\test\FormatTest.cpp	/^TEST(Format, uintToHex) {$/;"	f	signature:(Format, uintToHex)
TEST	.\test\FormatTest.cpp	/^TEST(Format, uintToOctal) {$/;"	f	signature:(Format, uintToOctal)
TEST	.\test\FutexTest.cpp	/^TEST(Futex, basic_deterministic) {$/;"	f	signature:(Futex, basic_deterministic)
TEST	.\test\FutexTest.cpp	/^TEST(Futex, basic_live) {$/;"	f	signature:(Futex, basic_live)
TEST	.\test\FutexTest.cpp	/^TEST(Futex, clock_source) {$/;"	f	signature:(Futex, clock_source)
TEST	.\test\GroupVarintTest.cpp	/^TEST(GroupVarint, GroupVarint32) {$/;"	f	signature:(GroupVarint, GroupVarint32)
TEST	.\test\GroupVarintTest.cpp	/^TEST(GroupVarint, GroupVarint64) {$/;"	f	signature:(GroupVarint, GroupVarint64)
TEST	.\test\GroupVarintTest.cpp	/^TEST(GroupVarint, GroupVarintDecoder) {$/;"	f	signature:(GroupVarint, GroupVarintDecoder)
TEST	.\test\GroupVarintTest.cpp	/^TEST(GroupVarint, GroupVarintEncoder) {$/;"	f	signature:(GroupVarint, GroupVarintEncoder)
TEST	.\test\HasMemberFnTraitsTest.cpp	/^TEST(HasMemberFnTraits, DirectMembers) {$/;"	f	signature:(HasMemberFnTraits, DirectMembers)
TEST	.\test\HashTest.cpp	/^TEST(Hash, Fnv32) {$/;"	f	signature:(Hash, Fnv32)
TEST	.\test\HashTest.cpp	/^TEST(Hash, Fnv64) {$/;"	f	signature:(Hash, Fnv64)
TEST	.\test\HashTest.cpp	/^TEST(Hash, Hsieh32) {$/;"	f	signature:(Hash, Hsieh32)
TEST	.\test\HashTest.cpp	/^TEST(Hash, Jenkins_Rev_Mix32) {$/;"	f	signature:(Hash, Jenkins_Rev_Mix32)
TEST	.\test\HashTest.cpp	/^TEST(Hash, Jenkins_Rev_Unmix32) {$/;"	f	signature:(Hash, Jenkins_Rev_Unmix32)
TEST	.\test\HashTest.cpp	/^TEST(Hash, TWang_32From64) {$/;"	f	signature:(Hash, TWang_32From64)
TEST	.\test\HashTest.cpp	/^TEST(Hash, TWang_Mix64) {$/;"	f	signature:(Hash, TWang_Mix64)
TEST	.\test\HashTest.cpp	/^TEST(Hash, TWang_Unmix64) {$/;"	f	signature:(Hash, TWang_Unmix64)
TEST	.\test\HashTest.cpp	/^TEST(Hash, hash_combine) {$/;"	f	signature:(Hash, hash_combine)
TEST	.\test\HashTest.cpp	/^TEST(Hash, hash_range) {$/;"	f	signature:(Hash, hash_range)
TEST	.\test\HashTest.cpp	/^TEST(Hash, hasher) {$/;"	f	signature:(Hash, hasher)
TEST	.\test\HashTest.cpp	/^TEST(Hash, pair) {$/;"	f	signature:(Hash, pair)
TEST	.\test\HashTest.cpp	/^TEST(Hash, std_tuple) {$/;"	f	signature:(Hash, std_tuple)
TEST	.\test\HashTest.cpp	/^TEST(Hash, std_tuple_different_hash) {$/;"	f	signature:(Hash, std_tuple_different_hash)
TEST	.\test\HistogramTest.cpp	/^TEST(Histogram, Test1) {$/;"	f	signature:(Histogram, Test1)
TEST	.\test\HistogramTest.cpp	/^TEST(Histogram, Test100) {$/;"	f	signature:(Histogram, Test100)
TEST	.\test\HistogramTest.cpp	/^TEST(Histogram, TestDouble) {$/;"	f	signature:(Histogram, TestDouble)
TEST	.\test\HistogramTest.cpp	/^TEST(Histogram, TestDoubleInexactWidth) {$/;"	f	signature:(Histogram, TestDoubleInexactWidth)
TEST	.\test\HistogramTest.cpp	/^TEST(Histogram, TestDoubleWidthTooBig) {$/;"	f	signature:(Histogram, TestDoubleWidthTooBig)
TEST	.\test\HistogramTest.cpp	/^TEST(Histogram, TestEmpty) {$/;"	f	signature:(Histogram, TestEmpty)
TEST	.\test\HistogramTest.cpp	/^TEST(Histogram, TestOverflowBucket) {$/;"	f	signature:(Histogram, TestOverflowBucket)
TEST	.\test\HistogramTest.cpp	/^TEST(Histogram, TestOverflowMax) {$/;"	f	signature:(Histogram, TestOverflowMax)
TEST	.\test\HistogramTest.cpp	/^TEST(Histogram, TestOverflowMin) {$/;"	f	signature:(Histogram, TestOverflowMin)
TEST	.\test\IPAddressTest.cpp	/^TEST(IPAddress, Assignment) {$/;"	f	signature:(IPAddress, Assignment)
TEST	.\test\IPAddressTest.cpp	/^TEST(IPAddress, CodeExample) {$/;"	f	signature:(IPAddress, CodeExample)
TEST	.\test\IPAddressTest.cpp	/^TEST(IPAddress, CreateLinkLocal) {$/;"	f	signature:(IPAddress, CreateLinkLocal)
TEST	.\test\IPAddressTest.cpp	/^TEST(IPAddress, CreateNetwork) {$/;"	f	signature:(IPAddress, CreateNetwork)
TEST	.\test\IPAddressTest.cpp	/^TEST(IPAddress, CtorDefault) {$/;"	f	signature:(IPAddress, CtorDefault)
TEST	.\test\IPAddressTest.cpp	/^TEST(IPAddress, CtorSockaddr) {$/;"	f	signature:(IPAddress, CtorSockaddr)
TEST	.\test\IPAddressTest.cpp	/^TEST(IPAddress, InSubnetWith6to4) {$/;"	f	signature:(IPAddress, InSubnetWith6to4)
TEST	.\test\IPAddressTest.cpp	/^TEST(IPAddress, InvalidAddressFamilyExceptions) {$/;"	f	signature:(IPAddress, InvalidAddressFamilyExceptions)
TEST	.\test\IPAddressTest.cpp	/^TEST(IPAddress, InvalidBBitAccess) {$/;"	f	signature:(IPAddress, InvalidBBitAccess)
TEST	.\test\IPAddressTest.cpp	/^TEST(IPAddress, InvalidByteAccess) {$/;"	f	signature:(IPAddress, InvalidByteAccess)
TEST	.\test\IPAddressTest.cpp	/^TEST(IPAddress, InvalidMask) {$/;"	f	signature:(IPAddress, InvalidMask)
TEST	.\test\IPAddressTest.cpp	/^TEST(IPAddress, LongestCommonPrefix) {$/;"	f	signature:(IPAddress, LongestCommonPrefix)
TEST	.\test\IPAddressTest.cpp	/^TEST(IPAddress, Ordering) {$/;"	f	signature:(IPAddress, Ordering)
TEST	.\test\IPAddressTest.cpp	/^TEST(IPAddress, Scope) {$/;"	f	signature:(IPAddress, Scope)
TEST	.\test\IPAddressTest.cpp	/^TEST(IPAddress, SolicitedNodeAddress) {$/;"	f	signature:(IPAddress, SolicitedNodeAddress)
TEST	.\test\IPAddressTest.cpp	/^TEST(IPAddress, ToFullyQualifiedFb) {$/;"	f	signature:(IPAddress, ToFullyQualifiedFb)
TEST	.\test\IPAddressTest.cpp	/^TEST(IPAddress, ToFullyQualifiedLocal) {$/;"	f	signature:(IPAddress, ToFullyQualifiedLocal)
TEST	.\test\IPAddressTest.cpp	/^TEST(IPAddress, ToLong) {$/;"	f	signature:(IPAddress, ToLong)
TEST	.\test\IPAddressTest.cpp	/^TEST(IPAddress, ToSockaddrStorage) {$/;"	f	signature:(IPAddress, ToSockaddrStorage)
TEST	.\test\IPAddressTest.cpp	/^TEST(IPAddress, ToString) {$/;"	f	signature:(IPAddress, ToString)
TEST	.\test\IPAddressTest.cpp	/^TEST(IPAddress, UnitializedEqual) {$/;"	f	signature:(IPAddress, UnitializedEqual)
TEST	.\test\IPAddressTest.cpp	/^TEST(IPAddress, V6Types) {$/;"	f	signature:(IPAddress, V6Types)
TEST	.\test\IPAddressTest.cpp	/^TEST(IPAddress, fromBinaryV4) {$/;"	f	signature:(IPAddress, fromBinaryV4)
TEST	.\test\IPAddressTest.cpp	/^TEST(IPAddress, fromBinaryV6) {$/;"	f	signature:(IPAddress, fromBinaryV6)
TEST	.\test\IndexedMemPoolTest.cpp	/^TEST(IndexedMemPool, locate_elem) {$/;"	f	signature:(IndexedMemPool, locate_elem)
TEST	.\test\IndexedMemPoolTest.cpp	/^TEST(IndexedMemPool, mt_capacity) {$/;"	f	signature:(IndexedMemPool, mt_capacity)
TEST	.\test\IndexedMemPoolTest.cpp	/^TEST(IndexedMemPool, no_starvation) {$/;"	f	signature:(IndexedMemPool, no_starvation)
TEST	.\test\IndexedMemPoolTest.cpp	/^TEST(IndexedMemPool, st_capacity) {$/;"	f	signature:(IndexedMemPool, st_capacity)
TEST	.\test\IndexedMemPoolTest.cpp	/^TEST(IndexedMemPool, unique_ptr) {$/;"	f	signature:(IndexedMemPool, unique_ptr)
TEST	.\test\JsonTest.cpp	/^TEST(Json, JavascriptSafe) {$/;"	f	signature:(Json, JavascriptSafe)
TEST	.\test\JsonTest.cpp	/^TEST(Json, JsonEscape) {$/;"	f	signature:(Json, JsonEscape)
TEST	.\test\JsonTest.cpp	/^TEST(Json, Parse) {$/;"	f	signature:(Json, Parse)
TEST	.\test\JsonTest.cpp	/^TEST(Json, ParseNonStringKeys) {$/;"	f	signature:(Json, ParseNonStringKeys)
TEST	.\test\JsonTest.cpp	/^TEST(Json, ParseTrailingComma) {$/;"	f	signature:(Json, ParseTrailingComma)
TEST	.\test\JsonTest.cpp	/^TEST(Json, Produce) {$/;"	f	signature:(Json, Produce)
TEST	.\test\JsonTest.cpp	/^TEST(Json, SortKeys) {$/;"	f	signature:(Json, SortKeys)
TEST	.\test\JsonTest.cpp	/^TEST(Json, StripComments) {$/;"	f	signature:(Json, StripComments)
TEST	.\test\JsonTest.cpp	/^TEST(Json, UTF8EncodeNonAsciiRetention) {$/;"	f	signature:(Json, UTF8EncodeNonAsciiRetention)
TEST	.\test\JsonTest.cpp	/^TEST(Json, UTF8Validation) {$/;"	f	signature:(Json, UTF8Validation)
TEST	.\test\JsonTest.cpp	/^TEST(Json, Unicode) {$/;"	f	signature:(Json, Unicode)
TEST	.\test\LazyTest.cpp	/^TEST(Lazy, Consty) {$/;"	f	namespace:folly	signature:(Lazy, Consty)
TEST	.\test\LazyTest.cpp	/^TEST(Lazy, Global) {$/;"	f	namespace:folly	signature:(Lazy, Global)
TEST	.\test\LazyTest.cpp	/^TEST(Lazy, Map) {$/;"	f	namespace:folly	signature:(Lazy, Map)
TEST	.\test\LazyTest.cpp	/^TEST(Lazy, NonLambda) {$/;"	f	namespace:folly	signature:(Lazy, NonLambda)
TEST	.\test\LazyTest.cpp	/^TEST(Lazy, Simple) {$/;"	f	namespace:folly	signature:(Lazy, Simple)
TEST	.\test\LifoSemTests.cpp	/^TEST(LifoSem, basic) {$/;"	f	signature:(LifoSem, basic)
TEST	.\test\LifoSemTests.cpp	/^TEST(LifoSem, multi) {$/;"	f	signature:(LifoSem, multi)
TEST	.\test\LifoSemTests.cpp	/^TEST(LifoSem, multi_try_wait) {$/;"	f	signature:(LifoSem, multi_try_wait)
TEST	.\test\LifoSemTests.cpp	/^TEST(LifoSem, multi_try_wait_simple) {$/;"	f	signature:(LifoSem, multi_try_wait_simple)
TEST	.\test\LifoSemTests.cpp	/^TEST(LifoSem, mutex) {$/;"	f	signature:(LifoSem, mutex)
TEST	.\test\LifoSemTests.cpp	/^TEST(LifoSem, no_blocking) {$/;"	f	signature:(LifoSem, no_blocking)
TEST	.\test\LifoSemTests.cpp	/^TEST(LifoSem, one_way) {$/;"	f	signature:(LifoSem, one_way)
TEST	.\test\LifoSemTests.cpp	/^TEST(LifoSem, pingpong) {$/;"	f	signature:(LifoSem, pingpong)
TEST	.\test\LifoSemTests.cpp	/^TEST(LifoSem, shutdown_multi) {$/;"	f	signature:(LifoSem, shutdown_multi)
TEST	.\test\LifoSemTests.cpp	/^TEST(LifoSem, shutdown_race) {$/;"	f	signature:(LifoSem, shutdown_race)
TEST	.\test\LoggingTest.cpp	/^TEST(LogEveryMs, basic) {$/;"	f	signature:(LogEveryMs, basic)
TEST	.\test\LoggingTest.cpp	/^TEST(LogEveryMs, zero) {$/;"	f	signature:(LogEveryMs, zero)
TEST	.\test\MPMCPipelineTest.cpp	/^TEST(MPMCPipeline, MultiThreaded) {$/;"	f	namespace:folly::test	signature:(MPMCPipeline, MultiThreaded)
TEST	.\test\MPMCPipelineTest.cpp	/^TEST(MPMCPipeline, Trivial) {$/;"	f	namespace:folly::test	signature:(MPMCPipeline, Trivial)
TEST	.\test\MPMCPipelineTest.cpp	/^TEST(MPMCPipeline, TrivialAmplification) {$/;"	f	namespace:folly::test	signature:(MPMCPipeline, TrivialAmplification)
TEST	.\test\MPMCQueueTest.cpp	/^TEST(MPMCQueue, enq_capacity_test) {$/;"	f	signature:(MPMCQueue, enq_capacity_test)
TEST	.\test\MPMCQueueTest.cpp	/^TEST(MPMCQueue, lots_of_element_types) {$/;"	f	signature:(MPMCQueue, lots_of_element_types)
TEST	.\test\MPMCQueueTest.cpp	/^TEST(MPMCQueue, mt_never_fail) {$/;"	f	signature:(MPMCQueue, mt_never_fail)
TEST	.\test\MPMCQueueTest.cpp	/^TEST(MPMCQueue, mt_never_fail_deterministic) {$/;"	f	signature:(MPMCQueue, mt_never_fail_deterministic)
TEST	.\test\MPMCQueueTest.cpp	/^TEST(MPMCQueue, mt_prod_cons) {$/;"	f	signature:(MPMCQueue, mt_prod_cons)
TEST	.\test\MPMCQueueTest.cpp	/^TEST(MPMCQueue, mt_prod_cons_deterministic) {$/;"	f	signature:(MPMCQueue, mt_prod_cons_deterministic)
TEST	.\test\MPMCQueueTest.cpp	/^TEST(MPMCQueue, mt_try_enq_deq) {$/;"	f	signature:(MPMCQueue, mt_try_enq_deq)
TEST	.\test\MPMCQueueTest.cpp	/^TEST(MPMCQueue, mt_try_enq_deq_deterministic) {$/;"	f	signature:(MPMCQueue, mt_try_enq_deq_deterministic)
TEST	.\test\MPMCQueueTest.cpp	/^TEST(MPMCQueue, sequencer) {$/;"	f	signature:(MPMCQueue, sequencer)
TEST	.\test\MPMCQueueTest.cpp	/^TEST(MPMCQueue, sequencer_deterministic) {$/;"	f	signature:(MPMCQueue, sequencer_deterministic)
TEST	.\test\MPMCQueueTest.cpp	/^TEST(MPMCQueue, single_thread_enqdeq) {$/;"	f	signature:(MPMCQueue, single_thread_enqdeq)
TEST	.\test\MPMCQueueTest.cpp	/^TEST(MPMCQueue, tryenq_capacity_test) {$/;"	f	signature:(MPMCQueue, tryenq_capacity_test)
TEST	.\test\MacAddressTest.cpp	/^TEST(MacAddress, attributes) {$/;"	f	signature:(MacAddress, attributes)
TEST	.\test\MacAddressTest.cpp	/^TEST(MacAddress, createMulticast) {$/;"	f	signature:(MacAddress, createMulticast)
TEST	.\test\MacAddressTest.cpp	/^TEST(MacAddress, fromBinary) {$/;"	f	signature:(MacAddress, fromBinary)
TEST	.\test\MacAddressTest.cpp	/^TEST(MacAddress, ordering) {$/;"	f	signature:(MacAddress, ordering)
TEST	.\test\MacAddressTest.cpp	/^TEST(MacAddress, parse) {$/;"	f	signature:(MacAddress, parse)
TEST	.\test\MacAddressTest.cpp	/^TEST(MacAddress, toString) {$/;"	f	signature:(MacAddress, toString)
TEST	.\test\MapUtilTest.cpp	/^TEST(MapUtil, Simple) {$/;"	f	signature:(MapUtil, Simple)
TEST	.\test\MemoryIdlerTest.cpp	/^TEST(MemoryIdler, futexWaitAwokenEarly) {$/;"	f	signature:(MemoryIdler, futexWaitAwokenEarly)
TEST	.\test\MemoryIdlerTest.cpp	/^TEST(MemoryIdler, futexWaitAwokenLate) {$/;"	f	signature:(MemoryIdler, futexWaitAwokenLate)
TEST	.\test\MemoryIdlerTest.cpp	/^TEST(MemoryIdler, futexWaitImmediateFlush) {$/;"	f	signature:(MemoryIdler, futexWaitImmediateFlush)
TEST	.\test\MemoryIdlerTest.cpp	/^TEST(MemoryIdler, futexWaitNeverFlush) {$/;"	f	signature:(MemoryIdler, futexWaitNeverFlush)
TEST	.\test\MemoryIdlerTest.cpp	/^TEST(MemoryIdler, futexWaitValueChangedEarly) {$/;"	f	signature:(MemoryIdler, futexWaitValueChangedEarly)
TEST	.\test\MemoryIdlerTest.cpp	/^TEST(MemoryIdler, futexWaitValueChangedLate) {$/;"	f	signature:(MemoryIdler, futexWaitValueChangedLate)
TEST	.\test\MemoryIdlerTest.cpp	/^TEST(MemoryIdler, releaseMallocTLS) {$/;"	f	signature:(MemoryIdler, releaseMallocTLS)
TEST	.\test\MemoryIdlerTest.cpp	/^TEST(MemoryIdler, releaseStack) {$/;"	f	signature:(MemoryIdler, releaseStack)
TEST	.\test\MemoryIdlerTest.cpp	/^TEST(MemoryIdler, releaseStackLargeExtra) {$/;"	f	signature:(MemoryIdler, releaseStackLargeExtra)
TEST	.\test\MemoryIdlerTest.cpp	/^TEST(MemoryIdler, releaseStackMinExtra) {$/;"	f	signature:(MemoryIdler, releaseStackMinExtra)
TEST	.\test\MemoryMappingTest.cpp	/^TEST(MemoryMapping, Basic) {$/;"	f	namespace:folly	signature:(MemoryMapping, Basic)
TEST	.\test\MemoryMappingTest.cpp	/^TEST(MemoryMapping, DoublyMapped) {$/;"	f	namespace:folly	signature:(MemoryMapping, DoublyMapped)
TEST	.\test\MemoryMappingTest.cpp	/^TEST(MemoryMapping, LargeFile) {$/;"	f	namespace:folly	signature:(MemoryMapping, LargeFile)
TEST	.\test\MemoryMappingTest.cpp	/^TEST(MemoryMapping, Move) {$/;"	f	namespace:folly	signature:(MemoryMapping, Move)
TEST	.\test\MemoryMappingTest.cpp	/^TEST(MemoryMapping, Simple) {$/;"	f	namespace:folly	signature:(MemoryMapping, Simple)
TEST	.\test\MemoryMappingTest.cpp	/^TEST(MemoryMapping, ZeroLength) {$/;"	f	namespace:folly	signature:(MemoryMapping, ZeroLength)
TEST	.\test\MemoryTest.cpp	/^TEST(StlAllocator, void_allocator) {$/;"	f	signature:(StlAllocator, void_allocator)
TEST	.\test\MemoryTest.cpp	/^TEST(as_stl_allocator, sanity_check) {$/;"	f	signature:(as_stl_allocator, sanity_check)
TEST	.\test\MemoryTest.cpp	/^TEST(rebind_allocator, sanity_check) {$/;"	f	signature:(rebind_allocator, sanity_check)
TEST	.\test\MergeTest.cpp	/^TEST(MergeTest, NonOverlapping) {$/;"	f	signature:(MergeTest, NonOverlapping)
TEST	.\test\MergeTest.cpp	/^TEST(MergeTest, OverlappingInDifferentInputRange) {$/;"	f	signature:(MergeTest, OverlappingInDifferentInputRange)
TEST	.\test\MergeTest.cpp	/^TEST(MergeTest, OverlappingInSingleInputRange) {$/;"	f	signature:(MergeTest, OverlappingInSingleInputRange)
TEST	.\test\MoveWrapperTest.cpp	/^TEST(makeMoveWrapper, Empty) {$/;"	f	namespace:folly	signature:(makeMoveWrapper, Empty)
TEST	.\test\MoveWrapperTest.cpp	/^TEST(makeMoveWrapper, NonEmpty) {$/;"	f	namespace:folly	signature:(makeMoveWrapper, NonEmpty)
TEST	.\test\OptionalTest.cpp	/^TEST(Optional, AssignmentContained) {$/;"	f	namespace:folly	signature:(Optional, AssignmentContained)
TEST	.\test\OptionalTest.cpp	/^TEST(Optional, Comparisons) {$/;"	f	namespace:folly	signature:(Optional, Comparisons)
TEST	.\test\OptionalTest.cpp	/^TEST(Optional, Const) {$/;"	f	namespace:folly	signature:(Optional, Const)
TEST	.\test\OptionalTest.cpp	/^TEST(Optional, Conversions) {$/;"	f	namespace:folly	signature:(Optional, Conversions)
TEST	.\test\OptionalTest.cpp	/^TEST(Optional, EmptyConstruct) {$/;"	f	namespace:folly	signature:(Optional, EmptyConstruct)
TEST	.\test\OptionalTest.cpp	/^TEST(Optional, MakeOptional) {$/;"	f	namespace:folly	signature:(Optional, MakeOptional)
TEST	.\test\OptionalTest.cpp	/^TEST(Optional, NoDefault) {$/;"	f	namespace:folly	signature:(Optional, NoDefault)
TEST	.\test\OptionalTest.cpp	/^TEST(Optional, Order) {$/;"	f	namespace:folly	signature:(Optional, Order)
TEST	.\test\OptionalTest.cpp	/^TEST(Optional, Pointee) {$/;"	f	namespace:folly	signature:(Optional, Pointee)
TEST	.\test\OptionalTest.cpp	/^TEST(Optional, SelfAssignment) {$/;"	f	namespace:folly	signature:(Optional, SelfAssignment)
TEST	.\test\OptionalTest.cpp	/^TEST(Optional, Shared) {$/;"	f	namespace:folly	signature:(Optional, Shared)
TEST	.\test\OptionalTest.cpp	/^TEST(Optional, Simple) {$/;"	f	namespace:folly	signature:(Optional, Simple)
TEST	.\test\OptionalTest.cpp	/^TEST(Optional, String) {$/;"	f	namespace:folly	signature:(Optional, String)
TEST	.\test\OptionalTest.cpp	/^TEST(Optional, Swap) {$/;"	f	namespace:folly	signature:(Optional, Swap)
TEST	.\test\OptionalTest.cpp	/^TEST(Optional, Unique) {$/;"	f	namespace:folly	signature:(Optional, Unique)
TEST	.\test\OptionalTest.cpp	/^TEST(Optional, value_or_noncopyable) {$/;"	f	namespace:folly	signature:(Optional, value_or_noncopyable)
TEST	.\test\OptionalTest.cpp	/^TEST(Optional, value_or_rvalue_arg) {$/;"	f	namespace:folly	signature:(Optional, value_or_rvalue_arg)
TEST	.\test\PackedSyncPtrTest.cpp	/^TEST(PackedSyncPtr, Application) {$/;"	f	signature:(PackedSyncPtr, Application)
TEST	.\test\PackedSyncPtrTest.cpp	/^TEST(PackedSyncPtr, Basic) {$/;"	f	signature:(PackedSyncPtr, Basic)
TEST	.\test\PackedSyncPtrTest.cpp	/^TEST(PackedSyncPtr, extraData) {$/;"	f	signature:(PackedSyncPtr, extraData)
TEST	.\test\PaddedTest.cpp	/^TEST(NodeTest, Padding) {$/;"	f	signature:(NodeTest, Padding)
TEST	.\test\PortabilityTest.cpp	/^TEST(Portability, Final) {$/;"	f	signature:(Portability, Final)
TEST	.\test\ProducerConsumerQueueTest.cpp	/^TEST(PCQ, Destructor) {$/;"	f	signature:(PCQ, Destructor)
TEST	.\test\ProducerConsumerQueueTest.cpp	/^TEST(PCQ, EmptyFull) {$/;"	f	signature:(PCQ, EmptyFull)
TEST	.\test\ProducerConsumerQueueTest.cpp	/^TEST(PCQ, PerfTest) {$/;"	f	signature:(PCQ, PerfTest)
TEST	.\test\ProducerConsumerQueueTest.cpp	/^TEST(PCQ, QueueCorrectness) {$/;"	f	signature:(PCQ, QueueCorrectness)
TEST	.\test\RWSpinLockTest.cpp	/^TEST(RWSpinLock, concurrent_holder_test) {$/;"	f	namespace:__anon130	signature:(RWSpinLock, concurrent_holder_test)
TEST	.\test\RWSpinLockTest.cpp	/^TEST(RWSpinLock, lock_unlock_tests) {$/;"	f	namespace:__anon130	signature:(RWSpinLock, lock_unlock_tests)
TEST	.\test\RandomTest.cpp	/^TEST(Random, MultiThreaded) {$/;"	f	signature:(Random, MultiThreaded)
TEST	.\test\RandomTest.cpp	/^TEST(Random, Simple) {$/;"	f	signature:(Random, Simple)
TEST	.\test\RandomTest.cpp	/^TEST(Random, StateSize) {$/;"	f	signature:(Random, StateSize)
TEST	.\test\RangeTest.cpp	/^TEST(NonConstTest, StringPiece) {$/;"	f	signature:(NonConstTest, StringPiece)
TEST	.\test\RangeTest.cpp	/^TEST(RangeFunc, Array) {$/;"	f	signature:(RangeFunc, Array)
TEST	.\test\RangeTest.cpp	/^TEST(RangeFunc, CArray) {$/;"	f	signature:(RangeFunc, CArray)
TEST	.\test\RangeTest.cpp	/^TEST(RangeFunc, Vector) {$/;"	f	signature:(RangeFunc, Vector)
TEST	.\test\RangeTest.cpp	/^TEST(ReplaceAll, BadArg) {$/;"	f	signature:(ReplaceAll, BadArg)
TEST	.\test\RangeTest.cpp	/^TEST(ReplaceAll, basicTest) {$/;"	f	signature:(ReplaceAll, basicTest)
TEST	.\test\RangeTest.cpp	/^TEST(ReplaceAll, randomTest) {$/;"	f	signature:(ReplaceAll, randomTest)
TEST	.\test\RangeTest.cpp	/^TEST(ReplaceAt, exhaustiveTest) {$/;"	f	signature:(ReplaceAt, exhaustiveTest)
TEST	.\test\RangeTest.cpp	/^TEST(StringPiece, All) {$/;"	f	signature:(StringPiece, All)
TEST	.\test\RangeTest.cpp	/^TEST(StringPiece, Constexpr) {$/;"	f	signature:(StringPiece, Constexpr)
TEST	.\test\RangeTest.cpp	/^TEST(StringPiece, EightBitComparisons) {$/;"	f	signature:(StringPiece, EightBitComparisons)
TEST	.\test\RangeTest.cpp	/^TEST(StringPiece, InvalidRange) {$/;"	f	signature:(StringPiece, InvalidRange)
TEST	.\test\RangeTest.cpp	/^TEST(StringPiece, Prefix) {$/;"	f	signature:(StringPiece, Prefix)
TEST	.\test\RangeTest.cpp	/^TEST(StringPiece, PrefixEmpty) {$/;"	f	signature:(StringPiece, PrefixEmpty)
TEST	.\test\RangeTest.cpp	/^TEST(StringPiece, Suffix) {$/;"	f	signature:(StringPiece, Suffix)
TEST	.\test\RangeTest.cpp	/^TEST(StringPiece, SuffixEmpty) {$/;"	f	signature:(StringPiece, SuffixEmpty)
TEST	.\test\RangeTest.cpp	/^TEST(StringPiece, ToByteRange) {$/;"	f	signature:(StringPiece, ToByteRange)
TEST	.\test\RangeTest.cpp	/^TEST(StringPiece, split_step_char_delimiter) {$/;"	f	signature:(StringPiece, split_step_char_delimiter)
TEST	.\test\RangeTest.cpp	/^TEST(StringPiece, split_step_range_delimiter) {$/;"	f	signature:(StringPiece, split_step_range_delimiter)
TEST	.\test\RangeTest.cpp	/^TEST(StringPiece, split_step_with_process_char_delimiter) {$/;"	f	signature:(StringPiece, split_step_with_process_char_delimiter)
TEST	.\test\RangeTest.cpp	/^TEST(StringPiece, split_step_with_process_char_delimiter_additional_args) {$/;"	f	signature:(StringPiece, split_step_with_process_char_delimiter_additional_args)
TEST	.\test\RangeTest.cpp	/^TEST(StringPiece, split_step_with_process_range_delimiter) {$/;"	f	signature:(StringPiece, split_step_with_process_range_delimiter)
TEST	.\test\RangeTest.cpp	/^TEST(StringPiece, split_step_with_process_range_delimiter_additional_args) {$/;"	f	signature:(StringPiece, split_step_with_process_range_delimiter_additional_args)
TEST	.\test\RangeTest.cpp	/^TEST(qfind, UInt32_Ranges) {$/;"	f	signature:(qfind, UInt32_Ranges)
TEST	.\test\SafeAssertTest.cpp	/^TEST(SafeAssert, AssertionFailure) {$/;"	f	signature:(SafeAssert, AssertionFailure)
TEST	.\test\ScopeGuardTest.cpp	/^TEST(ScopeGuard, DifferentWaysToBind) {$/;"	f	signature:(ScopeGuard, DifferentWaysToBind)
TEST	.\test\ScopeGuardTest.cpp	/^TEST(ScopeGuard, GuardException) {$/;"	f	signature:(ScopeGuard, GuardException)
TEST	.\test\ScopeGuardTest.cpp	/^TEST(ScopeGuard, TEST_SCOPE_EXIT) {$/;"	f	signature:(ScopeGuard, TEST_SCOPE_EXIT)
TEST	.\test\ScopeGuardTest.cpp	/^TEST(ScopeGuard, TEST_SCOPE_FAILURE2) {$/;"	f	signature:(ScopeGuard, TEST_SCOPE_FAILURE2)
TEST	.\test\ScopeGuardTest.cpp	/^TEST(ScopeGuard, TEST_SCOPE_FAIL_AND_SCOPE_SUCCESS) {$/;"	f	signature:(ScopeGuard, TEST_SCOPE_FAIL_AND_SCOPE_SUCCESS)
TEST	.\test\ScopeGuardTest.cpp	/^TEST(ScopeGuard, TEST_SCOPE_SUCCESS_THROW) {$/;"	f	signature:(ScopeGuard, TEST_SCOPE_SUCCESS_THROW)
TEST	.\test\ScopeGuardTest.cpp	/^TEST(ScopeGuard, TryCatchFinally) {$/;"	f	signature:(ScopeGuard, TryCatchFinally)
TEST	.\test\ScopeGuardTest.cpp	/^TEST(ScopeGuard, UndoAction) {$/;"	f	signature:(ScopeGuard, UndoAction)
TEST	.\test\SmallLocksTest.cpp	/^TEST(SmallLocks, PicoSpinCorrectness) {$/;"	f	signature:(SmallLocks, PicoSpinCorrectness)
TEST	.\test\SmallLocksTest.cpp	/^TEST(SmallLocks, PicoSpinSigned) {$/;"	f	signature:(SmallLocks, PicoSpinSigned)
TEST	.\test\SmallLocksTest.cpp	/^TEST(SmallLocks, RegClobber) {$/;"	f	signature:(SmallLocks, RegClobber)
TEST	.\test\SmallLocksTest.cpp	/^TEST(SmallLocks, SpinLockCorrectness) {$/;"	f	signature:(SmallLocks, SpinLockCorrectness)
TEST	.\test\SocketAddressTest.cpp	/^TEST(SocketAddress, AnonymousUnix) {$/;"	f	signature:(SocketAddress, AnonymousUnix)
TEST	.\test\SocketAddressTest.cpp	/^TEST(SocketAddress, CheckComparatorBehavior) {$/;"	f	signature:(SocketAddress, CheckComparatorBehavior)
TEST	.\test\SocketAddressTest.cpp	/^TEST(SocketAddress, ConstructFromInvalidIpv4) {$/;"	f	signature:(SocketAddress, ConstructFromInvalidIpv4)
TEST	.\test\SocketAddressTest.cpp	/^TEST(SocketAddress, ConstructFromIpv4) {$/;"	f	signature:(SocketAddress, ConstructFromIpv4)
TEST	.\test\SocketAddressTest.cpp	/^TEST(SocketAddress, EqualityAndHash) {$/;"	f	signature:(SocketAddress, EqualityAndHash)
TEST	.\test\SocketAddressTest.cpp	/^TEST(SocketAddress, IPv4ToStringConversion) {$/;"	f	signature:(SocketAddress, IPv4ToStringConversion)
TEST	.\test\SocketAddressTest.cpp	/^TEST(SocketAddress, IsLoopback) {$/;"	f	signature:(SocketAddress, IsLoopback)
TEST	.\test\SocketAddressTest.cpp	/^TEST(SocketAddress, IsPrivate) {$/;"	f	signature:(SocketAddress, IsPrivate)
TEST	.\test\SocketAddressTest.cpp	/^TEST(SocketAddress, PrefixMatch) {$/;"	f	signature:(SocketAddress, PrefixMatch)
TEST	.\test\SocketAddressTest.cpp	/^TEST(SocketAddress, SetFromHostname) {$/;"	f	signature:(SocketAddress, SetFromHostname)
TEST	.\test\SocketAddressTest.cpp	/^TEST(SocketAddress, SetFromInvalidIpv4) {$/;"	f	signature:(SocketAddress, SetFromInvalidIpv4)
TEST	.\test\SocketAddressTest.cpp	/^TEST(SocketAddress, SetFromIpv4) {$/;"	f	signature:(SocketAddress, SetFromIpv4)
TEST	.\test\SocketAddressTest.cpp	/^TEST(SocketAddress, SetFromSocketIPv4) {$/;"	f	signature:(SocketAddress, SetFromSocketIPv4)
TEST	.\test\SocketAddressTest.cpp	/^TEST(SocketAddress, SetFromSocketUnixAbstract) {$/;"	f	signature:(SocketAddress, SetFromSocketUnixAbstract)
TEST	.\test\SocketAddressTest.cpp	/^TEST(SocketAddress, SetFromSocketUnixAnonymous) {$/;"	f	signature:(SocketAddress, SetFromSocketUnixAnonymous)
TEST	.\test\SocketAddressTest.cpp	/^TEST(SocketAddress, SetFromSocketUnixExplicit) {$/;"	f	signature:(SocketAddress, SetFromSocketUnixExplicit)
TEST	.\test\SocketAddressTest.cpp	/^TEST(SocketAddress, SetFromStrings) {$/;"	f	signature:(SocketAddress, SetFromStrings)
TEST	.\test\SocketAddressTest.cpp	/^TEST(SocketAddress, Size) {$/;"	f	signature:(SocketAddress, Size)
TEST	.\test\SocketAddressTest.cpp	/^TEST(SocketAddress, Unix) {$/;"	f	signature:(SocketAddress, Unix)
TEST	.\test\StringTest.cpp	/^TEST(Escape, cEscape) {$/;"	f	signature:(Escape, cEscape)
TEST	.\test\StringTest.cpp	/^TEST(Escape, cUnescape) {$/;"	f	signature:(Escape, cUnescape)
TEST	.\test\StringTest.cpp	/^TEST(Escape, uriEscape) {$/;"	f	signature:(Escape, uriEscape)
TEST	.\test\StringTest.cpp	/^TEST(Escape, uriEscapeAllCombinations) {$/;"	f	signature:(Escape, uriEscapeAllCombinations)
TEST	.\test\StringTest.cpp	/^TEST(Escape, uriUnescape) {$/;"	f	signature:(Escape, uriUnescape)
TEST	.\test\StringTest.cpp	/^TEST(Escape, uriUnescapePercentDecoding) {$/;"	f	signature:(Escape, uriUnescapePercentDecoding)
TEST	.\test\StringTest.cpp	/^TEST(PrettyPrint, Basic) {$/;"	f	signature:(PrettyPrint, Basic)
TEST	.\test\StringTest.cpp	/^TEST(PrettyPrint, HexDump) {$/;"	f	signature:(PrettyPrint, HexDump)
TEST	.\test\StringTest.cpp	/^TEST(PrettyToDouble, Basic) {$/;"	f	signature:(PrettyToDouble, Basic)
TEST	.\test\StringTest.cpp	/^TEST(Split, fixed) {$/;"	f	signature:(Split, fixed)
TEST	.\test\StringTest.cpp	/^TEST(Split, fixed_convert) {$/;"	f	signature:(Split, fixed_convert)
TEST	.\test\StringTest.cpp	/^TEST(Split, pieces_fbvector) {$/;"	f	signature:(Split, pieces_fbvector)
TEST	.\test\StringTest.cpp	/^TEST(Split, pieces_vector) {$/;"	f	signature:(Split, pieces_vector)
TEST	.\test\StringTest.cpp	/^TEST(Split, split_fbvector) {$/;"	f	signature:(Split, split_fbvector)
TEST	.\test\StringTest.cpp	/^TEST(Split, split_vector) {$/;"	f	signature:(Split, split_vector)
TEST	.\test\StringTest.cpp	/^TEST(Split, std_string_fixed) {$/;"	f	signature:(Split, std_string_fixed)
TEST	.\test\StringTest.cpp	/^TEST(String, backslashify) {$/;"	f	signature:(String, backslashify)
TEST	.\test\StringTest.cpp	/^TEST(String, hexlify) {$/;"	f	signature:(String, hexlify)
TEST	.\test\StringTest.cpp	/^TEST(String, humanify) {$/;"	f	signature:(String, humanify)
TEST	.\test\StringTest.cpp	/^TEST(String, join) {$/;"	f	signature:(String, join)
TEST	.\test\StringTest.cpp	/^TEST(String, toLowerAsciiAligned) {$/;"	f	signature:(String, toLowerAsciiAligned)
TEST	.\test\StringTest.cpp	/^TEST(String, toLowerAsciiUnaligned) {$/;"	f	signature:(String, toLowerAsciiUnaligned)
TEST	.\test\StringTest.cpp	/^TEST(String, unhexlify) {$/;"	f	signature:(String, unhexlify)
TEST	.\test\StringTest.cpp	/^TEST(StringPrintf, Appending) {$/;"	f	signature:(StringPrintf, Appending)
TEST	.\test\StringTest.cpp	/^TEST(StringPrintf, BasicTest) {$/;"	f	signature:(StringPrintf, BasicTest)
TEST	.\test\StringTest.cpp	/^TEST(StringPrintf, NumericFormats) {$/;"	f	signature:(StringPrintf, NumericFormats)
TEST	.\test\StringTest.cpp	/^TEST(StringPrintf, VariousSizes) {$/;"	f	signature:(StringPrintf, VariousSizes)
TEST	.\test\StringTest.cpp	/^TEST(StringPrintf, oldStringAppendf) {$/;"	f	signature:(StringPrintf, oldStringAppendf)
TEST	.\test\StringTest.cpp	/^TEST(StringPrintf, oldStringPrintfTests) {$/;"	f	signature:(StringPrintf, oldStringPrintfTests)
TEST	.\test\StringTest.cpp	/^TEST(System, demangle) {$/;"	f	signature:(System, demangle)
TEST	.\test\StringTest.cpp	/^TEST(System, errnoStr) {$/;"	f	signature:(System, errnoStr)
TEST	.\test\SubprocessTest.cpp	/^TEST(CommunicateSubprocessTest, BigWrite) {$/;"	f	signature:(CommunicateSubprocessTest, BigWrite)
TEST	.\test\SubprocessTest.cpp	/^TEST(CommunicateSubprocessTest, Chatty) {$/;"	f	signature:(CommunicateSubprocessTest, Chatty)
TEST	.\test\SubprocessTest.cpp	/^TEST(CommunicateSubprocessTest, Duplex) {$/;"	f	signature:(CommunicateSubprocessTest, Duplex)
TEST	.\test\SubprocessTest.cpp	/^TEST(CommunicateSubprocessTest, Duplex2) {$/;"	f	signature:(CommunicateSubprocessTest, Duplex2)
TEST	.\test\SubprocessTest.cpp	/^TEST(CommunicateSubprocessTest, SimpleRead) {$/;"	f	signature:(CommunicateSubprocessTest, SimpleRead)
TEST	.\test\SubprocessTest.cpp	/^TEST(ParentDeathSubprocessTest, ParentDeathSignal) {$/;"	f	signature:(ParentDeathSubprocessTest, ParentDeathSignal)
TEST	.\test\SubprocessTest.cpp	/^TEST(PopenSubprocessTest, PopenRead) {$/;"	f	signature:(PopenSubprocessTest, PopenRead)
TEST	.\test\SubprocessTest.cpp	/^TEST(SimpleSubprocessTest, ChangeChildDirectorySuccessfully) {$/;"	f	signature:(SimpleSubprocessTest, ChangeChildDirectorySuccessfully)
TEST	.\test\SubprocessTest.cpp	/^TEST(SimpleSubprocessTest, ChangeChildDirectoryWithError) {$/;"	f	signature:(SimpleSubprocessTest, ChangeChildDirectoryWithError)
TEST	.\test\SubprocessTest.cpp	/^TEST(SimpleSubprocessTest, ExecFails) {$/;"	f	signature:(SimpleSubprocessTest, ExecFails)
TEST	.\test\SubprocessTest.cpp	/^TEST(SimpleSubprocessTest, ExitsSuccessfully) {$/;"	f	signature:(SimpleSubprocessTest, ExitsSuccessfully)
TEST	.\test\SubprocessTest.cpp	/^TEST(SimpleSubprocessTest, ExitsSuccessfullyChecked) {$/;"	f	signature:(SimpleSubprocessTest, ExitsSuccessfullyChecked)
TEST	.\test\SubprocessTest.cpp	/^TEST(SimpleSubprocessTest, ExitsWithError) {$/;"	f	signature:(SimpleSubprocessTest, ExitsWithError)
TEST	.\test\SubprocessTest.cpp	/^TEST(SimpleSubprocessTest, ExitsWithErrorChecked) {$/;"	f	signature:(SimpleSubprocessTest, ExitsWithErrorChecked)
TEST	.\test\SubprocessTest.cpp	/^TEST(SimpleSubprocessTest, FdLeakTest) {$/;"	f	signature:(SimpleSubprocessTest, FdLeakTest)
TEST	.\test\SubprocessTest.cpp	/^TEST(SimpleSubprocessTest, ShellExitsSuccesssfully) {$/;"	f	signature:(SimpleSubprocessTest, ShellExitsSuccesssfully)
TEST	.\test\SubprocessTest.cpp	/^TEST(SimpleSubprocessTest, ShellExitsWithError) {$/;"	f	signature:(SimpleSubprocessTest, ShellExitsWithError)
TEST	.\test\SynchronizedTest.cpp	/^TEST(Synchronized, Basic) {$/;"	f	signature:(Synchronized, Basic)
TEST	.\test\SynchronizedTest.cpp	/^TEST(Synchronized, Concurrency) {$/;"	f	signature:(Synchronized, Concurrency)
TEST	.\test\SynchronizedTest.cpp	/^TEST(Synchronized, ConstCopy) {$/;"	f	signature:(Synchronized, ConstCopy)
TEST	.\test\SynchronizedTest.cpp	/^TEST(Synchronized, DualLocking) {$/;"	f	signature:(Synchronized, DualLocking)
TEST	.\test\SynchronizedTest.cpp	/^TEST(Synchronized, DualLockingWithConst) {$/;"	f	signature:(Synchronized, DualLockingWithConst)
TEST	.\test\SynchronizedTest.cpp	/^TEST(Synchronized, TimedSynchronized) {$/;"	f	signature:(Synchronized, TimedSynchronized)
TEST	.\test\ThreadCachedArenaTest.cpp	/^TEST(ThreadCachedArena, BlockSize) {$/;"	f	signature:(ThreadCachedArena, BlockSize)
TEST	.\test\ThreadCachedArenaTest.cpp	/^TEST(ThreadCachedArena, MultiThreaded) {$/;"	f	signature:(ThreadCachedArena, MultiThreaded)
TEST	.\test\ThreadCachedArenaTest.cpp	/^TEST(ThreadCachedArena, SingleThreaded) {$/;"	f	signature:(ThreadCachedArena, SingleThreaded)
TEST	.\test\ThreadCachedArenaTest.cpp	/^TEST(ThreadCachedArena, StlAllocator) {$/;"	f	signature:(ThreadCachedArena, StlAllocator)
TEST	.\test\ThreadCachedIntTest.cpp	/^TEST(ThreadCachedInt, MultiThreadedCached) {$/;"	f	signature:(ThreadCachedInt, MultiThreadedCached)
TEST	.\test\ThreadCachedIntTest.cpp	/^TEST(ThreadCachedInt, SingleThreadedCached) {$/;"	f	signature:(ThreadCachedInt, SingleThreadedCached)
TEST	.\test\ThreadCachedIntTest.cpp	/^TEST(ThreadCachedInt, SingleThreadedNotCached) {$/;"	f	signature:(ThreadCachedInt, SingleThreadedNotCached)
TEST	.\test\ThreadLocalTest.cpp	/^TEST(ThreadLocal, BasicDestructor) {$/;"	f	signature:(ThreadLocal, BasicDestructor)
TEST	.\test\ThreadLocalTest.cpp	/^TEST(ThreadLocal, Fork) {$/;"	f	signature:(ThreadLocal, Fork)
TEST	.\test\ThreadLocalTest.cpp	/^TEST(ThreadLocal, Fork2) {$/;"	f	signature:(ThreadLocal, Fork2)
TEST	.\test\ThreadLocalTest.cpp	/^TEST(ThreadLocal, InterleavedDestructors) {$/;"	f	signature:(ThreadLocal, InterleavedDestructors)
TEST	.\test\ThreadLocalTest.cpp	/^TEST(ThreadLocal, Movable1) {$/;"	f	signature:(ThreadLocal, Movable1)
TEST	.\test\ThreadLocalTest.cpp	/^TEST(ThreadLocal, Movable2) {$/;"	f	signature:(ThreadLocal, Movable2)
TEST	.\test\ThreadLocalTest.cpp	/^TEST(ThreadLocal, SimpleRepeatDestructor) {$/;"	f	signature:(ThreadLocal, SimpleRepeatDestructor)
TEST	.\test\ThreadLocalTest.cpp	/^TEST(ThreadLocal, Stress) {$/;"	f	signature:(ThreadLocal, Stress)
TEST	.\test\ThreadLocalTest.cpp	/^TEST(ThreadLocal, resetNull) {$/;"	f	signature:(ThreadLocal, resetNull)
TEST	.\test\ThreadLocalTest.cpp	/^TEST(ThreadLocalPtr, AccessAllThreadsCounter) {$/;"	f	signature:(ThreadLocalPtr, AccessAllThreadsCounter)
TEST	.\test\ThreadLocalTest.cpp	/^TEST(ThreadLocalPtr, BasicDestructor) {$/;"	f	signature:(ThreadLocalPtr, BasicDestructor)
TEST	.\test\ThreadLocalTest.cpp	/^TEST(ThreadLocalPtr, CustomDeleter1) {$/;"	f	signature:(ThreadLocalPtr, CustomDeleter1)
TEST	.\test\ThreadLocalTest.cpp	/^TEST(ThreadLocalPtr, CustomDeleter2) {$/;"	f	signature:(ThreadLocalPtr, CustomDeleter2)
TEST	.\test\ThreadLocalTest.cpp	/^TEST(ThreadLocalPtr, TestRelease) {$/;"	f	signature:(ThreadLocalPtr, TestRelease)
TEST	.\test\ThreadLocalTest.cpp	/^TEST(ThreadLocalPtr, resetNull) {$/;"	f	signature:(ThreadLocalPtr, resetNull)
TEST	.\test\TimeoutQueueTest.cpp	/^TEST(TimeoutQueue, Erase) {$/;"	f	signature:(TimeoutQueue, Erase)
TEST	.\test\TimeoutQueueTest.cpp	/^TEST(TimeoutQueue, RunOnceRepeating) {$/;"	f	signature:(TimeoutQueue, RunOnceRepeating)
TEST	.\test\TimeoutQueueTest.cpp	/^TEST(TimeoutQueue, RunOnceReschedule) {$/;"	f	signature:(TimeoutQueue, RunOnceReschedule)
TEST	.\test\TimeoutQueueTest.cpp	/^TEST(TimeoutQueue, Simple) {$/;"	f	signature:(TimeoutQueue, Simple)
TEST	.\test\TimeseriesHistogramTest.cpp	/^TEST(TimeseriesHistogram, Basic) {$/;"	f	signature:(TimeseriesHistogram, Basic)
TEST	.\test\TimeseriesHistogramTest.cpp	/^TEST(TimeseriesHistogram, Clear) {$/;"	f	signature:(TimeseriesHistogram, Clear)
TEST	.\test\TimeseriesHistogramTest.cpp	/^TEST(TimeseriesHistogram, Percentile) {$/;"	f	signature:(TimeseriesHistogram, Percentile)
TEST	.\test\TimeseriesHistogramTest.cpp	/^TEST(TimeseriesHistogram, QueryByInterval) {$/;"	f	signature:(TimeseriesHistogram, QueryByInterval)
TEST	.\test\TimeseriesHistogramTest.cpp	/^TEST(TimeseriesHistogram, SingleUniqueValue) {$/;"	f	signature:(TimeseriesHistogram, SingleUniqueValue)
TEST	.\test\TimeseriesHistogramTest.cpp	/^TEST(TimeseriesHistogram, String) {$/;"	f	signature:(TimeseriesHistogram, String)
TEST	.\test\TimeseriesTest.cpp	/^TEST(BucketedTimeSeries, addHistorical) {$/;"	f	signature:(BucketedTimeSeries, addHistorical)
TEST	.\test\TimeseriesTest.cpp	/^TEST(BucketedTimeSeries, avgTypeConversion) {$/;"	f	signature:(BucketedTimeSeries, avgTypeConversion)
TEST	.\test\TimeseriesTest.cpp	/^TEST(BucketedTimeSeries, elapsed) {$/;"	f	signature:(BucketedTimeSeries, elapsed)
TEST	.\test\TimeseriesTest.cpp	/^TEST(BucketedTimeSeries, forEachBucket) {$/;"	f	signature:(BucketedTimeSeries, forEachBucket)
TEST	.\test\TimeseriesTest.cpp	/^TEST(BucketedTimeSeries, getBucketInfo) {$/;"	f	signature:(BucketedTimeSeries, getBucketInfo)
TEST	.\test\TimeseriesTest.cpp	/^TEST(BucketedTimeSeries, queryByInterval) {$/;"	f	signature:(BucketedTimeSeries, queryByInterval)
TEST	.\test\TimeseriesTest.cpp	/^TEST(BucketedTimeSeries, queryByIntervalSimple) {$/;"	f	signature:(BucketedTimeSeries, queryByIntervalSimple)
TEST	.\test\TimeseriesTest.cpp	/^TEST(BucketedTimeSeries, rate) {$/;"	f	signature:(BucketedTimeSeries, rate)
TEST	.\test\TimeseriesTest.cpp	/^TEST(BucketedTimeSeries, rateByInterval) {$/;"	f	signature:(BucketedTimeSeries, rateByInterval)
TEST	.\test\TimeseriesTest.cpp	/^TEST(BucketedTimeSeries, update100x10) {$/;"	f	signature:(BucketedTimeSeries, update100x10)
TEST	.\test\TimeseriesTest.cpp	/^TEST(BucketedTimeSeries, update71x5) {$/;"	f	signature:(BucketedTimeSeries, update71x5)
TEST	.\test\TimeseriesTest.cpp	/^TEST(MinuteHourTimeSeries, Basic) {$/;"	f	signature:(MinuteHourTimeSeries, Basic)
TEST	.\test\TimeseriesTest.cpp	/^TEST(MinuteHourTimeSeries, QueryByInterval) {$/;"	f	signature:(MinuteHourTimeSeries, QueryByInterval)
TEST	.\test\TraitsTest.cpp	/^TEST(Traits, bitAndInit) {$/;"	f	signature:(Traits, bitAndInit)
TEST	.\test\TraitsTest.cpp	/^TEST(Traits, bitprop) {$/;"	f	signature:(Traits, bitprop)
TEST	.\test\TraitsTest.cpp	/^TEST(Traits, containers) {$/;"	f	signature:(Traits, containers)
TEST	.\test\TraitsTest.cpp	/^TEST(Traits, is_complete) {$/;"	f	signature:(Traits, is_complete)
TEST	.\test\TraitsTest.cpp	/^TEST(Traits, is_negative) {$/;"	f	signature:(Traits, is_negative)
TEST	.\test\TraitsTest.cpp	/^TEST(Traits, original) {$/;"	f	signature:(Traits, original)
TEST	.\test\TraitsTest.cpp	/^TEST(Traits, relational) {$/;"	f	signature:(Traits, relational)
TEST	.\test\TraitsTest.cpp	/^TEST(Traits, scalars) {$/;"	f	signature:(Traits, scalars)
TEST	.\test\TraitsTest.cpp	/^TEST(Traits, typedefd) {$/;"	f	signature:(Traits, typedefd)
TEST	.\test\TraitsTest.cpp	/^TEST(Traits, unset) {$/;"	f	signature:(Traits, unset)
TEST	.\test\UriTest.cpp	/^TEST(Uri, Simple) {$/;"	f	signature:(Uri, Simple)
TEST	.\test\VarintTest.cpp	/^TEST(Varint, Simple) {$/;"	f	namespace:folly::test	signature:(Varint, Simple)
TEST	.\test\VarintTest.cpp	/^TEST(ZigZag, Simple) {$/;"	f	namespace:folly::test	signature:(ZigZag, Simple)
TEST	.\test\small_vector_test.cpp	/^TEST(small_vector, AllHeap) {$/;"	f	signature:(small_vector, AllHeap)
TEST	.\test\small_vector_test.cpp	/^TEST(small_vector, Basic) {$/;"	f	signature:(small_vector, Basic)
TEST	.\test\small_vector_test.cpp	/^TEST(small_vector, BasicGuarantee) {$/;"	f	signature:(small_vector, BasicGuarantee)
TEST	.\test\small_vector_test.cpp	/^TEST(small_vector, Capacity) {$/;"	f	signature:(small_vector, Capacity)
TEST	.\test\small_vector_test.cpp	/^TEST(small_vector, Emplace) {$/;"	f	signature:(small_vector, Emplace)
TEST	.\test\small_vector_test.cpp	/^TEST(small_vector, Erase) {$/;"	f	signature:(small_vector, Erase)
TEST	.\test\small_vector_test.cpp	/^TEST(small_vector, GrowShrinkGrow) {$/;"	f	signature:(small_vector, GrowShrinkGrow)
TEST	.\test\small_vector_test.cpp	/^TEST(small_vector, Insert) {$/;"	f	signature:(small_vector, Insert)
TEST	.\test\small_vector_test.cpp	/^TEST(small_vector, Iteration) {$/;"	f	signature:(small_vector, Iteration)
TEST	.\test\small_vector_test.cpp	/^TEST(small_vector, MaxSize) {$/;"	f	signature:(small_vector, MaxSize)
TEST	.\test\small_vector_test.cpp	/^TEST(small_vector, MoveConstructor) {$/;"	f	signature:(small_vector, MoveConstructor)
TEST	.\test\small_vector_test.cpp	/^TEST(small_vector, NoHeap) {$/;"	f	signature:(small_vector, NoHeap)
TEST	.\test\small_vector_test.cpp	/^TEST(small_vector, NonCopyableType) {$/;"	f	signature:(small_vector, NonCopyableType)
TEST	.\test\small_vector_test.cpp	/^TEST(small_vector, SelfEmplaceBack) {$/;"	f	signature:(small_vector, SelfEmplaceBack)
TEST	.\test\small_vector_test.cpp	/^TEST(small_vector, SelfInsert) {$/;"	f	signature:(small_vector, SelfInsert)
TEST	.\test\small_vector_test.cpp	/^TEST(small_vector, SelfPushBack) {$/;"	f	signature:(small_vector, SelfPushBack)
TEST	.\test\small_vector_test.cpp	/^TEST(small_vector, Swap) {$/;"	f	signature:(small_vector, Swap)
TEST	.\test\small_vector_test.cpp	/^TEST(small_vector, leak_test) {$/;"	f	signature:(small_vector, leak_test)
TEST	.\test\sorted_vector_test.cpp	/^TEST(SortedVectorTest, EmptyTest) {$/;"	f	signature:(SortedVectorTest, EmptyTest)
TEST	.\test\sorted_vector_test.cpp	/^TEST(SortedVectorTest, MoveTest) {$/;"	f	signature:(SortedVectorTest, MoveTest)
TEST	.\test\sorted_vector_test.cpp	/^TEST(SortedVectorTest, ShrinkTest) {$/;"	f	signature:(SortedVectorTest, ShrinkTest)
TEST	.\test\sorted_vector_test.cpp	/^TEST(SortedVectorTypes, CustomCompare) {$/;"	f	signature:(SortedVectorTypes, CustomCompare)
TEST	.\test\sorted_vector_test.cpp	/^TEST(SortedVectorTypes, GrowthPolicy) {$/;"	f	signature:(SortedVectorTypes, GrowthPolicy)
TEST	.\test\sorted_vector_test.cpp	/^TEST(SortedVectorTypes, InitializerLists) {$/;"	f	signature:(SortedVectorTypes, InitializerLists)
TEST	.\test\sorted_vector_test.cpp	/^TEST(SortedVectorTypes, SimpleMapTest) {$/;"	f	signature:(SortedVectorTypes, SimpleMapTest)
TEST	.\test\sorted_vector_test.cpp	/^TEST(SortedVectorTypes, SimpleSetTest) {$/;"	f	signature:(SortedVectorTypes, SimpleSetTest)
TEST	.\test\sorted_vector_test.cpp	/^TEST(SortedVectorTypes, Sizes) {$/;"	f	signature:(SortedVectorTypes, Sizes)
TEST	.\test\stl_tests\StlVectorTest.cpp	/^TEST(placeholder, gccversion) {}$/;"	f	signature:(placeholder, gccversion)
TEST	.\wangle\test\ExecutorTest.cpp	/^TEST(Executor, InlineExecutor) {$/;"	f	signature:(Executor, InlineExecutor)
TEST	.\wangle\test\ExecutorTest.cpp	/^TEST(Executor, QueuedImmediateExecutor) {$/;"	f	signature:(Executor, QueuedImmediateExecutor)
TEST	.\wangle\test\ExecutorTest.cpp	/^TEST(Executor, Runnable) {$/;"	f	signature:(Executor, Runnable)
TEST	.\wangle\test\ExecutorTest.cpp	/^TEST(Executor, RunnablePtr) {$/;"	f	signature:(Executor, RunnablePtr)
TEST	.\wangle\test\ExecutorTest.cpp	/^TEST(ManualExecutor, advanceBack) {$/;"	f	signature:(ManualExecutor, advanceBack)
TEST	.\wangle\test\ExecutorTest.cpp	/^TEST(ManualExecutor, advanceNeg) {$/;"	f	signature:(ManualExecutor, advanceNeg)
TEST	.\wangle\test\ExecutorTest.cpp	/^TEST(ManualExecutor, advanceTo) {$/;"	f	signature:(ManualExecutor, advanceTo)
TEST	.\wangle\test\ExecutorTest.cpp	/^TEST(ManualExecutor, clockStartsAt0) {$/;"	f	signature:(ManualExecutor, clockStartsAt0)
TEST	.\wangle\test\ExecutorTest.cpp	/^TEST(ManualExecutor, runIsStable) {$/;"	f	signature:(ManualExecutor, runIsStable)
TEST	.\wangle\test\ExecutorTest.cpp	/^TEST(ManualExecutor, scheduleAbs) {$/;"	f	signature:(ManualExecutor, scheduleAbs)
TEST	.\wangle\test\ExecutorTest.cpp	/^TEST(ManualExecutor, scheduleDur) {$/;"	f	signature:(ManualExecutor, scheduleDur)
TEST	.\wangle\test\FutureTest.cpp	/^TEST(Future, activateOnDestruct) {$/;"	f	signature:(Future, activateOnDestruct)
TEST	.\wangle\test\FutureTest.cpp	/^TEST(Future, callbackAfterActivate) {$/;"	f	signature:(Future, callbackAfterActivate)
TEST	.\wangle\test\FutureTest.cpp	/^TEST(Future, finish) {$/;"	f	signature:(Future, finish)
TEST	.\wangle\test\FutureTest.cpp	/^TEST(Future, futureNotReady) {$/;"	f	signature:(Future, futureNotReady)
TEST	.\wangle\test\FutureTest.cpp	/^TEST(Future, getFuture_after_setException) {$/;"	f	signature:(Future, getFuture_after_setException)
TEST	.\wangle\test\FutureTest.cpp	/^TEST(Future, getFuture_after_setValue) {$/;"	f	signature:(Future, getFuture_after_setValue)
TEST	.\wangle\test\FutureTest.cpp	/^TEST(Future, hasException) {$/;"	f	signature:(Future, hasException)
TEST	.\wangle\test\FutureTest.cpp	/^TEST(Future, hasValue) {$/;"	f	signature:(Future, hasValue)
TEST	.\wangle\test\FutureTest.cpp	/^TEST(Future, isReady) {$/;"	f	signature:(Future, isReady)
TEST	.\wangle\test\FutureTest.cpp	/^TEST(Future, makeFuture) {$/;"	f	signature:(Future, makeFuture)
TEST	.\wangle\test\FutureTest.cpp	/^TEST(Future, special) {$/;"	f	signature:(Future, special)
TEST	.\wangle\test\FutureTest.cpp	/^TEST(Future, then) {$/;"	f	signature:(Future, then)
TEST	.\wangle\test\FutureTest.cpp	/^TEST(Future, thenFunction) {$/;"	f	signature:(Future, thenFunction)
TEST	.\wangle\test\FutureTest.cpp	/^TEST(Future, thenFunctionFuture) {$/;"	f	signature:(Future, thenFunctionFuture)
TEST	.\wangle\test\FutureTest.cpp	/^TEST(Future, throwCaughtInImmediateThen) {$/;"	f	signature:(Future, throwCaughtInImmediateThen)
TEST	.\wangle\test\FutureTest.cpp	/^TEST(Future, throwIfFailed) {$/;"	f	signature:(Future, throwIfFailed)
TEST	.\wangle\test\FutureTest.cpp	/^TEST(Future, try) {$/;"	f	signature:(Future, try)
TEST	.\wangle\test\FutureTest.cpp	/^TEST(Future, unwrap) {$/;"	f	signature:(Future, unwrap)
TEST	.\wangle\test\FutureTest.cpp	/^TEST(Future, value) {$/;"	f	signature:(Future, value)
TEST	.\wangle\test\FutureTest.cpp	/^TEST(Future, viaIsCold) {$/;"	f	signature:(Future, viaIsCold)
TEST	.\wangle\test\FutureTest.cpp	/^TEST(Future, waitWithSemaphore) {$/;"	f	signature:(Future, waitWithSemaphore)
TEST	.\wangle\test\FutureTest.cpp	/^TEST(Future, waitWithSemaphoreForTime) {$/;"	f	signature:(Future, waitWithSemaphoreForTime)
TEST	.\wangle\test\FutureTest.cpp	/^TEST(Future, waitWithSemaphoreImmediate) {$/;"	f	signature:(Future, waitWithSemaphoreImmediate)
TEST	.\wangle\test\FutureTest.cpp	/^TEST(Future, whenAll) {$/;"	f	signature:(Future, whenAll)
TEST	.\wangle\test\FutureTest.cpp	/^TEST(Future, whenAllVariadic) {$/;"	f	signature:(Future, whenAllVariadic)
TEST	.\wangle\test\FutureTest.cpp	/^TEST(Future, whenAllVariadicReferences) {$/;"	f	signature:(Future, whenAllVariadicReferences)
TEST	.\wangle\test\FutureTest.cpp	/^TEST(Future, whenAll_none) {$/;"	f	signature:(Future, whenAll_none)
TEST	.\wangle\test\FutureTest.cpp	/^TEST(Future, whenAny) {$/;"	f	signature:(Future, whenAny)
TEST	.\wangle\test\FutureTest.cpp	/^TEST(Promise, fulfil) {$/;"	f	signature:(Promise, fulfil)
TEST	.\wangle\test\FutureTest.cpp	/^TEST(Promise, getFuture) {$/;"	f	signature:(Promise, getFuture)
TEST	.\wangle\test\FutureTest.cpp	/^TEST(Promise, setException) {$/;"	f	signature:(Promise, setException)
TEST	.\wangle\test\FutureTest.cpp	/^TEST(Promise, setValue) {$/;"	f	signature:(Promise, setValue)
TEST	.\wangle\test\FutureTest.cpp	/^TEST(Promise, special) {$/;"	f	signature:(Promise, special)
TEST	.\wangle\test\FutureTest.cpp	/^TEST(when, already_completed) {$/;"	f	signature:(when, already_completed)
TEST	.\wangle\test\FutureTest.cpp	/^TEST(when, small_vector) {$/;"	f	signature:(when, small_vector)
TEST	.\wangle\test\FutureTest.cpp	/^TEST(when, whenN) {$/;"	f	signature:(when, whenN)
TEST	.\wangle\test\LaterTest.cpp	/^TEST(Later, construct_and_launch) {$/;"	f	signature:(Later, construct_and_launch)
TEST	.\wangle\test\LaterTest.cpp	/^TEST(Later, exception_on_launch) {$/;"	f	signature:(Later, exception_on_launch)
TEST	.\wangle\test\LaterTest.cpp	/^TEST(Later, then_function) {$/;"	f	signature:(Later, then_function)
TEST	.\wangle\test\LaterTest.cpp	/^TEST(Later, then_future) {$/;"	f	signature:(Later, then_future)
TEST	.\wangle\test\LaterTest.cpp	/^TEST(Later, then_value) {$/;"	f	signature:(Later, then_value)
TEST	.\wangle\test\LaterTest.cpp	/^TEST(Later, when_all_later) {$/;"	f	signature:(Later, when_all_later)
TEST	.\wangle\test\Thens.cpp	/^TEST(Future, thenVariants) {$/;"	f	signature:(Future, thenVariants)
TEST	.\wangle\test\ThreadGateTest.cpp	/^TEST(GenericThreadGate, noWaiter) {$/;"	f	signature:(GenericThreadGate, noWaiter)
TEST	.\wangle\test\Try.cpp	/^TEST(Try, makeTryFunction) {$/;"	f	signature:(Try, makeTryFunction)
TEST	.\wangle\test\Try.cpp	/^TEST(Try, makeTryFunctionThrow) {$/;"	f	signature:(Try, makeTryFunctionThrow)
TEST	.\wangle\test\Try.cpp	/^TEST(Try, makeTryFunctionVoid) {$/;"	f	signature:(Try, makeTryFunctionVoid)
TEST	.\wangle\test\Try.cpp	/^TEST(Try, makeTryFunctionVoidThrow) {$/;"	f	signature:(Try, makeTryFunctionVoidThrow)
TESTFUN	.\test\FBVectorBenchmark.cpp	88;"	d	file:
TESTFUN	.\test\FBVectorTestBenchmarks.cpp.h	/^TESTFUN(clause_23_3_6_1_1) {$/;"	f	signature:(clause_23_3_6_1_1)
TESTFUN	.\test\FBVectorTestBenchmarks.cpp.h	/^TESTFUN(clause_23_3_6_1_11) {$/;"	f	signature:(clause_23_3_6_1_11)
TESTFUN	.\test\FBVectorTestBenchmarks.cpp.h	/^TESTFUN(clause_23_3_6_1_12) {$/;"	f	signature:(clause_23_3_6_1_12)
TESTFUN	.\test\FBVectorTestBenchmarks.cpp.h	/^TESTFUN(clause_23_3_6_1_3) {$/;"	f	signature:(clause_23_3_6_1_3)
TESTFUN	.\test\FBVectorTestBenchmarks.cpp.h	/^TESTFUN(clause_23_3_6_1_9) {$/;"	f	signature:(clause_23_3_6_1_9)
TESTFUN	.\test\FBVectorTestBenchmarks.cpp.h	/^TESTFUN(clause_23_3_6_2_1) {$/;"	f	signature:(clause_23_3_6_2_1)
TESTFUN	.\test\FBVectorTestBenchmarks.cpp.h	/^TESTFUN(clause_23_3_6_2_11) {$/;"	f	signature:(clause_23_3_6_2_11)
TESTFUN	.\test\FBVectorTestBenchmarks.cpp.h	/^TESTFUN(clause_23_3_6_2_7) {$/;"	f	signature:(clause_23_3_6_2_7)
TESTFUN	.\test\FBVectorTestBenchmarks.cpp.h	/^TESTFUN(clause_23_3_6_2_9) {$/;"	f	signature:(clause_23_3_6_2_9)
TESTFUN	.\test\FBVectorTestBenchmarks.cpp.h	/^TESTFUN(clause_23_3_6_3_1) {$/;"	f	signature:(clause_23_3_6_3_1)
TESTFUN	.\test\FBVectorTestBenchmarks.cpp.h	/^TESTFUN(clause_23_3_6_4_1_a) {$/;"	f	signature:(clause_23_3_6_4_1_a)
TESTFUN	.\test\FBVectorTestBenchmarks.cpp.h	/^TESTFUN(clause_23_3_6_4_1_c) {$/;"	f	signature:(clause_23_3_6_4_1_c)
TESTFUN	.\test\FBVectorTestBenchmarks.cpp.h	/^TESTFUN(clause_23_3_6_4_1_d) {$/;"	f	signature:(clause_23_3_6_4_1_d)
TESTFUN	.\test\FBVectorTestBenchmarks.cpp.h	/^TESTFUN(clause_23_3_6_4_3) {$/;"	f	signature:(clause_23_3_6_4_3)
TESTFUN	.\test\FBVectorTestBenchmarks.cpp.h	/^TESTFUN(clause_23_3_6_4_4) {$/;"	f	signature:(clause_23_3_6_4_4)
TESTFUN	.\test\FBVectorTestBenchmarks.cpp.h	/^TESTFUN(clause_23_3_6_4_clear) {$/;"	f	signature:(clause_23_3_6_4_clear)
TESTFUN	.\test\FBVectorTestBenchmarks.cpp.h	/^TESTFUN(clause_absent_element_access) {$/;"	f	signature:(clause_absent_element_access)
TEST_CLAUSE	.\test\FBStringTest.cpp	927;"	d	file:
TEST_F	.\experimental\symbolizer\test\ElfTests.cpp	/^TEST_F(ElfTest, IntegerValue) {$/;"	f	signature:(ElfTest, IntegerValue)
TEST_F	.\experimental\symbolizer\test\ElfTests.cpp	/^TEST_F(ElfTest, PointerValue) {$/;"	f	signature:(ElfTest, PointerValue)
TEST_F	.\experimental\symbolizer\test\SymbolizerTest.cpp	/^TEST_F(ElfCacheTest, SignalSafeElfCache) {$/;"	f	namespace:folly::symbolizer::test	signature:(ElfCacheTest, SignalSafeElfCache)
TEST_F	.\experimental\symbolizer\test\SymbolizerTest.cpp	/^TEST_F(ElfCacheTest, TinyElfCache) {$/;"	f	namespace:folly::symbolizer::test	signature:(ElfCacheTest, TinyElfCache)
TEST_F	.\test\FileUtilTest.cpp	/^TEST_F(FileUtilTest, pread) {$/;"	f	namespace:folly::test	signature:(FileUtilTest, pread)
TEST_F	.\test\FileUtilTest.cpp	/^TEST_F(FileUtilTest, preadv) {$/;"	f	namespace:folly::test	signature:(FileUtilTest, preadv)
TEST_F	.\test\FileUtilTest.cpp	/^TEST_F(FileUtilTest, read) {$/;"	f	namespace:folly::test	signature:(FileUtilTest, read)
TEST_F	.\test\FileUtilTest.cpp	/^TEST_F(FileUtilTest, readv) {$/;"	f	namespace:folly::test	signature:(FileUtilTest, readv)
TEST_F	.\test\PaddedTest.cpp	/^TEST_F(IntAdaptorTest, ResizeConstructor) {$/;"	f	signature:(IntAdaptorTest, ResizeConstructor)
TEST_F	.\test\PaddedTest.cpp	/^TEST_F(IntAdaptorTest, Simple) {$/;"	f	signature:(IntAdaptorTest, Simple)
TEST_F	.\test\PaddedTest.cpp	/^TEST_F(IntPaddedConstTest, Arithmetic) {$/;"	f	signature:(IntPaddedConstTest, Arithmetic)
TEST_F	.\test\PaddedTest.cpp	/^TEST_F(IntPaddedConstTest, Iteration) {$/;"	f	signature:(IntPaddedConstTest, Iteration)
TEST_F	.\test\PaddedTest.cpp	/^TEST_F(IntPaddedNonConstTest, Iteration) {$/;"	f	signature:(IntPaddedNonConstTest, Iteration)
TEST_F	.\test\PaddedTest.cpp	/^TEST_F(StructPaddedConstTest, Iteration) {$/;"	f	signature:(StructPaddedConstTest, Iteration)
TEST_F	.\wangle\test\LaterTest.cpp	/^TEST_F(LaterFixture, chain_laters) {$/;"	f	signature:(LaterFixture, chain_laters)
TEST_F	.\wangle\test\LaterTest.cpp	/^TEST_F(LaterFixture, thread_hops) {$/;"	f	signature:(LaterFixture, thread_hops)
TEST_F	.\wangle\test\LaterTest.cpp	/^TEST_F(LaterFixture, wrapping_preexisting_async_modules) {$/;"	f	signature:(LaterFixture, wrapping_preexisting_async_modules)
TEST_F	.\wangle\test\ThreadGateTest.cpp	/^TEST_F(GenericThreadGateFixture, gate_alternating) {$/;"	f	signature:(GenericThreadGateFixture, gate_alternating)
TEST_F	.\wangle\test\ThreadGateTest.cpp	/^TEST_F(GenericThreadGateFixture, gate_and_wait) {$/;"	f	signature:(GenericThreadGateFixture, gate_and_wait)
TEST_F	.\wangle\test\ThreadGateTest.cpp	/^TEST_F(GenericThreadGateFixture, gate_many) {$/;"	f	signature:(GenericThreadGateFixture, gate_many)
TEST_F	.\wangle\test\ThreadGateTest.cpp	/^TEST_F(GenericThreadGateFixture, gate_with_promise) {$/;"	f	signature:(GenericThreadGateFixture, gate_with_promise)
TEST_FUNCTIONS_H_	.\test\function_benchmark\test_functions.h	18;"	d
TEST_P	.\gen\test\FileTest.cpp	/^TEST_P(FileGenBufferedTest, FileWriter) {$/;"	f	signature:(FileGenBufferedTest, FileWriter)
TEST_P	.\io\test\CompressionTest.cpp	/^TEST_P(CompressionCorruptionTest, ConstantData) {$/;"	f	namespace:folly::io::test	signature:(CompressionCorruptionTest, ConstantData)
TEST_P	.\io\test\CompressionTest.cpp	/^TEST_P(CompressionCorruptionTest, RandomData) {$/;"	f	namespace:folly::io::test	signature:(CompressionCorruptionTest, RandomData)
TEST_P	.\io\test\CompressionTest.cpp	/^TEST_P(CompressionTest, ConstantData) {$/;"	f	namespace:folly::io::test	signature:(CompressionTest, ConstantData)
TEST_P	.\io\test\CompressionTest.cpp	/^TEST_P(CompressionTest, RandomData) {$/;"	f	namespace:folly::io::test	signature:(CompressionTest, RandomData)
TEST_P	.\io\test\IOBufTest.cpp	/^TEST_P(MoveToFbStringTest, Simple) {$/;"	f	signature:(MoveToFbStringTest, Simple)
TEST_P	.\test\IPAddressTest.cpp	/^TEST_P(IPAddressBitAccessorTest, CheckBits) {$/;"	f	signature:(IPAddressBitAccessorTest, CheckBits)
TEST_P	.\test\IPAddressTest.cpp	/^TEST_P(IPAddressByteAccessorTest, CheckBytes) {$/;"	f	signature:(IPAddressByteAccessorTest, CheckBytes)
TEST_P	.\test\IPAddressTest.cpp	/^TEST_P(IPAddressCtorBinaryTest, InvalidBinary) {$/;"	f	signature:(IPAddressCtorBinaryTest, InvalidBinary)
TEST_P	.\test\IPAddressTest.cpp	/^TEST_P(IPAddressCtorTest, InvalidCreation) {$/;"	f	signature:(IPAddressCtorTest, InvalidCreation)
TEST_P	.\test\IPAddressTest.cpp	/^TEST_P(IPAddressFlagTest, IsLinkLocal) {$/;"	f	signature:(IPAddressFlagTest, IsLinkLocal)
TEST_P	.\test\IPAddressTest.cpp	/^TEST_P(IPAddressFlagTest, IsLinkLocalBroadcast) {$/;"	f	signature:(IPAddressFlagTest, IsLinkLocalBroadcast)
TEST_P	.\test\IPAddressTest.cpp	/^TEST_P(IPAddressFlagTest, IsLoopback) {$/;"	f	signature:(IPAddressFlagTest, IsLoopback)
TEST_P	.\test\IPAddressTest.cpp	/^TEST_P(IPAddressFlagTest, IsNonroutable) {$/;"	f	signature:(IPAddressFlagTest, IsNonroutable)
TEST_P	.\test\IPAddressTest.cpp	/^TEST_P(IPAddressFlagTest, IsPrivate) {$/;"	f	signature:(IPAddressFlagTest, IsPrivate)
TEST_P	.\test\IPAddressTest.cpp	/^TEST_P(IPAddressFlagTest, IsZero) {$/;"	f	signature:(IPAddressFlagTest, IsZero)
TEST_P	.\test\IPAddressTest.cpp	/^TEST_P(IPAddressMappedTest, MappedEqual) {$/;"	f	signature:(IPAddressMappedTest, MappedEqual)
TEST_P	.\test\IPAddressTest.cpp	/^TEST_P(IPAddressMaskBoundaryTest, NonMaskedSubnet) {$/;"	f	signature:(IPAddressMaskBoundaryTest, NonMaskedSubnet)
TEST_P	.\test\IPAddressTest.cpp	/^TEST_P(IPAddressMaskTest, InSubnet) {$/;"	f	signature:(IPAddressMaskTest, InSubnet)
TEST_P	.\test\IPAddressTest.cpp	/^TEST_P(IPAddressMaskTest, Masks) {$/;"	f	signature:(IPAddressMaskTest, Masks)
TEST_P	.\test\IPAddressTest.cpp	/^TEST_P(IPAddressTest, CtorAddress) {$/;"	f	signature:(IPAddressTest, CtorAddress)
TEST_P	.\test\IPAddressTest.cpp	/^TEST_P(IPAddressTest, CtorBinary) {$/;"	f	signature:(IPAddressTest, CtorBinary)
TEST_P	.\test\IPAddressTest.cpp	/^TEST_P(IPAddressTest, CtorString) {$/;"	f	signature:(IPAddressTest, CtorString)
TEST_TYPES	.\test\stl_tests\StlVectorTest.cpp	910;"	d	file:
THE_GREAT_EXPECTATIONS	.\test\ConvTest.cpp	716;"	d	file:
THE_GREAT_EXPECTATIONS	.\test\ConvTest.cpp	748;"	d	file:
THIS_THREAD	.\ThreadLocal.h	/^  THIS_THREAD,$/;"	m	class:folly::TLPDestructionMode	access:private
TIMED_OUT	.\Baton.h	/^    TIMED_OUT = 4$/;"	m	struct:folly::Baton	typeref:enum:folly::Baton::	access:private
TIMED_SYNCHRONIZED	.\Synchronized.h	648;"	d
TIMED_SYNCHRONIZED_CONST	.\Synchronized.h	667;"	d
TLPDestructionMode	.\ThreadLocal.h	/^enum class TLPDestructionMode {$/;"	c	namespace:folly
TPair	.\EvictingCacheMap.h	/^  typedef std::pair<const TKey, TValue> TPair;$/;"	t	class:folly::EvictingCacheMap	access:private
TRIES	.\test\SpookyHashV1Test.cpp	383;"	d	file:
TRIES	.\test\SpookyHashV1Test.cpp	464;"	d	file:
TRIES	.\test\SpookyHashV2Test.cpp	309;"	d	file:
TRIES	.\test\SpookyHashV2Test.cpp	390;"	d	file:
TRY_LOCK	.\MemoryMapping.h	/^    TRY_LOCK,$/;"	m	class:folly::MemoryMapping::LockMode	access:private
TWO_ARG_CONSTRUCTOR	.\test\MPMCQueueTest.cpp	/^  TWO_ARG_CONSTRUCTOR,$/;"	e	enum:LifecycleEvent	file:
TYPED_TEST	.\experimental\test\EliasFanoCodingTest.cpp	/^TYPED_TEST(EliasFanoCodingTest, Empty) {$/;"	f	signature:(EliasFanoCodingTest, Empty)
TYPED_TEST	.\experimental\test\EliasFanoCodingTest.cpp	/^TYPED_TEST(EliasFanoCodingTest, ForwardPointers) {$/;"	f	signature:(EliasFanoCodingTest, ForwardPointers)
TYPED_TEST	.\experimental\test\EliasFanoCodingTest.cpp	/^TYPED_TEST(EliasFanoCodingTest, Simple) {$/;"	f	signature:(EliasFanoCodingTest, Simple)
TYPED_TEST	.\experimental\test\EliasFanoCodingTest.cpp	/^TYPED_TEST(EliasFanoCodingTest, SkipForwardPointers) {$/;"	f	signature:(EliasFanoCodingTest, SkipForwardPointers)
TYPED_TEST	.\experimental\test\EliasFanoCodingTest.cpp	/^TYPED_TEST(EliasFanoCodingTest, SkipPointers) {$/;"	f	signature:(EliasFanoCodingTest, SkipPointers)
TYPED_TEST	.\test\RWSpinLockTest.cpp	/^TYPED_TEST(RWSpinLockTest, ConcurrentTests) {$/;"	f	namespace:__anon130	signature:(RWSpinLockTest, ConcurrentTests)
TYPED_TEST	.\test\RWSpinLockTest.cpp	/^TYPED_TEST(RWSpinLockTest, Read_Holders) {$/;"	f	namespace:__anon130	signature:(RWSpinLockTest, Read_Holders)
TYPED_TEST	.\test\RWSpinLockTest.cpp	/^TYPED_TEST(RWSpinLockTest, Readers_Wait_Writer) {$/;"	f	namespace:__anon130	signature:(RWSpinLockTest, Readers_Wait_Writer)
TYPED_TEST	.\test\RWSpinLockTest.cpp	/^TYPED_TEST(RWSpinLockTest, Write_Holders) {$/;"	f	namespace:__anon130	signature:(RWSpinLockTest, Write_Holders)
TYPED_TEST	.\test\RWSpinLockTest.cpp	/^TYPED_TEST(RWSpinLockTest, Writer_Wait_Readers) {$/;"	f	namespace:__anon130	signature:(RWSpinLockTest, Writer_Wait_Readers)
TYPED_TEST	.\test\RWSpinLockTest.cpp	/^TYPED_TEST(RWSpinLockTest, Writer_Wait_Writer) {$/;"	f	namespace:__anon130	signature:(RWSpinLockTest, Writer_Wait_Writer)
TYPED_TEST	.\test\RangeTest.cpp	/^TYPED_TEST(NeedleFinderTest, Base) {$/;"	f	signature:(NeedleFinderTest, Base)
TYPED_TEST	.\test\RangeTest.cpp	/^TYPED_TEST(NeedleFinderTest, DelimDuplicates) {$/;"	f	signature:(NeedleFinderTest, DelimDuplicates)
TYPED_TEST	.\test\RangeTest.cpp	/^TYPED_TEST(NeedleFinderTest, Empty) {$/;"	f	signature:(NeedleFinderTest, Empty)
TYPED_TEST	.\test\RangeTest.cpp	/^TYPED_TEST(NeedleFinderTest, Needles256) {$/;"	f	signature:(NeedleFinderTest, Needles256)
TYPED_TEST	.\test\RangeTest.cpp	/^TYPED_TEST(NeedleFinderTest, NoSegFault) {$/;"	f	signature:(NeedleFinderTest, NoSegFault)
TYPED_TEST	.\test\RangeTest.cpp	/^TYPED_TEST(NeedleFinderTest, Null) {$/;"	f	signature:(NeedleFinderTest, Null)
TYPED_TEST	.\test\RangeTest.cpp	/^TYPED_TEST(NeedleFinderTest, Unaligned) {$/;"	f	signature:(NeedleFinderTest, Unaligned)
TYPED_TEST_CASE	.\test\RWSpinLockTest.cpp	/^TYPED_TEST_CASE(RWSpinLockTest, Implementations);$/;"	p	namespace:__anon130	file:	signature:(RWSpinLockTest, Implementations)
TYPIFY	.\test\stl_tests\StlVectorTest.cpp	822;"	d	file:
TYPIFY_a	.\test\stl_tests\StlVectorTest.cpp	1107;"	d	file:
TYPIFY_b	.\test\stl_tests\StlVectorTest.cpp	1118;"	d	file:
TYPIFY_i	.\test\stl_tests\StlVectorTest.cpp	1160;"	d	file:
TYPIFY_j	.\test\stl_tests\StlVectorTest.cpp	1166;"	d	file:
TYPIFY_m	.\test\stl_tests\StlVectorTest.cpp	1266;"	d	file:
TYPIFY_n	.\test\stl_tests\StlVectorTest.cpp	1147;"	d	file:
TYPIFY_p	.\test\stl_tests\StlVectorTest.cpp	1220;"	d	file:
TYPIFY_q	.\test\stl_tests\StlVectorTest.cpp	1230;"	d	file:
TYPIFY_t	.\test\stl_tests\StlVectorTest.cpp	1245;"	d	file:
TYPIFY_ticks	.\test\stl_tests\StlVectorTest.cpp	1038;"	d	file:
TYPIFY_z	.\test\stl_tests\StlVectorTest.cpp	1019;"	d	file:
Tag	.\test\ThreadLocalTest.cpp	/^struct Tag {};$/;"	s	namespace:__anon145	file:
TagIncr	.\IndexedMemPool.h	/^        TagIncr = 1U << SizeBits,$/;"	m	struct:folly::IndexedMemPool::TaggedPtr	typeref:enum:folly::IndexedMemPool::TaggedPtr::	access:public
TaggedPtr	.\IndexedMemPool.h	/^  struct TaggedPtr {$/;"	s	struct:folly::IndexedMemPool	access:private
Take	.\gen\Base-inl.h	/^  explicit Take(size_t count)$/;"	f	class:folly::gen::detail::Take	access:public	signature:(size_t count)
Take	.\gen\Base-inl.h	/^class Take : public Operator<Take> {$/;"	c	namespace:folly::gen::detail	inherits:Operator
Take	.\gen\Base.h	/^class Take;$/;"	x
TakeOwnershipOp	.\io\IOBuf.h	/^  enum TakeOwnershipOp { TAKE_OWNERSHIP };$/;"	g	class:folly::IOBuf	access:public
Task	.\experimental\wangle\concurrent\CPUThreadPoolExecutor.h	/^    Task() : func(nullptr), poison(true) {}$/;"	f	struct:folly::wangle::CPUThreadPoolExecutor::Task	access:public	signature:()
Task	.\experimental\wangle\concurrent\CPUThreadPoolExecutor.h	/^    Task(const Task&) = default;$/;"	p	struct:folly::wangle::CPUThreadPoolExecutor::Task	access:public	signature:(const Task&)
Task	.\experimental\wangle\concurrent\CPUThreadPoolExecutor.h	/^    explicit Task(Func&& taskArg) : func(std::move(taskArg)), poison(false) {}$/;"	f	struct:folly::wangle::CPUThreadPoolExecutor::Task	access:public	signature:(Func&& taskArg)
Task	.\experimental\wangle\concurrent\CPUThreadPoolExecutor.h	/^  struct Task {$/;"	s	class:folly::wangle::CPUThreadPoolExecutor	access:public
Task	.\experimental\wangle\concurrent\CPUThreadPoolExecutor.h	/^  struct Task;$/;"	x
TeardownFunc	.\experimental\Singleton.h	/^  typedef std::function<void(T*)> TeardownFunc;$/;"	t	class:folly::Singleton	access:public
TeardownFunc	.\experimental\Singleton.h	/^  typedef std::function<void(void*)> TeardownFunc;$/;"	t	class:folly::SingletonVault	access:public
TemporaryDirectory	.\experimental\TestUtil.cpp	/^TemporaryDirectory::TemporaryDirectory(StringPiece namePrefix,$/;"	f	class:folly::test::TemporaryDirectory	signature:(StringPiece namePrefix, fs::path dir, Scope scope)
TemporaryDirectory	.\experimental\TestUtil.h	/^  explicit TemporaryDirectory(StringPiece namePrefix = StringPiece(),$/;"	p	class:folly::test::TemporaryDirectory	access:public	signature:(StringPiece namePrefix = StringPiece(), fs::path dir = fs::path(), Scope scope = Scope::DELETE_ON_DESTRUCTION)
TemporaryDirectory	.\experimental\TestUtil.h	/^class TemporaryDirectory {$/;"	c	namespace:folly::test
TemporaryFile	.\experimental\TestUtil.cpp	/^TemporaryFile::TemporaryFile(StringPiece namePrefix,$/;"	f	class:folly::test::TemporaryFile	signature:(StringPiece namePrefix, fs::path dir, Scope scope, bool closeOnDestruction)
TemporaryFile	.\experimental\TestUtil.h	/^  explicit TemporaryFile(StringPiece namePrefix = StringPiece(),$/;"	p	class:folly::test::TemporaryFile	access:public	signature:(StringPiece namePrefix = StringPiece(), fs::path dir = fs::path(), Scope scope = Scope::UNLINK_ON_DESTRUCTION, bool closeOnDestruction = true)
TemporaryFile	.\experimental\TestUtil.h	/^class TemporaryFile {$/;"	c	namespace:folly::test
TemporaryFile	.\experimental\io\test\AsyncIOTest.cpp	/^  explicit TemporaryFile(size_t size);$/;"	p	class:__anon32::TemporaryFile	file:	access:public	signature:(size_t size)
TemporaryFile	.\experimental\io\test\AsyncIOTest.cpp	/^TemporaryFile::TemporaryFile(size_t size)$/;"	f	class:__anon32::TemporaryFile	signature:(size_t size)
TemporaryFile	.\experimental\io\test\AsyncIOTest.cpp	/^class TemporaryFile {$/;"	c	namespace:__anon32	file:
TestAlignment	.\test\SpookyHashV1Test.cpp	/^void TestAlignment()$/;"	f	signature:()
TestAlignment	.\test\SpookyHashV2Test.cpp	/^void TestAlignment()$/;"	f	signature:()
TestBasicGuarantee	.\test\small_vector_test.cpp	/^  explicit TestBasicGuarantee(int prepopulate)$/;"	f	struct:__anon132::TestBasicGuarantee	access:public	signature:(int prepopulate)
TestBasicGuarantee	.\test\small_vector_test.cpp	/^struct TestBasicGuarantee {$/;"	s	namespace:__anon132	file:
TestClass	.\test\function_benchmark\benchmark_impl.h	/^class TestClass;$/;"	x
TestClass	.\test\function_benchmark\test_functions.h	/^class TestClass {$/;"	c
TestClass::doNothing	.\test\function_benchmark\test_functions.cpp	/^void TestClass::doNothing() {$/;"	f	class:TestClass	signature:()
TestClass::doNothing	.\test\function_benchmark\test_functions.h	/^  void doNothing();$/;"	p	class:TestClass	access:public	signature:()
TestClobber	.\test\SmallLocksTest.cpp	/^  TestClobber() {$/;"	f	struct:__anon131::TestClobber	access:public	signature:()
TestClobber	.\test\SmallLocksTest.cpp	/^struct TestClobber {$/;"	s	namespace:__anon131	file:
TestData	.\test\TimeseriesTest.cpp	/^struct TestData {$/;"	s	file:
TestData::bucketStarts	.\test\TimeseriesTest.cpp	/^  vector<ssize_t> bucketStarts;$/;"	m	struct:TestData	file:	access:public
TestData::duration	.\test\TimeseriesTest.cpp	/^  size_t duration;$/;"	m	struct:TestData	file:	access:public
TestData::numBuckets	.\test\TimeseriesTest.cpp	/^  size_t numBuckets;$/;"	m	struct:TestData	file:	access:public
TestDeltas	.\test\SpookyHashV1Test.cpp	/^void TestDeltas(int seed)$/;"	f	signature:(int seed)
TestDeltas	.\test\SpookyHashV2Test.cpp	/^void TestDeltas(int seed)$/;"	f	signature:(int seed)
TestException	.\test\small_vector_test.cpp	/^struct TestException {};$/;"	s	namespace:__anon132	file:
TestExtendingFormatter	.\test\FormatTest.cpp	/^  explicit TestExtendingFormatter(StringPiece& str, Args&&... args)$/;"	f	class:TestExtendingFormatter	file:	access:private	signature:(StringPiece& str, Args&&... args)
TestExtendingFormatter	.\test\FormatTest.cpp	/^class TestExtendingFormatter$/;"	c	file:	inherits:BaseFormatter
TestExtendingFormatter	.\test\FormatTest.cpp	/^class TestExtendingFormatter;$/;"	x	file:
TestExtendingFormatter::BaseFormatter	.\test\FormatTest.cpp	/^  friend class BaseFormatter<TestExtendingFormatter<containerMode, Args...>,$/;"	x	file:
TestExtendingFormatter::TestExtendingFormatter	.\test\FormatTest.cpp	/^  explicit TestExtendingFormatter(StringPiece& str, Args&&... args)$/;"	f	class:TestExtendingFormatter	file:	access:private	signature:(StringPiece& str, Args&&... args)
TestExtendingFormatter::doFormatArg	.\test\FormatTest.cpp	/^  void doFormatArg(FormatArg& arg, Callback& cb) const {$/;"	f	class:TestExtendingFormatter	file:	access:private	signature:(FormatArg& arg, Callback& cb) const
TestExtendingFormatter::texsformat	.\test\FormatTest.cpp	/^  friend std::string texsformat(StringPiece fmt, A&&... arg);$/;"	p	class:TestExtendingFormatter	file:	access:friend	signature:(StringPiece fmt, A&&... arg)
TestHasher	.\test\HashTest.cpp	/^class TestHasher {$/;"	c	file:
TestHasher::hash	.\test\HashTest.cpp	/^  static size_t hash(const std::pair<int, int>& p) {$/;"	f	class:TestHasher	access:public	signature:(const std::pair<int, int>& p)
TestIntSeq	.\gen\test\BaseTest.cpp	/^  TestIntSeq() { }$/;"	f	class:__anon56::TestIntSeq	access:public	signature:()
TestIntSeq	.\gen\test\BaseTest.cpp	/^  TestIntSeq(const TestIntSeq&) = delete;$/;"	p	class:__anon56::TestIntSeq	file:	access:public	signature:(const TestIntSeq&)
TestIntSeq	.\gen\test\BaseTest.cpp	/^class TestIntSeq : public GenImpl<int, TestIntSeq> {$/;"	c	namespace:__anon56	file:	inherits:GenImpl
TestPieces	.\test\SpookyHashV1Test.cpp	/^void TestPieces()$/;"	f	signature:()
TestPieces	.\test\SpookyHashV2Test.cpp	/^void TestPieces()$/;"	f	signature:()
TestResults	.\test\SpookyHashV1Test.cpp	/^void TestResults()$/;"	f	signature:()
TestResults	.\test\SpookyHashV2Test.cpp	/^void TestResults()$/;"	f	signature:()
TestSpec	.\experimental\io\test\AsyncIOTest.cpp	/^struct TestSpec {$/;"	s	namespace:__anon32	file:
TestTraits	.\test\ProducerConsumerQueueTest.cpp	/^template<> struct TestTraits<std::string> {$/;"	s	namespace:__anon128	file:
TestTraits	.\test\ProducerConsumerQueueTest.cpp	/^template<class T> struct TestTraits {$/;"	s	namespace:__anon128	file:
TestType	.\experimental\test\EliasFanoCodingTest.cpp	/^struct TestType {$/;"	s	file:
TestType::Version	.\experimental\test\EliasFanoCodingTest.cpp	/^  static constexpr size_t Version = kVersion;$/;"	m	struct:TestType	file:	access:public
TestTypes	.\experimental\test\EliasFanoCodingTest.cpp	/^typedef ::testing::Types<TestType<0>, TestType<1>> TestTypes;$/;"	t	file:
ThisIsAVeryLongStructureName	.\test\StringTest.cpp	/^struct ThisIsAVeryLongStructureName {$/;"	s	namespace:folly_test	file:
Thread	.\experimental\wangle\concurrent\ThreadPoolExecutor.h	/^    Thread() : id(nextId++), handle(), idle(true) {};$/;"	f	struct:folly::wangle::ThreadPoolExecutor::Thread	access:public	signature:()
Thread	.\experimental\wangle\concurrent\ThreadPoolExecutor.h	/^  struct FOLLY_ALIGN_TO_AVOID_FALSE_SHARING Thread {$/;"	s	class:folly::wangle::ThreadPoolExecutor	access:protected
ThreadCachedArena	.\ThreadCachedArena.cpp	/^ThreadCachedArena::ThreadCachedArena(size_t minBlockSize, size_t maxAlign)$/;"	f	class:folly::ThreadCachedArena	signature:(size_t minBlockSize, size_t maxAlign)
ThreadCachedArena	.\ThreadCachedArena.h	/^  ThreadCachedArena(ThreadCachedArena&&) = delete;$/;"	p	class:folly::ThreadCachedArena	access:private	signature:(ThreadCachedArena&&)
ThreadCachedArena	.\ThreadCachedArena.h	/^  ThreadCachedArena(const ThreadCachedArena&) = delete;$/;"	p	class:folly::ThreadCachedArena	access:private	signature:(const ThreadCachedArena&)
ThreadCachedArena	.\ThreadCachedArena.h	/^  explicit ThreadCachedArena($/;"	p	class:folly::ThreadCachedArena	access:public	signature:( size_t minBlockSize = SysArena::kDefaultMinBlockSize, size_t maxAlign = SysArena::kDefaultMaxAlign)
ThreadCachedArena	.\ThreadCachedArena.h	/^class ThreadCachedArena {$/;"	c	namespace:folly
ThreadCachedInt	.\ThreadCachedInt.h	/^  explicit ThreadCachedInt(IntT initialVal = 0, uint32_t cacheSize = 1000)$/;"	f	class:folly::ThreadCachedInt	access:public	signature:(IntT initialVal = 0, uint32_t cacheSize = 1000)
ThreadCachedInt	.\ThreadCachedInt.h	/^class ThreadCachedInt : boost::noncopyable {$/;"	c	namespace:folly	inherits:boost::noncopyable
ThreadEntry	.\detail\ThreadLocalDetail.h	/^struct ThreadEntry {$/;"	s	namespace:folly::threadlocal_detail
ThreadFactory	.\experimental\wangle\concurrent\ThreadFactory.h	/^class ThreadFactory {$/;"	c	namespace:folly::wangle
ThreadGate	.\wangle\ThreadGate.h	/^class ThreadGate {$/;"	c	namespace:folly::wangle
ThreadList	.\experimental\wangle\concurrent\ThreadPoolExecutor.h	/^  class ThreadList {$/;"	c	class:folly::wangle::ThreadPoolExecutor	access:protected
ThreadLocal	.\ThreadLocal.h	/^  ThreadLocal() { }$/;"	f	class:folly::ThreadLocal	access:public	signature:()
ThreadLocal	.\ThreadLocal.h	/^  ThreadLocal(ThreadLocal&&) = default;$/;"	p	class:folly::ThreadLocal	access:public	signature:(ThreadLocal&&)
ThreadLocal	.\ThreadLocal.h	/^  ThreadLocal(const ThreadLocal&) = delete;$/;"	p	class:folly::ThreadLocal	access:private	signature:(const ThreadLocal&)
ThreadLocal	.\ThreadLocal.h	/^class ThreadLocal {$/;"	c	namespace:folly
ThreadLocalPRNG	.\Random.h	/^  ThreadLocalPRNG() {$/;"	f	class:folly::ThreadLocalPRNG	access:public	signature:()
ThreadLocalPRNG	.\Random.h	/^class ThreadLocalPRNG {$/;"	c	namespace:folly
ThreadLocalPtr	.\ThreadLocal.h	/^    friend class ThreadLocalPtr<T,Tag>;$/;"	x
ThreadLocalPtr	.\ThreadLocal.h	/^  ThreadLocalPtr() : id_(threadlocal_detail::StaticMeta<Tag>::create()) { }$/;"	f	class:folly::ThreadLocalPtr	access:public	signature:()
ThreadLocalPtr	.\ThreadLocal.h	/^  ThreadLocalPtr(ThreadLocalPtr&& other) : id_(other.id_) {$/;"	f	class:folly::ThreadLocalPtr	access:public	signature:(ThreadLocalPtr&& other)
ThreadLocalPtr	.\ThreadLocal.h	/^  ThreadLocalPtr(const ThreadLocalPtr&) = delete;$/;"	p	class:folly::ThreadLocalPtr	access:private	signature:(const ThreadLocalPtr&)
ThreadLocalPtr	.\ThreadLocal.h	/^class ThreadLocalPtr {$/;"	c	namespace:folly
ThreadLocalPtr	.\ThreadLocal.h	/^template<class T, class Tag> class ThreadLocalPtr;$/;"	x
ThreadPoolExecutor	.\experimental\wangle\concurrent\ThreadPoolExecutor.cpp	/^ThreadPoolExecutor::ThreadPoolExecutor($/;"	f	class:folly::wangle::ThreadPoolExecutor	signature:( size_t numThreads, std::unique_ptr<ThreadFactory> threadFactory)
ThreadPoolExecutor	.\experimental\wangle\concurrent\ThreadPoolExecutor.h	/^  explicit ThreadPoolExecutor($/;"	p	class:folly::wangle::ThreadPoolExecutor	access:public	signature:( size_t numThreads, std::unique_ptr<ThreadFactory> threadFactory)
ThreadPoolExecutor	.\experimental\wangle\concurrent\ThreadPoolExecutor.h	/^class ThreadPoolExecutor : public Executor {$/;"	c	namespace:folly::wangle	inherits:Executor
ThreadPtr	.\experimental\wangle\concurrent\ThreadPoolExecutor.h	/^  typedef std::shared_ptr<Thread> ThreadPtr;$/;"	t	class:folly::wangle::ThreadPoolExecutor	access:protected
ThroughputQueueType	.\test\ProducerConsumerQueueBenchmark.cpp	/^typedef ProducerConsumerQueue<ThroughputType> ThroughputQueueType;$/;"	t	namespace:__anon127	file:
ThroughputTest	.\test\ProducerConsumerQueueBenchmark.cpp	/^  explicit ThroughputTest(size_t size, int iters, int cpu0, int cpu1)$/;"	f	struct:__anon127::ThroughputTest	access:public	signature:(size_t size, int iters, int cpu0, int cpu1)
ThroughputTest	.\test\ProducerConsumerQueueBenchmark.cpp	/^struct ThroughputTest {$/;"	s	namespace:__anon127	file:
ThroughputType	.\test\ProducerConsumerQueueBenchmark.cpp	/^typedef int ThroughputType;$/;"	t	namespace:__anon127	file:
Thrower	.\detail\ExceptionWrapper.h	/^class Thrower {$/;"	c	namespace:folly::detail
Thrower	.\test\small_vector_test.cpp	/^  Thrower() : magic(kMagic) {$/;"	f	struct:__anon132::Thrower	access:public	signature:()
Thrower	.\test\small_vector_test.cpp	/^  Thrower(Thrower const& other) : magic(other.magic) {$/;"	f	struct:__anon132::Thrower	access:public	signature:(Thrower const& other)
Thrower	.\test\small_vector_test.cpp	/^struct Thrower {$/;"	s	namespace:__anon132	file:
Tick	.\test\stl_tests\StlVectorTest.cpp	/^  static void Tick(const std::string& s) {$/;"	f	struct:Ticker	access:public	signature:(const std::string& s)
TickException	.\test\stl_tests\StlVectorTest.cpp	/^  explicit TickException(const std::string& s)$/;"	f	struct:TickException	access:public	signature:(const std::string& s)
TickException	.\test\stl_tests\StlVectorTest.cpp	/^struct TickException : std::runtime_error {$/;"	s	file:	inherits:std::runtime_error
TickException::TickException	.\test\stl_tests\StlVectorTest.cpp	/^  explicit TickException(const std::string& s)$/;"	f	struct:TickException	access:public	signature:(const std::string& s)
Ticker	.\test\stl_tests\StlVectorTest.cpp	/^struct Ticker {$/;"	s	file:
Ticker::CountTicks	.\test\stl_tests\StlVectorTest.cpp	/^  static int CountTicks;$/;"	m	struct:Ticker	file:	access:public
Ticker::CountTicks	.\test\stl_tests\StlVectorTest.cpp	/^int Ticker::CountTicks = 0;$/;"	m	class:Ticker	file:
Ticker::Tick	.\test\stl_tests\StlVectorTest.cpp	/^  static void Tick(const std::string& s) {$/;"	f	struct:Ticker	access:public	signature:(const std::string& s)
Ticker::TicksLeft	.\test\stl_tests\StlVectorTest.cpp	/^  static int TicksLeft;$/;"	m	struct:Ticker	file:	access:public
Ticker::TicksLeft	.\test\stl_tests\StlVectorTest.cpp	/^int Ticker::TicksLeft = -1;$/;"	m	class:Ticker	file:
Ticket	.\MPMCPipeline.h	/^  class Ticket {$/;"	c	class:folly::MPMCPipeline	access:public
TicksLeft	.\test\stl_tests\StlVectorTest.cpp	/^  static int TicksLeft;$/;"	m	struct:Ticker	file:	access:public
TicksLeft	.\test\stl_tests\StlVectorTest.cpp	/^int Ticker::TicksLeft = -1;$/;"	m	class:Ticker	file:
TimeIterPair	.\Benchmark.h	/^typedef std::pair<uint64_t, unsigned int> TimeIterPair;$/;"	t	namespace:folly::detail
TimePoint	.\wangle\Executor.h	/^     typedef std::chrono::steady_clock::time_point TimePoint;$/;"	t	class:folly::wangle::Executor	access:public
TimeType	.\stats\BucketedTimeSeries.h	/^  typedef TT TimeType;$/;"	t	class:folly::BucketedTimeSeries	access:public
TimeType	.\stats\MultiLevelTimeSeries.h	/^  typedef TT TimeType;$/;"	t	class:folly::MultiLevelTimeSeries	access:public
TimeType	.\stats\TimeseriesHistogram.h	/^  typedef TT TimeType;$/;"	t	class:folly::TimeseriesHistogram	access:public
TimeoutManager	.\io\async\AsyncTimeout.h	/^class TimeoutManager;$/;"	x
TimeoutManager	.\io\async\TimeoutManager.h	/^class TimeoutManager {$/;"	c	namespace:folly
TimeoutQueue	.\TimeoutQueue.h	/^  TimeoutQueue() : nextId_(1) { }$/;"	f	class:folly::TimeoutQueue	access:public	signature:()
TimeoutQueue	.\TimeoutQueue.h	/^  TimeoutQueue(const TimeoutQueue&) = delete;$/;"	p	class:folly::TimeoutQueue	access:private	signature:(const TimeoutQueue&)
TimeoutQueue	.\TimeoutQueue.h	/^class TimeoutQueue {$/;"	c	namespace:folly
TimeseriesHistogram	.\stats\Instantiations.cpp	/^template class TimeseriesHistogram<int64_t>;$/;"	x	file:
TimeseriesHistogram	.\stats\TimeseriesHistogram-defs.h	/^TimeseriesHistogram<T, TT, C>::TimeseriesHistogram(ValueType bucketSize,$/;"	f	class:folly::TimeseriesHistogram	signature:(ValueType bucketSize, ValueType min, ValueType max, const ContainerType& copyMe)
TimeseriesHistogram	.\stats\TimeseriesHistogram.h	/^  TimeseriesHistogram(ValueType bucketSize, ValueType min, ValueType max,$/;"	p	class:folly::TimeseriesHistogram	access:public	signature:(ValueType bucketSize, ValueType min, ValueType max, const ContainerType& defaultContainer)
TimeseriesHistogram	.\stats\TimeseriesHistogram.h	/^class TimeseriesHistogram {$/;"	c	namespace:folly
To	.\gen\Base.h	/^class To {$/;"	c	namespace:folly::gen
To	.\gen\Base.h	/^class To<StringPiece> {$/;"	c	namespace:folly::gen
Token	.\test\DynamicConverterTest.cpp	/^  explicit Token(int kind, const fbstring& lexeme)$/;"	f	struct:Token	access:public	signature:(int kind, const fbstring& lexeme)
Token	.\test\DynamicConverterTest.cpp	/^struct Token {$/;"	s	file:
Token::Token	.\test\DynamicConverterTest.cpp	/^  explicit Token(int kind, const fbstring& lexeme)$/;"	f	struct:Token	access:public	signature:(int kind, const fbstring& lexeme)
Token::kind_	.\test\DynamicConverterTest.cpp	/^  int kind_;$/;"	m	struct:Token	file:	access:public
Token::lexeme_	.\test\DynamicConverterTest.cpp	/^  fbstring lexeme_;$/;"	m	struct:Token	file:	access:public
Tracker	.\test\stl_tests\StlVectorTest.cpp	/^  Tracker(Tracker* self, int uid) : self(self), uid(uid) {}$/;"	f	struct:Tracker	access:public	signature:(Tracker* self, int uid)
Tracker	.\test\stl_tests\StlVectorTest.cpp	/^struct Tracker {$/;"	s	file:
Tracker::Locations	.\test\stl_tests\StlVectorTest.cpp	/^  static std::map<const Tracker*, int> Locations;$/;"	m	struct:Tracker	file:	access:public
Tracker::Locations	.\test\stl_tests\StlVectorTest.cpp	/^std::map<const Tracker*, int> Tracker::Locations;$/;"	m	class:Tracker	file:
Tracker::Print	.\test\stl_tests\StlVectorTest.cpp	/^  static bool Print;$/;"	m	struct:Tracker	file:	access:public
Tracker::Print	.\test\stl_tests\StlVectorTest.cpp	/^bool Tracker::Print = false;$/;"	m	class:Tracker	file:
Tracker::Tracker	.\test\stl_tests\StlVectorTest.cpp	/^  Tracker(Tracker* self, int uid) : self(self), uid(uid) {}$/;"	f	struct:Tracker	access:public	signature:(Tracker* self, int uid)
Tracker::UID	.\test\stl_tests\StlVectorTest.cpp	/^  static int UID;$/;"	m	struct:Tracker	file:	access:public
Tracker::UID	.\test\stl_tests\StlVectorTest.cpp	/^int Tracker::UID = 1234;$/;"	m	class:Tracker	file:
Tracker::UIDCount	.\test\stl_tests\StlVectorTest.cpp	/^  static std::map<int, int> UIDCount;$/;"	m	struct:Tracker	file:	access:public
Tracker::UIDCount	.\test\stl_tests\StlVectorTest.cpp	/^std::map<int, int> Tracker::UIDCount;$/;"	m	class:Tracker	file:
Tracker::UIDTotal	.\test\stl_tests\StlVectorTest.cpp	/^  static int UIDTotal;$/;"	m	struct:Tracker	file:	access:public
Tracker::UIDTotal	.\test\stl_tests\StlVectorTest.cpp	/^int Tracker::UIDTotal = 0;$/;"	m	class:Tracker	file:
Tracker::self	.\test\stl_tests\StlVectorTest.cpp	/^  Tracker* self;$/;"	m	struct:Tracker	file:	access:public
Tracker::uid	.\test\stl_tests\StlVectorTest.cpp	/^  int uid;$/;"	m	struct:Tracker	file:	access:public
Traits	.\detail\GroupVarintDetail.h	/^  typedef GroupVarintTraits<T> Traits;$/;"	t	class:folly::detail::GroupVarintBase	access:protected
Transformer	.\DynamicConverter.h	/^  explicit Transformer(const It& it)$/;"	f	class:folly::dynamicconverter_detail::Transformer	access:public	signature:(const It& it)
Transformer	.\DynamicConverter.h	/^class Transformer : public boost::iterator_adaptor<$/;"	c	namespace:folly::dynamicconverter_detail	inherits:boost::iterator_adaptor
Transformer	.\test\stl_tests\StlVectorTest.cpp	/^  explicit Transformer(const It& it)$/;"	f	class:Transformer	access:public	signature:(const It& it)
Transformer	.\test\stl_tests\StlVectorTest.cpp	/^class Transformer : public boost::iterator_adaptor<$/;"	c	file:	inherits:boost::iterator_adaptor
Transformer::Transformer	.\test\stl_tests\StlVectorTest.cpp	/^  explicit Transformer(const It& it)$/;"	f	class:Transformer	access:public	signature:(const It& it)
Transformer::dereference	.\test\stl_tests\StlVectorTest.cpp	/^  typename iterator_traits<It>::value_type& dereference() const {$/;"	f	class:Transformer	access:public	signature:() const
Transformer::dereferenced	.\test\stl_tests\StlVectorTest.cpp	/^  shared_ptr<set<It>> dereferenced;$/;"	m	class:Transformer	file:	access:private
Try	.\wangle\Try-inl.h	/^Try<T>::Try(Try<T>&& t) : contains_(t.contains_) {$/;"	f	class:folly::wangle::Try	signature:(Try<T>&& t)
Try	.\wangle\Try.h	/^  Try() : contains_(Contains::NOTHING) {}$/;"	f	class:folly::wangle::Try	access:public	signature:()
Try	.\wangle\Try.h	/^  Try() : hasValue_(true) {}$/;"	f	class:folly::wangle::Try	access:public	signature:()
Try	.\wangle\Try.h	/^  Try(Try<T>&& t);$/;"	p	class:folly::wangle::Try	access:public	signature:(Try<T>&& t)
Try	.\wangle\Try.h	/^  explicit Try(T&& v) : contains_(Contains::VALUE), value_(std::move(v)) {}$/;"	f	class:folly::wangle::Try	access:public	signature:(T&& v)
Try	.\wangle\Try.h	/^  explicit Try(const T& v) : contains_(Contains::VALUE), value_(v) {}$/;"	f	class:folly::wangle::Try	access:public	signature:(const T& v)
Try	.\wangle\Try.h	/^  explicit Try(std::exception_ptr e) : contains_(Contains::EXCEPTION), e_(e) {}$/;"	f	class:folly::wangle::Try	access:public	signature:(std::exception_ptr e)
Try	.\wangle\Try.h	/^  explicit Try(std::exception_ptr e) : hasValue_(false), e_(e) {}$/;"	f	class:folly::wangle::Try	access:public	signature:(std::exception_ptr e)
Try	.\wangle\Try.h	/^class Try {$/;"	c	namespace:folly::wangle
Try	.\wangle\Try.h	/^class Try<void> {$/;"	c	namespace:folly::wangle
TryFormatValue	.\Format-inl.h	/^class TryFormatValue {$/;"	c	namespace:folly
TryFormatValue	.\Format-inl.h	/^class TryFormatValue<$/;"	x
TupleHasher	.\Hash.h	/^struct TupleHasher {$/;"	s	namespace:folly
TupleHasher	.\Hash.h	/^struct TupleHasher<0, Ts...> {$/;"	s	namespace:folly
TurnSequencer	.\MPMCQueue.h	/^struct TurnSequencer {$/;"	s	namespace:folly::detail
TwoBy32	.\test\AtomicStructTest.cpp	/^struct TwoBy32 {$/;"	s	file:
TwoBy32::left	.\test\AtomicStructTest.cpp	/^  uint32_t left;$/;"	m	struct:TwoBy32	file:	access:public
TwoBy32::right	.\test\AtomicStructTest.cpp	/^  uint32_t right;$/;"	m	struct:TwoBy32	file:	access:public
Type	.\FormatArg.h	/^  enum class Type {$/;"	c	struct:folly::FormatArg	access:public
Type	.\IPAddressV6.h	/^  enum Type {$/;"	g	class:folly::IPAddressV6	access:public
Type	.\dynamic.h	/^  enum Type {$/;"	g	struct:folly::dynamic	access:public
Type	.\experimental\Singleton.h	/^  enum class Type { Strict, Relaxed };$/;"	c	class:folly::SingletonVault	access:public
TypeAssertion	.\gen\Base-inl.h	/^class TypeAssertion : public Operator<TypeAssertion<Expected>> {$/;"	c	namespace:folly::gen::detail	inherits:Operator
TypeAssertion	.\gen\Base.h	/^class TypeAssertion;$/;"	x
TypeDescriptor	.\experimental\Singleton.h	/^  TypeDescriptor(const std::type_info& ti, std::string name)$/;"	f	class:folly::detail::TypeDescriptor	access:public	signature:(const std::type_info& ti, std::string name)
TypeDescriptor	.\experimental\Singleton.h	/^class TypeDescriptor {$/;"	c	namespace:folly::detail
TypeDescriptorHasher	.\experimental\Singleton.h	/^  friend class TypeDescriptorHasher;$/;"	x
TypeDescriptorHasher	.\experimental\Singleton.h	/^class TypeDescriptorHasher {$/;"	c	namespace:folly::detail
TypeError	.\IPAddressV6.h	/^  typedef std::runtime_error TypeError;$/;"	t	class:folly::IPAddressV6	access:public
TypeError	.\dynamic-inl.h	/^  explicit TypeError(const std::string& expected, dynamic::Type actual)$/;"	f	struct:folly::TypeError	access:public	signature:(const std::string& expected, dynamic::Type actual)
TypeError	.\dynamic-inl.h	/^  explicit TypeError(const std::string& expected,$/;"	f	struct:folly::TypeError	access:public	signature:(const std::string& expected, dynamic::Type actual1, dynamic::Type actual2)
TypeError	.\dynamic-inl.h	/^struct TypeError : std::runtime_error {$/;"	s	namespace:folly	inherits:std::runtime_error
TypeError	.\dynamic.h	/^  friend struct TypeError;$/;"	x
TypeError	.\dynamic.h	/^struct TypeError;$/;"	x
TypeInfo	.\dynamic-inl.h	/^template<class T> struct dynamic::TypeInfo {$/;"	s	class:folly::dynamic
TypeInfo	.\dynamic.h	/^  template<class T> struct TypeInfo;$/;"	x
Type_popcount	.\Bits.cpp	/^typedef decltype(popcount_builtin) Type_popcount;$/;"	t	namespace:__anon3	file:
Type_popcountll	.\Bits.cpp	/^typedef decltype(popcountll_builtin) Type_popcountll;$/;"	t	namespace:__anon3	file:
TypedIOBuf	.\io\TypedIOBuf.h	/^  TypedIOBuf(TypedIOBuf&&) = default;$/;"	p	class:folly::TypedIOBuf	access:public	signature:(TypedIOBuf&&)
TypedIOBuf	.\io\TypedIOBuf.h	/^  TypedIOBuf(const TypedIOBuf&) = delete;$/;"	p	class:folly::TypedIOBuf	access:private	signature:(const TypedIOBuf&)
TypedIOBuf	.\io\TypedIOBuf.h	/^  explicit TypedIOBuf(IOBuf* buf) : buf_(buf) { }$/;"	f	class:folly::TypedIOBuf	access:public	signature:(IOBuf* buf)
TypedIOBuf	.\io\TypedIOBuf.h	/^class TypedIOBuf {$/;"	c	namespace:folly
UID	.\test\stl_tests\StlVectorTest.cpp	/^  static int UID;$/;"	m	struct:Tracker	file:	access:public
UID	.\test\stl_tests\StlVectorTest.cpp	/^int Tracker::UID = 1234;$/;"	m	class:Tracker	file:
UIDCount	.\test\stl_tests\StlVectorTest.cpp	/^  static std::map<int, int> UIDCount;$/;"	m	struct:Tracker	file:	access:public
UIDCount	.\test\stl_tests\StlVectorTest.cpp	/^std::map<int, int> Tracker::UIDCount;$/;"	m	class:Tracker	file:
UIDTotal	.\test\stl_tests\StlVectorTest.cpp	/^  static int UIDTotal;$/;"	m	struct:Tracker	file:	access:public
UIDTotal	.\test\stl_tests\StlVectorTest.cpp	/^int Tracker::UIDTotal = 0;$/;"	m	class:Tracker	file:
UIntType	.\SmallLocks.h	/^  typedef typename std::make_unsigned<IntType>::type UIntType;$/;"	t	struct:folly::PicoSpinLock	access:public
UMAKER_a	.\test\stl_tests\StlVectorTest.cpp	1115;"	d	file:
UMAKER_b	.\test\stl_tests\StlVectorTest.cpp	1138;"	d	file:
UMAKER_i	.\test\stl_tests\StlVectorTest.cpp	1163;"	d	file:
UMAKER_j	.\test\stl_tests\StlVectorTest.cpp	1172;"	d	file:
UMAKER_m	.\test\stl_tests\StlVectorTest.cpp	1274;"	d	file:
UMAKER_n	.\test\stl_tests\StlVectorTest.cpp	1151;"	d	file:
UMAKER_p	.\test\stl_tests\StlVectorTest.cpp	1227;"	d	file:
UMAKER_q	.\test\stl_tests\StlVectorTest.cpp	1237;"	d	file:
UMAKER_t	.\test\stl_tests\StlVectorTest.cpp	1260;"	d	file:
UMAKER_ticks	.\test\stl_tests\StlVectorTest.cpp	1050;"	d	file:
UMAKER_z	.\test\stl_tests\StlVectorTest.cpp	1024;"	d	file:
UNHANDLED_ERROR	.\test\ScopeGuardTest.cpp	/^  UNHANDLED_ERROR,$/;"	m	class:ErrorBehavior	file:	access:private
UNINITIALIZED	.\experimental\io\AsyncIO.h	/^    UNINITIALIZED,$/;"	m	class:folly::AsyncIOOp::State	access:private
UNKNOWN_UNCOMPRESSED_LENGTH	.\io\Compression.h	/^  static constexpr uint64_t UNKNOWN_UNCOMPRESSED_LENGTH = uint64_t(-1);$/;"	m	class:folly::io::Codec	access:public
UNLIKELY	.\Likely.h	28;"	d
UNLIKELY	.\Likely.h	32;"	d
UNLIKELY	.\Likely.h	35;"	d
UNLIMITED_UNCOMPRESSED_LENGTH	.\io\Compression.h	/^  static constexpr uint64_t UNLIMITED_UNCOMPRESSED_LENGTH = uint64_t(-2);$/;"	m	class:folly::io::Codec	access:public
UNLINK_IMMEDIATELY	.\experimental\TestUtil.h	/^    UNLINK_IMMEDIATELY,$/;"	m	class:folly::test::TemporaryFile::Scope	access:private
UNSYNCHRONIZED	.\Synchronized.h	674;"	d
UNW_LOCAL_ONLY	.\experimental\symbolizer\StackTrace.cpp	20;"	d	file:
USER_DEFINED	.\io\Compression.h	/^  USER_DEFINED = 0,$/;"	m	class:folly::io::CodecType	access:private
USER_OWNED	.\io\test\IOBufTest.cpp	/^  USER_OWNED,$/;"	e	enum:BufType	file:
UnalignedNoASan	.\experimental\Bits.h	/^struct UnalignedNoASan : public Unaligned<T> { };$/;"	s	namespace:folly	inherits:Unaligned
UncaughtExceptionCounter	.\detail\UncaughtExceptionCounter.h	/^  UncaughtExceptionCounter()$/;"	f	class:folly::detail::UncaughtExceptionCounter	access:public	signature:()
UncaughtExceptionCounter	.\detail\UncaughtExceptionCounter.h	/^  UncaughtExceptionCounter(const UncaughtExceptionCounter& other)$/;"	f	class:folly::detail::UncaughtExceptionCounter	access:public	signature:(const UncaughtExceptionCounter& other)
UncaughtExceptionCounter	.\detail\UncaughtExceptionCounter.h	/^class UncaughtExceptionCounter {$/;"	c	namespace:folly::detail
UnderlyingType	.\experimental\Bits.h	/^  typedef T UnderlyingType;$/;"	t	struct:folly::detail::BitsTraits	access:public
UnderlyingType	.\experimental\Bits.h	/^  typedef typename Traits::UnderlyingType UnderlyingType;$/;"	t	struct:folly::Bits	access:public
UniformSubset	.\test\DeterministicSchedule.cpp	/^  UniformSubset(long seed, int subsetSize, int stepsBetweenSelect)$/;"	f	struct:folly::test::UniformSubset	access:public	signature:(long seed, int subsetSize, int stepsBetweenSelect)
UniformSubset	.\test\DeterministicSchedule.cpp	/^struct UniformSubset {$/;"	s	namespace:folly::test	file:
UniquePtr	.\IndexedMemPool.h	/^      UniquePtr;$/;"	t	struct:folly::IndexedMemPool	access:public
UniquePtr	.\LifoSem.h	/^                          LifoSemNodeRecycler<Handoff, Atom>> UniquePtr;$/;"	t	struct:folly::detail::LifoSemBase	access:protected
UniquePtr	.\experimental\wangle\ConnectionManager.h	/^  typedef std::unique_ptr<ConnectionManager, Destructor> UniquePtr;$/;"	t	class:folly::wangle::ConnectionManager	access:public
UniquePtr	.\io\async\HHWheelTimer.h	/^  typedef std::unique_ptr<HHWheelTimer, Destructor> UniquePtr;$/;"	t	class:folly::HHWheelTimer	access:public
UniquePtrComp	.\test\ConcurrentSkipListTest.cpp	/^struct UniquePtrComp {$/;"	s	namespace:__anon114	file:
UniquePtrDeleter	.\io\IOBuf.h	/^    explicit UniquePtrDeleter(Deleter deleter) : deleter_(std::move(deleter)){ }$/;"	f	struct:folly::IOBuf::UniquePtrDeleter	access:public	signature:(Deleter deleter)
UniquePtrDeleter	.\io\IOBuf.h	/^  struct UniquePtrDeleter : public DeleterBase {$/;"	s	class:folly::IOBuf	inherits:DeleterBase	access:private
UnregisteredWatchdog	.\experimental\test\SingletonTest.cpp	/^struct UnregisteredWatchdog : public Watchdog {};$/;"	s	file:	inherits:Watchdog
Unsplit	.\gen\String-inl.h	/^  explicit Unsplit(const Delimiter& delimiter)$/;"	f	class:folly::gen::detail::Unsplit	access:public	signature:(const Delimiter& delimiter)
Unsplit	.\gen\String-inl.h	/^class Unsplit : public Operator<Unsplit<Delimiter, Output>> {$/;"	c	namespace:folly::gen::detail	inherits:Operator
Unsplit	.\gen\String.h	/^class Unsplit;$/;"	x
UnsplitBuffer	.\gen\String-inl.h	/^  UnsplitBuffer(const Delimiter& delimiter, OutputBuffer* outputBuffer)$/;"	f	class:folly::gen::detail::UnsplitBuffer	access:public	signature:(const Delimiter& delimiter, OutputBuffer* outputBuffer)
UnsplitBuffer	.\gen\String-inl.h	/^class UnsplitBuffer : public Operator<UnsplitBuffer<Delimiter, OutputBuffer>> {$/;"	c	namespace:folly::gen::detail	inherits:Operator
UnsplitBuffer	.\gen\String.h	/^class UnsplitBuffer;$/;"	x
Unsynchronizer	.\Synchronized.h	/^      Unsynchronizer(const Unsynchronizer&) = delete;$/;"	p	struct:folly::Synchronized::ConstLockedPtr::Unsynchronizer	access:public	signature:(const Unsynchronizer&)
Unsynchronizer	.\Synchronized.h	/^      Unsynchronizer(const Unsynchronizer&) = delete;$/;"	p	struct:folly::Synchronized::LockedPtr::Unsynchronizer	access:public	signature:(const Unsynchronizer&)
Unsynchronizer	.\Synchronized.h	/^      explicit Unsynchronizer(ConstLockedPtr* p) : parent_(p) {$/;"	f	struct:folly::Synchronized::ConstLockedPtr::Unsynchronizer	access:public	signature:(ConstLockedPtr* p)
Unsynchronizer	.\Synchronized.h	/^      explicit Unsynchronizer(LockedPtr* p) : parent_(p) {$/;"	f	struct:folly::Synchronized::LockedPtr::Unsynchronizer	access:public	signature:(LockedPtr* p)
Unsynchronizer	.\Synchronized.h	/^    friend struct Unsynchronizer;$/;"	x
Unsynchronizer	.\Synchronized.h	/^    struct Unsynchronizer {$/;"	s	struct:folly::Synchronized::ConstLockedPtr	access:public
Unsynchronizer	.\Synchronized.h	/^    struct Unsynchronizer {$/;"	s	struct:folly::Synchronized::LockedPtr	access:public
Until	.\gen\Base-inl.h	/^  Until() {}$/;"	f	class:folly::gen::detail::Until	access:public	signature:()
Until	.\gen\Base-inl.h	/^  explicit Until(Predicate pred)$/;"	f	class:folly::gen::detail::Until	access:public	signature:(Predicate pred)
Until	.\gen\Base-inl.h	/^class Until : public Operator<Until<Predicate>> {$/;"	c	namespace:folly::gen::detail	inherits:Operator
Until	.\gen\Base.h	/^class Until;$/;"	x
Update	.\SpookyHashV1.cpp	/^void SpookyHashV1::Update(const void *message, size_t length)$/;"	f	class:folly::hash::SpookyHashV1	signature:(const void *message, size_t length)
Update	.\SpookyHashV1.h	/^    void Update($/;"	p	class:folly::hash::SpookyHashV1	access:public	signature:( const void *message, size_t length)
Update	.\SpookyHashV2.cpp	/^void SpookyHashV2::Update(const void *message, size_t length)$/;"	f	class:folly::hash::SpookyHashV2	signature:(const void *message, size_t length)
Update	.\SpookyHashV2.h	/^    void Update($/;"	p	class:folly::hash::SpookyHashV2	access:public	signature:( const void *message, size_t length)
UpgradedHolder	.\RWSpinLock.h	/^    UpgradedHolder(UpgradedHolder&& other) : lock_(other.lock_) {$/;"	f	class:folly::RWSpinLock::UpgradedHolder	access:public	signature:(UpgradedHolder&& other)
UpgradedHolder	.\RWSpinLock.h	/^    explicit UpgradedHolder(RWSpinLock& lock) : lock_(&lock) {$/;"	f	class:folly::RWSpinLock::UpgradedHolder	access:public	signature:(RWSpinLock& lock)
UpgradedHolder	.\RWSpinLock.h	/^    explicit UpgradedHolder(RWSpinLock* lock = nullptr) : lock_(lock) {$/;"	f	class:folly::RWSpinLock::UpgradedHolder	access:public	signature:(RWSpinLock* lock = nullptr)
UpgradedHolder	.\RWSpinLock.h	/^    explicit UpgradedHolder(WriteHolder&& writer) {$/;"	f	class:folly::RWSpinLock::UpgradedHolder	access:public	signature:(WriteHolder&& writer)
UpgradedHolder	.\RWSpinLock.h	/^    friend class UpgradedHolder;$/;"	x
UpgradedHolder	.\RWSpinLock.h	/^  class UpgradedHolder {$/;"	c	class:folly::RWSpinLock	access:public
UpgradedHolder	.\RWSpinLock.h	/^  class UpgradedHolder;$/;"	x
UpperBitsReader	.\experimental\EliasFanoCoding.h	/^  explicit UpperBitsReader(const EliasFanoCompressedList& list)$/;"	f	class:folly::compression::detail::UpperBitsReader	access:public	signature:(const EliasFanoCompressedList& list)
UpperBitsReader	.\experimental\EliasFanoCoding.h	/^class UpperBitsReader {$/;"	c	namespace:folly::compression::detail
Uri	.\Uri.cpp	/^Uri::Uri(StringPiece str) : port_(0) {$/;"	f	class:folly::Uri	signature:(StringPiece str)
Uri	.\Uri.h	/^  explicit Uri(StringPiece str);$/;"	p	class:folly::Uri	access:public	signature:(StringPiece str)
Uri	.\Uri.h	/^class Uri {$/;"	c	namespace:folly
UriEscapeMode	.\String.h	/^enum class UriEscapeMode : unsigned char {$/;"	c	namespace:folly
UserDefinedType	.\test\FBVectorTest.cpp	/^class UserDefinedType { int whatevs_; };$/;"	c	namespace:__anon115	file:
UsingUninitializedTry	.\wangle\WangleException.h	/^    explicit UsingUninitializedTry() :$/;"	f	class:folly::wangle::UsingUninitializedTry	access:public	signature:()
UsingUninitializedTry	.\wangle\WangleException.h	/^class UsingUninitializedTry : public WangleException {$/;"	c	namespace:folly::wangle	inherits:WangleException
VALUE	.\wangle\Try.h	/^    VALUE,$/;"	m	class:folly::wangle::Try::Contains	access:private
VALUE_CHANGED	.\detail\Futex.h	/^  VALUE_CHANGED, \/* Futex value didn't match expected *\/$/;"	m	class:folly::detail::FutexResult	access:private
VARARG	.\Preprocessor.h	37;"	d
VARARG_IMPL	.\Preprocessor.h	36;"	d
VARARG_IMPL2	.\Preprocessor.h	35;"	d
VA_NARGS	.\Preprocessor.h	34;"	d
VA_NARGS_IMPL	.\Preprocessor.h	33;"	d
VECTOR	.\test\FBVectorBenchmark.cpp	100;"	d	file:
VECTOR	.\test\FBVectorBenchmark.cpp	101;"	d	file:
VECTOR	.\test\FBVectorBenchmark.cpp	103;"	d	file:
VECTOR	.\test\FBVectorBenchmark.cpp	104;"	d	file:
VECTOR	.\test\FBVectorBenchmark.cpp	106;"	d	file:
VECTOR	.\test\FBVectorBenchmark.cpp	95;"	d	file:
VECTOR	.\test\FBVectorBenchmark.cpp	97;"	d	file:
VECTOR	.\test\FBVectorBenchmark.cpp	98;"	d	file:
VECTOR_	.\test\stl_tests\StlVectorTest.cpp	166;"	d	file:
VECTOR_	.\test\stl_tests\StlVectorTest.cpp	169;"	d	file:
VERIFICATION	.\test\stl_tests\StlVectorTest.cpp	1032;"	d	file:
VMAKER_a	.\test\stl_tests\StlVectorTest.cpp	1109;"	d	file:
VMAKER_b	.\test\stl_tests\StlVectorTest.cpp	1120;"	d	file:
VMAKER_i	.\test\stl_tests\StlVectorTest.cpp	1162;"	d	file:
VMAKER_j	.\test\stl_tests\StlVectorTest.cpp	1168;"	d	file:
VMAKER_m	.\test\stl_tests\StlVectorTest.cpp	1270;"	d	file:
VMAKER_n	.\test\stl_tests\StlVectorTest.cpp	1149;"	d	file:
VMAKER_p	.\test\stl_tests\StlVectorTest.cpp	1222;"	d	file:
VMAKER_q	.\test\stl_tests\StlVectorTest.cpp	1232;"	d	file:
VMAKER_t	.\test\stl_tests\StlVectorTest.cpp	1247;"	d	file:
VMAKER_ticks	.\test\stl_tests\StlVectorTest.cpp	1043;"	d	file:
VMAKER_z	.\test\stl_tests\StlVectorTest.cpp	1023;"	d	file:
Value	.\test\SpookyHashV1Test.cpp	/^    inline uint64_t Value()$/;"	f	class:Random	access:public	signature:()
Value	.\test\SpookyHashV2Test.cpp	/^    inline uint64_t Value()$/;"	f	class:Random	access:public	signature:()
ValueT	.\test\AtomicHashMapTest.cpp	/^typedef int32_t     ValueT;$/;"	t	file:
ValueTuple	.\Format.h	/^      typename std::decay<Args>::type>...> ValueTuple;$/;"	t	class:folly::BaseFormatter	access:private
ValueType	.\detail\Stats.h	/^  typedef T ValueType;$/;"	t	struct:folly::detail::Bucket	access:public
ValueType	.\experimental\EliasFanoCoding.h	/^  typedef Value ValueType;$/;"	t	struct:folly::compression::EliasFanoEncoder	access:public
ValueType	.\experimental\EliasFanoCoding.h	/^  typedef typename Encoder::ValueType ValueType;$/;"	t	class:folly::compression::EliasFanoReader	access:public
ValueType	.\experimental\EliasFanoCoding.h	/^  typedef typename Encoder::ValueType ValueType;$/;"	t	class:folly::compression::detail::UpperBitsReader	access:public
ValueType	.\gen\Core-inl.h	/^  typedef Value ValueType;$/;"	t	class:folly::gen::GenImpl	access:public
ValueType	.\stats\BucketedTimeSeries.h	/^  typedef VT ValueType;$/;"	t	class:folly::BucketedTimeSeries	access:public
ValueType	.\stats\Histogram.h	/^  typedef T ValueType;$/;"	t	class:folly::Histogram	access:public
ValueType	.\stats\Histogram.h	/^  typedef T ValueType;$/;"	t	class:folly::detail::HistogramBuckets	access:public
ValueType	.\stats\MultiLevelTimeSeries.h	/^  typedef VT ValueType;$/;"	t	class:folly::MultiLevelTimeSeries	access:public
ValueType	.\stats\TimeseriesHistogram.h	/^  typedef T ValueType;$/;"	t	class:folly::TimeseriesHistogram	access:public
ValueType	.\test\ConcurrentSkipListBenchmark.cpp	/^typedef int ValueType;$/;"	t	namespace:__anon113	file:
ValueType	.\test\ConcurrentSkipListTest.cpp	/^typedef int ValueType;$/;"	t	namespace:__anon114	file:
ValueTypeOfRange	.\gen\Base.h	/^struct ValueTypeOfRange {$/;"	s	namespace:folly::gen::detail
VariadicContext	.\wangle\detail\State.h	/^  VariadicContext() : total(0), count(0) {}$/;"	f	struct:folly::wangle::detail::VariadicContext	access:public	signature:()
VariadicContext	.\wangle\detail\State.h	/^struct VariadicContext {$/;"	s	namespace:folly::wangle::detail
VecT	.\test\PackedSyncPtrTest.cpp	/^typedef SyncVec<intptr_t> VecT;$/;"	t	file:
VectorSizes	.\test\stl_tests\StlVectorTest.cpp	/^static const vector<pair<int, int>> VectorSizes = {$/;"	v	file:
VectorType	.\gen\Base-inl.h	/^    typedef std::vector<StorageType> VectorType;$/;"	t	class:folly::gen::detail::Order::Generator	access:private
VectorType	.\test\ConcurrentSkipListTest.cpp	/^typedef vector<ValueType> VectorType;$/;"	t	namespace:__anon114	file:
Version	.\experimental\test\EliasFanoCodingTest.cpp	/^  static constexpr size_t Version = kVersion;$/;"	m	struct:TestType	file:	access:public
VirtualClass	.\test\function_benchmark\benchmark_impl.h	/^class VirtualClass;$/;"	x
VirtualClass	.\test\function_benchmark\test_functions.h	/^class VirtualClass {$/;"	c
VirtualClass::doNothing	.\test\function_benchmark\test_functions.cpp	/^void VirtualClass::doNothing() {$/;"	f	class:VirtualClass	signature:()
VirtualClass::doNothing	.\test\function_benchmark\test_functions.h	/^  virtual void doNothing();$/;"	p	class:VirtualClass	access:public	signature:()
VirtualClass::~VirtualClass	.\test\function_benchmark\test_functions.cpp	/^VirtualClass::~VirtualClass() {$/;"	f	class:VirtualClass	signature:()
VirtualClass::~VirtualClass	.\test\function_benchmark\test_functions.h	/^  virtual ~VirtualClass();$/;"	p	class:VirtualClass	access:public	signature:()
VirtualGen	.\gen\Base-inl.h	/^  VirtualGen(const VirtualGen& source)$/;"	f	class:folly::gen::VirtualGen	access:public	signature:(const VirtualGen& source)
VirtualGen	.\gen\Base-inl.h	/^  \/* implicit *\/ VirtualGen(Self source)$/;"	f	class:folly::gen::VirtualGen	access:public	signature:(Self source)
VirtualGen	.\gen\Base-inl.h	/^class VirtualGen : public GenImpl<Value, VirtualGen<Value>> {$/;"	c	namespace:folly::gen	inherits:GenImpl
VirtualGen	.\gen\Base.h	/^class VirtualGen;$/;"	x
VisitorResult	.\detail\DiscriminatedPtrDetail.h	/^struct VisitorResult {$/;"	s	namespace:folly::dptr_detail
VisitorResult1	.\detail\DiscriminatedPtrDetail.h	/^struct VisitorResult1 {$/;"	s	namespace:folly::dptr_detail
Volatile	.\test\HasMemberFnTraitsTest.cpp	/^struct Volatile {$/;"	s	file:
Volatile::test	.\test\HasMemberFnTraitsTest.cpp	/^  void test() volatile;$/;"	p	struct:Volatile	file:	access:public	signature:() volatile
WAITING	.\Baton.h	/^    WAITING = 2,$/;"	m	struct:folly::Baton	typeref:enum:folly::Baton::	access:private
WHEEL_BITS	.\io\async\HHWheelTimer.h	/^  static constexpr int WHEEL_BITS = 8;$/;"	m	class:folly::HHWheelTimer	access:private
WHEEL_BUCKETS	.\io\async\HHWheelTimer.h	/^  static constexpr int WHEEL_BUCKETS = 4;$/;"	m	class:folly::HHWheelTimer	access:private
WHEEL_MASK	.\io\async\HHWheelTimer.h	/^  static constexpr unsigned int WHEEL_MASK = (WHEEL_SIZE - 1);$/;"	m	class:folly::HHWheelTimer	access:private
WHEEL_SIZE	.\io\async\HHWheelTimer.h	/^  static constexpr unsigned int WHEEL_SIZE = (1 << WHEEL_BITS);$/;"	m	class:folly::HHWheelTimer	access:private
WHITE	.\experimental\symbolizer\Symbolizer.h	/^  enum Color { DEFAULT, RED, GREEN, YELLOW, BLUE, CYAN, WHITE, PURPLE };$/;"	e	enum:folly::symbolizer::SymbolizePrinter::Color
WRAP_BUFFER	.\io\IOBuf.h	/^  enum WrapBufferOp { WRAP_BUFFER };$/;"	e	enum:folly::IOBuf::WrapBufferOp
WRITE	.\io\async\EventHandler.h	/^    WRITE = EV_WRITE,$/;"	e	enum:folly::EventHandler::EventFlags
WRITE_TEST	.\experimental\test\BitsTest.cpp	276;"	d	file:
WRITE_TEST	.\experimental\test\BitsTest.cpp	287;"	d	file:
WaitResult	.\LifoSem.h	/^  enum class WaitResult {$/;"	c	struct:folly::detail::LifoSemBase	access:protected
WangleException	.\wangle\WangleException.h	/^  explicit WangleException(std::string message_arg)$/;"	f	class:folly::wangle::WangleException	access:public	signature:(std::string message_arg)
WangleException	.\wangle\WangleException.h	/^class WangleException : public std::exception {$/;"	c	namespace:folly::wangle	inherits:std::exception
Wat	.\test\ApplyTupleTest.cpp	/^  Wat() {}$/;"	f	struct:__anon104::Wat	access:public	signature:()
Wat	.\test\ApplyTupleTest.cpp	/^  Wat(Wat const&) = delete;$/;"	p	struct:__anon104::Wat	file:	access:public	signature:(Wat const&)
Wat	.\test\ApplyTupleTest.cpp	/^struct Wat {$/;"	s	namespace:__anon104	file:
Watchdog	.\experimental\test\SingletonTest.cpp	/^  Watchdog() : serial_number(++global_counter) {$/;"	f	struct:Watchdog	access:public	signature:()
Watchdog	.\experimental\test\SingletonTest.cpp	/^  Watchdog(const Watchdog&) = delete;$/;"	p	struct:Watchdog	file:	access:public	signature:(const Watchdog&)
Watchdog	.\experimental\test\SingletonTest.cpp	/^struct Watchdog {$/;"	s	file:
Watchdog::Watchdog	.\experimental\test\SingletonTest.cpp	/^  Watchdog() : serial_number(++global_counter) {$/;"	f	struct:Watchdog	access:public	signature:()
Watchdog::Watchdog	.\experimental\test\SingletonTest.cpp	/^  Watchdog(const Watchdog&) = delete;$/;"	p	struct:Watchdog	file:	access:public	signature:(const Watchdog&)
Watchdog::creation_order	.\experimental\test\SingletonTest.cpp	/^  static std::vector<Watchdog*> creation_order;$/;"	m	struct:Watchdog	file:	access:public
Watchdog::creation_order	.\experimental\test\SingletonTest.cpp	/^std::vector<Watchdog*> Watchdog::creation_order;$/;"	m	class:Watchdog	file:
Watchdog::livingWatchdogCount	.\experimental\test\SingletonTest.cpp	/^  size_t livingWatchdogCount() const { return creation_order.size(); }$/;"	f	struct:Watchdog	access:public	signature:() const
Watchdog::noexcept	.\experimental\test\SingletonTest.cpp	/^  Watchdog(Watchdog&&) noexcept = default;$/;"	m	struct:Watchdog	file:	access:public
Watchdog::operator =	.\experimental\test\SingletonTest.cpp	/^  Watchdog& operator=(const Watchdog&) = delete;$/;"	p	struct:Watchdog	file:	access:public	signature:(const Watchdog&)
Watchdog::serial_number	.\experimental\test\SingletonTest.cpp	/^  const size_t serial_number;$/;"	m	struct:Watchdog	file:	access:public
Watchdog::~Watchdog	.\experimental\test\SingletonTest.cpp	/^  ~Watchdog() {$/;"	f	struct:Watchdog	access:public	signature:()
WhenAllContext	.\wangle\detail\State.h	/^  explicit WhenAllContext() : count(0), total(0) {}$/;"	f	struct:folly::wangle::detail::WhenAllContext	access:public	signature:()
WhenAllContext	.\wangle\detail\State.h	/^struct WhenAllContext {$/;"	s	namespace:folly::wangle::detail
WhenAllLaterContext	.\wangle\detail\State.h	/^  explicit WhenAllLaterContext() : count(0), total(0) {}$/;"	f	struct:folly::wangle::detail::WhenAllLaterContext	access:public	signature:()
WhenAllLaterContext	.\wangle\detail\State.h	/^struct WhenAllLaterContext {$/;"	s	namespace:folly::wangle::detail
WhenAnyContext	.\wangle\detail\State.h	/^  explicit WhenAnyContext(size_t n) : done(false), ref_count(n) {};$/;"	f	struct:folly::wangle::detail::WhenAnyContext	access:public	signature:(size_t n)
WhenAnyContext	.\wangle\detail\State.h	/^struct WhenAnyContext {$/;"	s	namespace:folly::wangle::detail
Widget	.\test\ThreadLocalTest.cpp	/^struct Widget {$/;"	s	file:
Widget::customDeleter	.\test\ThreadLocalTest.cpp	/^  static void customDeleter(Widget* w, TLPDestructionMode mode) {$/;"	f	struct:Widget	access:public	signature:(Widget* w, TLPDestructionMode mode)
Widget::totalVal_	.\test\ThreadLocalTest.cpp	/^  static int totalVal_;$/;"	m	struct:Widget	file:	access:public
Widget::totalVal_	.\test\ThreadLocalTest.cpp	/^int Widget::totalVal_ = 0;$/;"	m	class:Widget	file:
Widget::val_	.\test\ThreadLocalTest.cpp	/^  int val_;$/;"	m	struct:Widget	file:	access:public
Widget::~Widget	.\test\ThreadLocalTest.cpp	/^  ~Widget() {$/;"	f	struct:Widget	access:public	signature:()
WrapBufferOp	.\io\IOBuf.h	/^  enum WrapBufferOp { WRAP_BUFFER };$/;"	g	class:folly::IOBuf	access:public
WrapperBase	.\gen\Base-inl.h	/^  class WrapperBase {$/;"	c	class:folly::gen::VirtualGen	access:private
WrapperImpl	.\gen\Base-inl.h	/^    explicit WrapperImpl(Wrapped wrapped)$/;"	f	class:folly::gen::VirtualGen::WrapperImpl	access:public	signature:(Wrapped wrapped)
WrapperImpl	.\gen\Base-inl.h	/^  class WrapperImpl : public WrapperBase {$/;"	c	class:folly::gen::VirtualGen	inherits:WrapperBase	access:private
Writable	.\io\Cursor.h	/^class Writable {$/;"	c	namespace:folly::io::detail
WriteHolder	.\RWSpinLock.h	/^    WriteHolder(WriteHolder&& other) : lock_(other.lock_) {$/;"	f	class:folly::RWSpinLock::WriteHolder	access:public	signature:(WriteHolder&& other)
WriteHolder	.\RWSpinLock.h	/^    explicit WriteHolder(RWSpinLock &lock) : lock_ (&lock) {$/;"	f	class:folly::RWTicketSpinLockT::WriteHolder	access:public	signature:(RWSpinLock &lock)
WriteHolder	.\RWSpinLock.h	/^    explicit WriteHolder(RWSpinLock *lock = nullptr) : lock_(lock) {$/;"	f	class:folly::RWTicketSpinLockT::WriteHolder	access:public	signature:(RWSpinLock *lock = nullptr)
WriteHolder	.\RWSpinLock.h	/^    explicit WriteHolder(RWSpinLock& lock) : lock_(&lock) {$/;"	f	class:folly::RWSpinLock::WriteHolder	access:public	signature:(RWSpinLock& lock)
WriteHolder	.\RWSpinLock.h	/^    explicit WriteHolder(RWSpinLock* lock = nullptr) : lock_(lock) {$/;"	f	class:folly::RWSpinLock::WriteHolder	access:public	signature:(RWSpinLock* lock = nullptr)
WriteHolder	.\RWSpinLock.h	/^    explicit WriteHolder(UpgradedHolder&& upgraded) {$/;"	f	class:folly::RWSpinLock::WriteHolder	access:public	signature:(UpgradedHolder&& upgraded)
WriteHolder	.\RWSpinLock.h	/^    friend class WriteHolder;$/;"	x
WriteHolder	.\RWSpinLock.h	/^  class WriteHolder : boost::noncopyable {$/;"	c	class:folly::RWTicketSpinLockT	inherits:boost::noncopyable	access:public
WriteHolder	.\RWSpinLock.h	/^  class WriteHolder {$/;"	c	class:folly::RWSpinLock	access:public
WriteHolder	.\RWSpinLock.h	/^  class WriteHolder;$/;"	x
X	.\CpuId.h	118;"	d
X	.\CpuId.h	49;"	d
X	.\experimental\io\AsyncIO.cpp	305;"	d	file:
X	.\experimental\io\AsyncIO.cpp	332;"	d	file:
YELLOW	.\experimental\symbolizer\Symbolizer.h	/^  enum Color { DEFAULT, RED, GREEN, YELLOW, BLUE, CYAN, WHITE, PURPLE };$/;"	e	enum:folly::symbolizer::SymbolizePrinter::Color
Yield	.\gen\Base-inl.h	/^  explicit Yield(Source source)$/;"	f	class:folly::gen::detail::Yield	access:public	signature:(Source source)
Yield	.\gen\Base-inl.h	/^class Yield : public GenImpl<Value, Yield<Value, Source>> {$/;"	c	namespace:folly::gen::detail	inherits:GenImpl
Yield	.\gen\Base.h	/^class Yield;$/;"	x
ZERO	.\MacAddress.cpp	/^const MacAddress MacAddress::ZERO;$/;"	m	class:folly::MacAddress	file:
ZERO	.\MacAddress.h	/^  static const MacAddress ZERO;$/;"	m	class:folly::MacAddress	access:public
ZLIB	.\io\Compression.h	/^  ZLIB = 4,$/;"	m	class:folly::io::CodecType	access:private
Zip	.\gen\Combine-inl.h	/^  explicit Zip(Container container)$/;"	f	class:folly::gen::detail::Zip	access:public	signature:(Container container)
Zip	.\gen\Combine-inl.h	/^class Zip : public Operator<Zip<Container>> {$/;"	c	namespace:folly::gen::detail	inherits:Operator
Zip	.\gen\Combine.h	/^class Zip;$/;"	x
ZlibCodec	.\io\Compression.cpp	/^  explicit ZlibCodec(int level, CodecType type);$/;"	p	class:folly::io::__anon64::FOLLY_FINAL	file:	access:public	signature:(int level, CodecType type)
ZlibCodec	.\io\Compression.cpp	/^ZlibCodec::ZlibCodec(int level, CodecType type) : Codec(type) {$/;"	f	class:folly::io::__anon64::ZlibCodec	signature:(int level, CodecType type)
_GLIBCXX_VISIBILITY	.\FBString.h	/^namespace std _GLIBCXX_VISIBILITY(default) {$/;"	f	signature:(default)
_GNU_SOURCE	.\Subprocess.cpp	18;"	d	file:
_GNU_SOURCE	.\detail\CacheLocality.cpp	19;"	d	file:
_TP1	.\test\stl_tests\StlVectorTest.cpp	/^typedef VECTOR_<EP1, Alloc<EP1>> _TP1;$/;"	t	file:
_TP2	.\test\stl_tests\StlVectorTest.cpp	/^typedef VECTOR_<EP2, Alloc<EP2>> _TP2;$/;"	t	file:
_TP3	.\test\stl_tests\StlVectorTest.cpp	/^typedef VECTOR_<EP3, Alloc<EP3>> _TP3;$/;"	t	file:
_TSpecialMA	.\test\stl_tests\StlVectorTest.cpp	/^typedef VECTOR_<DDSMA, Alloc<DDSMA>> _TSpecialMA;$/;"	t	file:
_TV1	.\test\stl_tests\StlVectorTest.cpp	/^typedef VECTOR_<ED1, std::allocator<ED1>> _TV1;$/;"	t	file:
_TV2	.\test\stl_tests\StlVectorTest.cpp	/^typedef VECTOR_<ED2, std::allocator<ED2>> _TV2;$/;"	t	file:
_TV3	.\test\stl_tests\StlVectorTest.cpp	/^typedef VECTOR_<ED3, std::allocator<ED3>> _TV3;$/;"	t	file:
_TV4	.\test\stl_tests\StlVectorTest.cpp	/^typedef VECTOR_<ED4, std::allocator<ED4>> _TV4;$/;"	t	file:
_TV5	.\test\stl_tests\StlVectorTest.cpp	/^typedef VECTOR_<ED5, Alloc<ED5>> _TV5;$/;"	t	file:
_TV5v1	.\test\stl_tests\StlVectorTest.cpp	/^typedef VECTOR_<ED5, std::allocator<ED5>> _TV5v1;$/;"	t	file:
_TVI	.\test\stl_tests\StlVectorTest.cpp	/^typedef VECTOR_<int, Alloc<int>> _TVI;$/;"	t	file:
_TVIS	.\test\stl_tests\StlVectorTest.cpp	/^typedef VECTOR_<int, std::allocator<int>> _TVIS;$/;"	t	file:
_USE_ATTRIBUTES_FOR_SAL	.\Portability.h	65;"	d
_USE_ATTRIBUTES_FOR_SAL	.\Portability.h	67;"	d
__GNUC_PREREQ	.\Portability.h	129;"	d
__GNUC_PREREQ	.\Portability.h	132;"	d
__NR_eventfd2	.\io\async\EventFDWrapper.h	52;"	d
__NR_eventfd2	.\io\async\EventFDWrapper.h	54;"	d
__PRETTY_FUNCTION__	.\Portability.h	238;"	d
__STDC_FORMAT_MACROS	.\SocketAddress.cpp	18;"	d	file:
__STDC_FORMAT_MACROS	.\build\GenerateFingerprintTables.cpp	18;"	d	file:
__STDC_FORMAT_MACROS	.\io\async\EventBase.cpp	18;"	d	file:
__STDC_FORMAT_MACROS	.\test\SpookyHashV1Test.cpp	20;"	d	file:
__STDC_FORMAT_MACROS	.\test\SpookyHashV2Test.cpp	20;"	d	file:
__STDC_LIMIT_MACROS	.\io\IOBuf.cpp	17;"	d	file:
__anon102::Guard	.\test\AHMIntStressTest.cpp	/^typedef std::lock_guard<std::mutex> Guard;$/;"	t	namespace:__anon102	file:
__anon102::MyMap	.\test\AHMIntStressTest.cpp	/^typedef folly::AtomicHashMap<int,std::shared_ptr<MyObject>> MyMap;$/;"	t	namespace:__anon102	file:
__anon102::MyObject	.\test\AHMIntStressTest.cpp	/^struct MyObject {$/;"	s	namespace:__anon102	file:
__anon102::MyObject::MyObject	.\test\AHMIntStressTest.cpp	/^  explicit MyObject(int i) : i(i) {}$/;"	f	struct:__anon102::MyObject	access:public	signature:(int i)
__anon102::MyObject::i	.\test\AHMIntStressTest.cpp	/^  int i;$/;"	m	struct:__anon102::MyObject	file:	access:public
__anon102::MyObjectDirectory	.\test\AHMIntStressTest.cpp	/^struct MyObjectDirectory {$/;"	s	namespace:__anon102	file:
__anon102::MyObjectDirectory::MyObjectDirectory	.\test\AHMIntStressTest.cpp	/^  MyObjectDirectory()$/;"	f	struct:__anon102::MyObjectDirectory	access:public	signature:()
__anon102::MyObjectDirectory::archive	.\test\AHMIntStressTest.cpp	/^  void archive() {$/;"	f	struct:__anon102::MyObjectDirectory	access:public	signature:()
__anon102::MyObjectDirectory::cur_	.\test\AHMIntStressTest.cpp	/^  std::shared_ptr<MyMap> cur_;$/;"	m	struct:__anon102::MyObjectDirectory	file:	access:public
__anon102::MyObjectDirectory::get	.\test\AHMIntStressTest.cpp	/^  std::shared_ptr<MyObject> get(int key) {$/;"	f	struct:__anon102::MyObjectDirectory	access:public	signature:(int key)
__anon102::MyObjectDirectory::lock_	.\test\AHMIntStressTest.cpp	/^  std::mutex lock_;$/;"	m	struct:__anon102::MyObjectDirectory	file:	access:public
__anon102::MyObjectDirectory::prev_	.\test\AHMIntStressTest.cpp	/^  std::shared_ptr<MyMap> prev_;$/;"	m	struct:__anon102::MyObjectDirectory	file:	access:public
__anon102::MyObjectDirectory::tryGet	.\test\AHMIntStressTest.cpp	/^  std::shared_ptr<MyObject> tryGet(int key) {$/;"	f	struct:__anon102::MyObjectDirectory	access:public	signature:(int key)
__anon102::newMap	.\test\AHMIntStressTest.cpp	/^std::unique_ptr<MyMap> newMap() { return folly::make_unique<MyMap>(100); }$/;"	f	namespace:__anon102	signature:()
__anon104::CopyCount	.\test\ApplyTupleTest.cpp	/^struct CopyCount {$/;"	s	namespace:__anon104	file:
__anon104::CopyCount::CopyCount	.\test\ApplyTupleTest.cpp	/^  CopyCount() {}$/;"	f	struct:__anon104::CopyCount	access:public	signature:()
__anon104::CopyCount::CopyCount	.\test\ApplyTupleTest.cpp	/^  CopyCount(CopyCount const&) {$/;"	f	struct:__anon104::CopyCount	access:public	signature:(CopyCount const&)
__anon104::Func	.\test\ApplyTupleTest.cpp	/^struct Func {$/;"	s	namespace:__anon104	file:
__anon104::Func::operator ()	.\test\ApplyTupleTest.cpp	/^  int operator()() const {$/;"	f	struct:__anon104::Func	access:public	signature:() const
__anon104::Guard	.\test\ApplyTupleTest.cpp	/^typedef GuardObjBase const& Guard;$/;"	t	namespace:__anon104	file:
__anon104::GuardObj	.\test\ApplyTupleTest.cpp	/^struct GuardObj : GuardObjBase {$/;"	s	namespace:__anon104	file:	inherits:GuardObjBase
__anon104::GuardObj::GuardObj	.\test\ApplyTupleTest.cpp	/^  GuardObj(GuardObj&& g)$/;"	f	struct:__anon104::GuardObj	access:public	signature:(GuardObj&& g)
__anon104::GuardObj::GuardObj	.\test\ApplyTupleTest.cpp	/^  GuardObj(const GuardObj&) = delete;$/;"	p	struct:__anon104::GuardObj	file:	access:public	signature:(const GuardObj&)
__anon104::GuardObj::GuardObj	.\test\ApplyTupleTest.cpp	/^  explicit GuardObj(F&& f, Tuple&& args)$/;"	f	struct:__anon104::GuardObj	access:public	signature:(F&& f, Tuple&& args)
__anon104::GuardObj::args_	.\test\ApplyTupleTest.cpp	/^  Tuple args_;$/;"	m	struct:__anon104::GuardObj	file:	access:private
__anon104::GuardObj::f_	.\test\ApplyTupleTest.cpp	/^  F f_;$/;"	m	struct:__anon104::GuardObj	file:	access:private
__anon104::GuardObj::operator =	.\test\ApplyTupleTest.cpp	/^  GuardObj& operator=(const GuardObj&) = delete;$/;"	p	struct:__anon104::GuardObj	file:	access:public	signature:(const GuardObj&)
__anon104::GuardObj::~GuardObj	.\test\ApplyTupleTest.cpp	/^  ~GuardObj() {$/;"	f	struct:__anon104::GuardObj	access:public	signature:()
__anon104::GuardObjBase	.\test\ApplyTupleTest.cpp	/^struct GuardObjBase {$/;"	s	namespace:__anon104	file:
__anon104::GuardObjBase::GuardObjBase	.\test\ApplyTupleTest.cpp	/^  GuardObjBase() {}$/;"	f	struct:__anon104::GuardObjBase	access:public	signature:()
__anon104::GuardObjBase::GuardObjBase	.\test\ApplyTupleTest.cpp	/^  GuardObjBase(GuardObjBase const&) = delete;$/;"	p	struct:__anon104::GuardObjBase	file:	access:public	signature:(GuardObjBase const&)
__anon104::GuardObjBase::GuardObjBase	.\test\ApplyTupleTest.cpp	/^  GuardObjBase(GuardObjBase&&) {}$/;"	f	struct:__anon104::GuardObjBase	access:public	signature:(GuardObjBase&&)
__anon104::GuardObjBase::operator =	.\test\ApplyTupleTest.cpp	/^  GuardObjBase& operator=(GuardObjBase const&) = delete;$/;"	p	struct:__anon104::GuardObjBase	file:	access:public	signature:(GuardObjBase const&)
__anon104::Mover	.\test\ApplyTupleTest.cpp	/^struct Mover {$/;"	s	namespace:__anon104	file:
__anon104::Mover::Mover	.\test\ApplyTupleTest.cpp	/^  Mover() {}$/;"	f	struct:__anon104::Mover	access:public	signature:()
__anon104::Mover::Mover	.\test\ApplyTupleTest.cpp	/^  Mover(Mover&&) {}$/;"	f	struct:__anon104::Mover	access:public	signature:(Mover&&)
__anon104::Mover::Mover	.\test\ApplyTupleTest.cpp	/^  Mover(const Mover&) = delete;$/;"	p	struct:__anon104::Mover	file:	access:public	signature:(const Mover&)
__anon104::Mover::operator =	.\test\ApplyTupleTest.cpp	/^  Mover& operator=(const Mover&) = delete;$/;"	p	struct:__anon104::Mover	file:	access:public	signature:(const Mover&)
__anon104::Overloaded	.\test\ApplyTupleTest.cpp	/^struct Overloaded {$/;"	s	namespace:__anon104	file:
__anon104::Overloaded::func	.\test\ApplyTupleTest.cpp	/^  bool func(bool) { return true; }$/;"	f	struct:__anon104::Overloaded	access:public	signature:(bool)
__anon104::Overloaded::func	.\test\ApplyTupleTest.cpp	/^  int func(int) { return 0; }$/;"	f	struct:__anon104::Overloaded	access:public	signature:(int)
__anon104::Wat	.\test\ApplyTupleTest.cpp	/^struct Wat {$/;"	s	namespace:__anon104	file:
__anon104::Wat::Wat	.\test\ApplyTupleTest.cpp	/^  Wat() {}$/;"	f	struct:__anon104::Wat	access:public	signature:()
__anon104::Wat::Wat	.\test\ApplyTupleTest.cpp	/^  Wat(Wat const&) = delete;$/;"	p	struct:__anon104::Wat	file:	access:public	signature:(Wat const&)
__anon104::Wat::foo	.\test\ApplyTupleTest.cpp	/^  int foo;$/;"	m	struct:__anon104::Wat	file:	access:public
__anon104::Wat::func	.\test\ApplyTupleTest.cpp	/^  void func(int a, int b, double c) {$/;"	f	struct:__anon104::Wat	access:public	signature:(int a, int b, double c)
__anon104::Wat::retVal	.\test\ApplyTupleTest.cpp	/^  double retVal(int a, double b) {$/;"	f	struct:__anon104::Wat	access:public	signature:(int a, double b)
__anon104::anotherFunc	.\test\ApplyTupleTest.cpp	/^void anotherFunc(CopyCount const&) {}$/;"	f	namespace:__anon104	signature:(CopyCount const&)
__anon104::func	.\test\ApplyTupleTest.cpp	/^void func(int a, int b, double c) {$/;"	f	namespace:__anon104	signature:(int a, int b, double c)
__anon104::guard	.\test\ApplyTupleTest.cpp	/^guard(F&& f, Args&&... args) {$/;"	f	namespace:__anon104	signature:(F&& f, Args&&... args)
__anon104::makeFunc	.\test\ApplyTupleTest.cpp	/^std::function<void (int, int, double)> makeFunc() {$/;"	f	namespace:__anon104	signature:()
__anon104::move_only_func	.\test\ApplyTupleTest.cpp	/^void move_only_func(Mover&&) {}$/;"	f	namespace:__anon104	signature:(Mover&&)
__anon105::insertThread	.\test\AtomicHashMapTest.cpp	/^void* insertThread(void* jj) {$/;"	f	namespace:__anon105	signature:(void* jj)
__anon105::insertThreadArr	.\test\AtomicHashMapTest.cpp	/^void* insertThreadArr(void* jj) {$/;"	f	namespace:__anon105	signature:(void* jj)
__anon105::numOpsPerThread	.\test\AtomicHashMapTest.cpp	/^int numOpsPerThread = 0;$/;"	m	namespace:__anon105	file:
__anon105::randomizeKey	.\test\AtomicHashMapTest.cpp	/^inline KeyT randomizeKey(int key) {$/;"	f	namespace:__anon105	signature:(int key)
__anon105::runThreads	.\test\AtomicHashMapTest.cpp	/^void runThreads(void *(*thread)(void*)) {$/;"	f	namespace:__anon105	signature:(void *(*thread)(void*))
__anon105::runThreads	.\test\AtomicHashMapTest.cpp	/^void runThreads(void *(*thread)(void*), int numThreads, void **statuses) {$/;"	f	namespace:__anon105	signature:(void *(*thread)(void*), int numThreads, void **statuses)
__anon105::runThreadsCreatedAllThreads	.\test\AtomicHashMapTest.cpp	/^std::atomic<bool> runThreadsCreatedAllThreads;$/;"	m	namespace:__anon105	file:
__anon106::kInsertPerThread	.\test\AtomicHashMapTest.cpp	/^const int kInsertPerThread = 100000;$/;"	m	namespace:__anon106	file:
__anon106::raceFinalSizeEstimate	.\test\AtomicHashMapTest.cpp	/^int raceFinalSizeEstimate;$/;"	m	namespace:__anon106	file:
__anon106::raceInsertRandomThread	.\test\AtomicHashMapTest.cpp	/^void* raceInsertRandomThread(void* jj) {$/;"	f	namespace:__anon106	signature:(void* jj)
__anon106::raceIterateThread	.\test\AtomicHashMapTest.cpp	/^void* raceIterateThread(void* jj) {$/;"	f	namespace:__anon106	signature:(void* jj)
__anon107::insertedLevel	.\test\AtomicHashMapTest.cpp	/^std::atomic<int32_t> insertedLevel;$/;"	m	namespace:__anon107	file:
__anon107::kTestEraseInsertions	.\test\AtomicHashMapTest.cpp	/^const int kTestEraseInsertions = 200000;$/;"	m	namespace:__anon107	file:
__anon107::testEraseEraseThread	.\test\AtomicHashMapTest.cpp	/^void* testEraseEraseThread(void*) {$/;"	f	namespace:__anon107	signature:(void*)
__anon107::testEraseInsertThread	.\test\AtomicHashMapTest.cpp	/^void* testEraseInsertThread(void*) {$/;"	f	namespace:__anon107	signature:(void*)
__anon108::loadGlobalAha	.\test\AtomicHashMapTest.cpp	/^void loadGlobalAha() {$/;"	f	namespace:__anon108	signature:()
__anon108::loadGlobalAhm	.\test\AtomicHashMapTest.cpp	/^void loadGlobalAhm() {$/;"	f	namespace:__anon108	signature:()
__anon109::checkIt	.\test\BitIteratorTest.cpp	/^void checkIt(INT exp, IT& it) {$/;"	f	namespace:__anon109	signature:(INT exp, IT& it)
__anon109::checkRange	.\test\BitIteratorTest.cpp	/^void checkRange(INT exp, IT begin, IT end) {$/;"	f	namespace:__anon109	signature:(INT exp, IT begin, IT end)
__anon110::runFFSTest	.\test\BitIteratorTest.cpp	/^void runFFSTest(FFS fn) {$/;"	f	namespace:__anon110	signature:(FFS fn)
__anon110::runRealFFSTest	.\test\BitIteratorTest.cpp	/^void runRealFFSTest(int iters) {$/;"	f	namespace:__anon110	signature:(int iters)
__anon110::runSimpleFFSTest	.\test\BitIteratorTest.cpp	/^void runSimpleFFSTest(int iters) {$/;"	f	namespace:__anon110	signature:(int iters)
__anon110::simpleFFS	.\test\BitIteratorTest.cpp	/^BitIterator<BaseIter> simpleFFS(BitIterator<BaseIter> begin,$/;"	f	namespace:__anon110	signature:(BitIterator<BaseIter> begin, BitIterator<BaseIter> end)
__anon111::testFFS	.\test\BitsTest.cpp	/^void testFFS() {$/;"	f	namespace:__anon111	signature:()
__anon111::testFLS	.\test\BitsTest.cpp	/^void testFLS() {$/;"	f	namespace:__anon111	signature:()
__anon112::BUFFER_SIZE	.\test\ChecksumTest.cpp	/^const unsigned int BUFFER_SIZE = 512 * 1024 * sizeof(uint64_t);$/;"	m	namespace:__anon112	file:
__anon112::ExpectedResult	.\test\ChecksumTest.cpp	/^struct ExpectedResult {$/;"	s	namespace:__anon112	file:
__anon112::ExpectedResult::crc32c	.\test\ChecksumTest.cpp	/^  uint32_t crc32c;$/;"	m	struct:__anon112::ExpectedResult	file:	access:public
__anon112::ExpectedResult::length	.\test\ChecksumTest.cpp	/^  size_t length;$/;"	m	struct:__anon112::ExpectedResult	file:	access:public
__anon112::ExpectedResult::offset	.\test\ChecksumTest.cpp	/^  size_t offset;$/;"	m	struct:__anon112::ExpectedResult	file:	access:public
__anon112::buffer	.\test\ChecksumTest.cpp	/^uint8_t buffer[BUFFER_SIZE];$/;"	m	namespace:__anon112	file:
__anon112::expectedResults	.\test\ChecksumTest.cpp	/^ExpectedResult expectedResults[] = {$/;"	m	namespace:__anon112	file:
__anon112::testCRC32C	.\test\ChecksumTest.cpp	/^void testCRC32C($/;"	f	namespace:__anon112	signature:( std::function<uint32_t(const uint8_t*, size_t, uint32_t)> impl)
__anon112::testCRC32CContinuation	.\test\ChecksumTest.cpp	/^void testCRC32CContinuation($/;"	f	namespace:__anon112	signature:( std::function<uint32_t(const uint8_t*, size_t, uint32_t)> impl)
__anon113::BENCHMARK	.\test\ConcurrentSkipListBenchmark.cpp	/^BENCHMARK(Accessor, iters) {$/;"	f	namespace:__anon113	signature:(Accessor, iters)
__anon113::BENCHMARK	.\test\ConcurrentSkipListBenchmark.cpp	/^BENCHMARK(accessorBasicRefcounting, iters) {$/;"	f	namespace:__anon113	signature:(accessorBasicRefcounting, iters)
__anon113::BENCHMARK_DRAW_LINE	.\test\ConcurrentSkipListBenchmark.cpp	/^BENCHMARK_DRAW_LINE();$/;"	p	namespace:__anon113	file:	signature:()
__anon113::BENCHMARK_PARAM	.\test\ConcurrentSkipListBenchmark.cpp	/^BENCHMARK_PARAM(BM_AddSet,      1000);$/;"	p	namespace:__anon113	file:	signature:(BM_AddSet, 1000)
__anon113::BENCHMARK_PARAM	.\test\ConcurrentSkipListBenchmark.cpp	/^BENCHMARK_PARAM(BM_AddSet,      1000000);$/;"	p	namespace:__anon113	file:	signature:(BM_AddSet, 1000000)
__anon113::BENCHMARK_PARAM	.\test\ConcurrentSkipListBenchmark.cpp	/^BENCHMARK_PARAM(BM_AddSet,      65536);$/;"	p	namespace:__anon113	file:	signature:(BM_AddSet, 65536)
__anon113::BENCHMARK_PARAM	.\test\ConcurrentSkipListBenchmark.cpp	/^BENCHMARK_PARAM(BM_AddSkipList, 1000);$/;"	p	namespace:__anon113	file:	signature:(BM_AddSkipList, 1000)
__anon113::BENCHMARK_PARAM	.\test\ConcurrentSkipListBenchmark.cpp	/^BENCHMARK_PARAM(BM_AddSkipList, 1000000);$/;"	p	namespace:__anon113	file:	signature:(BM_AddSkipList, 1000000)
__anon113::BENCHMARK_PARAM	.\test\ConcurrentSkipListBenchmark.cpp	/^BENCHMARK_PARAM(BM_AddSkipList, 65536);$/;"	p	namespace:__anon113	file:	signature:(BM_AddSkipList, 65536)
__anon113::BENCHMARK_PARAM	.\test\ConcurrentSkipListBenchmark.cpp	/^BENCHMARK_PARAM(BM_CSLContainsFound, 1000);$/;"	p	namespace:__anon113	file:	signature:(BM_CSLContainsFound, 1000)
__anon113::BENCHMARK_PARAM	.\test\ConcurrentSkipListBenchmark.cpp	/^BENCHMARK_PARAM(BM_CSLContainsFound, 100000);$/;"	p	namespace:__anon113	file:	signature:(BM_CSLContainsFound, 100000)
__anon113::BENCHMARK_PARAM	.\test\ConcurrentSkipListBenchmark.cpp	/^BENCHMARK_PARAM(BM_CSLContainsFound, 1000000);$/;"	p	namespace:__anon113	file:	signature:(BM_CSLContainsFound, 1000000)
__anon113::BENCHMARK_PARAM	.\test\ConcurrentSkipListBenchmark.cpp	/^BENCHMARK_PARAM(BM_CSLContainsFound, 10000000);$/;"	p	namespace:__anon113	file:	signature:(BM_CSLContainsFound, 10000000)
__anon113::BENCHMARK_PARAM	.\test\ConcurrentSkipListBenchmark.cpp	/^BENCHMARK_PARAM(BM_CSLContainsNotFound, 1000);$/;"	p	namespace:__anon113	file:	signature:(BM_CSLContainsNotFound, 1000)
__anon113::BENCHMARK_PARAM	.\test\ConcurrentSkipListBenchmark.cpp	/^BENCHMARK_PARAM(BM_CSLContainsNotFound, 100000);$/;"	p	namespace:__anon113	file:	signature:(BM_CSLContainsNotFound, 100000)
__anon113::BENCHMARK_PARAM	.\test\ConcurrentSkipListBenchmark.cpp	/^BENCHMARK_PARAM(BM_CSLContainsNotFound, 1000000);$/;"	p	namespace:__anon113	file:	signature:(BM_CSLContainsNotFound, 1000000)
__anon113::BENCHMARK_PARAM	.\test\ConcurrentSkipListBenchmark.cpp	/^BENCHMARK_PARAM(BM_CSLMergeIntersection, 1000);$/;"	p	namespace:__anon113	file:	signature:(BM_CSLMergeIntersection, 1000)
__anon113::BENCHMARK_PARAM	.\test\ConcurrentSkipListBenchmark.cpp	/^BENCHMARK_PARAM(BM_CSLMergeIntersection, 1000000);$/;"	p	namespace:__anon113	file:	signature:(BM_CSLMergeIntersection, 1000000)
__anon113::BENCHMARK_PARAM	.\test\ConcurrentSkipListBenchmark.cpp	/^BENCHMARK_PARAM(BM_CSLMergeIntersection, 65536);$/;"	p	namespace:__anon113	file:	signature:(BM_CSLMergeIntersection, 65536)
__anon113::BENCHMARK_PARAM	.\test\ConcurrentSkipListBenchmark.cpp	/^BENCHMARK_PARAM(BM_CSLMergeLookup,       1000);$/;"	p	namespace:__anon113	file:	signature:(BM_CSLMergeLookup, 1000)
__anon113::BENCHMARK_PARAM	.\test\ConcurrentSkipListBenchmark.cpp	/^BENCHMARK_PARAM(BM_CSLMergeLookup,       1000000);$/;"	p	namespace:__anon113	file:	signature:(BM_CSLMergeLookup, 1000000)
__anon113::BENCHMARK_PARAM	.\test\ConcurrentSkipListBenchmark.cpp	/^BENCHMARK_PARAM(BM_CSLMergeLookup,       65536);$/;"	p	namespace:__anon113	file:	signature:(BM_CSLMergeLookup, 65536)
__anon113::BENCHMARK_PARAM	.\test\ConcurrentSkipListBenchmark.cpp	/^BENCHMARK_PARAM(BM_ContentionCSL,    1024);$/;"	p	namespace:__anon113	file:	signature:(BM_ContentionCSL, 1024)
__anon113::BENCHMARK_PARAM	.\test\ConcurrentSkipListBenchmark.cpp	/^BENCHMARK_PARAM(BM_ContentionCSL,    1048576);$/;"	p	namespace:__anon113	file:	signature:(BM_ContentionCSL, 1048576)
__anon113::BENCHMARK_PARAM	.\test\ConcurrentSkipListBenchmark.cpp	/^BENCHMARK_PARAM(BM_ContentionCSL,    65536);$/;"	p	namespace:__anon113	file:	signature:(BM_ContentionCSL, 65536)
__anon113::BENCHMARK_PARAM	.\test\ConcurrentSkipListBenchmark.cpp	/^BENCHMARK_PARAM(BM_ContentionStdSet, 1024);$/;"	p	namespace:__anon113	file:	signature:(BM_ContentionStdSet, 1024)
__anon113::BENCHMARK_PARAM	.\test\ConcurrentSkipListBenchmark.cpp	/^BENCHMARK_PARAM(BM_ContentionStdSet, 1048576);$/;"	p	namespace:__anon113	file:	signature:(BM_ContentionStdSet, 1048576)
__anon113::BENCHMARK_PARAM	.\test\ConcurrentSkipListBenchmark.cpp	/^BENCHMARK_PARAM(BM_ContentionStdSet, 65536);$/;"	p	namespace:__anon113	file:	signature:(BM_ContentionStdSet, 65536)
__anon113::BENCHMARK_PARAM	.\test\ConcurrentSkipListBenchmark.cpp	/^BENCHMARK_PARAM(BM_IterateOverSet,  1000);$/;"	p	namespace:__anon113	file:	signature:(BM_IterateOverSet, 1000)
__anon113::BENCHMARK_PARAM	.\test\ConcurrentSkipListBenchmark.cpp	/^BENCHMARK_PARAM(BM_IterateOverSet,  1000000);$/;"	p	namespace:__anon113	file:	signature:(BM_IterateOverSet, 1000000)
__anon113::BENCHMARK_PARAM	.\test\ConcurrentSkipListBenchmark.cpp	/^BENCHMARK_PARAM(BM_IterateSkipList, 1000);$/;"	p	namespace:__anon113	file:	signature:(BM_IterateSkipList, 1000)
__anon113::BENCHMARK_PARAM	.\test\ConcurrentSkipListBenchmark.cpp	/^BENCHMARK_PARAM(BM_IterateSkipList, 1000000);$/;"	p	namespace:__anon113	file:	signature:(BM_IterateSkipList, 1000000)
__anon113::BENCHMARK_PARAM	.\test\ConcurrentSkipListBenchmark.cpp	/^BENCHMARK_PARAM(BM_SetContainsFound, 1000);$/;"	p	namespace:__anon113	file:	signature:(BM_SetContainsFound, 1000)
__anon113::BENCHMARK_PARAM	.\test\ConcurrentSkipListBenchmark.cpp	/^BENCHMARK_PARAM(BM_SetContainsFound, 100000);$/;"	p	namespace:__anon113	file:	signature:(BM_SetContainsFound, 100000)
__anon113::BENCHMARK_PARAM	.\test\ConcurrentSkipListBenchmark.cpp	/^BENCHMARK_PARAM(BM_SetContainsFound, 1000000);$/;"	p	namespace:__anon113	file:	signature:(BM_SetContainsFound, 1000000)
__anon113::BENCHMARK_PARAM	.\test\ConcurrentSkipListBenchmark.cpp	/^BENCHMARK_PARAM(BM_SetContainsFound, 10000000);$/;"	p	namespace:__anon113	file:	signature:(BM_SetContainsFound, 10000000)
__anon113::BENCHMARK_PARAM	.\test\ConcurrentSkipListBenchmark.cpp	/^BENCHMARK_PARAM(BM_SetContainsNotFound, 1000);$/;"	p	namespace:__anon113	file:	signature:(BM_SetContainsNotFound, 1000)
__anon113::BENCHMARK_PARAM	.\test\ConcurrentSkipListBenchmark.cpp	/^BENCHMARK_PARAM(BM_SetContainsNotFound, 100000);$/;"	p	namespace:__anon113	file:	signature:(BM_SetContainsNotFound, 100000)
__anon113::BENCHMARK_PARAM	.\test\ConcurrentSkipListBenchmark.cpp	/^BENCHMARK_PARAM(BM_SetContainsNotFound, 1000000);$/;"	p	namespace:__anon113	file:	signature:(BM_SetContainsNotFound, 1000000)
__anon113::BENCHMARK_PARAM	.\test\ConcurrentSkipListBenchmark.cpp	/^BENCHMARK_PARAM(BM_SetMerge,             1000);$/;"	p	namespace:__anon113	file:	signature:(BM_SetMerge, 1000)
__anon113::BENCHMARK_PARAM	.\test\ConcurrentSkipListBenchmark.cpp	/^BENCHMARK_PARAM(BM_SetMerge,             1000000);$/;"	p	namespace:__anon113	file:	signature:(BM_SetMerge, 1000000)
__anon113::BENCHMARK_PARAM	.\test\ConcurrentSkipListBenchmark.cpp	/^BENCHMARK_PARAM(BM_SetMerge,             65536);$/;"	p	namespace:__anon113	file:	signature:(BM_SetMerge, 65536)
__anon113::BM_AddSet	.\test\ConcurrentSkipListBenchmark.cpp	/^void BM_AddSet(int iters, int size) {$/;"	f	namespace:__anon113	signature:(int iters, int size)
__anon113::BM_AddSkipList	.\test\ConcurrentSkipListBenchmark.cpp	/^void BM_AddSkipList(int iters, int size) {$/;"	f	namespace:__anon113	signature:(int iters, int size)
__anon113::BM_CSLContainsFound	.\test\ConcurrentSkipListBenchmark.cpp	/^void BM_CSLContainsFound(int iters, int size) {$/;"	f	namespace:__anon113	signature:(int iters, int size)
__anon113::BM_CSLContainsNotFound	.\test\ConcurrentSkipListBenchmark.cpp	/^void BM_CSLContainsNotFound(int iters, int size) {$/;"	f	namespace:__anon113	signature:(int iters, int size)
__anon113::BM_CSLMergeIntersection	.\test\ConcurrentSkipListBenchmark.cpp	/^void BM_CSLMergeIntersection(int iters, int size) {$/;"	f	namespace:__anon113	signature:(int iters, int size)
__anon113::BM_CSLMergeLookup	.\test\ConcurrentSkipListBenchmark.cpp	/^void BM_CSLMergeLookup(int iters, int size) {$/;"	f	namespace:__anon113	signature:(int iters, int size)
__anon113::BM_ContentionCSL	.\test\ConcurrentSkipListBenchmark.cpp	/^void BM_ContentionCSL(int iters, int size) {$/;"	f	namespace:__anon113	signature:(int iters, int size)
__anon113::BM_ContentionStdSet	.\test\ConcurrentSkipListBenchmark.cpp	/^void BM_ContentionStdSet(int iters, int size) {$/;"	f	namespace:__anon113	signature:(int iters, int size)
__anon113::BM_IterateOverSet	.\test\ConcurrentSkipListBenchmark.cpp	/^void BM_IterateOverSet(int iters, int size) {$/;"	f	namespace:__anon113	signature:(int iters, int size)
__anon113::BM_IterateSkipList	.\test\ConcurrentSkipListBenchmark.cpp	/^void BM_IterateSkipList(int iters, int size) {$/;"	f	namespace:__anon113	signature:(int iters, int size)
__anon113::BM_SetContainsFound	.\test\ConcurrentSkipListBenchmark.cpp	/^void BM_SetContainsFound(int iters, int size) {$/;"	f	namespace:__anon113	signature:(int iters, int size)
__anon113::BM_SetContainsNotFound	.\test\ConcurrentSkipListBenchmark.cpp	/^void BM_SetContainsNotFound(int iters, int size) {$/;"	f	namespace:__anon113	signature:(int iters, int size)
__anon113::BM_SetMerge	.\test\ConcurrentSkipListBenchmark.cpp	/^void BM_SetMerge(int iters, int size) {$/;"	f	namespace:__anon113	signature:(int iters, int size)
__anon113::ConcurrentAccessData	.\test\ConcurrentSkipListBenchmark.cpp	/^class ConcurrentAccessData {$/;"	c	namespace:__anon113	file:
__anon113::ConcurrentAccessData::ConcurrentAccessData	.\test\ConcurrentSkipListBenchmark.cpp	/^  explicit ConcurrentAccessData(int size) :$/;"	f	class:__anon113::ConcurrentAccessData	access:public	signature:(int size)
__anon113::ConcurrentAccessData::accessSet	.\test\ConcurrentSkipListBenchmark.cpp	/^  bool accessSet(int64_t id, int t) {$/;"	f	class:__anon113::ConcurrentAccessData	access:public	signature:(int64_t id, int t)
__anon113::ConcurrentAccessData::accessSkipList	.\test\ConcurrentSkipListBenchmark.cpp	/^  bool accessSkipList(int64_t id, int t) {$/;"	f	class:__anon113::ConcurrentAccessData	access:public	signature:(int64_t id, int t)
__anon113::ConcurrentAccessData::deleteValues_	.\test\ConcurrentSkipListBenchmark.cpp	/^  std::vector<ValueType> deleteValues_;$/;"	m	class:__anon113::ConcurrentAccessData	file:	access:private
__anon113::ConcurrentAccessData::locks_	.\test\ConcurrentSkipListBenchmark.cpp	/^  std::vector<RWSpinLock*> locks_;$/;"	m	class:__anon113::ConcurrentAccessData	file:	access:private
__anon113::ConcurrentAccessData::readValues_	.\test\ConcurrentSkipListBenchmark.cpp	/^  std::vector<ValueType> readValues_;$/;"	m	class:__anon113::ConcurrentAccessData	file:	access:private
__anon113::ConcurrentAccessData::runSet	.\test\ConcurrentSkipListBenchmark.cpp	/^  void runSet(int id, int iters) {$/;"	f	class:__anon113::ConcurrentAccessData	access:public	signature:(int id, int iters)
__anon113::ConcurrentAccessData::runSkipList	.\test\ConcurrentSkipListBenchmark.cpp	/^  void runSkipList(int id, int iters) {$/;"	f	class:__anon113::ConcurrentAccessData	access:public	signature:(int id, int iters)
__anon113::ConcurrentAccessData::setErase	.\test\ConcurrentSkipListBenchmark.cpp	/^  inline void setErase(int idx, ValueType val) {$/;"	f	class:__anon113::ConcurrentAccessData	access:public	signature:(int idx, ValueType val)
__anon113::ConcurrentAccessData::setFind	.\test\ConcurrentSkipListBenchmark.cpp	/^  inline bool setFind(int idx, ValueType val) {$/;"	f	class:__anon113::ConcurrentAccessData	access:public	signature:(int idx, ValueType val)
__anon113::ConcurrentAccessData::setInsert	.\test\ConcurrentSkipListBenchmark.cpp	/^  inline void setInsert(int idx, ValueType val) {$/;"	f	class:__anon113::ConcurrentAccessData	access:public	signature:(int idx, ValueType val)
__anon113::ConcurrentAccessData::sets_	.\test\ConcurrentSkipListBenchmark.cpp	/^  std::vector<SetType> sets_;$/;"	m	class:__anon113::ConcurrentAccessData	file:	access:private
__anon113::ConcurrentAccessData::skipListErase	.\test\ConcurrentSkipListBenchmark.cpp	/^  inline void skipListErase(int idx, ValueType val) {$/;"	f	class:__anon113::ConcurrentAccessData	access:public	signature:(int idx, ValueType val)
__anon113::ConcurrentAccessData::skipListFind	.\test\ConcurrentSkipListBenchmark.cpp	/^  inline bool skipListFind(int idx, ValueType val) {$/;"	f	class:__anon113::ConcurrentAccessData	access:public	signature:(int idx, ValueType val)
__anon113::ConcurrentAccessData::skipListInsert	.\test\ConcurrentSkipListBenchmark.cpp	/^  inline void skipListInsert(int idx, ValueType val) {$/;"	f	class:__anon113::ConcurrentAccessData	access:public	signature:(int idx, ValueType val)
__anon113::ConcurrentAccessData::skipList_	.\test\ConcurrentSkipListBenchmark.cpp	/^  SkipListType::Accessor skipList_;$/;"	m	class:__anon113::ConcurrentAccessData	file:	access:private
__anon113::ConcurrentAccessData::writeValues_	.\test\ConcurrentSkipListBenchmark.cpp	/^  std::vector<ValueType> writeValues_;$/;"	m	class:__anon113::ConcurrentAccessData	file:	access:private
__anon113::ConcurrentAccessData::~ConcurrentAccessData	.\test\ConcurrentSkipListBenchmark.cpp	/^  ~ConcurrentAccessData() {$/;"	f	class:__anon113::ConcurrentAccessData	access:public	signature:()
__anon113::SetType	.\test\ConcurrentSkipListBenchmark.cpp	/^typedef std::set<ValueType> SetType;$/;"	t	namespace:__anon113	file:
__anon113::SkipListAccessor	.\test\ConcurrentSkipListBenchmark.cpp	/^typedef SkipListType::Accessor SkipListAccessor;$/;"	t	namespace:__anon113	file:
__anon113::SkipListType	.\test\ConcurrentSkipListBenchmark.cpp	/^typedef ConcurrentSkipList<ValueType> SkipListType;$/;"	t	namespace:__anon113	file:
__anon113::ValueType	.\test\ConcurrentSkipListBenchmark.cpp	/^typedef int ValueType;$/;"	t	namespace:__anon113	file:
__anon113::gData	.\test\ConcurrentSkipListBenchmark.cpp	/^static std::vector<ValueType> gData;$/;"	m	namespace:__anon113	file:
__anon113::g_data	.\test\ConcurrentSkipListBenchmark.cpp	/^static std::map<int, std::shared_ptr<ConcurrentAccessData> > g_data;$/;"	m	namespace:__anon113	file:
__anon113::initData	.\test\ConcurrentSkipListBenchmark.cpp	/^static void initData() {$/;"	f	namespace:__anon113	signature:()
__anon113::mayInitTestData	.\test\ConcurrentSkipListBenchmark.cpp	/^static ConcurrentAccessData *mayInitTestData(int size) {$/;"	f	namespace:__anon113	signature:(int size)
__anon114::SetType	.\test\ConcurrentSkipListTest.cpp	/^typedef std::set<ValueType> SetType;$/;"	t	namespace:__anon114	file:
__anon114::SkipListAccessor	.\test\ConcurrentSkipListTest.cpp	/^typedef SkipListType::Accessor SkipListAccessor;$/;"	t	namespace:__anon114	file:
__anon114::SkipListNodeType	.\test\ConcurrentSkipListTest.cpp	/^typedef detail::SkipListNode<ValueType> SkipListNodeType;$/;"	t	namespace:__anon114	file:
__anon114::SkipListType	.\test\ConcurrentSkipListTest.cpp	/^typedef ConcurrentSkipList<ValueType> SkipListType;$/;"	t	namespace:__anon114	file:
__anon114::TEST	.\test\ConcurrentSkipListTest.cpp	/^TEST(ConcurrentSkipList, ConcurrentAccess) {$/;"	f	namespace:__anon114	signature:(ConcurrentSkipList, ConcurrentAccess)
__anon114::TEST	.\test\ConcurrentSkipListTest.cpp	/^TEST(ConcurrentSkipList, ConcurrentAdd) {$/;"	f	namespace:__anon114	signature:(ConcurrentSkipList, ConcurrentAdd)
__anon114::TEST	.\test\ConcurrentSkipListTest.cpp	/^TEST(ConcurrentSkipList, ConcurrentRemove) {$/;"	f	namespace:__anon114	signature:(ConcurrentSkipList, ConcurrentRemove)
__anon114::TEST	.\test\ConcurrentSkipListTest.cpp	/^TEST(ConcurrentSkipList, SequentialAccess) {$/;"	f	namespace:__anon114	signature:(ConcurrentSkipList, SequentialAccess)
__anon114::TEST	.\test\ConcurrentSkipListTest.cpp	/^TEST(ConcurrentSkipList, TestMovableData) {$/;"	f	namespace:__anon114	signature:(ConcurrentSkipList, TestMovableData)
__anon114::TEST	.\test\ConcurrentSkipListTest.cpp	/^TEST(ConcurrentSkipList, TestStringType) {$/;"	f	namespace:__anon114	signature:(ConcurrentSkipList, TestStringType)
__anon114::UniquePtrComp	.\test\ConcurrentSkipListTest.cpp	/^struct UniquePtrComp {$/;"	s	namespace:__anon114	file:
__anon114::UniquePtrComp::operator ()	.\test\ConcurrentSkipListTest.cpp	/^  bool operator ()($/;"	f	struct:__anon114::UniquePtrComp	access:public	signature:( const std::unique_ptr<int> &x, const std::unique_ptr<int> &y) const
__anon114::ValueType	.\test\ConcurrentSkipListTest.cpp	/^typedef int ValueType;$/;"	t	namespace:__anon114	file:
__anon114::VectorType	.\test\ConcurrentSkipListTest.cpp	/^typedef vector<ValueType> VectorType;$/;"	t	namespace:__anon114	file:
__anon114::concurrentSkip	.\test\ConcurrentSkipListTest.cpp	/^static void concurrentSkip(const vector<ValueType> *values,$/;"	f	namespace:__anon114	signature:(const vector<ValueType> *values, SkipListAccessor skipList)
__anon114::kHeadHeight	.\test\ConcurrentSkipListTest.cpp	/^static const int kHeadHeight = 2;$/;"	m	namespace:__anon114	file:
__anon114::kMaxValue	.\test\ConcurrentSkipListTest.cpp	/^static const int kMaxValue = 5000;$/;"	m	namespace:__anon114	file:
__anon114::makeRandomeString	.\test\ConcurrentSkipListTest.cpp	/^static std::string makeRandomeString(int len) {$/;"	f	namespace:__anon114	signature:(int len)
__anon114::randomAdding	.\test\ConcurrentSkipListTest.cpp	/^static void randomAdding(int size,$/;"	f	namespace:__anon114	signature:(int size, SkipListAccessor skipList, SetType *verifier, int maxValue = kMaxValue)
__anon114::randomRemoval	.\test\ConcurrentSkipListTest.cpp	/^static void randomRemoval(int size,$/;"	f	namespace:__anon114	signature:(int size, SkipListAccessor skipList, SetType *verifier, int maxValue=kMaxValue)
__anon114::sumAllValues	.\test\ConcurrentSkipListTest.cpp	/^static void sumAllValues(SkipListAccessor skipList, int64_t *sum) {$/;"	f	namespace:__anon114	signature:(SkipListAccessor skipList, int64_t *sum)
__anon114::testConcurrentAccess	.\test\ConcurrentSkipListTest.cpp	/^static void testConcurrentAccess($/;"	f	namespace:__anon114	signature:( int numInsertions, int numDeletions, int maxValue)
__anon114::testConcurrentAdd	.\test\ConcurrentSkipListTest.cpp	/^void testConcurrentAdd(int numThreads) {$/;"	f	namespace:__anon114	signature:(int numThreads)
__anon114::testConcurrentRemoval	.\test\ConcurrentSkipListTest.cpp	/^void testConcurrentRemoval(int numThreads, int maxValue) {$/;"	f	namespace:__anon114	signature:(int numThreads, int maxValue)
__anon114::verifyEqual	.\test\ConcurrentSkipListTest.cpp	/^bool verifyEqual(SkipListAccessor skipList,$/;"	f	namespace:__anon114	signature:(SkipListAccessor skipList, const SetType &verifier)
__anon115::UserDefinedType	.\test\FBVectorTest.cpp	/^class UserDefinedType { int whatevs_; };$/;"	c	namespace:__anon115	file:
__anon115::UserDefinedType::whatevs_	.\test\FBVectorTest.cpp	/^class UserDefinedType { int whatevs_; };$/;"	m	class:__anon115::UserDefinedType	file:	access:private
__anon116::expectOK	.\test\FileTest.cpp	/^void expectOK(ssize_t r) {$/;"	f	namespace:__anon116	signature:(ssize_t r)
__anon116::expectWouldBlock	.\test\FileTest.cpp	/^void expectWouldBlock(ssize_t r) {$/;"	f	namespace:__anon116	signature:(ssize_t r)
__anon118::bigBuf	.\test\FormatBenchmark.cpp	/^char bigBuf[300];$/;"	m	namespace:__anon118	file:
__anon119::KeyValue	.\test\FormatTest.cpp	/^struct KeyValue {$/;"	s	namespace:__anon119	file:
__anon119::KeyValue::key	.\test\FormatTest.cpp	/^  std::string key;$/;"	m	struct:__anon119::KeyValue	file:	access:public
__anon119::KeyValue::value	.\test\FormatTest.cpp	/^  int value;$/;"	m	struct:__anon119::KeyValue	file:	access:public
__anon120::Opaque	.\test\FormatTest.cpp	/^struct Opaque {$/;"	s	namespace:__anon120	file:
__anon120::Opaque::k	.\test\FormatTest.cpp	/^  int k;$/;"	m	struct:__anon120::Opaque	file:	access:public
__anon121::GroupVarint32Decoder	.\test\GroupVarintTest.cpp	/^typedef GroupVarintDecoder<uint32_t> GroupVarint32Decoder;$/;"	t	namespace:__anon121	file:
__anon121::GroupVarint32Encoder	.\test\GroupVarintTest.cpp	/^typedef GroupVarintEncoder<uint32_t, StringAppender> GroupVarint32Encoder;$/;"	t	namespace:__anon121	file:
__anon121::GroupVarint64Decoder	.\test\GroupVarintTest.cpp	/^typedef GroupVarintDecoder<uint32_t> GroupVarint64Decoder;$/;"	t	namespace:__anon121	file:
__anon121::GroupVarint64Encoder	.\test\GroupVarintTest.cpp	/^typedef GroupVarintEncoder<uint64_t, StringAppender> GroupVarint64Encoder;$/;"	t	namespace:__anon121	file:
__anon121::StringAppender	.\test\GroupVarintTest.cpp	/^class StringAppender {$/;"	c	namespace:__anon121	file:
__anon121::StringAppender::StringAppender	.\test\GroupVarintTest.cpp	/^  \/* implicit *\/ StringAppender(std::string& s) : s_(s) { }$/;"	f	class:__anon121::StringAppender	access:public	signature:(std::string& s)
__anon121::StringAppender::operator ()	.\test\GroupVarintTest.cpp	/^  void operator()(StringPiece sp) {$/;"	f	class:__anon121::StringAppender	access:public	signature:(StringPiece sp)
__anon121::StringAppender::s_	.\test\GroupVarintTest.cpp	/^  std::string& s_;$/;"	m	class:__anon121::StringAppender	file:	access:private
__anon121::testGroupVarint32	.\test\GroupVarintTest.cpp	/^void testGroupVarint32(uint32_t a, uint32_t b, uint32_t c, uint32_t d, ...) {$/;"	f	namespace:__anon121	signature:(uint32_t a, uint32_t b, uint32_t c, uint32_t d, ...)
__anon121::testGroupVarint64	.\test\GroupVarintTest.cpp	/^void testGroupVarint64(uint64_t a, uint64_t b, uint64_t c, uint64_t d,$/;"	f	namespace:__anon121	signature:(uint64_t a, uint64_t b, uint64_t c, uint64_t d, uint64_t e, ...)
__anon122::checkTWang	.\test\HashTest.cpp	/^void checkTWang(uint64_t r) {$/;"	f	namespace:__anon122	signature:(uint64_t r)
__anon123::checkJenkins	.\test\HashTest.cpp	/^void checkJenkins(uint32_t r) {$/;"	f	namespace:__anon123	signature:(uint32_t r)
__anon124::hash_vector	.\test\HashTest.cpp	/^size_t hash_vector(const std::vector<T>& v) {$/;"	f	namespace:__anon124	signature:(const std::vector<T>& v)
__anon126::FOLLY_PACK_ATTR	.\test\PackedSyncPtrTest.cpp	/^struct ignore { PackedSyncPtr<int> foo; char c; } FOLLY_PACK_ATTR;$/;"	m	namespace:__anon126	typeref:struct:__anon126::ignore	file:
__anon126::ignore	.\test\PackedSyncPtrTest.cpp	/^struct ignore { PackedSyncPtr<int> foo; char c; } FOLLY_PACK_ATTR;$/;"	s	namespace:__anon126	file:
__anon126::ignore::c	.\test\PackedSyncPtrTest.cpp	/^struct ignore { PackedSyncPtr<int> foo; char c; } FOLLY_PACK_ATTR;$/;"	m	struct:__anon126::ignore	file:	access:public
__anon126::ignore::foo	.\test\PackedSyncPtrTest.cpp	/^struct ignore { PackedSyncPtr<int> foo; char c; } FOLLY_PACK_ATTR;$/;"	m	struct:__anon126::ignore	file:	access:public
__anon126::sizeof	.\test\PackedSyncPtrTest.cpp	/^static_assert(sizeof(ignore) == 9, "PackedSyncPtr wasn't packable");$/;"	p	namespace:__anon126	file:	signature:(ignore)
__anon127::BENCHMARK_DRAW_LINE	.\test\ProducerConsumerQueueBenchmark.cpp	/^BENCHMARK_DRAW_LINE();$/;"	p	namespace:__anon127	file:	signature:()
__anon127::BENCHMARK_PARAM	.\test\ProducerConsumerQueueBenchmark.cpp	/^BENCHMARK_PARAM(BM_ProducerConsumer, 1048574);$/;"	p	namespace:__anon127	file:	signature:(BM_ProducerConsumer, 1048574)
__anon127::BENCHMARK_PARAM	.\test\ProducerConsumerQueueBenchmark.cpp	/^BENCHMARK_PARAM(BM_ProducerConsumerAffinity, 1048574);$/;"	p	namespace:__anon127	file:	signature:(BM_ProducerConsumerAffinity, 1048574)
__anon127::BENCHMARK_PARAM	.\test\ProducerConsumerQueueBenchmark.cpp	/^BENCHMARK_PARAM(BM_ProducerConsumerLatency, 1048574);$/;"	p	namespace:__anon127	file:	signature:(BM_ProducerConsumerLatency, 1048574)
__anon127::BM_ProducerConsumer	.\test\ProducerConsumerQueueBenchmark.cpp	/^void BM_ProducerConsumer(int iters, int size) {$/;"	f	namespace:__anon127	signature:(int iters, int size)
__anon127::BM_ProducerConsumerAffinity	.\test\ProducerConsumerQueueBenchmark.cpp	/^void BM_ProducerConsumerAffinity(int iters, int size) {$/;"	f	namespace:__anon127	signature:(int iters, int size)
__anon127::BM_ProducerConsumerLatency	.\test\ProducerConsumerQueueBenchmark.cpp	/^void BM_ProducerConsumerLatency(int iters, int size) {$/;"	f	namespace:__anon127	signature:(int iters, int size)
__anon127::LatencyQueueType	.\test\ProducerConsumerQueueBenchmark.cpp	/^typedef ProducerConsumerQueue<LatencyType> LatencyQueueType;$/;"	t	namespace:__anon127	file:
__anon127::LatencyTest	.\test\ProducerConsumerQueueBenchmark.cpp	/^struct LatencyTest {$/;"	s	namespace:__anon127	file:
__anon127::LatencyTest::LatencyTest	.\test\ProducerConsumerQueueBenchmark.cpp	/^  explicit LatencyTest(size_t size, int iters, int cpu0, int cpu1)$/;"	f	struct:__anon127::LatencyTest	access:public	signature:(size_t size, int iters, int cpu0, int cpu1)
__anon127::LatencyTest::computeTimeCost	.\test\ProducerConsumerQueueBenchmark.cpp	/^  void computeTimeCost() {$/;"	f	struct:__anon127::LatencyTest	access:public	signature:()
__anon127::LatencyTest::consumer	.\test\ProducerConsumerQueueBenchmark.cpp	/^  void consumer() {$/;"	f	struct:__anon127::LatencyTest	access:public	signature:()
__anon127::LatencyTest::cpu0_	.\test\ProducerConsumerQueueBenchmark.cpp	/^  int cpu0_;$/;"	m	struct:__anon127::LatencyTest	file:	access:public
__anon127::LatencyTest::cpu1_	.\test\ProducerConsumerQueueBenchmark.cpp	/^  int cpu1_;$/;"	m	struct:__anon127::LatencyTest	file:	access:public
__anon127::LatencyTest::done_	.\test\ProducerConsumerQueueBenchmark.cpp	/^  std::atomic<bool> done_;$/;"	m	struct:__anon127::LatencyTest	file:	access:public
__anon127::LatencyTest::hist_	.\test\ProducerConsumerQueueBenchmark.cpp	/^  Histogram<int> hist_;$/;"	m	struct:__anon127::LatencyTest	file:	access:public
__anon127::LatencyTest::iters_	.\test\ProducerConsumerQueueBenchmark.cpp	/^  int iters_;$/;"	m	struct:__anon127::LatencyTest	file:	access:public
__anon127::LatencyTest::printHistogram	.\test\ProducerConsumerQueueBenchmark.cpp	/^  void printHistogram() {$/;"	f	struct:__anon127::LatencyTest	access:public	signature:()
__anon127::LatencyTest::producer	.\test\ProducerConsumerQueueBenchmark.cpp	/^  void producer() {$/;"	f	struct:__anon127::LatencyTest	access:public	signature:()
__anon127::LatencyTest::queue_	.\test\ProducerConsumerQueueBenchmark.cpp	/^  QueueType queue_;$/;"	m	struct:__anon127::LatencyTest	file:	access:public
__anon127::LatencyTest::time_cost_	.\test\ProducerConsumerQueueBenchmark.cpp	/^  int time_cost_;$/;"	m	struct:__anon127::LatencyTest	file:	access:public
__anon127::LatencyType	.\test\ProducerConsumerQueueBenchmark.cpp	/^typedef long LatencyType;$/;"	t	namespace:__anon127	file:
__anon127::ThroughputQueueType	.\test\ProducerConsumerQueueBenchmark.cpp	/^typedef ProducerConsumerQueue<ThroughputType> ThroughputQueueType;$/;"	t	namespace:__anon127	file:
__anon127::ThroughputTest	.\test\ProducerConsumerQueueBenchmark.cpp	/^struct ThroughputTest {$/;"	s	namespace:__anon127	file:
__anon127::ThroughputTest::ThroughputTest	.\test\ProducerConsumerQueueBenchmark.cpp	/^  explicit ThroughputTest(size_t size, int iters, int cpu0, int cpu1)$/;"	f	struct:__anon127::ThroughputTest	access:public	signature:(size_t size, int iters, int cpu0, int cpu1)
__anon127::ThroughputTest::consumer	.\test\ProducerConsumerQueueBenchmark.cpp	/^  void consumer() {$/;"	f	struct:__anon127::ThroughputTest	access:public	signature:()
__anon127::ThroughputTest::cpu0_	.\test\ProducerConsumerQueueBenchmark.cpp	/^  int cpu0_;$/;"	m	struct:__anon127::ThroughputTest	file:	access:public
__anon127::ThroughputTest::cpu1_	.\test\ProducerConsumerQueueBenchmark.cpp	/^  int cpu1_;$/;"	m	struct:__anon127::ThroughputTest	file:	access:public
__anon127::ThroughputTest::done_	.\test\ProducerConsumerQueueBenchmark.cpp	/^  std::atomic<bool> done_;$/;"	m	struct:__anon127::ThroughputTest	file:	access:public
__anon127::ThroughputTest::iters_	.\test\ProducerConsumerQueueBenchmark.cpp	/^  int iters_;$/;"	m	struct:__anon127::ThroughputTest	file:	access:public
__anon127::ThroughputTest::producer	.\test\ProducerConsumerQueueBenchmark.cpp	/^  void producer() {$/;"	f	struct:__anon127::ThroughputTest	access:public	signature:()
__anon127::ThroughputTest::queue_	.\test\ProducerConsumerQueueBenchmark.cpp	/^  QueueType queue_;$/;"	m	struct:__anon127::ThroughputTest	file:	access:public
__anon127::ThroughputType	.\test\ProducerConsumerQueueBenchmark.cpp	/^typedef int ThroughputType;$/;"	t	namespace:__anon127	file:
__anon128::CorrectnessTest	.\test\ProducerConsumerQueueTest.cpp	/^struct CorrectnessTest {$/;"	s	namespace:__anon128	file:
__anon128::CorrectnessTest::CorrectnessTest	.\test\ProducerConsumerQueueTest.cpp	/^  explicit CorrectnessTest()$/;"	f	struct:__anon128::CorrectnessTest	access:public	signature:()
__anon128::CorrectnessTest::T	.\test\ProducerConsumerQueueTest.cpp	/^  typedef typename QueueType::value_type T;$/;"	t	struct:__anon128::CorrectnessTest	file:	access:public
__anon128::CorrectnessTest::consumer	.\test\ProducerConsumerQueueTest.cpp	/^  void consumer() {$/;"	f	struct:__anon128::CorrectnessTest	access:public	signature:()
__anon128::CorrectnessTest::consumerPop	.\test\ProducerConsumerQueueTest.cpp	/^  void consumerPop() {$/;"	f	struct:__anon128::CorrectnessTest	access:public	signature:()
__anon128::CorrectnessTest::consumerRead	.\test\ProducerConsumerQueueTest.cpp	/^  void consumerRead() {$/;"	f	struct:__anon128::CorrectnessTest	access:public	signature:()
__anon128::CorrectnessTest::done_	.\test\ProducerConsumerQueueTest.cpp	/^  std::atomic<bool> done_;$/;"	m	struct:__anon128::CorrectnessTest	file:	access:public
__anon128::CorrectnessTest::operator ()	.\test\ProducerConsumerQueueTest.cpp	/^  void operator()() {$/;"	f	struct:__anon128::CorrectnessTest	access:public	signature:()
__anon128::CorrectnessTest::producer	.\test\ProducerConsumerQueueTest.cpp	/^  void producer() {$/;"	f	struct:__anon128::CorrectnessTest	access:public	signature:()
__anon128::CorrectnessTest::queue_	.\test\ProducerConsumerQueueTest.cpp	/^  QueueType queue_;$/;"	m	struct:__anon128::CorrectnessTest	file:	access:public
__anon128::CorrectnessTest::testData_	.\test\ProducerConsumerQueueTest.cpp	/^  std::vector<T> testData_;$/;"	m	struct:__anon128::CorrectnessTest	file:	access:public
__anon128::CorrectnessTest::traits_	.\test\ProducerConsumerQueueTest.cpp	/^  TestTraits<T> traits_;$/;"	m	struct:__anon128::CorrectnessTest	file:	access:public
__anon128::DtorChecker	.\test\ProducerConsumerQueueTest.cpp	/^struct DtorChecker {$/;"	s	namespace:__anon128	file:
__anon128::DtorChecker::DtorChecker	.\test\ProducerConsumerQueueTest.cpp	/^  DtorChecker() { ++numInstances; }$/;"	f	struct:__anon128::DtorChecker	access:public	signature:()
__anon128::DtorChecker::DtorChecker	.\test\ProducerConsumerQueueTest.cpp	/^  DtorChecker(const DtorChecker& o) { ++numInstances; }$/;"	f	struct:__anon128::DtorChecker	access:public	signature:(const DtorChecker& o)
__anon128::DtorChecker::numInstances	.\test\ProducerConsumerQueueTest.cpp	/^  static int numInstances;$/;"	m	struct:__anon128::DtorChecker	file:	access:public
__anon128::DtorChecker::numInstances	.\test\ProducerConsumerQueueTest.cpp	/^int DtorChecker::numInstances = 0;$/;"	m	class:__anon128::DtorChecker	file:
__anon128::DtorChecker::~DtorChecker	.\test\ProducerConsumerQueueTest.cpp	/^  ~DtorChecker() { --numInstances; }$/;"	f	struct:__anon128::DtorChecker	access:public	signature:()
__anon128::PerfTest	.\test\ProducerConsumerQueueTest.cpp	/^struct PerfTest {$/;"	s	namespace:__anon128	file:
__anon128::PerfTest::PerfTest	.\test\ProducerConsumerQueueTest.cpp	/^  explicit PerfTest() : queue_(Size), done_(false) {}$/;"	f	struct:__anon128::PerfTest	access:public	signature:()
__anon128::PerfTest::T	.\test\ProducerConsumerQueueTest.cpp	/^  typedef typename QueueType::value_type T;$/;"	t	struct:__anon128::PerfTest	file:	access:public
__anon128::PerfTest::consumer	.\test\ProducerConsumerQueueTest.cpp	/^  void consumer() {$/;"	f	struct:__anon128::PerfTest	access:public	signature:()
__anon128::PerfTest::done_	.\test\ProducerConsumerQueueTest.cpp	/^  std::atomic<bool> done_;$/;"	m	struct:__anon128::PerfTest	file:	access:public
__anon128::PerfTest::operator ()	.\test\ProducerConsumerQueueTest.cpp	/^  void operator()() {$/;"	f	struct:__anon128::PerfTest	access:public	signature:()
__anon128::PerfTest::producer	.\test\ProducerConsumerQueueTest.cpp	/^  void producer() {$/;"	f	struct:__anon128::PerfTest	access:public	signature:()
__anon128::PerfTest::queue_	.\test\ProducerConsumerQueueTest.cpp	/^  QueueType queue_;$/;"	m	struct:__anon128::PerfTest	file:	access:public
__anon128::PerfTest::traits_	.\test\ProducerConsumerQueueTest.cpp	/^  TestTraits<T> traits_;$/;"	m	struct:__anon128::PerfTest	file:	access:public
__anon128::TestTraits	.\test\ProducerConsumerQueueTest.cpp	/^template<> struct TestTraits<std::string> {$/;"	s	namespace:__anon128	file:
__anon128::TestTraits	.\test\ProducerConsumerQueueTest.cpp	/^template<class T> struct TestTraits {$/;"	s	namespace:__anon128	file:
__anon128::TestTraits::generate	.\test\ProducerConsumerQueueTest.cpp	/^  T generate() const { return rand() % 26; }$/;"	f	struct:__anon128::TestTraits	access:public	signature:() const
__anon128::TestTraits::generate	.\test\ProducerConsumerQueueTest.cpp	/^  std::string generate() const { return std::string(12, ' '); }$/;"	f	struct:__anon128::TestTraits	access:public	signature:() const
__anon128::TestTraits::limit	.\test\ProducerConsumerQueueTest.cpp	/^  T limit() const { return 1 << 24; }$/;"	f	struct:__anon128::TestTraits	access:public	signature:() const
__anon128::TestTraits::limit	.\test\ProducerConsumerQueueTest.cpp	/^  int limit() const { return 1 << 22; }$/;"	f	struct:__anon128::TestTraits	access:public	signature:() const
__anon128::correctnessTestType	.\test\ProducerConsumerQueueTest.cpp	/^void correctnessTestType(const std::string& type) {$/;"	f	namespace:__anon128	signature:(const std::string& type)
__anon128::doTest	.\test\ProducerConsumerQueueTest.cpp	/^template<class TestType> void doTest(const char* name) {$/;"	f	namespace:__anon128	signature:(const char* name)
__anon128::perfTestType	.\test\ProducerConsumerQueueTest.cpp	/^void perfTestType(const char* type) {$/;"	f	namespace:__anon128	signature:(const char* type)
__anon129::ffoDelim	.\test\RangeFindBenchmark.cpp	/^vector<string> ffoDelim;$/;"	m	namespace:__anon129	file:
__anon129::ffoDelimSize	.\test\RangeFindBenchmark.cpp	/^const size_t ffoDelimSize = 128;$/;"	m	namespace:__anon129	file:
__anon129::ffoTestString	.\test\RangeFindBenchmark.cpp	/^string ffoTestString;$/;"	m	namespace:__anon129	file:
__anon129::generateString	.\test\RangeFindBenchmark.cpp	/^string generateString(int len) {$/;"	f	namespace:__anon129	signature:(int len)
__anon129::initDelims	.\test\RangeFindBenchmark.cpp	/^void initDelims(int len) {$/;"	f	namespace:__anon129	signature:(int len)
__anon129::initStr	.\test\RangeFindBenchmark.cpp	/^void initStr(int len) {$/;"	f	namespace:__anon129	signature:(int len)
__anon129::kVstrSize	.\test\RangeFindBenchmark.cpp	/^constexpr int kVstrSize = 16;$/;"	m	namespace:__anon129	file:
__anon129::rnd	.\test\RangeFindBenchmark.cpp	/^std::mt19937 rnd;$/;"	m	namespace:__anon129	file:
__anon129::str	.\test\RangeFindBenchmark.cpp	/^std::string str;$/;"	m	namespace:__anon129	file:
__anon129::vstr	.\test\RangeFindBenchmark.cpp	/^std::vector<std::string> vstr;$/;"	m	namespace:__anon129	file:
__anon129::vstrp	.\test\RangeFindBenchmark.cpp	/^std::vector<StringPiece> vstrp;$/;"	m	namespace:__anon129	file:
__anon130::Implementations	.\test\RWSpinLockTest.cpp	/^> Implementations;$/;"	t	namespace:__anon130	file:
__anon130::RWSpinLockTest	.\test\RWSpinLockTest.cpp	/^template<typename RWSpinLockT> struct RWSpinLockTest: public testing::Test {$/;"	s	namespace:__anon130	file:	inherits:testing::Test
__anon130::RWSpinLockTest::RWSpinLockType	.\test\RWSpinLockTest.cpp	/^  typedef RWSpinLockT RWSpinLockType;$/;"	t	struct:__anon130::RWSpinLockTest	file:	access:public
__anon130::TEST	.\test\RWSpinLockTest.cpp	/^TEST(RWSpinLock, concurrent_holder_test) {$/;"	f	namespace:__anon130	signature:(RWSpinLock, concurrent_holder_test)
__anon130::TEST	.\test\RWSpinLockTest.cpp	/^TEST(RWSpinLock, lock_unlock_tests) {$/;"	f	namespace:__anon130	signature:(RWSpinLock, lock_unlock_tests)
__anon130::TYPED_TEST	.\test\RWSpinLockTest.cpp	/^TYPED_TEST(RWSpinLockTest, ConcurrentTests) {$/;"	f	namespace:__anon130	signature:(RWSpinLockTest, ConcurrentTests)
__anon130::TYPED_TEST	.\test\RWSpinLockTest.cpp	/^TYPED_TEST(RWSpinLockTest, Read_Holders) {$/;"	f	namespace:__anon130	signature:(RWSpinLockTest, Read_Holders)
__anon130::TYPED_TEST	.\test\RWSpinLockTest.cpp	/^TYPED_TEST(RWSpinLockTest, Readers_Wait_Writer) {$/;"	f	namespace:__anon130	signature:(RWSpinLockTest, Readers_Wait_Writer)
__anon130::TYPED_TEST	.\test\RWSpinLockTest.cpp	/^TYPED_TEST(RWSpinLockTest, Write_Holders) {$/;"	f	namespace:__anon130	signature:(RWSpinLockTest, Write_Holders)
__anon130::TYPED_TEST	.\test\RWSpinLockTest.cpp	/^TYPED_TEST(RWSpinLockTest, Writer_Wait_Readers) {$/;"	f	namespace:__anon130	signature:(RWSpinLockTest, Writer_Wait_Readers)
__anon130::TYPED_TEST	.\test\RWSpinLockTest.cpp	/^TYPED_TEST(RWSpinLockTest, Writer_Wait_Writer) {$/;"	f	namespace:__anon130	signature:(RWSpinLockTest, Writer_Wait_Writer)
__anon130::TYPED_TEST_CASE	.\test\RWSpinLockTest.cpp	/^TYPED_TEST_CASE(RWSpinLockTest, Implementations);$/;"	p	namespace:__anon130	file:	signature:(RWSpinLockTest, Implementations)
__anon130::kMaxReaders	.\test\RWSpinLockTest.cpp	/^static const int kMaxReaders = 50;$/;"	m	namespace:__anon130	file:
__anon130::run	.\test\RWSpinLockTest.cpp	/^static void run(RWSpinLockType* lock) {$/;"	f	namespace:__anon130	signature:(RWSpinLockType* lock)
__anon130::stopThread	.\test\RWSpinLockTest.cpp	/^static std::atomic<bool> stopThread;$/;"	m	namespace:__anon130	file:
__anon131::FOLLY_PACK_ATTR	.\test\SmallLocksTest.cpp	/^  FOLLY_PACK_ATTR;$/;"	m	namespace:__anon131	typeref:struct:__anon131::ignore2	file:
__anon131::FOLLY_PACK_ATTR	.\test\SmallLocksTest.cpp	/^struct ignore1 { MicroSpinLock msl; int16_t foo; } FOLLY_PACK_ATTR;$/;"	m	namespace:__anon131	typeref:struct:__anon131::ignore1	file:
__anon131::LockedVal	.\test\SmallLocksTest.cpp	/^struct LockedVal {$/;"	s	namespace:__anon131	file:
__anon131::LockedVal::LockedVal	.\test\SmallLocksTest.cpp	/^  LockedVal() {$/;"	f	struct:__anon131::LockedVal	access:public	signature:()
__anon131::LockedVal::ar	.\test\SmallLocksTest.cpp	/^  int ar[1024];$/;"	m	struct:__anon131::LockedVal	file:	access:public
__anon131::LockedVal::lock	.\test\SmallLocksTest.cpp	/^  MicroSpinLock lock;$/;"	m	struct:__anon131::LockedVal	file:	access:public
__anon131::PslTest	.\test\SmallLocksTest.cpp	/^template<class T> struct PslTest {$/;"	s	namespace:__anon131	file:
__anon131::PslTest::PslTest	.\test\SmallLocksTest.cpp	/^  PslTest() { lock.init(); }$/;"	f	struct:__anon131::PslTest	access:public	signature:()
__anon131::PslTest::doTest	.\test\SmallLocksTest.cpp	/^  void doTest() {$/;"	f	struct:__anon131::PslTest	access:public	signature:()
__anon131::PslTest::lock	.\test\SmallLocksTest.cpp	/^  PicoSpinLock<T> lock;$/;"	m	struct:__anon131::PslTest	file:	access:public
__anon131::TestClobber	.\test\SmallLocksTest.cpp	/^struct TestClobber {$/;"	s	namespace:__anon131	file:
__anon131::TestClobber::TestClobber	.\test\SmallLocksTest.cpp	/^  TestClobber() {$/;"	f	struct:__anon131::TestClobber	access:public	signature:()
__anon131::TestClobber::go	.\test\SmallLocksTest.cpp	/^  void go() {$/;"	f	struct:__anon131::TestClobber	access:public	signature:()
__anon131::TestClobber::lock_	.\test\SmallLocksTest.cpp	/^  MicroSpinLock lock_;$/;"	m	struct:__anon131::TestClobber	file:	access:private
__anon131::doPslTest	.\test\SmallLocksTest.cpp	/^void doPslTest() {$/;"	f	namespace:__anon131	signature:()
__anon131::ignore1	.\test\SmallLocksTest.cpp	/^struct ignore1 { MicroSpinLock msl; int16_t foo; } FOLLY_PACK_ATTR;$/;"	s	namespace:__anon131	file:
__anon131::ignore1::foo	.\test\SmallLocksTest.cpp	/^struct ignore1 { MicroSpinLock msl; int16_t foo; } FOLLY_PACK_ATTR;$/;"	m	struct:__anon131::ignore1	file:	access:public
__anon131::ignore1::msl	.\test\SmallLocksTest.cpp	/^struct ignore1 { MicroSpinLock msl; int16_t foo; } FOLLY_PACK_ATTR;$/;"	m	struct:__anon131::ignore1	file:	access:public
__anon131::ignore2	.\test\SmallLocksTest.cpp	/^struct ignore2 { PicoSpinLock<uint32_t> psl; int16_t foo; }$/;"	s	namespace:__anon131	file:
__anon131::ignore2::foo	.\test\SmallLocksTest.cpp	/^struct ignore2 { PicoSpinLock<uint32_t> psl; int16_t foo; }$/;"	m	struct:__anon131::ignore2	file:	access:public
__anon131::ignore2::psl	.\test\SmallLocksTest.cpp	/^struct ignore2 { PicoSpinLock<uint32_t> psl; int16_t foo; }$/;"	m	struct:__anon131::ignore2	file:	access:public
__anon131::sizeof	.\test\SmallLocksTest.cpp	/^static_assert(sizeof(ignore1) == 3, "Size check failed");$/;"	p	namespace:__anon131	file:	signature:(ignore1)
__anon131::sizeof	.\test\SmallLocksTest.cpp	/^static_assert(sizeof(ignore2) == 6, "Size check failed");$/;"	p	namespace:__anon131	file:	signature:(ignore2)
__anon131::splock_test	.\test\SmallLocksTest.cpp	/^void splock_test() {$/;"	f	namespace:__anon131	signature:()
__anon131::v	.\test\SmallLocksTest.cpp	/^LockedVal v;$/;"	m	namespace:__anon131	file:
__anon132::MaybeThrow	.\test\small_vector_test.cpp	/^void MaybeThrow() {$/;"	f	namespace:__anon132	signature:()
__anon132::NoncopyableCounter	.\test\small_vector_test.cpp	/^struct NoncopyableCounter {$/;"	s	namespace:__anon132	file:
__anon132::NoncopyableCounter::NoncopyableCounter	.\test\small_vector_test.cpp	/^  NoncopyableCounter() {$/;"	f	struct:__anon132::NoncopyableCounter	access:public	signature:()
__anon132::NoncopyableCounter::NoncopyableCounter	.\test\small_vector_test.cpp	/^  NoncopyableCounter(NoncopyableCounter const&) = delete;$/;"	p	struct:__anon132::NoncopyableCounter	file:	access:public	signature:(NoncopyableCounter const&)
__anon132::NoncopyableCounter::NoncopyableCounter	.\test\small_vector_test.cpp	/^  NoncopyableCounter(NoncopyableCounter&&) { ++alive; }$/;"	f	struct:__anon132::NoncopyableCounter	access:public	signature:(NoncopyableCounter&&)
__anon132::NoncopyableCounter::alive	.\test\small_vector_test.cpp	/^  static int alive;$/;"	m	struct:__anon132::NoncopyableCounter	file:	access:public
__anon132::NoncopyableCounter::alive	.\test\small_vector_test.cpp	/^int NoncopyableCounter::alive = 0;$/;"	m	class:__anon132::NoncopyableCounter	file:
__anon132::NoncopyableCounter::operator =	.\test\small_vector_test.cpp	/^  NoncopyableCounter& operator=(NoncopyableCounter const&) const = delete;$/;"	p	struct:__anon132::NoncopyableCounter	file:	access:public	signature:(NoncopyableCounter const&) const
__anon132::NoncopyableCounter::operator =	.\test\small_vector_test.cpp	/^  NoncopyableCounter& operator=(NoncopyableCounter&&) { return *this; }$/;"	f	struct:__anon132::NoncopyableCounter	access:public	signature:(NoncopyableCounter&&)
__anon132::NoncopyableCounter::~NoncopyableCounter	.\test\small_vector_test.cpp	/^  ~NoncopyableCounter() {$/;"	f	struct:__anon132::NoncopyableCounter	access:public	signature:()
__anon132::NontrivialType	.\test\small_vector_test.cpp	/^struct NontrivialType {$/;"	s	namespace:__anon132	file:
__anon132::NontrivialType::NontrivialType	.\test\small_vector_test.cpp	/^  NontrivialType(NontrivialType const& s) {$/;"	f	struct:__anon132::NontrivialType	access:public	signature:(NontrivialType const& s)
__anon132::NontrivialType::NontrivialType	.\test\small_vector_test.cpp	/^  \/* implicit *\/ NontrivialType(int a) : a(a) {$/;"	f	struct:__anon132::NontrivialType	access:public	signature:(int a)
__anon132::NontrivialType::NontrivialType	.\test\small_vector_test.cpp	/^  explicit NontrivialType() : a(0) {}$/;"	f	struct:__anon132::NontrivialType	access:public	signature:()
__anon132::NontrivialType::a	.\test\small_vector_test.cpp	/^  int32_t a;$/;"	m	struct:__anon132::NontrivialType	file:	access:public
__anon132::NontrivialType::ctored	.\test\small_vector_test.cpp	/^  static int ctored;$/;"	m	struct:__anon132::NontrivialType	file:	access:public
__anon132::NontrivialType::ctored	.\test\small_vector_test.cpp	/^int NontrivialType::ctored = 0;$/;"	m	class:__anon132::NontrivialType	file:
__anon132::NontrivialType::operator =	.\test\small_vector_test.cpp	/^  NontrivialType& operator=(NontrivialType const& o) {$/;"	f	struct:__anon132::NontrivialType	access:public	signature:(NontrivialType const& o)
__anon132::TestBasicGuarantee	.\test\small_vector_test.cpp	/^struct TestBasicGuarantee {$/;"	s	namespace:__anon132	file:
__anon132::TestBasicGuarantee::TestBasicGuarantee	.\test\small_vector_test.cpp	/^  explicit TestBasicGuarantee(int prepopulate)$/;"	f	struct:__anon132::TestBasicGuarantee	access:public	signature:(int prepopulate)
__anon132::TestBasicGuarantee::operator ()	.\test\small_vector_test.cpp	/^  void operator()(int insertCount, Operation const& op) {$/;"	f	struct:__anon132::TestBasicGuarantee	access:public	signature:(int insertCount, Operation const& op)
__anon132::TestBasicGuarantee::prepopulate	.\test\small_vector_test.cpp	/^  int const prepopulate;$/;"	m	struct:__anon132::TestBasicGuarantee	file:	access:public
__anon132::TestBasicGuarantee::vec	.\test\small_vector_test.cpp	/^  folly::small_vector<Thrower,3> vec;$/;"	m	struct:__anon132::TestBasicGuarantee	file:	access:public
__anon132::TestBasicGuarantee::~TestBasicGuarantee	.\test\small_vector_test.cpp	/^  ~TestBasicGuarantee() {$/;"	f	struct:__anon132::TestBasicGuarantee	access:public	signature:()
__anon132::TestException	.\test\small_vector_test.cpp	/^struct TestException {};$/;"	s	namespace:__anon132	file:
__anon132::Thrower	.\test\small_vector_test.cpp	/^struct Thrower {$/;"	s	namespace:__anon132	file:
__anon132::Thrower::Thrower	.\test\small_vector_test.cpp	/^  Thrower() : magic(kMagic) {$/;"	f	struct:__anon132::Thrower	access:public	signature:()
__anon132::Thrower::Thrower	.\test\small_vector_test.cpp	/^  Thrower(Thrower const& other) : magic(other.magic) {$/;"	f	struct:__anon132::Thrower	access:public	signature:(Thrower const& other)
__anon132::Thrower::alive	.\test\small_vector_test.cpp	/^  static int alive;$/;"	m	struct:__anon132::Thrower	file:	access:public
__anon132::Thrower::alive	.\test\small_vector_test.cpp	/^int Thrower::alive = 0;$/;"	m	class:__anon132::Thrower	file:
__anon132::Thrower::magic	.\test\small_vector_test.cpp	/^  int magic;$/;"	m	struct:__anon132::Thrower	file:	access:public
__anon132::Thrower::operator =	.\test\small_vector_test.cpp	/^  Thrower& operator=(Thrower const& other) {$/;"	f	struct:__anon132::Thrower	access:public	signature:(Thrower const& other)
__anon132::kMagic	.\test\small_vector_test.cpp	/^const int kMagic = 0xdeadbeef;$/;"	m	namespace:__anon132	file:
__anon132::throwCounter	.\test\small_vector_test.cpp	/^int throwCounter = 1;$/;"	m	namespace:__anon132	file:
__anon133::CountCopyCtor	.\test\sorted_vector_test.cpp	/^struct CountCopyCtor {$/;"	s	namespace:__anon133	file:
__anon133::CountCopyCtor::CountCopyCtor	.\test\sorted_vector_test.cpp	/^  CountCopyCtor(const CountCopyCtor& c)$/;"	f	struct:__anon133::CountCopyCtor	access:public	signature:(const CountCopyCtor& c)
__anon133::CountCopyCtor::CountCopyCtor	.\test\sorted_vector_test.cpp	/^  explicit CountCopyCtor() : val_(0) {}$/;"	f	struct:__anon133::CountCopyCtor	access:public	signature:()
__anon133::CountCopyCtor::CountCopyCtor	.\test\sorted_vector_test.cpp	/^  explicit CountCopyCtor(int val) : val_(val), count_(0) {}$/;"	f	struct:__anon133::CountCopyCtor	access:public	signature:(int val)
__anon133::CountCopyCtor::count_	.\test\sorted_vector_test.cpp	/^  int count_;$/;"	m	struct:__anon133::CountCopyCtor	file:	access:public
__anon133::CountCopyCtor::operator <	.\test\sorted_vector_test.cpp	/^  bool operator<(const CountCopyCtor& o) const {$/;"	f	struct:__anon133::CountCopyCtor	access:public	signature:(const CountCopyCtor& o) const
__anon133::CountCopyCtor::val_	.\test\sorted_vector_test.cpp	/^  int val_;$/;"	m	struct:__anon133::CountCopyCtor	file:	access:public
__anon133::OneAtATimePolicy	.\test\sorted_vector_test.cpp	/^struct OneAtATimePolicy {$/;"	s	namespace:__anon133	file:
__anon133::OneAtATimePolicy::increase_capacity	.\test\sorted_vector_test.cpp	/^  void increase_capacity(Container& c) {$/;"	f	struct:__anon133::OneAtATimePolicy	access:public	signature:(Container& c)
__anon133::check_invariant	.\test\sorted_vector_test.cpp	/^void check_invariant(Container& c) {$/;"	f	namespace:__anon133	signature:(Container& c)
__anon133::less_invert	.\test\sorted_vector_test.cpp	/^struct less_invert : std::binary_function<T,T,bool> {$/;"	s	namespace:__anon133	file:	inherits:std::binary_function
__anon133::less_invert::operator ()	.\test\sorted_vector_test.cpp	/^  bool operator()(const T& a, const T& b) const {$/;"	f	struct:__anon133::less_invert	access:public	signature:(const T& a, const T& b) const
__anon134::expectPrintable	.\test\StringTest.cpp	/^void expectPrintable(StringPiece s) {$/;"	f	namespace:__anon134	signature:(StringPiece s)
__anon135::isHex	.\test\StringTest.cpp	/^bool isHex(int v) {$/;"	f	namespace:__anon135	signature:(int v)
__anon136::BENCHMARK	.\test\StringTest.cpp	/^BENCHMARK(BM_cEscape, iters) {$/;"	f	namespace:__anon136	signature:(BM_cEscape, iters)
__anon136::BENCHMARK	.\test\StringTest.cpp	/^BENCHMARK(BM_cUnescape, iters) {$/;"	f	namespace:__anon136	signature:(BM_cUnescape, iters)
__anon136::BENCHMARK	.\test\StringTest.cpp	/^BENCHMARK(BM_uriEscape, iters) {$/;"	f	namespace:__anon136	signature:(BM_uriEscape, iters)
__anon136::BENCHMARK	.\test\StringTest.cpp	/^BENCHMARK(BM_uriUnescape, iters) {$/;"	f	namespace:__anon136	signature:(BM_uriUnescape, iters)
__anon136::cEscapedString	.\test\StringTest.cpp	/^fbstring cEscapedString;$/;"	m	namespace:__anon136	file:
__anon136::cUnescapedString	.\test\StringTest.cpp	/^fbstring cUnescapedString;$/;"	m	namespace:__anon136	file:
__anon136::cbmEscapedString	.\test\StringTest.cpp	/^fbstring cbmEscapedString;$/;"	m	namespace:__anon136	file:
__anon136::cbmString	.\test\StringTest.cpp	/^fbstring cbmString;$/;"	m	namespace:__anon136	file:
__anon136::initBenchmark	.\test\StringTest.cpp	/^void initBenchmark() {$/;"	f	namespace:__anon136	signature:()
__anon136::kCBmStringLength	.\test\StringTest.cpp	/^const size_t kCBmStringLength = 64 << 10;$/;"	m	namespace:__anon136	file:
__anon136::kCPrintablePercentage	.\test\StringTest.cpp	/^const uint32_t kCPrintablePercentage = 90;$/;"	m	namespace:__anon136	file:
__anon136::kURIBmStringLength	.\test\StringTest.cpp	/^const size_t kURIBmStringLength = 256;$/;"	m	namespace:__anon136	file:
__anon136::kURIPassThroughPercentage	.\test\StringTest.cpp	/^const uint32_t kURIPassThroughPercentage = 50;$/;"	m	namespace:__anon136	file:
__anon136::uriEscapedString	.\test\StringTest.cpp	/^fbstring uriEscapedString;$/;"	m	namespace:__anon136	file:
__anon136::uriUnescapedString	.\test\StringTest.cpp	/^fbstring uriUnescapedString;$/;"	m	namespace:__anon136	file:
__anon136::uribmEscapedString	.\test\StringTest.cpp	/^fbstring uribmEscapedString;$/;"	m	namespace:__anon136	file:
__anon136::uribmString	.\test\StringTest.cpp	/^fbstring uribmString;$/;"	m	namespace:__anon136	file:
__anon137::pow2	.\test\StringTest.cpp	/^double pow2(int exponent) {$/;"	f	namespace:__anon137	signature:(int exponent)
__anon138::piecesTest	.\test\StringTest.cpp	/^void piecesTest() {$/;"	f	namespace:__anon138	signature:()
__anon138::splitTest	.\test\StringTest.cpp	/^void splitTest() {$/;"	f	namespace:__anon138	signature:()
__anon139::copyWithSameAlignment	.\test\StringTest.cpp	/^char* copyWithSameAlignment(char* dst, const char* src, size_t length) {$/;"	f	namespace:__anon139	signature:(char* dst, const char* src, size_t length)
__anon139::testToLowerAscii	.\test\StringTest.cpp	/^void testToLowerAscii(Range<const char*> src) {$/;"	f	namespace:__anon139	signature:(Range<const char*> src)
__anon140::checkFdLeak	.\test\SubprocessTest.cpp	/^void checkFdLeak(const Runnable& r) {$/;"	f	namespace:__anon140	signature:(const Runnable& r)
__anon140::getOpenFds	.\test\SubprocessTest.cpp	/^boost::container::flat_set<int> getOpenFds() {$/;"	f	namespace:__anon140	signature:()
__anon141::readToString	.\test\SubprocessTest.cpp	/^bool readToString(int fd, std::string& buf, size_t maxSize) {$/;"	f	namespace:__anon141	signature:(int fd, std::string& buf, size_t maxSize)
__anon142::kSignal	.\test\SubprocessTestParentDeathHelper.cpp	/^constexpr int kSignal = SIGUSR1;$/;"	m	namespace:__anon142	file:
__anon143::ArenaTester	.\test\ThreadCachedArenaTest.cpp	/^class ArenaTester {$/;"	c	namespace:__anon143	file:
__anon143::ArenaTester::ArenaTester	.\test\ThreadCachedArenaTest.cpp	/^  explicit ArenaTester(ThreadCachedArena& arena) : arena_(&arena) { }$/;"	f	class:__anon143::ArenaTester	access:public	signature:(ThreadCachedArena& arena)
__anon143::ArenaTester::allocate	.\test\ThreadCachedArenaTest.cpp	/^  void allocate(size_t count, size_t maxSize);$/;"	p	class:__anon143::ArenaTester	file:	access:public	signature:(size_t count, size_t maxSize)
__anon143::ArenaTester::allocate	.\test\ThreadCachedArenaTest.cpp	/^void ArenaTester::allocate(size_t count, size_t maxSize) {$/;"	f	class:__anon143::ArenaTester	signature:(size_t count, size_t maxSize)
__anon143::ArenaTester::areas_	.\test\ThreadCachedArenaTest.cpp	/^  std::vector<std::pair<uint8_t, Range<uint8_t*>>> areas_;$/;"	m	class:__anon143::ArenaTester	file:	access:private
__anon143::ArenaTester::arena_	.\test\ThreadCachedArenaTest.cpp	/^  ThreadCachedArena* arena_;$/;"	m	class:__anon143::ArenaTester	file:	access:private
__anon143::ArenaTester::merge	.\test\ThreadCachedArenaTest.cpp	/^  void merge(ArenaTester&& other);$/;"	p	class:__anon143::ArenaTester	file:	access:public	signature:(ArenaTester&& other)
__anon143::ArenaTester::merge	.\test\ThreadCachedArenaTest.cpp	/^void ArenaTester::merge(ArenaTester&& other) {$/;"	f	class:__anon143::ArenaTester	signature:(ArenaTester&& other)
__anon143::ArenaTester::mergeMutex_	.\test\ThreadCachedArenaTest.cpp	/^  std::mutex mergeMutex_;$/;"	m	class:__anon143::ArenaTester	file:	access:private
__anon143::ArenaTester::verify	.\test\ThreadCachedArenaTest.cpp	/^  void verify();$/;"	p	class:__anon143::ArenaTester	file:	access:public	signature:()
__anon143::ArenaTester::verify	.\test\ThreadCachedArenaTest.cpp	/^void ArenaTester::verify() {$/;"	f	class:__anon143::ArenaTester	signature:()
__anon144::BENCHMARK	.\test\ThreadCachedArenaTest.cpp	/^BENCHMARK(bmMArena, iters) {$/;"	f	namespace:__anon144	signature:(bmMArena, iters)
__anon144::BENCHMARK	.\test\ThreadCachedArenaTest.cpp	/^BENCHMARK(bmMStandard, iters) {$/;"	f	namespace:__anon144	signature:(bmMStandard, iters)
__anon144::BENCHMARK	.\test\ThreadCachedArenaTest.cpp	/^BENCHMARK(bmUMArena, iters) {$/;"	f	namespace:__anon144	signature:(bmUMArena, iters)
__anon144::BENCHMARK	.\test\ThreadCachedArenaTest.cpp	/^BENCHMARK(bmUMStandard, iters) {$/;"	f	namespace:__anon144	signature:(bmUMStandard, iters)
__anon144::kNumValues	.\test\ThreadCachedArenaTest.cpp	/^static const int kNumValues = 10000;$/;"	m	namespace:__anon144	file:
__anon145::Foo	.\test\ThreadLocalTest.cpp	/^struct Foo {$/;"	s	namespace:__anon145	file:
__anon145::Foo::tl	.\test\ThreadLocalTest.cpp	/^  folly::ThreadLocal<int, Tag> tl;$/;"	m	struct:__anon145::Foo	file:	access:public
__anon145::Tag	.\test\ThreadLocalTest.cpp	/^struct Tag {};$/;"	s	namespace:__anon145	file:
__anon146::FillObject	.\test\ThreadLocalTest.cpp	/^class FillObject {$/;"	c	namespace:__anon146	file:
__anon146::FillObject::FillObject	.\test\ThreadLocalTest.cpp	/^  explicit FillObject(uint64_t idx) : idx_(idx) {$/;"	f	class:__anon146::FillObject	access:public	signature:(uint64_t idx)
__anon146::FillObject::check	.\test\ThreadLocalTest.cpp	/^  void check() {$/;"	f	class:__anon146::FillObject	access:public	signature:()
__anon146::FillObject::data_	.\test\ThreadLocalTest.cpp	/^  uint64_t data_[kFillObjectSize];$/;"	m	class:__anon146::FillObject	file:	access:private
__anon146::FillObject::idx_	.\test\ThreadLocalTest.cpp	/^  uint64_t idx_;$/;"	m	class:__anon146::FillObject	file:	access:private
__anon146::FillObject::val	.\test\ThreadLocalTest.cpp	/^  uint64_t val() const {$/;"	f	class:__anon146::FillObject	file:	access:private	signature:() const
__anon146::FillObject::~FillObject	.\test\ThreadLocalTest.cpp	/^  ~FillObject() {$/;"	f	class:__anon146::FillObject	access:public	signature:()
__anon146::gDestroyed	.\test\ThreadLocalTest.cpp	/^std::atomic<uint64_t> gDestroyed;$/;"	m	namespace:__anon146	file:
__anon146::kFillObjectSize	.\test\ThreadLocalTest.cpp	/^constexpr size_t kFillObjectSize = 300;$/;"	m	namespace:__anon146	file:
__anon147::HoldsOne	.\test\ThreadLocalTest.cpp	/^class HoldsOne {$/;"	c	namespace:__anon147	file:
__anon147::HoldsOne::HoldsOne	.\test\ThreadLocalTest.cpp	/^  HoldsOne() : value_(1) { }$/;"	f	class:__anon147::HoldsOne	access:public	signature:()
__anon147::HoldsOne::value	.\test\ThreadLocalTest.cpp	/^  int value() const { return value_; }$/;"	f	class:__anon147::HoldsOne	access:public	signature:() const
__anon147::HoldsOne::value_	.\test\ThreadLocalTest.cpp	/^  int value_;$/;"	m	class:__anon147::HoldsOne	file:	access:private
__anon147::HoldsOneTag	.\test\ThreadLocalTest.cpp	/^struct HoldsOneTag {};$/;"	s	namespace:__anon147	file:
__anon147::ptr	.\test\ThreadLocalTest.cpp	/^ThreadLocal<HoldsOne, HoldsOneTag> ptr;$/;"	m	namespace:__anon147	file:
__anon147::totalValue	.\test\ThreadLocalTest.cpp	/^int totalValue() {$/;"	f	namespace:__anon147	signature:()
__anon22::GetExceptionStackTraceStackType	.\experimental\exception_tracer\ExceptionTracer.cpp	/^typedef StackTraceStack* (*GetExceptionStackTraceStackType)(void);$/;"	t	file:
__anon22::getExceptionStackTraceStack	.\experimental\exception_tracer\ExceptionTracer.cpp	/^StackTraceStack* getExceptionStackTraceStack(void) __attribute__((__weak__));$/;"	p	file:	signature:(void)
__anon22::getExceptionStackTraceStackFn	.\experimental\exception_tracer\ExceptionTracer.cpp	/^GetExceptionStackTraceStackType getExceptionStackTraceStackFn;$/;"	v
__anon25::CxaBeginCatchType	.\experimental\exception_tracer\ExceptionTracerLib.cpp	/^typedef void* (*CxaBeginCatchType)(void*);$/;"	t	file:
__anon25::CxaEndCatchType	.\experimental\exception_tracer\ExceptionTracerLib.cpp	/^typedef void (*CxaEndCatchType)(void);$/;"	t	file:
__anon25::CxaRethrowType	.\experimental\exception_tracer\ExceptionTracerLib.cpp	/^FOLLY_NORETURN typedef void (*CxaRethrowType)(void);$/;"	t	file:
__anon25::CxaThrowType	.\experimental\exception_tracer\ExceptionTracerLib.cpp	/^FOLLY_NORETURN typedef void (*CxaThrowType)(void*, std::type_info*,$/;"	t	file:
__anon25::RethrowExceptionType	.\experimental\exception_tracer\ExceptionTracerLib.cpp	/^FOLLY_NORETURN typedef void (*RethrowExceptionType)(std::exception_ptr);$/;"	t	namespace:__anon25	file:
__anon25::activeExceptions	.\experimental\exception_tracer\ExceptionTracerLib.cpp	/^FOLLY_TLS StackTraceStack activeExceptions;$/;"	m	namespace:__anon25	file:
__anon25::caughtExceptions	.\experimental\exception_tracer\ExceptionTracerLib.cpp	/^FOLLY_TLS StackTraceStack caughtExceptions;$/;"	m	namespace:__anon25	file:
__anon25::initialize	.\experimental\exception_tracer\ExceptionTracerLib.cpp	/^void initialize() {$/;"	f	namespace:__anon25	signature:()
__anon25::initialized	.\experimental\exception_tracer\ExceptionTracerLib.cpp	/^pthread_once_t initialized = PTHREAD_ONCE_INIT;$/;"	m	namespace:__anon25	file:
__anon25::invalid	.\experimental\exception_tracer\ExceptionTracerLib.cpp	/^FOLLY_TLS bool invalid;$/;"	m	namespace:__anon25	file:
__anon25::orig_cxa_begin_catch	.\experimental\exception_tracer\ExceptionTracerLib.cpp	/^CxaBeginCatchType orig_cxa_begin_catch;$/;"	v
__anon25::orig_cxa_end_catch	.\experimental\exception_tracer\ExceptionTracerLib.cpp	/^CxaEndCatchType orig_cxa_end_catch;$/;"	v
__anon25::orig_cxa_rethrow	.\experimental\exception_tracer\ExceptionTracerLib.cpp	/^CxaRethrowType orig_cxa_rethrow;$/;"	v
__anon25::orig_cxa_throw	.\experimental\exception_tracer\ExceptionTracerLib.cpp	/^CxaThrowType orig_cxa_throw;$/;"	v
__anon25::orig_rethrow_exception	.\experimental\exception_tracer\ExceptionTracerLib.cpp	/^RethrowExceptionType orig_rethrow_exception;$/;"	m	namespace:__anon25	file:
__anon26::addActiveException	.\experimental\exception_tracer\ExceptionTracerLib.cpp	/^FOLLY_NOINLINE void addActiveException();$/;"	p	namespace:__anon26	file:	signature:()
__anon26::addActiveException	.\experimental\exception_tracer\ExceptionTracerLib.cpp	/^void addActiveException() {$/;"	f	namespace:__anon26	signature:()
__anon26::moveTopException	.\experimental\exception_tracer\ExceptionTracerLib.cpp	/^void moveTopException(StackTraceStack& from, StackTraceStack& to) {$/;"	f	namespace:__anon26	signature:(StackTraceStack& from, StackTraceStack& to)
__anon27::Initializer	.\experimental\exception_tracer\ExceptionTracerLib.cpp	/^struct Initializer {$/;"	s	namespace:__anon27	file:
__anon27::Initializer::Initializer	.\experimental\exception_tracer\ExceptionTracerLib.cpp	/^  Initializer() {$/;"	f	struct:__anon27::Initializer	access:public	signature:()
__anon27::initializer	.\experimental\exception_tracer\ExceptionTracerLib.cpp	/^Initializer initializer;$/;"	m	namespace:__anon27	file:
__anon31::copy	.\experimental\io\HugePageUtil.cpp	/^void copy(const char* srcFile, const char* dest) {$/;"	f	namespace:__anon31	signature:(const char* srcFile, const char* dest)
__anon31::list	.\experimental\io\HugePageUtil.cpp	/^void list() {$/;"	f	namespace:__anon31	signature:()
__anon31::usage	.\experimental\io\HugePageUtil.cpp	/^FOLLY_NORETURN void usage(const char* name);$/;"	p	namespace:__anon31	file:	signature:(const char* name)
__anon31::usage	.\experimental\io\HugePageUtil.cpp	/^void usage(const char* name) {$/;"	f	namespace:__anon31	signature:(const char* name)
__anon32::ManagedBuffer	.\experimental\io\test\AsyncIOTest.cpp	/^typedef std::unique_ptr<char, void(*)(void*)> ManagedBuffer;$/;"	t	namespace:__anon32	file:
__anon32::TemporaryFile	.\experimental\io\test\AsyncIOTest.cpp	/^class TemporaryFile {$/;"	c	namespace:__anon32	file:
__anon32::TemporaryFile::TemporaryFile	.\experimental\io\test\AsyncIOTest.cpp	/^  explicit TemporaryFile(size_t size);$/;"	p	class:__anon32::TemporaryFile	file:	access:public	signature:(size_t size)
__anon32::TemporaryFile::TemporaryFile	.\experimental\io\test\AsyncIOTest.cpp	/^TemporaryFile::TemporaryFile(size_t size)$/;"	f	class:__anon32::TemporaryFile	signature:(size_t size)
__anon32::TemporaryFile::path	.\experimental\io\test\AsyncIOTest.cpp	/^  const fs::path path() const { return path_; }$/;"	f	class:__anon32::TemporaryFile	access:public	signature:() const
__anon32::TemporaryFile::path_	.\experimental\io\test\AsyncIOTest.cpp	/^  fs::path path_;$/;"	m	class:__anon32::TemporaryFile	file:	access:private
__anon32::TemporaryFile::~TemporaryFile	.\experimental\io\test\AsyncIOTest.cpp	/^  ~TemporaryFile();$/;"	p	class:__anon32::TemporaryFile	file:	access:public	signature:()
__anon32::TemporaryFile::~TemporaryFile	.\experimental\io\test\AsyncIOTest.cpp	/^TemporaryFile::~TemporaryFile() {$/;"	f	class:__anon32::TemporaryFile	signature:()
__anon32::TestSpec	.\experimental\io\test\AsyncIOTest.cpp	/^struct TestSpec {$/;"	s	namespace:__anon32	file:
__anon32::TestSpec::size	.\experimental\io\test\AsyncIOTest.cpp	/^  size_t size;$/;"	m	struct:__anon32::TestSpec	file:	access:public
__anon32::TestSpec::start	.\experimental\io\test\AsyncIOTest.cpp	/^  off_t start;$/;"	m	struct:__anon32::TestSpec	file:	access:public
__anon32::allocateAligned	.\experimental\io\test\AsyncIOTest.cpp	/^ManagedBuffer allocateAligned(size_t size) {$/;"	f	namespace:__anon32	signature:(size_t size)
__anon32::kAlign	.\experimental\io\test\AsyncIOTest.cpp	/^constexpr size_t kAlign = 4096;  \/\/ align reads to 4096 B (for O_DIRECT)$/;"	m	namespace:__anon32	file:
__anon32::readerWait	.\experimental\io\test\AsyncIOTest.cpp	/^folly::Range<AsyncIO::Op**> readerWait(AsyncIO* reader) {$/;"	f	namespace:__anon32	signature:(AsyncIO* reader)
__anon32::testReads	.\experimental\io\test\AsyncIOTest.cpp	/^void testReads(const std::vector<TestSpec>& specs,$/;"	f	namespace:__anon32	signature:(const std::vector<TestSpec>& specs, AsyncIO::PollMode pollMode)
__anon32::testReadsParallel	.\experimental\io\test\AsyncIOTest.cpp	/^void testReadsParallel(const std::vector<TestSpec>& specs,$/;"	f	namespace:__anon32	signature:(const std::vector<TestSpec>& specs, AsyncIO::PollMode pollMode, bool multithreaded)
__anon32::testReadsQueued	.\experimental\io\test\AsyncIOTest.cpp	/^void testReadsQueued(const std::vector<TestSpec>& specs,$/;"	f	namespace:__anon32	signature:(const std::vector<TestSpec>& specs, AsyncIO::PollMode pollMode)
__anon32::testReadsSerially	.\experimental\io\test\AsyncIOTest.cpp	/^void testReadsSerially(const std::vector<TestSpec>& specs,$/;"	f	namespace:__anon32	signature:(const std::vector<TestSpec>& specs, AsyncIO::PollMode pollMode)
__anon32::waitUntilReadable	.\experimental\io\test\AsyncIOTest.cpp	/^void waitUntilReadable(int fd) {$/;"	f	namespace:__anon32	signature:(int fd)
__anon33::expectPathEq	.\experimental\io\test\FsUtilTest.cpp	/^void expectPathEq(const path& a, const path& b) {$/;"	f	namespace:__anon33	signature:(const path& a, const path& b)
__anon3::Type_popcount	.\Bits.cpp	/^typedef decltype(popcount_builtin) Type_popcount;$/;"	t	namespace:__anon3	file:
__anon3::Type_popcountll	.\Bits.cpp	/^typedef decltype(popcountll_builtin) Type_popcountll;$/;"	t	namespace:__anon3	file:
__anon3::folly_popcount_ifunc	.\Bits.cpp	/^extern "C" Type_popcount* folly_popcount_ifunc() {$/;"	f	namespace:__anon3	signature:()
__anon3::folly_popcountll_ifunc	.\Bits.cpp	/^extern "C" Type_popcountll* folly_popcountll_ifunc() {$/;"	f	namespace:__anon3	signature:()
__anon3::popcount_builtin	.\Bits.cpp	/^int popcount_builtin(unsigned int x) {$/;"	f	namespace:__anon3	signature:(unsigned int x)
__anon3::popcount_inst	.\Bits.cpp	/^int popcount_inst(unsigned int x) {$/;"	f	namespace:__anon3	signature:(unsigned int x)
__anon3::popcountll_builtin	.\Bits.cpp	/^int popcountll_builtin(unsigned long long x) {$/;"	f	namespace:__anon3	signature:(unsigned long long x)
__anon3::popcountll_inst	.\Bits.cpp	/^int popcountll_inst(unsigned long long x) {$/;"	f	namespace:__anon3	signature:(unsigned long long x)
__anon45::testGet	.\experimental\test\BitsTest.cpp	/^typename std::enable_if<!aligned, T>::type testGet(uint8_t *buf,$/;"	f	namespace:__anon45	signature:(uint8_t *buf, size_t start, size_t bits)
__anon45::testGet	.\experimental\test\BitsTest.cpp	/^typename std::enable_if<aligned, T>::type testGet(uint8_t *buf,$/;"	f	namespace:__anon45	signature:(uint8_t *buf, size_t start, size_t bits)
__anon45::testSet	.\experimental\test\BitsTest.cpp	/^typename std::enable_if<!aligned>::type testSet(uint8_t *buf,$/;"	f	namespace:__anon45	signature:(uint8_t *buf, size_t start, size_t bits, T value)
__anon45::testSet	.\experimental\test\BitsTest.cpp	/^typename std::enable_if<aligned>::type testSet(uint8_t *buf,$/;"	f	namespace:__anon45	signature:(uint8_t *buf, size_t start, size_t bits, T value)
__anon45::testValue	.\experimental\test\BitsTest.cpp	/^T testValue(int bits) {$/;"	f	namespace:__anon45	signature:(int bits)
__anon46::Semaphore	.\experimental\test\EventCountTest.cpp	/^class Semaphore {$/;"	c	namespace:__anon46	file:
__anon46::Semaphore::Semaphore	.\experimental\test\EventCountTest.cpp	/^  explicit Semaphore(int v=0) : value_(v) { }$/;"	f	class:__anon46::Semaphore	access:public	signature:(int v=0)
__anon46::Semaphore::down	.\experimental\test\EventCountTest.cpp	/^  void down() {$/;"	f	class:__anon46::Semaphore	access:public	signature:()
__anon46::Semaphore::ec_	.\experimental\test\EventCountTest.cpp	/^  EventCount ec_;$/;"	m	class:__anon46::Semaphore	file:	access:private
__anon46::Semaphore::tryDown	.\experimental\test\EventCountTest.cpp	/^  bool tryDown() {$/;"	f	class:__anon46::Semaphore	file:	access:private	signature:()
__anon46::Semaphore::up	.\experimental\test\EventCountTest.cpp	/^  void up() {$/;"	f	class:__anon46::Semaphore	access:public	signature:()
__anon46::Semaphore::value	.\experimental\test\EventCountTest.cpp	/^  int value() const {$/;"	f	class:__anon46::Semaphore	access:public	signature:() const
__anon46::Semaphore::value_	.\experimental\test\EventCountTest.cpp	/^  std::atomic<int> value_;$/;"	m	class:__anon46::Semaphore	file:	access:private
__anon46::randomPartition	.\experimental\test\EventCountTest.cpp	/^void randomPartition(Random& random, T key, int n,$/;"	f	namespace:__anon46	signature:(Random& random, T key, int n, std::vector<std::pair<T, int>>& out)
__anon47::global_watchdog	.\experimental\test\SingletonTest.cpp	/^Singleton<GlobalWatchdog> global_watchdog;$/;"	m	namespace:__anon47	file:
__anon4::computeTables	.\build\GenerateFingerprintTables.cpp	/^void computeTables(FILE* file, const FingerprintPolynomial<DEG>& poly) {$/;"	f	namespace:__anon4	signature:(FILE* file, const FingerprintPolynomial<DEG>& poly)
__anon56::TestIntSeq	.\gen\test\BaseTest.cpp	/^class TestIntSeq : public GenImpl<int, TestIntSeq> {$/;"	c	namespace:__anon56	file:	inherits:GenImpl
__anon56::TestIntSeq::TestIntSeq	.\gen\test\BaseTest.cpp	/^  TestIntSeq() { }$/;"	f	class:__anon56::TestIntSeq	access:public	signature:()
__anon56::TestIntSeq::TestIntSeq	.\gen\test\BaseTest.cpp	/^  TestIntSeq(const TestIntSeq&) = delete;$/;"	p	class:__anon56::TestIntSeq	file:	access:public	signature:(const TestIntSeq&)
__anon56::TestIntSeq::apply	.\gen\test\BaseTest.cpp	/^  bool apply(Body&& body) const {$/;"	f	class:__anon56::TestIntSeq	access:public	signature:(Body&& body) const
__anon56::TestIntSeq::noexcept	.\gen\test\BaseTest.cpp	/^  TestIntSeq& operator=(TestIntSeq&&) noexcept = default;$/;"	m	class:__anon56::TestIntSeq	file:	access:public
__anon56::TestIntSeq::noexcept	.\gen\test\BaseTest.cpp	/^  TestIntSeq(TestIntSeq&&) noexcept = default;$/;"	m	class:__anon56::TestIntSeq	file:	access:public
__anon56::TestIntSeq::operator =	.\gen\test\BaseTest.cpp	/^  TestIntSeq& operator=(const TestIntSeq&) = delete;$/;"	p	class:__anon56::TestIntSeq	file:	access:public	signature:(const TestIntSeq&)
__anon57::operator ()	.\gen\test\ParallelTest.cpp	/^  std::unique_ptr<T> operator()(T t) const {$/;"	f	struct:__anon57	access:public	signature:(T t) const
__anon58::bigLines	.\gen\test\StringBenchmark.cpp	/^std::string bigLines;$/;"	m	namespace:__anon58	file:
__anon58::initStringResplitterBenchmark	.\gen\test\StringBenchmark.cpp	/^void initStringResplitterBenchmark() {$/;"	f	namespace:__anon58	signature:()
__anon58::kLine	.\gen\test\StringBenchmark.cpp	/^const char* const kLine = "The quick brown fox jumped over the lazy dog.\\n";$/;"	m	namespace:__anon58	file:
__anon58::kLineCount	.\gen\test\StringBenchmark.cpp	/^const size_t kLineCount = 10000;$/;"	m	namespace:__anon58	file:
__anon58::kSmallLineSize	.\gen\test\StringBenchmark.cpp	/^const size_t kSmallLineSize = 17;$/;"	m	namespace:__anon58	file:
__anon58::len	.\gen\test\StringBenchmark.cpp	/^size_t len(folly::StringPiece s) { return s.size(); }$/;"	f	namespace:__anon58	signature:(folly::StringPiece s)
__anon58::smallLines	.\gen\test\StringBenchmark.cpp	/^std::vector<std::string> smallLines;$/;"	m	namespace:__anon58	file:
__anon58::testStrVector	.\gen\test\StringBenchmark.cpp	/^static vector<fbstring> testStrVector$/;"	m	namespace:__anon58	file:
__anon62::FunctionLoopCallback	.\io\async\EventBase.cpp	/^class FunctionLoopCallback : public EventBase::LoopCallback {$/;"	c	namespace:__anon62	file:	inherits:EventBase::LoopCallback
__anon62::FunctionLoopCallback::FunctionLoopCallback	.\io\async\EventBase.cpp	/^  explicit FunctionLoopCallback(Cob&& function)$/;"	f	class:__anon62::FunctionLoopCallback	access:public	signature:(Cob&& function)
__anon62::FunctionLoopCallback::FunctionLoopCallback	.\io\async\EventBase.cpp	/^  explicit FunctionLoopCallback(const Cob& function)$/;"	f	class:__anon62::FunctionLoopCallback	access:public	signature:(const Cob& function)
__anon62::FunctionLoopCallback::function_	.\io\async\EventBase.cpp	/^  Callback function_;$/;"	m	class:__anon62::FunctionLoopCallback	file:	access:private
__anon66::takeOwnershipError	.\io\IOBuf.cpp	/^void takeOwnershipError(bool freeOnError, void* buf,$/;"	f	namespace:__anon66	signature:(bool freeOnError, void* buf, folly::IOBuf::FreeFunction freeFn, void* userData)
__anon67::MAX_ALLOC_SIZE	.\io\IOBufQueue.cpp	/^const size_t MAX_ALLOC_SIZE = 8000;$/;"	m	namespace:__anon67	file:
__anon67::MAX_PACK_COPY	.\io\IOBufQueue.cpp	/^const size_t MAX_PACK_COPY = 4096;$/;"	m	namespace:__anon67	file:
__anon67::MIN_ALLOC_SIZE	.\io\IOBufQueue.cpp	/^const size_t MIN_ALLOC_SIZE = 2000;$/;"	m	namespace:__anon67	file:
__anon67::appendToChain	.\io\IOBufQueue.cpp	/^appendToChain(unique_ptr<IOBuf>& dst, unique_ptr<IOBuf>&& src, bool pack) {$/;"	f	namespace:__anon67	signature:(unique_ptr<IOBuf>& dst, unique_ptr<IOBuf>&& src, bool pack)
__anon69::append	.\io\test\IOBufCursorTest.cpp	/^void append(Appender& appender, folly::StringPiece data) {$/;"	f	namespace:__anon69	signature:(Appender& appender, folly::StringPiece data)
__anon69::append	.\io\test\IOBufCursorTest.cpp	/^void append(std::unique_ptr<IOBuf>& buf, folly::StringPiece data) {$/;"	f	namespace:__anon69	signature:(std::unique_ptr<IOBuf>& buf, folly::StringPiece data)
__anon69::toString	.\io\test\IOBufCursorTest.cpp	/^std::string toString(const IOBuf& buf) {$/;"	f	namespace:__anon69	signature:(const IOBuf& buf)
__anon70::Initializer	.\io\test\IOBufQueueTest.cpp	/^struct Initializer {$/;"	s	namespace:__anon70	file:
__anon70::Initializer::Initializer	.\io\test\IOBufQueueTest.cpp	/^  Initializer() {$/;"	f	struct:__anon70::Initializer	access:public	signature:()
__anon70::checkConsistency	.\io\test\IOBufQueueTest.cpp	/^void checkConsistency(const IOBufQueue& queue) {$/;"	f	namespace:__anon70	signature:(const IOBufQueue& queue)
__anon70::clOptions	.\io\test\IOBufQueueTest.cpp	/^IOBufQueue::Options clOptions;$/;"	m	namespace:__anon70	file:
__anon70::initializer	.\io\test\IOBufQueueTest.cpp	/^Initializer initializer;$/;"	m	namespace:__anon70	file:
__anon70::stringToIOBuf	.\io\test\IOBufQueueTest.cpp	/^stringToIOBuf(const char* s, uint32_t len) {$/;"	f	namespace:__anon70	signature:(const char* s, uint32_t len)
__anon71::CustomDeleter	.\io\test\IOBufTest.cpp	/^typedef std::function<void(OwnershipTestClass*)> CustomDeleter;$/;"	t	namespace:__anon71	file:
__anon71::OwnershipTestClass	.\io\test\IOBufTest.cpp	/^struct OwnershipTestClass {$/;"	s	namespace:__anon71	file:
__anon71::OwnershipTestClass::OwnershipTestClass	.\io\test\IOBufTest.cpp	/^  explicit OwnershipTestClass(int v = 0) : val(v) { }$/;"	f	struct:__anon71::OwnershipTestClass	access:public	signature:(int v = 0)
__anon71::OwnershipTestClass::val	.\io\test\IOBufTest.cpp	/^  int val;$/;"	m	struct:__anon71::OwnershipTestClass	file:	access:public
__anon71::OwnershipTestClass::~OwnershipTestClass	.\io\test\IOBufTest.cpp	/^  ~OwnershipTestClass() {$/;"	f	struct:__anon71::OwnershipTestClass	access:public	signature:()
__anon71::customDelete	.\io\test\IOBufTest.cpp	/^void customDelete(OwnershipTestClass* p) {$/;"	f	namespace:__anon71	signature:(OwnershipTestClass* p)
__anon71::customDeleteArray	.\io\test\IOBufTest.cpp	/^void customDeleteArray(OwnershipTestClass* p) {$/;"	f	namespace:__anon71	signature:(OwnershipTestClass* p)
__anon71::customDeleterCount	.\io\test\IOBufTest.cpp	/^int customDeleterCount = 0;$/;"	m	namespace:__anon71	file:
__anon71::destructorCount	.\io\test\IOBufTest.cpp	/^int destructorCount = 0;$/;"	m	namespace:__anon71	file:
__anon72::fromStr	.\io\test\IOBufTest.cpp	/^std::unique_ptr<IOBuf> fromStr(StringPiece sp) {$/;"	f	namespace:__anon72	signature:(StringPiece sp)
__anon90::HostAndPort	.\SocketAddress.cpp	/^struct HostAndPort {$/;"	s	namespace:__anon90	file:
__anon90::HostAndPort::HostAndPort	.\SocketAddress.cpp	/^  HostAndPort(const char* str, bool hostRequired)$/;"	f	struct:__anon90::HostAndPort	access:public	signature:(const char* str, bool hostRequired)
__anon90::HostAndPort::allocated	.\SocketAddress.cpp	/^  char* allocated;$/;"	m	struct:__anon90::HostAndPort	file:	access:public
__anon90::HostAndPort::host	.\SocketAddress.cpp	/^  const char* host;$/;"	m	struct:__anon90::HostAndPort	file:	access:public
__anon90::HostAndPort::port	.\SocketAddress.cpp	/^  const char* port;$/;"	m	struct:__anon90::HostAndPort	file:	access:public
__anon90::HostAndPort::~HostAndPort	.\SocketAddress.cpp	/^  ~HostAndPort() {$/;"	f	struct:__anon90::HostAndPort	access:public	signature:()
__anon90::ScopedAddrInfo	.\SocketAddress.cpp	/^struct ScopedAddrInfo {$/;"	s	namespace:__anon90	file:
__anon90::ScopedAddrInfo::ScopedAddrInfo	.\SocketAddress.cpp	/^  explicit ScopedAddrInfo(struct addrinfo* info) : info(info) {}$/;"	f	struct:__anon90::ScopedAddrInfo	access:public	signature:(struct addrinfo* info)
__anon90::ScopedAddrInfo::info	.\SocketAddress.cpp	/^  struct addrinfo* info;$/;"	m	struct:__anon90::ScopedAddrInfo	typeref:struct:__anon90::ScopedAddrInfo::addrinfo	file:	access:public
__anon90::ScopedAddrInfo::~ScopedAddrInfo	.\SocketAddress.cpp	/^  ~ScopedAddrInfo() {$/;"	f	struct:__anon90::ScopedAddrInfo	access:public	signature:()
__anon9::my_strlcpy	.\Demangle.cpp	/^size_t my_strlcpy(char* dest, const char* src, size_t size) {$/;"	f	namespace:__anon9	signature:(char* dest, const char* src, size_t size)
__cxa_begin_catch	.\experimental\exception_tracer\ExceptionTracerLib.cpp	/^void* __cxa_begin_catch(void *excObj) {$/;"	f	namespace:__cxxabiv1	signature:(void *excObj)
__cxa_begin_catch	.\experimental\exception_tracer\ExceptionTracerLib.cpp	/^void* __cxa_begin_catch(void* excObj);$/;"	p	file:	signature:(void* excObj)
__cxa_eh_globals	.\detail\UncaughtExceptionCounter.h	/^struct __cxa_eh_globals;$/;"	x
__cxa_eh_globals	.\experimental\exception_tracer\ExceptionAbi.h	/^struct __cxa_eh_globals {$/;"	s	namespace:__cxxabiv1
__cxa_end_catch	.\experimental\exception_tracer\ExceptionTracerLib.cpp	/^void __cxa_end_catch() {$/;"	f	namespace:__cxxabiv1	signature:()
__cxa_end_catch	.\experimental\exception_tracer\ExceptionTracerLib.cpp	/^void __cxa_end_catch(void);$/;"	p	file:	signature:(void)
__cxa_exception	.\experimental\exception_tracer\ExceptionAbi.h	/^struct __cxa_exception {$/;"	s	namespace:__cxxabiv1
__cxa_rethrow	.\experimental\exception_tracer\ExceptionTracerLib.cpp	/^FOLLY_NORETURN void __cxa_rethrow(void);$/;"	p	file:	signature:(void)
__cxa_rethrow	.\experimental\exception_tracer\ExceptionTracerLib.cpp	/^void __cxa_rethrow() {$/;"	f	namespace:__cxxabiv1	signature:()
__cxa_throw	.\experimental\exception_tracer\ExceptionTracerLib.cpp	/^FOLLY_NORETURN void __cxa_throw(void* thrownException,$/;"	p	file:	signature:(void* thrownException, std::type_info* type, void (*destructor)(void))
__cxa_throw	.\experimental\exception_tracer\ExceptionTracerLib.cpp	/^void __cxa_throw(void* thrownException, std::type_info* type,$/;"	f	namespace:__cxxabiv1	signature:(void* thrownException, std::type_info* type, void (*destructor)(void))
__cxxabiv1	.\detail\UncaughtExceptionCounter.h	/^namespace __cxxabiv1 {$/;"	n
__cxxabiv1	.\experimental\exception_tracer\ExceptionAbi.h	/^namespace __cxxabiv1 {$/;"	n
__cxxabiv1	.\experimental\exception_tracer\ExceptionTracerLib.cpp	/^namespace __cxxabiv1 {$/;"	n	file:
__cxxabiv1::__cxa_begin_catch	.\experimental\exception_tracer\ExceptionTracerLib.cpp	/^void* __cxa_begin_catch(void *excObj) {$/;"	f	namespace:__cxxabiv1	signature:(void *excObj)
__cxxabiv1::__cxa_begin_catch	.\experimental\exception_tracer\ExceptionTracerLib.cpp	/^void* __cxa_begin_catch(void* excObj);$/;"	p	file:	signature:(void* excObj)
__cxxabiv1::__cxa_eh_globals	.\detail\UncaughtExceptionCounter.h	/^struct __cxa_eh_globals;$/;"	x
__cxxabiv1::__cxa_eh_globals	.\experimental\exception_tracer\ExceptionAbi.h	/^struct __cxa_eh_globals {$/;"	s	namespace:__cxxabiv1
__cxxabiv1::__cxa_eh_globals::caughtExceptions	.\experimental\exception_tracer\ExceptionAbi.h	/^  __cxa_exception* caughtExceptions;$/;"	m	struct:__cxxabiv1::__cxa_eh_globals	access:public
__cxxabiv1::__cxa_eh_globals::uncaughtExceptions	.\experimental\exception_tracer\ExceptionAbi.h	/^  unsigned int uncaughtExceptions;$/;"	m	struct:__cxxabiv1::__cxa_eh_globals	access:public
__cxxabiv1::__cxa_end_catch	.\experimental\exception_tracer\ExceptionTracerLib.cpp	/^void __cxa_end_catch() {$/;"	f	namespace:__cxxabiv1	signature:()
__cxxabiv1::__cxa_end_catch	.\experimental\exception_tracer\ExceptionTracerLib.cpp	/^void __cxa_end_catch(void);$/;"	p	file:	signature:(void)
__cxxabiv1::__cxa_exception	.\experimental\exception_tracer\ExceptionAbi.h	/^struct __cxa_exception {$/;"	s	namespace:__cxxabiv1
__cxxabiv1::__cxa_exception::actionRecord	.\experimental\exception_tracer\ExceptionAbi.h	/^  const char* actionRecord;$/;"	m	struct:__cxxabiv1::__cxa_exception	access:public
__cxxabiv1::__cxa_exception::adjustedPtr	.\experimental\exception_tracer\ExceptionAbi.h	/^  void* adjustedPtr;$/;"	m	struct:__cxxabiv1::__cxa_exception	access:public
__cxxabiv1::__cxa_exception::catchTemp	.\experimental\exception_tracer\ExceptionAbi.h	/^  void* catchTemp;$/;"	m	struct:__cxxabiv1::__cxa_exception	access:public
__cxxabiv1::__cxa_exception::exceptionDestructor	.\experimental\exception_tracer\ExceptionAbi.h	/^  void (*exceptionDestructor) (void*);$/;"	m	struct:__cxxabiv1::__cxa_exception	access:public
__cxxabiv1::__cxa_exception::exceptionType	.\experimental\exception_tracer\ExceptionAbi.h	/^  std::type_info* exceptionType;$/;"	m	struct:__cxxabiv1::__cxa_exception	access:public
__cxxabiv1::__cxa_exception::handlerCount	.\experimental\exception_tracer\ExceptionAbi.h	/^  int handlerCount;$/;"	m	struct:__cxxabiv1::__cxa_exception	access:public
__cxxabiv1::__cxa_exception::handlerSwitchValue	.\experimental\exception_tracer\ExceptionAbi.h	/^  int handlerSwitchValue;$/;"	m	struct:__cxxabiv1::__cxa_exception	access:public
__cxxabiv1::__cxa_exception::languageSpecificData	.\experimental\exception_tracer\ExceptionAbi.h	/^  const char* languageSpecificData;$/;"	m	struct:__cxxabiv1::__cxa_exception	access:public
__cxxabiv1::__cxa_exception::nextException	.\experimental\exception_tracer\ExceptionAbi.h	/^  __cxa_exception* nextException;$/;"	m	struct:__cxxabiv1::__cxa_exception	access:public
__cxxabiv1::__cxa_exception::terminateHandler	.\experimental\exception_tracer\ExceptionAbi.h	/^  std::terminate_handler terminateHandler;$/;"	m	struct:__cxxabiv1::__cxa_exception	access:public
__cxxabiv1::__cxa_exception::unexpectedHandler	.\experimental\exception_tracer\ExceptionAbi.h	/^  std::unexpected_handler unexpectedHandler;$/;"	m	struct:__cxxabiv1::__cxa_exception	access:public
__cxxabiv1::__cxa_exception::unwindHeader	.\experimental\exception_tracer\ExceptionAbi.h	/^  _Unwind_Exception unwindHeader;$/;"	m	struct:__cxxabiv1::__cxa_exception	access:public
__cxxabiv1::__cxa_rethrow	.\experimental\exception_tracer\ExceptionTracerLib.cpp	/^FOLLY_NORETURN void __cxa_rethrow(void);$/;"	p	file:	signature:(void)
__cxxabiv1::__cxa_rethrow	.\experimental\exception_tracer\ExceptionTracerLib.cpp	/^void __cxa_rethrow() {$/;"	f	namespace:__cxxabiv1	signature:()
__cxxabiv1::__cxa_throw	.\experimental\exception_tracer\ExceptionTracerLib.cpp	/^FOLLY_NORETURN void __cxa_throw(void* thrownException,$/;"	p	file:	signature:(void* thrownException, std::type_info* type, void (*destructor)(void))
__cxxabiv1::__cxa_throw	.\experimental\exception_tracer\ExceptionTracerLib.cpp	/^void __cxa_throw(void* thrownException, std::type_info* type,$/;"	f	namespace:__cxxabiv1	signature:(void* thrownException, std::type_info* type, void (*destructor)(void))
__cxxabiv1::noexcept	.\detail\UncaughtExceptionCounter.h	/^extern "C" __cxa_eh_globals* __cxa_get_globals() noexcept;$/;"	m	namespace:__cxxabiv1
__gnu_cxx	.\FBString.h	/^namespace __gnu_cxx {$/;"	n
__has_builtin	.\Checksum.cpp	28;"	d	file:
__throw_bad_alloc	.\detail\FunctionalExcept.cpp	/^void __throw_bad_alloc() {$/;"	f	signature:()
__throw_bad_alloc	.\detail\FunctionalExcept.h	/^FOLLY_NORETURN void __throw_bad_alloc();$/;"	p	signature:()
__throw_length_error	.\detail\FunctionalExcept.cpp	/^void __throw_length_error(const char* msg) {$/;"	f	signature:(const char* msg)
__throw_length_error	.\detail\FunctionalExcept.h	/^FOLLY_NORETURN void __throw_length_error(const char* msg);$/;"	p	signature:(const char* msg)
__throw_logic_error	.\detail\FunctionalExcept.cpp	/^void __throw_logic_error(const char* msg) {$/;"	f	signature:(const char* msg)
__throw_logic_error	.\detail\FunctionalExcept.h	/^FOLLY_NORETURN void __throw_logic_error(const char* msg);$/;"	p	signature:(const char* msg)
__throw_out_of_range	.\detail\FunctionalExcept.cpp	/^void __throw_out_of_range(const char* msg) {$/;"	f	signature:(const char* msg)
__throw_out_of_range	.\detail\FunctionalExcept.h	/^FOLLY_NORETURN void __throw_out_of_range(const char* msg);$/;"	p	signature:(const char* msg)
a	.\test\OptionalTest.cpp	/^  char a, b, c;$/;"	m	struct:folly::NoDefault	file:	access:public
a	.\test\small_vector_test.cpp	/^  int32_t a;$/;"	m	struct:__anon132::NontrivialType	file:	access:public
a	.\test\stl_tests\StlVectorTest.cpp	/^  std::allocator<T> a;$/;"	m	struct:Alloc	file:	access:public
aFunction	.\wangle\test\Thens.h	/^Ret aFunction(Params...);$/;"	p	signature:(Params....)
aFunction	.\wangle\test\Thens.h	/^aFunction(Params...) {$/;"	f	signature:(Params....)
aMethod	.\wangle\test\Thens.h	/^  Ret aMethod(Params...);$/;"	p	class:SomeClass	access:public	signature:(Params....)
aMethod	.\wangle\test\Thens.h	/^  aMethod(Params...) {$/;"	f	class:SomeClass	access:public	signature:(Params....)
aStaticMethod	.\wangle\test\Thens.h	/^  aStaticMethod(Params...) {$/;"	f	class:SomeClass	access:public	signature:(Params....)
aStaticMethod	.\wangle\test\Thens.h	/^  static Ret aStaticMethod(Params...);$/;"	p	class:SomeClass	access:public	signature:(Params....)
aStdFunction	.\wangle\test\Thens.h	/^aStdFunction(typename std::enable_if<!isFuture<Ret>::value, bool>::type = false) {$/;"	f	signature:(typename std::enable_if<!isFuture<Ret>::value, bool>::type = false)
aStdFunction	.\wangle\test\Thens.h	/^aStdFunction(typename std::enable_if<isFuture<Ret>::value, bool>::type = true) {$/;"	f	signature:(typename std::enable_if<isFuture<Ret>::value, bool>::type = true)
a_	.\test\PaddedTest.cpp	/^  IntAdaptor a_;$/;"	m	class:IntAdaptorTest	file:	access:protected
abbrev_	.\experimental\symbolizer\Dwarf.h	/^  folly::StringPiece abbrev_;     \/\/ .debug_abbrev$/;"	m	class:folly::symbolizer::Dwarf	access:private
accessAllThreads	.\ThreadLocal.h	/^  Accessor accessAllThreads() const {$/;"	f	class:folly::ThreadLocal	access:public	signature:() const
accessAllThreads	.\ThreadLocal.h	/^  Accessor accessAllThreads() const {$/;"	f	class:folly::ThreadLocalPtr	access:public	signature:() const
accessSet	.\test\ConcurrentSkipListBenchmark.cpp	/^  bool accessSet(int64_t id, int t) {$/;"	f	class:__anon113::ConcurrentAccessData	access:public	signature:(int64_t id, int t)
accessSkipList	.\test\ConcurrentSkipListBenchmark.cpp	/^  bool accessSkipList(int64_t id, int t) {$/;"	f	class:__anon113::ConcurrentAccessData	access:public	signature:(int64_t id, int t)
accessor_	.\ConcurrentSkipList.h	/^  Accessor accessor_;$/;"	m	class:folly::ConcurrentSkipList::Skipper	access:private
accessor_	.\ThreadLocal.h	/^      const Accessor* const accessor_;$/;"	m	class:folly::ThreadLocalPtr::Accessor::Iterator	access:private
acquire	.\Synchronized.h	/^    void acquire() {$/;"	f	struct:folly::Synchronized::ConstLockedPtr	access:private	signature:()
acquire	.\Synchronized.h	/^    void acquire() {$/;"	f	struct:folly::Synchronized::LockedPtr	access:private	signature:()
acquireGuard	.\ConcurrentSkipList-inl.h	/^  std::unique_lock<MicroSpinLock> acquireGuard() {$/;"	f	class:folly::detail::SkipListNode	access:public	signature:()
acquireLoadKey	.\AtomicHashArray.h	/^  static KeyT acquireLoadKey(const value_type& r) {$/;"	f	class:folly::AtomicHashArray	access:private	signature:(const value_type& r)
acquireRead	.\RWSpinLock.h	/^  friend void acquireRead(RWSpinLock& l) { return l.lock_shared(); }$/;"	f	class:folly::RWSpinLock	access:friend	signature:(RWSpinLock& l)
acquireRead	.\RWSpinLock.h	/^  friend void acquireRead(RWTicketSpinLockT& mutex) {$/;"	f	class:folly::RWTicketSpinLockT	access:friend	signature:(RWTicketSpinLockT& mutex)
acquireRead	.\Synchronized.h	/^acquireRead(T& mutex) {$/;"	f	namespace:folly::detail	signature:(T& mutex)
acquireRead	.\Synchronized.h	/^acquireRead(T& mutex,$/;"	f	namespace:folly::detail	signature:(T& mutex, unsigned int milliseconds)
acquireReadWrite	.\RWSpinLock.h	/^  friend bool acquireReadWrite(RWTicketSpinLockT& mutex,$/;"	f	class:folly::RWTicketSpinLockT	access:friend	signature:(RWTicketSpinLockT& mutex, unsigned int milliseconds)
acquireReadWrite	.\RWSpinLock.h	/^  friend void acquireReadWrite(RWSpinLock& l) { return l.lock(); }$/;"	f	class:folly::RWSpinLock	access:friend	signature:(RWSpinLock& l)
acquireReadWrite	.\RWSpinLock.h	/^  friend void acquireReadWrite(RWTicketSpinLockT& mutex) {$/;"	f	class:folly::RWTicketSpinLockT	access:friend	signature:(RWTicketSpinLockT& mutex)
acquireReadWrite	.\Synchronized.h	/^acquireReadWrite(T& mutex) {$/;"	f	namespace:folly::detail	signature:(T& mutex)
acquireReadWrite	.\Synchronized.h	/^acquireReadWrite(T& mutex,$/;"	f	namespace:folly::detail	signature:(T& mutex, unsigned int milliseconds)
action	.\wangle\ManualExecutor.h	/^      Action action;$/;"	m	struct:folly::wangle::ManualExecutor::ScheduledAction	access:public
actionRecord	.\experimental\exception_tracer\ExceptionAbi.h	/^  const char* actionRecord;$/;"	m	struct:__cxxabiv1::__cxa_exception	access:public
actions_	.\wangle\ManualExecutor.h	/^    std::queue<Action> actions_;$/;"	m	class:folly::wangle::ManualExecutor	access:private
activate	.\wangle\Future.h	/^  void activate() {$/;"	f	class:folly::wangle::Future	access:public	signature:()
activate	.\wangle\detail\State.h	/^  void activate() {$/;"	f	class:folly::wangle::detail::State	access:public	signature:()
activeExceptions	.\experimental\exception_tracer\ExceptionTracerLib.cpp	/^FOLLY_TLS StackTraceStack activeExceptions;$/;"	m	namespace:__anon25	file:
active_	.\test\DeterministicSchedule.h	/^  std::unordered_set<std::thread::id> active_;$/;"	m	class:folly::test::DeterministicSchedule	access:private
active_	.\wangle\detail\State.h	/^  bool active_ = true;$/;"	m	class:folly::wangle::detail::State	access:private
actualCapacity_	.\IndexedMemPool.h	/^  size_t actualCapacity_;$/;"	m	namespace:folly
add	.\ConcurrentSkipList-inl.h	/^  void add(NodeType* node) { }$/;"	f	class:folly::detail::NodeRecycler	access:public	signature:(NodeType* node)
add	.\ConcurrentSkipList-inl.h	/^  void add(NodeType* node) {$/;"	f	class:folly::detail::NodeRecycler	access:public	signature:(NodeType* node)
add	.\ConcurrentSkipList.h	/^  bool add(const key_type &data) { return sl_->addOrGetData(data).second; }$/;"	f	class:folly::ConcurrentSkipList::Accessor	access:public	signature:(const key_type &data)
add	.\GroupVarint.h	/^  void add(type val) {$/;"	f	class:folly::GroupVarintEncoder	access:public	signature:(type val)
add	.\Range.cpp	/^  inline void add(uint8_t i) {$/;"	f	class:folly::__anon83::FastByteSet	access:public	signature:(uint8_t i)
add	.\TimeoutQueue.cpp	/^TimeoutQueue::Id TimeoutQueue::add($/;"	f	class:folly::TimeoutQueue	signature:( int64_t now, int64_t delay, Callback callback)
add	.\TimeoutQueue.h	/^  Id add(int64_t now, int64_t delay, Callback callback);$/;"	p	class:folly::TimeoutQueue	access:public	signature:(int64_t now, int64_t delay, Callback callback)
add	.\detail\FingerprintPolynomial.h	/^  void add(const FingerprintPolynomial<DEG>& other) {$/;"	f	class:folly::detail::FingerprintPolynomial	access:public	signature:(const FingerprintPolynomial<DEG>& other)
add	.\detail\Stats.h	/^  void add(const ValueType& s, uint64_t c) {$/;"	f	struct:folly::detail::Bucket	access:public	signature:(const ValueType& s, uint64_t c)
add	.\experimental\EliasFanoCoding.h	/^  void add(ValueType value) {$/;"	f	struct:folly::compression::EliasFanoEncoder	access:public	signature:(ValueType value)
add	.\experimental\symbolizer\SignalHandler.cpp	/^  void add(SignalCallback func);$/;"	p	class:folly::symbolizer::__anon36::FatalSignalCallbackRegistry	file:	access:public	signature:(SignalCallback func)
add	.\experimental\symbolizer\SignalHandler.cpp	/^void FatalSignalCallbackRegistry::add(SignalCallback func) {$/;"	f	class:folly::symbolizer::__anon36::FatalSignalCallbackRegistry	signature:(SignalCallback func)
add	.\experimental\wangle\concurrent\BlockingQueue.h	/^  virtual void add(T item) = 0;$/;"	p	class:folly::wangle::BlockingQueue	access:public	signature:(T item)
add	.\experimental\wangle\concurrent\CPUThreadPoolExecutor.cpp	/^void CPUThreadPoolExecutor::add(Func func) {$/;"	f	class:folly::wangle::CPUThreadPoolExecutor	signature:(Func func)
add	.\experimental\wangle\concurrent\Executor.h	/^  virtual void add(Func func) = 0;$/;"	p	class:folly::wangle::Executor	access:public	signature:(Func func)
add	.\experimental\wangle\concurrent\IOThreadPoolExecutor.cpp	/^void IOThreadPoolExecutor::add(Func func) {$/;"	f	class:folly::wangle::IOThreadPoolExecutor	signature:(Func func)
add	.\experimental\wangle\concurrent\ThreadPoolExecutor.cpp	/^void ThreadPoolExecutor::StoppedThreadQueue::add($/;"	f	class:folly::wangle::ThreadPoolExecutor::StoppedThreadQueue	signature:( ThreadPoolExecutor::ThreadPtr item)
add	.\experimental\wangle\concurrent\ThreadPoolExecutor.h	/^    void add(const ThreadPtr& state) {$/;"	f	class:folly::wangle::ThreadPoolExecutor::ThreadList	access:public	signature:(const ThreadPtr& state)
add	.\gen\test\BaseBenchmark.cpp	/^auto add = [](int a, int b) { return a + b; };$/;"	v
add	.\gen\test\BaseTest.cpp	/^auto add = [](int a, int b) { return a + b; };$/;"	v
add	.\gen\test\ParallelBenchmark.cpp	/^static auto add = [](int a, int b) { return a + b; };$/;"	v	file:
add	.\test\ThreadLocalTest.cpp	/^  void add(int val) {$/;"	f	class:SimpleThreadCachedInt	access:public	signature:(int val)
add	.\wangle\Executor.h	/^     virtual void add(Action&&) = 0;$/;"	p	class:folly::wangle::Executor	access:public	signature:(Action&&)
add	.\wangle\ManualExecutor.cpp	/^void ManualExecutor::add(std::function<void()>&& callback) {$/;"	f	class:folly::wangle::ManualExecutor	signature:(std::function<void()>&& callback)
add	.\wangle\QueuedImmediateExecutor.cpp	/^void QueuedImmediateExecutor::add(Action&& callback)$/;"	f	class:folly::wangle::QueuedImmediateExecutor	signature:(Action&& callback)
addActiveException	.\experimental\exception_tracer\ExceptionTracerLib.cpp	/^FOLLY_NOINLINE void addActiveException();$/;"	p	namespace:__anon26	file:	signature:()
addActiveException	.\experimental\exception_tracer\ExceptionTracerLib.cpp	/^void addActiveException() {$/;"	f	namespace:__anon26	signature:()
addAsync	.\wangle\test\LaterTest.cpp	/^  void addAsync(int a, int b, std::function<void(int&&)>&& cob) {$/;"	f	struct:LaterFixture	access:public	signature:(int a, int b, std::function<void(int&&)>&& cob)
addBenchmark	.\Benchmark.h	/^addBenchmark(const char* file, const char* name, Lambda&& lambda) {$/;"	f	namespace:folly	signature:(const char* file, const char* name, Lambda&& lambda)
addBenchmarkImpl	.\Benchmark.cpp	/^void detail::addBenchmarkImpl(const char* file, const char* name,$/;"	f	class:folly::detail	signature:(const char* file, const char* name, BenchmarkFun fun)
addBenchmarkImpl	.\Benchmark.h	/^void addBenchmarkImpl(const char* file,$/;"	p	namespace:folly::detail	signature:(const char* file, const char* name, std::function<TimeIterPair(unsigned int)>)
addConnection	.\experimental\wangle\ConnectionManager.cpp	/^ConnectionManager::addConnection(ManagedConnection* connection,$/;"	f	class:folly::wangle::ConnectionManager	signature:(ManagedConnection* connection, bool timeout)
addConnection	.\experimental\wangle\ConnectionManager.h	/^  void addConnection(ManagedConnection* connection,$/;"	p	class:folly::wangle::ConnectionManager	access:public	signature:(ManagedConnection* connection, bool timeout = false)
addEast	.\wangle\GenericThreadGate.h	/^  void addEast(std::function<void()>&& fn) { eastExecutor->add(std::move(fn)); }$/;"	f	class:folly::wangle::GenericThreadGate	access:public	signature:(std::function<void()>&& fn)
addEast	.\wangle\ThreadGate.h	/^  virtual void addEast(std::function<void()>&&) = 0;$/;"	p	class:folly::wangle::ThreadGate	access:public	signature:(std::function<void()>&&)
addFatalSignalCallback	.\experimental\symbolizer\SignalHandler.cpp	/^void addFatalSignalCallback(SignalCallback cb) {$/;"	f	namespace:folly::symbolizer	signature:(SignalCallback cb)
addFatalSignalCallback	.\experimental\symbolizer\SignalHandler.h	/^void addFatalSignalCallback(SignalCallback callback);$/;"	p	namespace:folly::symbolizer	signature:(SignalCallback callback)
addOrGetData	.\ConcurrentSkipList.h	/^  std::pair<NodeType*, size_t> addOrGetData(U &&data) {$/;"	f	class:folly::ConcurrentSkipList	access:private	signature:(U &&data)
addOrGetData	.\ConcurrentSkipList.h	/^  std::pair<key_type*, bool> addOrGetData(const key_type &data) {$/;"	f	class:folly::ConcurrentSkipList::Accessor	access:public	signature:(const key_type &data)
addOutputBuffer	.\io\Compression.cpp	/^  std::unique_ptr<IOBuf> addOutputBuffer(lzma_stream* stream, size_t length);$/;"	p	class:folly::io::__anon64::FOLLY_FINAL	file:	access:private	signature:(lzma_stream* stream, size_t length)
addOutputBuffer	.\io\Compression.cpp	/^  std::unique_ptr<IOBuf> addOutputBuffer(z_stream* stream, uint32_t length);$/;"	p	class:folly::io::__anon64::FOLLY_FINAL	file:	access:private	signature:(z_stream* stream, uint32_t length)
addOutputBuffer	.\io\Compression.cpp	/^std::unique_ptr<IOBuf> LZMA2Codec::addOutputBuffer($/;"	f	class:folly::io::__anon64::LZMA2Codec	signature:( lzma_stream* stream, size_t length)
addOutputBuffer	.\io\Compression.cpp	/^std::unique_ptr<IOBuf> ZlibCodec::addOutputBuffer(z_stream* stream,$/;"	f	class:folly::io::__anon64::ZlibCodec	signature:(z_stream* stream, uint32_t length)
addParallel	.\RWSpinLock.h	/^  static inline uint32_t addParallel(__m128i in, __m128i kDelta) {$/;"	f	struct:folly::detail::RWTicketIntTrait	access:public	signature:(__m128i in, __m128i kDelta)
addParallel	.\RWSpinLock.h	/^  static inline uint64_t addParallel(__m128i in, __m128i kDelta) {$/;"	f	struct:folly::detail::RWTicketIntTrait	access:public	signature:(__m128i in, __m128i kDelta)
addPtr	.\wangle\Executor.h	/^     void addPtr(P fn) {$/;"	f	class:folly::wangle::Executor	access:public	signature:(P fn)
addRef	.\ConcurrentSkipList-inl.h	/^  int addRef() {$/;"	f	class:folly::detail::NodeRecycler	access:public	signature:()
addRef	.\ConcurrentSkipList-inl.h	/^  void addRef() { }$/;"	f	class:folly::detail::NodeRecycler	access:public	signature:()
addRepeatedValue	.\stats\Histogram.h	/^  void addRepeatedValue(ValueType value, uint64_t nSamples) {$/;"	f	class:folly::Histogram	access:public	signature:(ValueType value, uint64_t nSamples)
addRepeating	.\TimeoutQueue.cpp	/^TimeoutQueue::Id TimeoutQueue::addRepeating($/;"	f	class:folly::TimeoutQueue	signature:( int64_t now, int64_t interval, Callback callback)
addRepeating	.\TimeoutQueue.h	/^  Id addRepeating(int64_t now, int64_t interval, Callback callback);$/;"	p	class:folly::TimeoutQueue	access:public	signature:(int64_t now, int64_t interval, Callback callback)
addSample	.\io\async\EventBase.cpp	/^void EventBase::SmoothLoopTime::addSample(int64_t idle, int64_t busy) {$/;"	f	class:folly::EventBase::SmoothLoopTime	signature:(int64_t idle, int64_t busy)
addSample	.\io\async\EventBase.h	/^    void addSample(int64_t idle, int64_t busy);$/;"	p	class:folly::EventBase::SmoothLoopTime	access:public	signature:(int64_t idle, int64_t busy)
addThreads	.\experimental\wangle\concurrent\ThreadPoolExecutor.cpp	/^void ThreadPoolExecutor::addThreads(size_t n) {$/;"	f	class:folly::wangle::ThreadPoolExecutor	signature:(size_t n)
addThreads	.\experimental\wangle\concurrent\ThreadPoolExecutor.h	/^  void addThreads(size_t n);$/;"	p	class:folly::wangle::ThreadPoolExecutor	access:protected	signature:(size_t n)
addValue	.\stats\BucketedTimeSeries-defs.h	/^bool BucketedTimeSeries<VT, TT>::addValue(TimeType now, const ValueType& val) {$/;"	f	class:folly::BucketedTimeSeries	signature:(TimeType now, const ValueType& val)
addValue	.\stats\BucketedTimeSeries-defs.h	/^bool BucketedTimeSeries<VT, TT>::addValue(TimeType now,$/;"	f	class:folly::BucketedTimeSeries	signature:(TimeType now, const ValueType& val, int64_t times)
addValue	.\stats\BucketedTimeSeries.h	/^  bool addValue(TimeType now, const ValueType& val);$/;"	p	class:folly::BucketedTimeSeries	access:public	signature:(TimeType now, const ValueType& val)
addValue	.\stats\BucketedTimeSeries.h	/^  bool addValue(TimeType now, const ValueType& val, int64_t times);$/;"	p	class:folly::BucketedTimeSeries	access:public	signature:(TimeType now, const ValueType& val, int64_t times)
addValue	.\stats\Histogram.h	/^  void addValue(ValueType value) {$/;"	f	class:folly::Histogram	access:public	signature:(ValueType value)
addValue	.\stats\MultiLevelTimeSeries-defs.h	/^void MultiLevelTimeSeries<VT, TT>::addValue(TimeType now,$/;"	f	class:folly::MultiLevelTimeSeries	signature:(TimeType now, const ValueType& val)
addValue	.\stats\MultiLevelTimeSeries-defs.h	/^void MultiLevelTimeSeries<VT, TT>::addValue(TimeType now,$/;"	f	class:folly::MultiLevelTimeSeries	signature:(TimeType now, const ValueType& val, int64_t times)
addValue	.\stats\MultiLevelTimeSeries.h	/^  void addValue(TimeType now, const ValueType& val);$/;"	p	class:folly::MultiLevelTimeSeries	access:public	signature:(TimeType now, const ValueType& val)
addValue	.\stats\MultiLevelTimeSeries.h	/^  void addValue(TimeType now, const ValueType& val, int64_t times);$/;"	p	class:folly::MultiLevelTimeSeries	access:public	signature:(TimeType now, const ValueType& val, int64_t times)
addValue	.\stats\TimeseriesHistogram-defs.h	/^void TimeseriesHistogram<T, TT, C>::addValue(TimeType now,$/;"	f	class:folly::TimeseriesHistogram	signature:(TimeType now, const ValueType& value)
addValue	.\stats\TimeseriesHistogram-defs.h	/^void TimeseriesHistogram<T, TT, C>::addValue(TimeType now,$/;"	f	class:folly::TimeseriesHistogram	signature:(TimeType now, const ValueType& value, int64_t times)
addValue	.\stats\TimeseriesHistogram.h	/^  void addValue(TimeType now, const ValueType& value);$/;"	p	class:folly::TimeseriesHistogram	access:public	signature:(TimeType now, const ValueType& value)
addValue	.\stats\TimeseriesHistogram.h	/^  void addValue(TimeType now, const ValueType& value, int64_t times);$/;"	p	class:folly::TimeseriesHistogram	access:public	signature:(TimeType now, const ValueType& value, int64_t times)
addValue	.\test\HistogramBenchmark.cpp	/^void addValue(unsigned int n, int64_t bucketSize, int64_t min, int64_t max) {$/;"	f	signature:(unsigned int n, int64_t bucketSize, int64_t min, int64_t max)
addValue	.\test\TimeseriesBenchmark.cpp	/^void addValue(unsigned int iters,$/;"	f	signature:(unsigned int iters, seconds duration, size_t numBuckets, size_t callsPerSecond)
addValueAggregated	.\stats\BucketedTimeSeries-defs.h	/^bool BucketedTimeSeries<VT, TT>::addValueAggregated(TimeType now,$/;"	f	class:folly::BucketedTimeSeries	signature:(TimeType now, const ValueType& total, int64_t nsamples)
addValueAggregated	.\stats\BucketedTimeSeries.h	/^  bool addValueAggregated(TimeType now, const ValueType& sum, int64_t nsamples);$/;"	p	class:folly::BucketedTimeSeries	access:public	signature:(TimeType now, const ValueType& sum, int64_t nsamples)
addValueAggregated	.\stats\MultiLevelTimeSeries-defs.h	/^void MultiLevelTimeSeries<VT, TT>::addValueAggregated(TimeType now,$/;"	f	class:folly::MultiLevelTimeSeries	signature:(TimeType now, const ValueType& total, int64_t nsamples)
addValueAggregated	.\stats\MultiLevelTimeSeries.h	/^  void addValueAggregated(TimeType now, const ValueType& sum, int64_t nsamples);$/;"	p	class:folly::MultiLevelTimeSeries	access:public	signature:(TimeType now, const ValueType& sum, int64_t nsamples)
addValues	.\stats\TimeseriesHistogram-defs.h	/^void TimeseriesHistogram<T, TT, C>::addValues($/;"	f	class:folly::TimeseriesHistogram	signature:( TimeType now, const folly::Histogram<ValueType>& hist)
addValues	.\stats\TimeseriesHistogram.h	/^  void addValues(TimeType now, const folly::Histogram<ValueType>& values);$/;"	p	class:folly::TimeseriesHistogram	access:public	signature:(TimeType now, const folly::Histogram<ValueType>& values)
addWest	.\wangle\GenericThreadGate.h	/^  void addWest(std::function<void()>&& fn) { westExecutor->add(std::move(fn)); }$/;"	f	class:folly::wangle::GenericThreadGate	access:public	signature:(std::function<void()>&& fn)
addWest	.\wangle\ThreadGate.h	/^  virtual void addWest(std::function<void()>&&) = 0;$/;"	p	class:folly::wangle::ThreadGate	access:public	signature:(std::function<void()>&&)
addXk	.\detail\FingerprintPolynomial.h	/^  void addXk(int k) {$/;"	f	class:folly::detail::FingerprintPolynomial	access:public	signature:(int k)
addr	.\SocketAddress.h	/^    struct sockaddr_un *addr;$/;"	m	struct:folly::SocketAddress::ExternalUnixAddr	typeref:struct:folly::SocketAddress::ExternalUnixAddr::sockaddr_un	access:public
addr_	.\IPAddress.h	/^  IPAddressV46 addr_;$/;"	m	class:folly::IPAddress	access:private
addr_	.\IPAddressV4.h	/^  } addr_;$/;"	m	class:folly::IPAddressV4	typeref:union:folly::IPAddressV4::AddressStorage	access:private
addr_	.\IPAddressV6.h	/^  } addr_;$/;"	m	class:folly::IPAddressV6	typeref:union:folly::IPAddressV6::AddressStorage	access:private
address	.\Memory.h	/^  T* address(T& x) const {$/;"	f	class:folly::StlAllocator	access:public	signature:(T& x) const
address	.\Memory.h	/^  const T* address(const T& x) const {$/;"	f	class:folly::StlAllocator	access:public	signature:(const T& x) const
address	.\MemoryMapping.h	/^    void* address = nullptr;$/;"	m	struct:folly::MemoryMapping::Options	access:public
address	.\test\AtomicHashArrayTest.cpp	/^  T* address(T& x) const {$/;"	f	class:MmapAllocator	access:public	signature:(T& x) const
address	.\test\AtomicHashArrayTest.cpp	/^  const T* address(const T& x) const {$/;"	f	class:MmapAllocator	access:public	signature:(const T& x) const
address	.\test\IPAddressTest.h	/^  std::string address;$/;"	m	struct:folly::AddressData	access:public
address	.\test\IPAddressTest.h	/^  std::string address;$/;"	m	struct:folly::AddressFlags	access:public
address	.\test\IPAddressTest.h	/^  std::string address;$/;"	m	struct:folly::MaskData	access:public
address	.\test\IPAddressTest.h	/^  std::string address;$/;"	m	struct:folly::SerializeData	access:public
address_	.\experimental\symbolizer\Dwarf.h	/^    uint64_t address_;$/;"	m	class:folly::symbolizer::Dwarf::LineNumberVM	access:private
addresses	.\experimental\exception_tracer\StackTrace.h	/^  uintptr_t addresses[kMaxFrames];$/;"	m	struct:folly::exception_tracer::StackTrace	access:public
addresses	.\experimental\symbolizer\Symbolizer.h	/^  uintptr_t addresses[N];$/;"	m	struct:folly::symbolizer::FrameArray	access:public
adjustForEnd	.\io\IOBuf.h	/^  void adjustForEnd() {$/;"	f	class:folly::IOBuf::Iterator	access:private	signature:()
adjustPermSize	.\test\DeterministicSchedule.cpp	/^  void adjustPermSize(int numActive) {$/;"	f	struct:folly::test::UniformSubset	file:	access:private	signature:(int numActive)
adjustedPtr	.\experimental\exception_tracer\ExceptionAbi.h	/^  void* adjustedPtr;$/;"	m	struct:__cxxabiv1::__cxa_exception	access:public
advance	.\Padded.h	/^  void advance(typename Super::difference_type n) {$/;"	f	namespace:folly::padded	access:private	signature:(typename Super::difference_type n)
advance	.\Range.h	/^  void advance(size_type n) {$/;"	f	class:folly::Range	access:public	signature:(size_type n)
advance	.\io\IOBuf.h	/^  void advance(uint64_t amount) {$/;"	f	class:folly::IOBuf	access:public	signature:(uint64_t amount)
advance	.\io\TypedIOBuf.h	/^  void advance(uint32_t n) {$/;"	f	class:folly::TypedIOBuf	access:public	signature:(uint32_t n)
advance	.\wangle\ManualExecutor.h	/^    void advance(Duration const& dur) {$/;"	f	class:folly::wangle::ManualExecutor	access:public	signature:(Duration const& dur)
advanceDone	.\io\Cursor.h	/^  void advanceDone() {$/;"	f	class:folly::io::RWCursor	access:private	signature:()
advanceDone	.\io\Cursor.h	/^  void advanceDone() {$/;"	f	class:folly::io::detail::CursorBase	access:private	signature:()
advancePastEmpty	.\AtomicHashArray-inl.h	/^  void advancePastEmpty() {$/;"	f	struct:folly::AtomicHashArray::aha_iterator	access:private	signature:()
advanceTo	.\wangle\ManualExecutor.cpp	/^void ManualExecutor::advanceTo(TimePoint const& t) {$/;"	f	class:folly::wangle::ManualExecutor	signature:(TimePoint const& t)
advanceTo	.\wangle\ManualExecutor.h	/^    void advanceTo(TimePoint const& t);$/;"	p	class:folly::wangle::ManualExecutor	access:public	signature:(TimePoint const& t)
advanceToValid	.\io\RecordIO-inl.h	/^  void advanceToValid();$/;"	p	class:folly::RecordIOReader::Iterator	access:private	signature:()
advanceToValid	.\io\RecordIO.cpp	/^void RecordIOReader::Iterator::advanceToValid() {$/;"	f	class:folly::RecordIOReader::Iterator	signature:()
advise	.\MemoryMapping.cpp	/^void MemoryMapping::advise(int advice) const {$/;"	f	class:folly::MemoryMapping	signature:(int advice) const
advise	.\MemoryMapping.h	/^  void advise(int advice) const;$/;"	p	class:folly::MemoryMapping	access:public	signature:(int advice) const
advisoryMaxQueueSize_	.\io\async\NotificationQueue.h	/^      advisoryMaxQueueSize_(maxSize),$/;"	p	class:folly::NotificationQueue	access:public	signature:(maxSize)
advisoryMaxQueueSize_	.\io\async\NotificationQueue.h	/^  uint32_t advisoryMaxQueueSize_;$/;"	m	class:folly::NotificationQueue	access:private
afterSharedAccess	.\test\DeterministicSchedule.cpp	/^DeterministicSchedule::afterSharedAccess() {$/;"	f	class:folly::test::DeterministicSchedule	signature:()
afterSharedAccess	.\test\DeterministicSchedule.h	/^  static void afterSharedAccess();$/;"	p	class:folly::test::DeterministicSchedule	access:public	signature:()
afterThreadCreate	.\test\DeterministicSchedule.cpp	/^DeterministicSchedule::afterThreadCreate(sem_t* sem) {$/;"	f	class:folly::test::DeterministicSchedule	signature:(sem_t* sem)
afterThreadCreate	.\test\DeterministicSchedule.h	/^  void afterThreadCreate(sem_t*);$/;"	p	class:folly::test::DeterministicSchedule	access:private	signature:(sem_t*)
aha_	.\AtomicHashArray-inl.h	/^  ContT* aha_;$/;"	m	struct:folly::AtomicHashArray::aha_iterator	access:private
aha_iterator	.\AtomicHashArray-inl.h	/^  aha_iterator(const aha_iterator<OtherContT,OtherVal>& o,$/;"	f	struct:folly::AtomicHashArray::aha_iterator	access:public	signature:(const aha_iterator<OtherContT,OtherVal>& o, typename std::enable_if< std::is_convertible<OtherVal*,IterVal*>::value >::type* = 0)
aha_iterator	.\AtomicHashArray-inl.h	/^  explicit aha_iterator() : aha_(0) {}$/;"	f	struct:folly::AtomicHashArray::aha_iterator	access:public	signature:()
aha_iterator	.\AtomicHashArray-inl.h	/^  explicit aha_iterator(ContT* array, size_t offset)$/;"	f	struct:folly::AtomicHashArray::aha_iterator	access:public	signature:(ContT* array, size_t offset)
aha_iterator	.\AtomicHashArray-inl.h	/^struct AtomicHashArray<KeyT, ValueT, HashFcn, EqualFcn, Allocator>::aha_iterator$/;"	s	class:folly::AtomicHashArray	inherits:boost::iterator_facade
aha_iterator	.\AtomicHashArray.h	/^  struct aha_iterator;$/;"	x
ahm	.\test\AtomicHashMapTest.cpp	/^  AtomicHashMap<int64_t,int64_t> ahm;$/;"	m	class:Counters	file:	access:private
ahm_	.\AtomicHashMap-inl.h	/^  ContT* ahm_;$/;"	m	struct:folly::AtomicHashMap::ahm_iterator	access:private
ahm_iterator	.\AtomicHashMap-inl.h	/^  ahm_iterator(const ahm_iterator<OtherContT,OtherVal,OtherSubIt>& o,$/;"	f	struct:folly::AtomicHashMap::ahm_iterator	access:public	signature:(const ahm_iterator<OtherContT,OtherVal,OtherSubIt>& o, typename std::enable_if< std::is_convertible<OtherSubIt,SubIt>::value >::type* = 0)
ahm_iterator	.\AtomicHashMap-inl.h	/^  explicit ahm_iterator() : ahm_(0) {}$/;"	f	struct:folly::AtomicHashMap::ahm_iterator	access:public	signature:()
ahm_iterator	.\AtomicHashMap-inl.h	/^  explicit ahm_iterator(ContT* ahm,$/;"	f	struct:folly::AtomicHashMap::ahm_iterator	access:private	signature:(ContT* ahm, uint32_t subMap, const SubIt& subIt)
ahm_iterator	.\AtomicHashMap-inl.h	/^struct AtomicHashMap<KeyT, ValueT, HashFcn, EqualFcn, Allocator>::ahm_iterator$/;"	s	class:folly::AtomicHashMap	inherits:boost::iterator_facade
ahm_iterator	.\AtomicHashMap.h	/^  struct ahm_iterator;$/;"	x
align	.\FormatArg.h	/^  Align align;$/;"	m	struct:folly::FormatArg	access:public
align	.\io\IOBuf.cpp	/^  MaxAlign align;$/;"	m	struct:folly::IOBuf::HeapFullStorage	file:	access:public
alignedForwardMemcpy	.\MemoryMapping.cpp	/^void alignedForwardMemcpy(void* dst, const void* src, size_t size) {$/;"	f	namespace:folly	signature:(void* dst, const void* src, size_t size)
alignedForwardMemcpy	.\MemoryMapping.h	/^void alignedForwardMemcpy(void* dest, const void* src, size_t size);$/;"	p	namespace:folly	signature:(void* dest, const void* src, size_t size)
alignof	.\AtomicStruct.h	/^  static_assert(alignof(T) <= alignof(Raw),$/;"	p	class:folly::AtomicStruct	access:private	signature:(T)
alignof	.\LifoSem.h	/^  static_assert(alignof(Handoff) <=$/;"	p	struct:folly::detail::LifoSemNode	access:public	signature:(Handoff)
alive	.\gen\test\BaseTest.cpp	/^  static int alive;$/;"	m	struct:CopyCounter	file:	access:public
alive	.\gen\test\BaseTest.cpp	/^int CopyCounter::alive = 0;$/;"	m	class:CopyCounter	file:
alive	.\test\small_vector_test.cpp	/^  static int alive;$/;"	m	struct:__anon132::NoncopyableCounter	file:	access:public
alive	.\test\small_vector_test.cpp	/^  static int alive;$/;"	m	struct:__anon132::Thrower	file:	access:public
alive	.\test\small_vector_test.cpp	/^int NoncopyableCounter::alive = 0;$/;"	m	class:__anon132::NoncopyableCounter	file:
alive	.\test\small_vector_test.cpp	/^int Thrower::alive = 0;$/;"	m	class:__anon132::Thrower	file:
all	.\gen\Base.h	/^All all(Predicate pred = Predicate()) {$/;"	f	namespace:folly::gen	signature:(Predicate pred = Predicate())
alloc	.\Arena.h	/^  Alloc& alloc() { return allocAndSize_; }$/;"	f	class:folly::Arena	access:private	signature:()
alloc	.\Arena.h	/^  const Alloc& alloc() const { return allocAndSize_; }$/;"	f	class:folly::Arena	access:private	signature:() const
alloc	.\ConcurrentSkipList-inl.h	/^  NodeAlloc& alloc() { return alloc_; }$/;"	f	class:folly::detail::NodeRecycler	access:public	signature:()
alloc	.\Memory.h	/^  Alloc* alloc() const {$/;"	f	class:folly::StlAllocator	access:public	signature:() const
allocAndSize_	.\Arena.h	/^  AllocAndSize allocAndSize_;$/;"	m	class:folly::Arena	access:private
allocElem	.\IndexedMemPool.h	/^  UniquePtr allocElem() {$/;"	f	struct:folly::IndexedMemPool	access:public	signature:()
allocExtBuffer	.\io\IOBuf.cpp	/^void IOBuf::allocExtBuffer(uint64_t minCapacity,$/;"	f	class:folly::IOBuf	signature:(uint64_t minCapacity, uint8_t** bufReturn, SharedInfo** infoReturn, uint64_t* capacityReturn)
allocExtBuffer	.\io\IOBuf.h	/^  static void allocExtBuffer(uint64_t minCapacity,$/;"	p	class:folly::IOBuf	access:private	signature:(uint64_t minCapacity, uint8_t** bufReturn, SharedInfo** infoReturn, uint64_t* capacityReturn)
allocGen	.\test\stl_tests\StlVectorTest.cpp	/^struct allocGen {$/;"	s	file:
allocGen	.\test\stl_tests\StlVectorTest.cpp	/^struct allocGen<Alloc<T>> {$/;"	s	file:
allocGen::get	.\test\stl_tests\StlVectorTest.cpp	/^  static A get() { return A(); }$/;"	f	struct:allocGen	access:public	signature:()
allocGen::get	.\test\stl_tests\StlVectorTest.cpp	/^  static Alloc<T> get() {$/;"	f	struct:allocGen	access:public	signature:()
allocIndex	.\IndexedMemPool.h	/^  uint32_t allocIndex() {$/;"	f	struct:folly::IndexedMemPool	access:public	signature:()
alloc_	.\ConcurrentSkipList-inl.h	/^  NodeAlloc alloc_;$/;"	m	class:folly::detail::NodeRecycler	access:private
alloc_	.\Memory.h	/^  Alloc* alloc_;$/;"	m	class:folly::StlAllocator	access:private
allocate	.\Arena-inl.h	/^Arena<Alloc>::Block::allocate(Alloc& alloc, size_t size, bool allowSlack) {$/;"	f	class:folly::Arena::Block	signature:(Alloc& alloc, size_t size, bool allowSlack)
allocate	.\Arena.h	/^    static std::pair<Block*, size_t> allocate($/;"	p	struct:folly::Arena::Block	access:public	signature:( Alloc& alloc, size_t size, bool allowSlack)
allocate	.\Arena.h	/^  void* allocate(size_t size) {$/;"	f	class:folly::Arena	access:public	signature:(size_t size)
allocate	.\Memory.h	/^  T* allocate(size_t n, const void* hint = nullptr) {$/;"	f	class:folly::StlAllocator	access:public	signature:(size_t n, const void* hint = nullptr)
allocate	.\Memory.h	/^  void* allocate(size_t size) {$/;"	f	class:folly::SysAlloc	access:public	signature:(size_t size)
allocate	.\ThreadCachedArena.h	/^  void* allocate(size_t size) {$/;"	f	class:folly::ThreadCachedArena	access:public	signature:(size_t size)
allocate	.\experimental\exception_tracer\StackTrace.cpp	/^  static Node* allocate();$/;"	p	class:folly::exception_tracer::StackTraceStack::Node	file:	access:public	signature:()
allocate	.\io\IOBufQueue.h	/^  void* allocate(uint64_t n) {$/;"	f	class:folly::IOBufQueue	access:public	signature:(uint64_t n)
allocate	.\test\AtomicHashArrayTest.cpp	/^  T *allocate(size_t n) {$/;"	f	class:MmapAllocator	access:public	signature:(size_t n)
allocate	.\test\ThreadCachedArenaTest.cpp	/^  void allocate(size_t count, size_t maxSize);$/;"	p	class:__anon143::ArenaTester	file:	access:public	signature:(size_t count, size_t maxSize)
allocate	.\test\ThreadCachedArenaTest.cpp	/^void ArenaTester::allocate(size_t count, size_t maxSize) {$/;"	f	class:__anon143::ArenaTester	signature:(size_t count, size_t maxSize)
allocate	.\test\stl_tests\StlVectorTest.cpp	/^  pointer allocate(size_type n) {$/;"	f	struct:Alloc	access:public	signature:(size_type n)
allocateAligned	.\experimental\io\test\AsyncIOTest.cpp	/^ManagedBuffer allocateAligned(size_t size) {$/;"	f	namespace:__anon32	signature:(size_t size)
allocateNode	.\LifoSem.h	/^  UniquePtr allocateNode(Args&&... args) {$/;"	f	struct:folly::detail::LifoSemBase	access:protected	signature:(Args&&.... args)
allocateSlow	.\Arena-inl.h	/^void* Arena<Alloc>::allocateSlow(size_t size) {$/;"	f	class:folly::Arena	signature:(size_t size)
allocateSlow	.\Arena.h	/^  void* allocateSlow(size_t size);$/;"	p	class:folly::Arena	access:private	signature:(size_t size)
allocateThreadLocalArena	.\ThreadCachedArena.cpp	/^SysArena* ThreadCachedArena::allocateThreadLocalArena() {$/;"	f	class:folly::ThreadCachedArena	signature:()
allocateThreadLocalArena	.\ThreadCachedArena.h	/^  SysArena* allocateThreadLocalArena();$/;"	p	class:folly::ThreadCachedArena	access:private	signature:()
allocate_shared	.\Memory.h	/^std::shared_ptr<T> allocate_shared(Allocator&& allocator, Args&&... args) {$/;"	f	namespace:folly	signature:(Allocator&& allocator, Args&&... args)
allocate_unique	.\Memory.h	/^typename AllocatorUniquePtr<T, Allocator>::type allocate_unique($/;"	f	namespace:folly	signature:( Allocator&& allocator, Args&&... args )
allocated	.\SocketAddress.cpp	/^  char* allocated;$/;"	m	struct:__anon90::HostAndPort	file:	access:public
allocator	.\Memory.h	/^  >::type allocator;$/;"	t	class:folly::is_simple_allocator	access:private
allocator_delete	.\Memory.h	/^  allocator_delete() = default;$/;"	p	class:folly::allocator_delete	access:public	signature:()
allocator_delete	.\Memory.h	/^  allocator_delete(const allocator_delete<U>& other)$/;"	f	class:folly::allocator_delete	access:public	signature:(const allocator_delete<U>& other)
allocator_delete	.\Memory.h	/^  explicit allocator_delete(allocator_type&& allocator)$/;"	f	class:folly::allocator_delete	access:public	signature:(allocator_type&& allocator)
allocator_delete	.\Memory.h	/^  explicit allocator_delete(const allocator_type& allocator)$/;"	f	class:folly::allocator_delete	access:public	signature:(const allocator_type& allocator)
allocator_delete	.\Memory.h	/^class allocator_delete$/;"	c	namespace:folly	inherits:std::remove_reference::type
allocator_type	.\FBVector.h	/^  typedef Allocator                                   allocator_type;$/;"	t	class:folly::fbvector	access:public
allocator_type	.\Memory.h	/^  typedef typename std::remove_reference<Allocator>::type allocator_type;$/;"	t	class:folly::allocator_delete	access:private
allow_nan_inf	.\json.h	/^    bool allow_nan_inf;$/;"	m	struct:folly::json::serialization_opts	access:public
allow_non_string_keys	.\json.h	/^    bool allow_non_string_keys;$/;"	m	struct:folly::json::serialization_opts	access:public
allow_trailing_comma	.\json.h	/^    bool allow_trailing_comma;$/;"	m	struct:folly::json::serialization_opts	access:public
anotherFunc	.\test\ApplyTupleTest.cpp	/^void anotherFunc(CopyCount const&) {}$/;"	f	namespace:__anon104	signature:(CopyCount const&)
any	.\gen\Base-inl.h	/^static const detail::Any any;$/;"	m	namespace:folly::gen
appThread	.\test\PackedSyncPtrTest.cpp	/^void appThread(intptr_t id) {$/;"	f	signature:(intptr_t id)
append	.\io\Cursor.h	/^  void append(size_t n) { queue_->postallocate(n); }$/;"	f	class:folly::io::QueueAppender	access:public	signature:(size_t n)
append	.\io\Cursor.h	/^  void append(size_t n) {$/;"	f	class:folly::io::Appender	access:public	signature:(size_t n)
append	.\io\IOBuf.h	/^  void append(uint64_t amount) {$/;"	f	class:folly::IOBuf	access:public	signature:(uint64_t amount)
append	.\io\IOBufQueue.cpp	/^IOBufQueue::append(IOBufQueue& other, bool pack) {$/;"	f	class:folly::IOBufQueue	signature:(IOBufQueue& other, bool pack)
append	.\io\IOBufQueue.cpp	/^IOBufQueue::append(const void* buf, size_t len) {$/;"	f	class:folly::IOBufQueue	signature:(const void* buf, size_t len)
append	.\io\IOBufQueue.cpp	/^IOBufQueue::append(unique_ptr<IOBuf>&& buf, bool pack) {$/;"	f	class:folly::IOBufQueue	signature:(unique_ptr<IOBuf>&& buf, bool pack)
append	.\io\IOBufQueue.h	/^  void append(IOBufQueue& other, bool pack=false);$/;"	p	class:folly::IOBufQueue	access:public	signature:(IOBufQueue& other, bool pack=false)
append	.\io\IOBufQueue.h	/^  void append(IOBufQueue&& other, bool pack=false) {$/;"	f	class:folly::IOBufQueue	access:public	signature:(IOBufQueue&& other, bool pack=false)
append	.\io\IOBufQueue.h	/^  void append(StringPiece sp) {$/;"	f	class:folly::IOBufQueue	access:public	signature:(StringPiece sp)
append	.\io\IOBufQueue.h	/^  void append(const void* buf, size_t len);$/;"	p	class:folly::IOBufQueue	access:public	signature:(const void* buf, size_t len)
append	.\io\IOBufQueue.h	/^  void append(std::unique_ptr<folly::IOBuf>&& buf,$/;"	p	class:folly::IOBufQueue	access:public	signature:(std::unique_ptr<folly::IOBuf>&& buf, bool pack=false)
append	.\io\TypedIOBuf.h	/^  void append(uint32_t n) {$/;"	f	class:folly::TypedIOBuf	access:public	signature:(uint32_t n)
append	.\io\test\IOBufCursorTest.cpp	/^void append(Appender& appender, folly::StringPiece data) {$/;"	f	namespace:__anon69	signature:(Appender& appender, folly::StringPiece data)
append	.\io\test\IOBufCursorTest.cpp	/^void append(std::unique_ptr<IOBuf>& buf, folly::StringPiece data) {$/;"	f	namespace:__anon69	signature:(std::unique_ptr<IOBuf>& buf, folly::StringPiece data)
append	.\io\test\IOBufTest.cpp	/^void append(std::unique_ptr<IOBuf>& buf, StringPiece str) {$/;"	f	signature:(std::unique_ptr<IOBuf>& buf, StringPiece str)
appendChain	.\io\IOBuf.h	/^  void appendChain(std::unique_ptr<IOBuf>&& iobuf) {$/;"	f	class:folly::IOBuf	access:public	signature:(std::unique_ptr<IOBuf>&& iobuf)
appendOutput	.\Format-inl.h	/^void BaseFormatter<Derived, containerMode, Args...>::appendOutput(Output& out)$/;"	f	class:folly::BaseFormatter	signature:(Output& out) const
appendOutput	.\Format.h	/^  void appendOutput(Output& out) const;$/;"	p	class:folly::BaseFormatter	access:private	signature:(Output& out) const
appendTo	.\Format.h	/^  appendTo(Str& str) const {$/;"	f	class:folly::BaseFormatter	access:public	signature:(Str& str) const
appendTo	.\gen\Base.h	/^Append appendTo(Collection& collection) {$/;"	f	namespace:folly::gen	signature:(Collection& collection)
appendToChain	.\io\IOBufQueue.cpp	/^appendToChain(unique_ptr<IOBuf>& dst, unique_ptr<IOBuf>&& src, bool pack) {$/;"	f	namespace:__anon67	signature:(unique_ptr<IOBuf>& dst, unique_ptr<IOBuf>&& src, bool pack)
apply	.\DiscriminatedPtr.h	/^  typename dptr_detail::ConstVisitorResult<V, Types...>::type apply(V&& visitor)$/;"	f	class:folly::DiscriminatedPtr	access:public	signature:(V&& visitor) const
apply	.\DiscriminatedPtr.h	/^  typename dptr_detail::VisitorResult<V, Types...>::type apply(V&& visitor) {$/;"	f	class:folly::DiscriminatedPtr	access:public	signature:(V&& visitor)
apply	.\gen\Base-inl.h	/^    bool apply(Handler&& handler) const {$/;"	f	class:folly::gen::detail::Batch::Generator	access:public	signature:(Handler&& handler) const
apply	.\gen\Base-inl.h	/^    bool apply(Handler&& handler) const {$/;"	f	class:folly::gen::detail::Concat::Generator	access:public	signature:(Handler&& handler) const
apply	.\gen\Base-inl.h	/^    bool apply(Handler&& handler) const {$/;"	f	class:folly::gen::detail::Cycle::Generator	access:public	signature:(Handler&& handler) const
apply	.\gen\Base-inl.h	/^    bool apply(Handler&& handler) const {$/;"	f	class:folly::gen::detail::Dereference::Generator	access:public	signature:(Handler&& handler) const
apply	.\gen\Base-inl.h	/^    bool apply(Handler&& handler) const {$/;"	f	class:folly::gen::detail::Distinct::Generator	access:public	signature:(Handler&& handler) const
apply	.\gen\Base-inl.h	/^    bool apply(Handler&& handler) const {$/;"	f	class:folly::gen::detail::Filter::Generator	access:public	signature:(Handler&& handler) const
apply	.\gen\Base-inl.h	/^    bool apply(Handler&& handler) const {$/;"	f	class:folly::gen::detail::GuardImpl::Generator	access:public	signature:(Handler&& handler) const
apply	.\gen\Base-inl.h	/^    bool apply(Handler&& handler) const {$/;"	f	class:folly::gen::detail::Map::Generator	access:public	signature:(Handler&& handler) const
apply	.\gen\Base-inl.h	/^    bool apply(Handler&& handler) const {$/;"	f	class:folly::gen::detail::Order::Generator	access:public	signature:(Handler&& handler) const
apply	.\gen\Base-inl.h	/^    bool apply(Handler&& handler) const {$/;"	f	class:folly::gen::detail::RangeConcat::Generator	access:public	signature:(Handler&& handler) const
apply	.\gen\Base-inl.h	/^    bool apply(Handler&& handler) const {$/;"	f	class:folly::gen::detail::Sample::Generator	access:public	signature:(Handler&& handler) const
apply	.\gen\Base-inl.h	/^    bool apply(Handler&& handler) const {$/;"	f	class:folly::gen::detail::Skip::Generator	access:public	signature:(Handler&& handler) const
apply	.\gen\Base-inl.h	/^    bool apply(Handler&& handler) const {$/;"	f	class:folly::gen::detail::Take::Generator	access:public	signature:(Handler&& handler) const
apply	.\gen\Base-inl.h	/^    bool apply(Handler&& handler) const {$/;"	f	class:folly::gen::detail::Until::Generator	access:public	signature:(Handler&& handler) const
apply	.\gen\Base-inl.h	/^    virtual bool apply(const std::function<bool(Value)>& handler) const = 0;$/;"	p	class:folly::gen::VirtualGen::WrapperBase	access:public	signature:(const std::function<bool(Value)>& handler) const
apply	.\gen\Base-inl.h	/^    virtual bool apply(const std::function<bool(Value)>& handler) const {$/;"	f	class:folly::gen::VirtualGen::WrapperImpl	access:public	signature:(const std::function<bool(Value)>& handler) const
apply	.\gen\Base-inl.h	/^   bool apply(Handler&& handler) const {$/;"	f	class:folly::gen::detail::Stride::Generator	access:public	signature:(Handler&& handler) const
apply	.\gen\Base-inl.h	/^  bool apply(Handler&& handler) const {$/;"	f	class:folly::gen::detail::CopiedSource	access:public	signature:(Handler&& handler) const
apply	.\gen\Base-inl.h	/^  bool apply(Handler&& handler) const {$/;"	f	class:folly::gen::detail::Just	access:public	signature:(Handler&& handler) const
apply	.\gen\Base-inl.h	/^  bool apply(Handler&& handler) const {$/;"	f	class:folly::gen::detail::RangeSource	access:public	signature:(Handler&& handler) const
apply	.\gen\Base-inl.h	/^  bool apply(Handler&& handler) const {$/;"	f	class:folly::gen::detail::ReferencedSource	access:public	signature:(Handler&& handler) const
apply	.\gen\Base-inl.h	/^  bool apply(Handler&& handler) const {$/;"	f	class:folly::gen::detail::Sequence	access:public	signature:(Handler&& handler) const
apply	.\gen\Base-inl.h	/^  bool apply(Handler&& handler) const {$/;"	f	class:folly::gen::detail::Yield	access:public	signature:(Handler&& handler) const
apply	.\gen\Base-inl.h	/^  bool apply(Handler&&) const {$/;"	f	class:folly::gen::detail::Empty	access:public	signature:(Handler&&) const
apply	.\gen\Base-inl.h	/^  bool apply(const std::function<bool(Value)>& handler) const {$/;"	f	class:folly::gen::VirtualGen	access:public	signature:(const std::function<bool(Value)>& handler) const
apply	.\gen\Combine-inl.h	/^    bool apply(Handler&& handler) const {$/;"	f	class:folly::gen::detail::Interleave::Generator	access:public	signature:(Handler&& handler) const
apply	.\gen\Combine-inl.h	/^    bool apply(Handler&& handler) const {$/;"	f	class:folly::gen::detail::Zip::Generator	access:public	signature:(Handler&& handler) const
apply	.\gen\Core-inl.h	/^  bool apply(Handler&& handler) const {$/;"	f	class:folly::gen::detail::Chain	access:public	signature:(Handler&& handler) const
apply	.\gen\Core-inl.h	/^  bool apply(Handler&& handler) const;$/;"	p	class:folly::gen::GenImpl	access:public	signature:(Handler&& handler) const
apply	.\gen\File-inl.h	/^  bool apply(Body&& body) const {$/;"	f	class:folly::gen::detail::FileReader	access:public	signature:(Body&& body) const
apply	.\gen\Parallel-inl.h	/^      bool apply(Handler&& handler) const {$/;"	f	class:folly::gen::detail::Parallel::Generator::Puller	access:public	signature:(Handler&& handler) const
apply	.\gen\Parallel-inl.h	/^    bool apply(Handler&& handler) const {$/;"	f	class:folly::gen::detail::Parallel::Generator	access:public	signature:(Handler&& handler) const
apply	.\gen\Parallel-inl.h	/^  bool apply(Handler&& handler) const {$/;"	f	class:folly::gen::detail::ChunkedRangeSource	access:public	signature:(Handler&& handler) const
apply	.\gen\ParallelMap-inl.h	/^    bool apply(Handler&& handler) const {$/;"	f	class:folly::gen::detail::PMap::Generator	access:public	signature:(Handler&& handler) const
apply	.\gen\String-inl.h	/^    bool apply(Body&& body) const {$/;"	f	class:folly::gen::detail::StringResplitter::Generator	access:public	signature:(Body&& body) const
apply	.\gen\String-inl.h	/^  bool apply(Body&& body) const {$/;"	f	class:folly::gen::detail::SplitStringSource	access:public	signature:(Body&& body) const
apply	.\gen\test\BaseTest.cpp	/^  bool apply(Body&& body) const {$/;"	f	class:__anon56::TestIntSeq	access:public	signature:(Body&& body) const
ar	.\test\SmallLocksTest.cpp	/^  int ar[1024];$/;"	m	struct:__anon131::LockedVal	file:	access:public
aranges_	.\experimental\symbolizer\Dwarf.h	/^  folly::StringPiece aranges_;    \/\/ .debug_aranges$/;"	m	class:folly::symbolizer::Dwarf	access:private
archive	.\test\AHMIntStressTest.cpp	/^  void archive() {$/;"	f	struct:__anon102::MyObjectDirectory	access:public	signature:()
areas_	.\test\ThreadCachedArenaTest.cpp	/^  std::vector<std::pair<uint8_t, Range<uint8_t*>>> areas_;$/;"	m	class:__anon143::ArenaTester	file:	access:private
arena_	.\ThreadCachedArena.h	/^  ThreadLocalPtr<SysArena> arena_;  \/\/ per-thread arena$/;"	m	class:folly::ThreadCachedArena	access:private
arena_	.\test\ThreadCachedArenaTest.cpp	/^  ThreadCachedArena* arena_;$/;"	m	class:__anon143::ArenaTester	file:	access:private
arg_	.\io\async\EventBase.h	/^    void* arg_;$/;"	m	class:folly::EventBase::RunInLoopCallback	access:private
args_	.\test\ApplyTupleTest.cpp	/^  Tuple args_;$/;"	m	struct:__anon104::GuardObj	file:	access:private
array	.\dynamic.h	/^    Array array;$/;"	m	union:folly::dynamic::Data	access:public
as	.\gen\Base.h	/^Collect as() {$/;"	f	namespace:folly::gen	signature:()
asBool	.\dynamic-inl.h	/^inline bool     dynamic::asBool()   const { return asImpl<bool>(); }$/;"	f	class:folly::dynamic	signature:() const
asBool	.\dynamic.h	/^  bool     asBool() const;$/;"	p	struct:folly::dynamic	access:public	signature:() const
asConst	.\Synchronized.h	/^  const Synchronized& asConst() const {$/;"	f	struct:folly::Synchronized	access:public	signature:() const
asDouble	.\dynamic-inl.h	/^inline double   dynamic::asDouble() const { return asImpl<double>(); }$/;"	f	class:folly::dynamic	signature:() const
asDouble	.\dynamic.h	/^  double   asDouble() const;$/;"	p	struct:folly::dynamic	access:public	signature:() const
asImpl	.\dynamic-inl.h	/^T dynamic::asImpl() const {$/;"	f	class:folly::dynamic	signature:() const
asImpl	.\dynamic.h	/^  template<class T> T asImpl() const;$/;"	p	struct:folly::dynamic	access:private	signature:() const
asInt	.\dynamic-inl.h	/^inline int64_t  dynamic::asInt()    const { return asImpl<int64_t>(); }$/;"	f	class:folly::dynamic	signature:() const
asInt	.\dynamic.h	/^  int64_t  asInt() const;$/;"	p	struct:folly::dynamic	access:public	signature:() const
asRange	.\MemoryMapping.h	/^  Range<const T*> asRange() const {$/;"	f	class:folly::MemoryMapping	access:public	signature:() const
asString	.\dynamic-inl.h	/^inline fbstring dynamic::asString() const { return asImpl<fbstring>(); }$/;"	f	class:folly::dynamic	signature:() const
asString	.\dynamic.h	/^  fbstring asString() const;$/;"	p	struct:folly::dynamic	access:public	signature:() const
asV4	.\IPAddress.h	/^  const IPAddressV4& asV4() const {$/;"	f	class:folly::IPAddress	access:public	signature:() const
asV6	.\IPAddress.h	/^  const IPAddressV6& asV6() const {$/;"	f	class:folly::IPAddress	access:public	signature:() const
asVector	.\gen\Base-inl.h	/^    VectorType asVector() const {$/;"	f	class:folly::gen::detail::Order::Generator	access:private	signature:() const
asWritableRange	.\MemoryMapping.h	/^  Range<T*> asWritableRange() const {$/;"	f	class:folly::MemoryMapping	access:public	signature:() const
as_stl_allocator	.\Memory.h	/^struct as_stl_allocator {$/;"	s	namespace:folly
asciiCaseInsensitive	.\Range.cpp	/^const AsciiCaseInsensitive asciiCaseInsensitive = AsciiCaseInsensitive();$/;"	m	namespace:folly	file:
asciiCaseSensitive	.\Range.cpp	/^const AsciiCaseSensitive asciiCaseSensitive = AsciiCaseSensitive();$/;"	m	namespace:folly	file:
assert_type	.\gen\Base.h	/^detail::TypeAssertion<Value> assert_type() {$/;"	f	namespace:folly::gen	signature:()
assertionFailure	.\SafeAssert.cpp	/^void assertionFailure(const char* expr, const char* msg, const char* file,$/;"	f	namespace:folly::detail	signature:(const char* expr, const char* msg, const char* file, unsigned int line, const char* function)
assertionFailure	.\SafeAssert.h	/^FOLLY_NORETURN void assertionFailure(const char* expr, const char* msg,$/;"	p	namespace:folly::detail	signature:(const char* expr, const char* msg, const char* file, unsigned int line, const char* function)
assign	.\FBVector.h	/^  void assign(ForwardIterator first, ForwardIterator last,$/;"	f	signature:(ForwardIterator first, ForwardIterator last, std::forward_iterator_tag)
assign	.\FBVector.h	/^  void assign(InputIterator first, InputIterator last,$/;"	f	signature:(InputIterator first, InputIterator last, std::input_iterator_tag)
assign	.\FBVector.h	/^  void assign(It first, It last) {$/;"	f	signature:(It first, It last)
assign	.\FBVector.h	/^  void assign(size_type n, VT value) {$/;"	f	signature:(size_type n, VT value)
assign	.\FBVector.h	/^  void assign(std::initializer_list<T> il) {$/;"	f	signature:(std::initializer_list<T> il)
assign	.\Optional.h	/^  void assign(Optional&& src) {$/;"	f	class:folly::Optional	access:public	signature:(Optional&& src)
assign	.\Optional.h	/^  void assign(Value&& newValue) {$/;"	f	class:folly::Optional	access:public	signature:(Value&& newValue)
assign	.\Optional.h	/^  void assign(const None&) {$/;"	f	class:folly::Optional	access:public	signature:(const None&)
assign	.\Optional.h	/^  void assign(const Optional& src) {$/;"	f	class:folly::Optional	access:public	signature:(const Optional& src)
assign	.\Optional.h	/^  void assign(const Value& newValue) {$/;"	f	class:folly::Optional	access:public	signature:(const Value& newValue)
assign	.\Range.h	/^  void assign(Iter start, Iter end) {$/;"	f	class:folly::Range	access:public	signature:(Iter start, Iter end)
assign	.\small_vector.h	/^  void assign(Arg first, Arg last) {$/;"	f	class:folly::small_vector	access:public	signature:(Arg first, Arg last)
assign	.\small_vector.h	/^  void assign(size_type n, const value_type& t) {$/;"	f	class:folly::small_vector	access:public	signature:(size_type n, const value_type& t)
assign	.\small_vector.h	/^  void assign(std::initializer_list<value_type> il) {$/;"	f	class:folly::small_vector	access:public	signature:(std::initializer_list<value_type> il)
assign_eptr	.\ExceptionWrapper.h	/^  assign_eptr(Ex& e) {$/;"	f	class:folly::try_and_catch	access:protected	signature:(Ex& e)
assign_exception	.\ExceptionWrapper.h	/^  assign_exception(Ex& e) {$/;"	f	class:folly::try_and_catch	access:protected	signature:(Ex& e)
assignmentFill	.\test\FBStringTestBenchmarks.cpp.h	/^void BENCHFUN(assignmentFill)(int iters, int) {$/;"	f	signature:(int iters, int)
assignmentOp	.\test\FBStringTestBenchmarks.cpp.h	/^void BENCHFUN(assignmentOp)(int iters, int arg) {$/;"	f	signature:(int iters, int arg)
asyncIO_	.\experimental\io\AsyncIO.h	/^  AsyncIO* asyncIO_;$/;"	m	class:folly::AsyncIOQueue	access:private
asyncIoOpStateToString	.\experimental\io\AsyncIO.cpp	/^const char* asyncIoOpStateToString(AsyncIOOp::State state) {$/;"	f	namespace:folly::__anon28	signature:(AsyncIOOp::State state)
at	.\FBVector.h	/^  const_reference at(size_type n) const {$/;"	f	signature:(size_type n) const
at	.\FBVector.h	/^  reference at(size_type n) {$/;"	f	signature:(size_type n)
at	.\Range.h	/^  const value_type& at(size_t i) const {$/;"	f	class:folly::Range	access:public	signature:(size_t i) const
at	.\Range.h	/^  value_type& at(size_t i) {$/;"	f	class:folly::Range	access:public	signature:(size_t i)
at	.\dynamic-inl.h	/^inline dynamic const& dynamic::at(dynamic const& idx) const {$/;"	f	class:folly::dynamic	signature:(dynamic const& idx) const
at	.\dynamic-inl.h	/^inline dynamic& dynamic::at(dynamic const& idx) {$/;"	f	class:folly::dynamic	signature:(dynamic const& idx)
at	.\dynamic.h	/^  dynamic const& at(dynamic const&) const;$/;"	p	struct:folly::dynamic	access:public	signature:(dynamic const&) const
at	.\dynamic.h	/^  dynamic&       at(dynamic const&);$/;"	p	struct:folly::dynamic	access:public	signature:(dynamic const&)
at	.\small_vector.h	/^  const_reference at(size_type i) const {$/;"	f	class:folly::small_vector	access:public	signature:(size_type i) const
at	.\small_vector.h	/^  reference at(size_type i) {$/;"	f	class:folly::small_vector	access:public	signature:(size_type i)
atDelim	.\String-inl.h	/^inline bool atDelim(const char* s, StringPiece sp) {$/;"	f	namespace:folly::detail	signature:(const char* s, StringPiece sp)
atDelim	.\String-inl.h	/^inline bool atDelim(const char* s, char c) {$/;"	f	namespace:folly::detail	signature:(const char* s, char c)
atomicHashArrayInsertRaceArray	.\test\AtomicHashMapTest.cpp	/^auto atomicHashArrayInsertRaceArray = AHA::create(2, configRace);$/;"	v
atomicHashArrayInsertRaceThread	.\test\AtomicHashMapTest.cpp	/^void* atomicHashArrayInsertRaceThread(void* j) {$/;"	f	signature:(void* j)
atomicIncrBaseline	.\test\CacheLocalityTest.cpp	/^static void atomicIncrBaseline(size_t iters, size_t work,$/;"	f	file:	signature:(size_t iters, size_t work, size_t numThreads = 32)
attach	.\FBVector.h	/^  friend void attach(fbvector<_T, _A>&, _T* data, size_t sz, size_t cap);$/;"	p	signature:(fbvector<_T, _A>&, _T* data, size_t sz, size_t cap)
attachEventBase	.\io\async\AsyncTimeout.cpp	/^void AsyncTimeout::attachEventBase($/;"	f	class:folly::AsyncTimeout	signature:( EventBase* eventBase, InternalEnum internal)
attachEventBase	.\io\async\AsyncTimeout.h	/^  void attachEventBase(EventBase* eventBase,$/;"	p	class:folly::AsyncTimeout	access:public	signature:(EventBase* eventBase, InternalEnum internal = InternalEnum::NORMAL)
attachEventBase	.\io\async\EventHandler.cpp	/^void EventHandler::attachEventBase(EventBase* eventBase) {$/;"	f	class:folly::EventHandler	signature:(EventBase* eventBase)
attachEventBase	.\io\async\EventHandler.h	/^  void attachEventBase(EventBase* eventBase);$/;"	p	class:folly::EventHandler	access:public	signature:(EventBase* eventBase)
attachTimeoutManager	.\io\async\AsyncTimeout.cpp	/^void AsyncTimeout::attachTimeoutManager($/;"	f	class:folly::AsyncTimeout	signature:( TimeoutManager* timeoutManager, InternalEnum internal)
attachTimeoutManager	.\io\async\AsyncTimeout.h	/^  void attachTimeoutManager(TimeoutManager* timeoutManager,$/;"	p	class:folly::AsyncTimeout	access:public	signature:(TimeoutManager* timeoutManager, InternalEnum internal = InternalEnum::NORMAL)
attachTimeoutManager	.\io\async\EventBase.cpp	/^void EventBase::attachTimeoutManager(AsyncTimeout* obj,$/;"	f	class:folly::EventBase	signature:(AsyncTimeout* obj, InternalEnum internal)
attachTimeoutManager	.\io\async\EventBase.h	/^  void attachTimeoutManager(AsyncTimeout* obj,$/;"	p	class:folly::EventBase	access:private	signature:(AsyncTimeout* obj, TimeoutManager::InternalEnum internal)
attachTimeoutManager	.\io\async\TimeoutManager.h	/^  virtual void attachTimeoutManager(AsyncTimeout* obj,$/;"	p	class:folly::TimeoutManager	access:public	signature:(AsyncTimeout* obj, InternalEnum internal)
attributes	.\experimental\symbolizer\Dwarf.h	/^    folly::StringPiece attributes;$/;"	m	struct:folly::symbolizer::Dwarf::DIEAbbreviation	access:public
authority	.\Uri.cpp	/^fbstring Uri::authority() const {$/;"	f	class:folly::Uri	signature:() const
authority	.\Uri.h	/^  fbstring authority() const;$/;"	p	class:folly::Uri	access:public	signature:() const
available_	.\io\Compression.cpp	/^  size_t available_;$/;"	m	class:folly::io::__anon64::FOLLY_FINAL	file:	access:private
avg	.\detail\Stats.h	/^  ReturnType avg() const {$/;"	f	struct:folly::detail::Bucket	access:public	signature:() const
avg	.\stats\BucketedTimeSeries-defs.h	/^ReturnType BucketedTimeSeries<VT, TT>::avg(TimeType start, TimeType end) const {$/;"	f	class:folly::BucketedTimeSeries	signature:(TimeType start, TimeType end) const
avg	.\stats\BucketedTimeSeries.h	/^  ReturnType avg() const {$/;"	f	class:folly::BucketedTimeSeries	access:public	signature:() const
avg	.\stats\BucketedTimeSeries.h	/^  ReturnType avg(TimeType start, TimeType end) const;$/;"	p	class:folly::BucketedTimeSeries	access:public	signature:(TimeType start, TimeType end) const
avg	.\stats\MultiLevelTimeSeries.h	/^  ReturnType avg(TimeType start, TimeType end) const {$/;"	f	class:folly::MultiLevelTimeSeries	access:public	signature:(TimeType start, TimeType end) const
avg	.\stats\MultiLevelTimeSeries.h	/^  ReturnType avg(int level) const {$/;"	f	class:folly::MultiLevelTimeSeries	access:public	signature:(int level) const
avg	.\stats\TimeseriesHistogram-defs.h	/^ReturnType TimeseriesHistogram<T, TT, C>::avg(TimeType start,$/;"	f	class:folly::TimeseriesHistogram	signature:(TimeType start, TimeType end) const
avg	.\stats\TimeseriesHistogram-defs.h	/^ReturnType TimeseriesHistogram<T, TT, C>::avg(int level) const {$/;"	f	class:folly::TimeseriesHistogram	signature:(int level) const
avg	.\stats\TimeseriesHistogram.h	/^  ReturnType avg(TimeType start, TimeType end) const;$/;"	p	class:folly::TimeseriesHistogram	access:public	signature:(TimeType start, TimeType end) const
avg	.\stats\TimeseriesHistogram.h	/^  ReturnType avg(int level) const;$/;"	p	class:folly::TimeseriesHistogram	access:public	signature:(int level) const
avgHelper	.\detail\Stats.h	/^ReturnType avgHelper(long double sum, uint64_t count) {$/;"	f	namespace:folly::detail	signature:(long double sum, uint64_t count)
avgHelper	.\detail\Stats.h	/^avgHelper(ValueType sum, uint64_t count) {$/;"	f	namespace:folly::detail	signature:(ValueType sum, uint64_t count)
avgLoopTime_	.\io\async\EventBase.h	/^  SmoothLoopTime avgLoopTime_;$/;"	m	class:folly::EventBase	access:private
avoidAliasing	.\test\FBStringBenchmark.cpp	/^static const bool avoidAliasing = true;$/;"	v	file:
avoidAliasing	.\test\FBStringTest.cpp	/^static const bool avoidAliasing = true;$/;"	v	file:
avoidAliasing	.\test\FBVectorBenchmark.cpp	/^static const bool avoidAliasing = true;$/;"	v	file:
avoidAliasing	.\test\FBVectorTest.cpp	/^static const bool avoidAliasing = true;$/;"	v	file:
await	.\experimental\EventCount.h	/^  void await(Condition condition);$/;"	p	class:folly::EventCount	access:public	signature:(Condition condition)
await	.\experimental\EventCount.h	/^void EventCount::await(Condition condition) {$/;"	f	class:folly::EventCount	signature:(Condition condition)
b	.\test\OptionalTest.cpp	/^  char a, b, c;$/;"	m	struct:folly::NoDefault	file:	access:public
b	.\wangle\test\Thens.h	/^  B b;$/;"	m	class:SomeClass	access:private
b0key	.\GroupVarint.h	/^  static size_t b0key(size_t x) { return x & 3; }$/;"	f	class:folly::GroupVarint	access:private	signature:(size_t x)
b0key	.\GroupVarint.h	/^  static uint8_t b0key(uint16_t x) { return x & 7; }$/;"	f	class:folly::GroupVarint	access:private	signature:(uint16_t x)
b1key	.\GroupVarint.h	/^  static size_t b1key(size_t x) { return (x >> 2) & 3; }$/;"	f	class:folly::GroupVarint	access:private	signature:(size_t x)
b1key	.\GroupVarint.h	/^  static uint8_t b1key(uint16_t x) { return (x >> 3) & 7; }$/;"	f	class:folly::GroupVarint	access:private	signature:(uint16_t x)
b2key	.\GroupVarint.h	/^  static size_t b2key(size_t x) { return (x >> 4) & 3; }$/;"	f	class:folly::GroupVarint	access:private	signature:(size_t x)
b2key	.\GroupVarint.h	/^  static uint8_t b2key(uint16_t x) { return (x >> 6) & 7; }$/;"	f	class:folly::GroupVarint	access:private	signature:(uint16_t x)
b3key	.\GroupVarint.h	/^  static size_t b3key(size_t x) { return (x >> 6) & 3; }$/;"	f	class:folly::GroupVarint	access:private	signature:(size_t x)
b3key	.\GroupVarint.h	/^  static uint8_t b3key(uint16_t x) { return (x >> 9) & 7; }$/;"	f	class:folly::GroupVarint	access:private	signature:(uint16_t x)
b4key	.\GroupVarint.h	/^  static uint8_t b4key(uint16_t x) { return (x >> 12) & 7; }$/;"	f	class:folly::GroupVarint	access:private	signature:(uint16_t x)
b_	.\FBVector.h	/^        b_(other.b_), e_(other.e_), z_(other.z_)$/;"	p	struct:folly::fbvector::Impl	access:public	signature:(other.b_)
b_	.\FBVector.h	/^    pointer b_, e_, z_;$/;"	m	struct:folly::fbvector::Impl	access:public
b_	.\Range.h	/^  Iter b_, e_;$/;"	m	class:folly::Range	access:private
back	.\FBVector.h	/^  const_reference back() const {$/;"	f	signature:() const
back	.\FBVector.h	/^  reference back()  {$/;"	f	signature:()
back	.\Padded.h	/^  const value_type& back() const {$/;"	f	class:folly::Adaptor	access:public	signature:() const
back	.\Padded.h	/^  value_type& back() {$/;"	f	class:folly::Adaptor	access:public	signature:()
back	.\Range.h	/^  const value_type& back() const {$/;"	f	class:folly::Range	access:public	signature:() const
back	.\Range.h	/^  value_type& back() {$/;"	f	class:folly::Range	access:public	signature:()
back	.\detail\CacheLocality.cpp	/^    CacheLocality::system<>().numCachesByLevel.back());$/;"	p	namespace:folly::detail	file:	signature:()
back	.\io\TypedIOBuf.h	/^  T& back() {$/;"	f	class:folly::TypedIOBuf	access:public	signature:()
back	.\io\TypedIOBuf.h	/^  const T& back() const {$/;"	f	class:folly::TypedIOBuf	access:public	signature:() const
back	.\small_vector.h	/^  const_reference back() const  { assert(!empty()); return *(end() - 1); }$/;"	f	class:folly::small_vector	access:public	signature:() const
back	.\small_vector.h	/^  reference back()              { assert(!empty()); return *(end() - 1); }$/;"	f	class:folly::small_vector	access:public	signature:()
back	.\test\DeterministicSchedule.cpp	/^    CacheLocality::system<>().numCachesByLevel.back());$/;"	p	namespace:folly::detail	file:	signature:()
backslashify	.\String-inl.h	/^void backslashify(const String1& input, String2& output, bool hex_style) {$/;"	f	namespace:folly	signature:(const String1& input, String2& output, bool hex_style)
backslashify	.\String.h	/^String backslashify(const String& input, bool hex_style=false) {$/;"	f	class:folly::UriEscapeMode	access:private	signature:(const String& input, bool hex_style=false)
backslashify	.\String.h	/^void backslashify(const String1& input, String2& output, bool hex_style=false);$/;"	p	class:folly::UriEscapeMode	access:private	signature:(const String1& input, String2& output, bool hex_style=false)
bar	.\experimental\exception_tracer\ExceptionTracerTest.cpp	/^void bar() {$/;"	f	signature:()
bar	.\experimental\symbolizer\test\SymbolizerTest.cpp	/^FOLLY_NOINLINE void bar();$/;"	p	namespace:folly::symbolizer::test	file:	signature:()
bar	.\experimental\symbolizer\test\SymbolizerTest.cpp	/^void bar() {$/;"	f	namespace:folly::symbolizer::test	signature:()
base	.\test\PackedSyncPtrTest.cpp	/^  PackedSyncPtr<T> base;$/;"	m	struct:SyncVec	file:	access:public
baseAddress_	.\experimental\symbolizer\Elf.cpp	/^    baseAddress_(other.baseAddress_) {$/;"	f	namespace:folly::symbolizer	signature:(other.baseAddress_)
baseAddress_	.\experimental\symbolizer\Elf.h	/^  uintptr_t baseAddress_;$/;"	m	class:folly::symbolizer::ElfFile	access:private
baseDir	.\experimental\symbolizer\Dwarf.h	/^    folly::StringPiece baseDir() const { return baseDir_; };$/;"	f	class:folly::symbolizer::Dwarf::Path	access:public	signature:() const
baseDir_	.\experimental\symbolizer\Dwarf.h	/^    folly::StringPiece baseDir_;$/;"	m	class:folly::symbolizer::Dwarf::Path	access:private
basePrefix	.\FormatArg.h	/^  bool basePrefix;$/;"	m	struct:folly::FormatArg	access:public
base_	.\io\async\NotificationQueue.h	/^    EventBase* base_;$/;"	m	class:folly::NotificationQueue::Consumer	access:private
base_reference	.\Padded.h	/^  const Node& node() const { return *this->base_reference(); }$/;"	p	namespace:folly::padded::detail	signature:()
basic	.\experimental\wangle\concurrent\test\ThreadPoolExecutorTest.cpp	/^static void basic() {$/;"	f	file:	signature:()
basicBlock_	.\experimental\symbolizer\Dwarf.h	/^    bool basicBlock_;$/;"	m	class:folly::symbolizer::Dwarf::LineNumberVM	access:private
basic_string	.\Traits.h	/^  class basic_string;$/;"	x
batch	.\gen\Base-inl.h	/^inline detail::Batch batch(size_t batchSize) {$/;"	f	namespace:folly::gen	signature:(size_t batchSize)
batchSize_	.\gen\Base-inl.h	/^    size_t batchSize_;$/;"	m	class:folly::gen::detail::Batch::Generator	access:private
batchSize_	.\gen\Base-inl.h	/^  size_t batchSize_;$/;"	m	class:folly::gen::detail::Batch	access:private
baz	.\experimental\exception_tracer\ExceptionTracerTest.cpp	/^void baz() {$/;"	f	signature:()
beforeSharedAccess	.\test\DeterministicSchedule.cpp	/^DeterministicSchedule::beforeSharedAccess() {$/;"	f	class:folly::test::DeterministicSchedule	signature:()
beforeSharedAccess	.\test\DeterministicSchedule.h	/^  static void beforeSharedAccess();$/;"	p	class:folly::test::DeterministicSchedule	access:public	signature:()
beforeThreadCreate	.\test\DeterministicSchedule.cpp	/^DeterministicSchedule::beforeThreadCreate() {$/;"	f	class:folly::test::DeterministicSchedule	signature:()
beforeThreadCreate	.\test\DeterministicSchedule.h	/^  sem_t* beforeThreadCreate();$/;"	p	class:folly::test::DeterministicSchedule	access:private	signature:()
beforeThreadExit	.\test\DeterministicSchedule.cpp	/^DeterministicSchedule::beforeThreadExit() {$/;"	f	class:folly::test::DeterministicSchedule	signature:()
beforeThreadExit	.\test\DeterministicSchedule.h	/^  void beforeThreadExit();$/;"	p	class:folly::test::DeterministicSchedule	access:private	signature:()
begin	.\AtomicHashArray.h	/^  const_iterator begin() const { return const_iterator(this, 0); }$/;"	f	class:folly::AtomicHashArray	access:public	signature:() const
begin	.\AtomicHashArray.h	/^  iterator begin()             { return iterator(this, 0); }$/;"	f	class:folly::AtomicHashArray	access:public	signature:()
begin	.\AtomicHashMap.h	/^  const_iterator begin() const {$/;"	f	class:folly::AtomicHashMap	access:public	signature:() const
begin	.\AtomicHashMap.h	/^  iterator begin() {$/;"	f	class:folly::AtomicHashMap	access:public	signature:()
begin	.\ConcurrentSkipList.h	/^  iterator begin() const {$/;"	f	class:folly::ConcurrentSkipList::Accessor	access:public	signature:() const
begin	.\EvictingCacheMap.h	/^  const_iterator begin() const {$/;"	f	class:folly::EvictingCacheMap	access:public	signature:() const
begin	.\EvictingCacheMap.h	/^  iterator begin() {$/;"	f	class:folly::EvictingCacheMap	access:public	signature:()
begin	.\Padded.h	/^  const_iterator begin() const { return cbegin(); }$/;"	f	class:folly::Adaptor	access:public	signature:() const
begin	.\Padded.h	/^  iterator begin() {$/;"	f	class:folly::Adaptor	access:public	signature:()
begin	.\Padded.h	/^Iterator<typename Container::const_iterator> begin(const Container& c) {$/;"	f	namespace:folly	signature:(const Container& c)
begin	.\Padded.h	/^Iterator<typename Container::iterator> begin(Container& c) {$/;"	f	namespace:folly	signature:(Container& c)
begin	.\Range.h	/^  Iter begin() const { return b_; }$/;"	f	class:folly::Range	access:public	signature:() const
begin	.\ThreadLocal.h	/^    Iterator begin() const {$/;"	f	class:folly::ThreadLocalPtr::Accessor	access:public	signature:() const
begin	.\dynamic-inl.h	/^  It begin() const {$/;"	f	struct:folly::dynamic::IterableProxy	access:public	signature:() const
begin	.\dynamic-inl.h	/^inline dynamic::const_iterator dynamic::begin() const {$/;"	f	class:folly::dynamic	signature:() const
begin	.\dynamic.h	/^  const_iterator begin()  const;$/;"	p	struct:folly::dynamic	access:public	signature:() const
begin	.\io\IOBuf.h	/^  Iterator begin() const;$/;"	p	class:folly::IOBuf	access:public	signature:() const
begin	.\io\IOBuf.h	/^inline IOBuf::Iterator IOBuf::begin() const { return cbegin(); }$/;"	f	class:folly::IOBuf	signature:() const
begin	.\io\RecordIO.h	/^  Iterator begin() const;$/;"	p	class:folly::RecordIOReader	access:public	signature:() const
begin	.\io\TypedIOBuf.h	/^  T* begin() { return writableData(); }$/;"	f	class:folly::TypedIOBuf	access:public	signature:()
begin	.\io\TypedIOBuf.h	/^  const T* begin() const { return cbegin(); }$/;"	f	class:folly::TypedIOBuf	access:public	signature:() const
begin	.\json.cpp	/^  char const* begin() const { return range_.begin(); }$/;"	f	struct:folly::json::__anon75::Input	access:public	signature:() const
begin	.\small_vector.h	/^  const_iterator begin()   const { return data(); }$/;"	f	class:folly::small_vector	access:public	signature:() const
begin	.\small_vector.h	/^  iterator       begin()         { return data(); }$/;"	f	class:folly::small_vector	access:public	signature:()
begin	.\sorted_vector_types.h	/^  const_iterator begin() const          { return m_.cont_.begin();  }$/;"	f	class:folly::sorted_vector_map	access:public	signature:() const
begin	.\sorted_vector_types.h	/^  const_iterator begin() const          { return m_.cont_.begin();  }$/;"	f	class:folly::sorted_vector_set	access:public	signature:() const
begin	.\sorted_vector_types.h	/^  iterator begin()                      { return m_.cont_.begin();  }$/;"	f	class:folly::sorted_vector_map	access:public	signature:()
begin	.\sorted_vector_types.h	/^  iterator begin()                      { return m_.cont_.begin();  }$/;"	f	class:folly::sorted_vector_set	access:public	signature:()
begin	.\stats\Histogram.h	/^  typename std::vector<BucketType>::const_iterator begin() const {$/;"	f	class:folly::detail::HistogramBuckets	access:public	signature:() const
begin	.\stats\Histogram.h	/^  typename std::vector<BucketType>::iterator begin() {$/;"	f	class:folly::detail::HistogramBuckets	access:public	signature:()
begin	.\test\PackedSyncPtrTest.cpp	/^  T* begin() const { return base.get(); }$/;"	f	struct:SyncVec	access:public	signature:() const
benchmark	.\Benchmark.h	/^DECLARE_bool(benchmark);$/;"	v
benchmark	.\io\test\IOBufCursorTest.cpp	/^DECLARE_bool(benchmark);$/;"	v
benchmarkGet	.\experimental\test\BitsBenchmark.cpp	/^void benchmarkGet(size_t n, T x) {$/;"	f	signature:(size_t n, T x)
benchmarkHardwareCRC32C	.\test\ChecksumTest.cpp	/^void benchmarkHardwareCRC32C(unsigned long iters, size_t blockSize) {$/;"	f	signature:(unsigned long iters, size_t blockSize)
benchmarkSet	.\experimental\test\BitsBenchmark.cpp	/^void benchmarkSet(size_t n, T) {$/;"	f	signature:(size_t n, T)
benchmarkSetup	.\test\AtomicHashMapTest.cpp	/^void benchmarkSetup() {$/;"	f	signature:()
benchmarkSoftwareCRC32C	.\test\ChecksumTest.cpp	/^void benchmarkSoftwareCRC32C(unsigned long iters, size_t blockSize) {$/;"	f	signature:(unsigned long iters, size_t blockSize)
benchmark_size	.\io\test\IOBufCursorTest.cpp	/^int benchmark_size = 1000;$/;"	v
benchmarks	.\Benchmark.cpp	/^static vector<tuple<const char*, const char*, BenchmarkFun>> benchmarks;$/;"	m	namespace:folly	file:
bigBuf	.\test\FormatBenchmark.cpp	/^char bigBuf[300];$/;"	m	namespace:__anon118	file:
bigInt	.\test\ConvTest.cpp	/^static size_t bigInt = 11424545345345;$/;"	v	file:
bigLines	.\gen\test\StringBenchmark.cpp	/^std::string bigLines;$/;"	m	namespace:__anon58	file:
binaryPath	.\experimental\symbolizer\test\ElfTests.cpp	/^  static std::string binaryPath;$/;"	m	class:ElfTest	file:	access:public
binaryPath	.\experimental\symbolizer\test\ElfTests.cpp	/^std::string ElfTest::binaryPath;$/;"	m	class:ElfTest	file:
binary_values	.\build\generate_format_tables.py	/^def binary_values():$/;"	f	access:public
bitCount	.\IPAddress.h	/^  size_t bitCount() const {$/;"	f	class:folly::IPAddress	access:public	signature:() const
bitCount	.\IPAddressV4.h	/^  static size_t bitCount() { return 32; }$/;"	f	class:folly::IPAddressV4	access:public	signature:()
bitCount	.\IPAddressV6.h	/^  static size_t bitCount() { return 128; }$/;"	f	class:folly::IPAddressV6	access:public	signature:()
bitOffset	.\AtomicBitSet.h	/^  static constexpr size_t bitOffset(size_t bit) {$/;"	f	class:folly::AtomicBitSet	access:private	signature:(size_t bit)
bitOffset	.\experimental\Bits.h	/^  static constexpr size_t bitOffset(size_t bit) {$/;"	f	struct:folly::Bits	access:public	signature:(size_t bit)
bitOffset_	.\Bits.h	/^  ssize_t bitOffset_;$/;"	v
bit_	.\detail\BitIteratorDetail.h	/^  size_t bit_;$/;"	m	class:folly::bititerator_detail::BitReference	access:private
bititerator_detail	.\detail\BitIteratorDetail.h	/^namespace bititerator_detail {$/;"	n	namespace:folly
bits	.\LifoSem.h	/^  uint64_t bits;$/;"	m	class:folly::detail::LifoSemHead	access:public
bits	.\RWSpinLock.h	/^  int32_t bits() const { return bits_.load(std::memory_order_acquire); }$/;"	f	class:folly::RWSpinLock	access:public	signature:() const
bitsPerBlock	.\experimental\Bits.h	/^  static constexpr size_t bitsPerBlock = std::numeric_limits<$/;"	m	struct:folly::Bits	access:public
bits_	.\RWSpinLock.h	/^  std::atomic<int32_t> bits_;$/;"	m	class:folly::RWSpinLock	access:private
block	.\gen\test\ParallelBenchmark.cpp	/^std::mutex block;$/;"	v
blockCount	.\experimental\Bits.h	/^  static constexpr size_t blockCount(size_t nbits) {$/;"	f	struct:folly::Bits	access:public	signature:(size_t nbits)
blockIndex	.\AtomicBitSet.h	/^  static constexpr size_t blockIndex(size_t bit) {$/;"	f	class:folly::AtomicBitSet	access:private	signature:(size_t bit)
blockIndex	.\experimental\Bits.h	/^  static constexpr size_t blockIndex(size_t bit) {$/;"	f	struct:folly::Bits	access:public	signature:(size_t bit)
block_	.\experimental\EliasFanoCoding.h	/^  block_t block_;$/;"	m	class:folly::compression::detail::UpperBitsReader	access:private
block_t	.\experimental\EliasFanoCoding.h	/^  typedef unsigned long long block_t;$/;"	t	class:folly::compression::detail::UpperBitsReader	access:private
blockingRead	.\MPMCPipeline.h	/^  void blockingRead($/;"	f	class:folly::MPMCPipeline	access:public	signature:( typename std::tuple_element< sizeof...(Stages), StageTuple>::type::value_type& elem)
blockingRead	.\gen\ParallelMap-inl.h	/^      void blockingRead(Output& out) {$/;"	f	class:folly::gen::detail::PMap::Generator::ExecutionPipeline	access:public	signature:(Output& out)
blockingReadStage	.\MPMCPipeline.h	/^  Ticket<Stage> blockingReadStage($/;"	f	class:folly::MPMCPipeline	access:public	signature:( typename std::tuple_element<Stage, StageTuple>::type::value_type& elem)
blockingWrite	.\MPMCPipeline.h	/^  void blockingWrite(Args&&... args) {$/;"	f	class:folly::MPMCPipeline	access:public	signature:(Args&&.... args)
blockingWrite	.\gen\ParallelMap-inl.h	/^      void blockingWrite(Value&& value) {$/;"	f	class:folly::gen::detail::PMap::Generator::ExecutionPipeline	access:public	signature:(Value&& value)
blockingWriteStage	.\MPMCPipeline.h	/^  void blockingWriteStage(Ticket<Stage>& ticket, Args&&... args) {$/;"	f	class:folly::MPMCPipeline	access:public	signature:(Ticket<Stage>& ticket, Args&&... args)
blocks_	.\Arena.h	/^  BlockList blocks_;$/;"	m	class:folly::Arena	access:private
bm	.\experimental\test\EliasFanoCodingTest.cpp	/^namespace bm {$/;"	n	file:
bm::Encoder	.\experimental\test\EliasFanoCodingTest.cpp	/^typedef EliasFanoEncoder<uint32_t, uint32_t, 128, 128, kVersion> Encoder;$/;"	t	namespace:bm	file:
bm::Reader	.\experimental\test\EliasFanoCodingTest.cpp	/^typedef EliasFanoReader<Encoder> Reader;$/;"	t	namespace:bm	file:
bm::data	.\experimental\test\EliasFanoCodingTest.cpp	/^std::vector<uint32_t> data;$/;"	m	namespace:bm	file:
bm::encodeLargeData	.\experimental\test\EliasFanoCodingTest.cpp	/^std::vector<uint32_t> encodeLargeData;$/;"	m	namespace:bm	file:
bm::encodeSmallData	.\experimental\test\EliasFanoCodingTest.cpp	/^std::vector<uint32_t> encodeSmallData;$/;"	m	namespace:bm	file:
bm::free	.\experimental\test\EliasFanoCodingTest.cpp	/^void free() {$/;"	f	namespace:bm	signature:()
bm::init	.\experimental\test\EliasFanoCodingTest.cpp	/^void init() {$/;"	f	namespace:bm	signature:()
bm::k1M	.\experimental\test\EliasFanoCodingTest.cpp	/^constexpr size_t k1M = 1000000;$/;"	m	namespace:bm	file:
bm::kVersion	.\experimental\test\EliasFanoCodingTest.cpp	/^constexpr size_t kVersion = 1;$/;"	m	namespace:bm	file:
bm::list	.\experimental\test\EliasFanoCodingTest.cpp	/^typename Encoder::CompressedList list;$/;"	m	namespace:bm	file:
bm::order	.\experimental\test\EliasFanoCodingTest.cpp	/^std::vector<size_t> order;$/;"	m	namespace:bm	file:
bmJump	.\experimental\test\CodingTestUtils.h	/^void bmJump(const List& list, const std::vector<uint32_t>& data,$/;"	f	namespace:folly::compression	signature:(const List& list, const std::vector<uint32_t>& data, const std::vector<size_t>& order, size_t iters)
bmJumpTo	.\experimental\test\CodingTestUtils.h	/^void bmJumpTo(const List& list, const std::vector<uint32_t>& data,$/;"	f	namespace:folly::compression	signature:(const List& list, const std::vector<uint32_t>& data, const std::vector<size_t>& order, size_t iters)
bmMap	.\test\ForeachTest.cpp	/^std::map<int, std::string> bmMap;  \/\/ For use in benchmarks below.$/;"	v
bmNext	.\experimental\test\CodingTestUtils.h	/^void bmNext(const List& list, const std::vector<uint32_t>& data,$/;"	f	namespace:folly::compression	signature:(const List& list, const std::vector<uint32_t>& data, size_t iters)
bmSkip	.\experimental\test\CodingTestUtils.h	/^void bmSkip(const List& list, const std::vector<uint32_t>& data,$/;"	f	namespace:folly::compression	signature:(const List& list, const std::vector<uint32_t>& data, size_t skip, size_t iters)
bmSkipTo	.\experimental\test\CodingTestUtils.h	/^void bmSkipTo(const List& list, const std::vector<uint32_t>& data,$/;"	f	namespace:folly::compression	signature:(const List& list, const std::vector<uint32_t>& data, size_t skip, size_t iters)
bol_	.\experimental\symbolizer\LineReader.h	/^  char* bol_;$/;"	m	class:folly::symbolizer::LineReader	access:private
bool_str_cmp	.\Conv.cpp	/^inline bool bool_str_cmp(const char** b, size_t len, const char* value) {$/;"	f	namespace:folly::detail	signature:(const char** b, size_t len, const char* value)
boolean	.\dynamic.h	/^    bool boolean;$/;"	m	union:folly::dynamic::Data	access:public
boost	.\String.h	/^namespace boost {$/;"	n	namespace:folly
boost	.\Traits.h	/^namespace boost {$/;"	n
boost::has_nothrow_constructor	.\Traits.h	/^struct has_nothrow_constructor< std::pair<T, U> >$/;"	s	namespace:boost	inherits:::boost::mpl::and_
boost::shared_ptr	.\Traits.h	/^template <class T> class shared_ptr;$/;"	x
boost_tsp	.\test\ThreadLocalTest.cpp	/^REG(boost_tsp);$/;"	v
boost_tsp	.\test\ThreadLocalTest.cpp	/^boost::thread_specific_ptr<int> boost_tsp;$/;"	v
boundary	.\Benchmark.cpp	/^  double boundary;$/;"	m	struct:folly::ScaleInfo	file:	access:public
bsys	.\experimental\io\FsUtil.cpp	/^namespace bsys = ::boost::system;$/;"	x	file:
bucketSize_	.\stats\Histogram.h	/^  ValueType bucketSize_;$/;"	m	class:folly::detail::HistogramBuckets	access:private
bucketStarts	.\test\TimeseriesTest.cpp	/^  vector<ssize_t> bucketStarts;$/;"	m	struct:TestData	file:	access:public
buckets_	.\io\async\HHWheelTimer.h	/^  CallbackList buckets_[WHEEL_BUCKETS][WHEEL_SIZE];$/;"	m	class:folly::HHWheelTimer	access:private
buckets_	.\stats\BucketedTimeSeries.h	/^  std::vector<Bucket> buckets_;  \/\/ actual buckets of values$/;"	m	class:folly::BucketedTimeSeries	access:private
buckets_	.\stats\Histogram.h	/^  detail::HistogramBuckets<ValueType, Bucket> buckets_;$/;"	m	class:folly::Histogram	access:private
buckets_	.\stats\Histogram.h	/^  std::vector<BucketType> buckets_;$/;"	m	class:folly::detail::HistogramBuckets	access:private
buckets_	.\stats\TimeseriesHistogram.h	/^  folly::detail::HistogramBuckets<ValueType, ContainerType> buckets_;$/;"	m	class:folly::TimeseriesHistogram	access:private
buf	.\io\IOBuf.cpp	/^  folly::IOBuf buf;$/;"	m	struct:folly::IOBuf::HeapStorage	file:	access:public
buf2_	.\io\test\IOBufTest.cpp	/^  std::unique_ptr<IOBuf> buf2_;$/;"	m	class:MoveToFbStringTest	file:	access:protected
bufEnd_	.\experimental\symbolizer\LineReader.h	/^  char* const bufEnd_;$/;"	m	class:folly::symbolizer::LineReader	access:private
bufPool	.\io\test\NetworkBenchmark.cpp	/^vector<unique_ptr<IOBuf>> bufPool;$/;"	v
bufSize_	.\Subprocess.h	/^    const uint64_t bufSize_;$/;"	m	class:folly::Subprocess::ReadLinesCallback	access:private
bufTemplate	.\experimental\symbolizer\Symbolizer.cpp	/^constexpr char AddressFormatter::bufTemplate[];$/;"	m	class:folly::symbolizer::AddressFormatter	file:
bufTemplate	.\experimental\symbolizer\Symbolizer.h	/^  static constexpr char bufTemplate[] = "    @ 0000000000000000";$/;"	m	class:folly::symbolizer::AddressFormatter	access:private
buf_	.\GroupVarint.h	/^  type buf_[Base::kGroupSize];$/;"	m	class:folly::GroupVarintDecoder	access:private
buf_	.\GroupVarint.h	/^  type buf_[Base::kGroupSize];$/;"	m	class:folly::GroupVarintEncoder	access:private
buf_	.\experimental\symbolizer\LineReader.h	/^  char* const buf_;$/;"	m	class:folly::symbolizer::LineReader	access:private
buf_	.\experimental\symbolizer\Symbolizer.h	/^  char buf_[sizeof(bufTemplate)];$/;"	m	class:folly::symbolizer::AddressFormatter	access:private
buf_	.\experimental\symbolizer\Symbolizer.h	/^  fbstring buf_;$/;"	m	class:folly::symbolizer::StringSymbolizePrinter	access:private
buf_	.\io\TypedIOBuf.h	/^  IOBuf* buf_;$/;"	m	class:folly::TypedIOBuf	access:private
buf_	.\io\test\IOBufTest.cpp	/^  std::unique_ptr<IOBuf> buf_;$/;"	m	class:MoveToFbStringTest	file:	access:protected
buffer	.\io\IOBuf.h	/^  const uint8_t* buffer() const {$/;"	f	class:folly::IOBuf	access:public	signature:() const
buffer	.\io\TypedIOBuf.h	/^  const T* buffer() const {$/;"	f	class:folly::TypedIOBuf	access:public	signature:() const
buffer	.\test\ChecksumTest.cpp	/^uint8_t buffer[BUFFER_SIZE];$/;"	m	namespace:__anon112	file:
bufferEnd	.\io\IOBuf.h	/^  const uint8_t* bufferEnd() const {$/;"	f	class:folly::IOBuf	access:public	signature:() const
bufferEnd	.\io\TypedIOBuf.h	/^  const T* bufferEnd() const {$/;"	f	class:folly::TypedIOBuf	access:public	signature:() const
bufferSize_	.\Random.cpp	/^  const size_t bufferSize_;$/;"	m	class:folly::__anon82::BufferedRandomDevice	file:	access:private
buffer_	.\Random.cpp	/^  std::unique_ptr<unsigned char[]> buffer_;$/;"	m	class:folly::__anon82::BufferedRandomDevice	file:	access:private
buffer_	.\experimental\symbolizer\Symbolizer.h	/^  std::unique_ptr<IOBuf> buffer_;$/;"	m	class:folly::symbolizer::FDSymbolizePrinter	access:private
buffer_	.\gen\File-inl.h	/^  std::unique_ptr<IOBuf> buffer_;$/;"	m	class:folly::gen::detail::FileReader	access:private
buffer_	.\gen\File-inl.h	/^  std::unique_ptr<IOBuf> buffer_;$/;"	m	class:folly::gen::detail::FileWriter	access:private
buffer_	.\gen\String.h	/^  IOBuf buffer_;$/;"	m	class:folly::gen::StreamSplitter	access:private
buffer_	.\io\Cursor.h	/^  BufType* buffer_;$/;"	m	class:folly::io::detail::CursorBase	access:private
buffer_	.\io\Cursor.h	/^  IOBuf* buffer_;$/;"	m	class:folly::io::Appender	access:private
bufferedRandomDevice	.\Random.cpp	/^ThreadLocal<BufferedRandomDevice> bufferedRandomDevice;$/;"	m	namespace:folly::__anon82	file:
buffers_	.\test\FileUtilTest.cpp	/^  std::vector<std::string> buffers_;$/;"	m	class:folly::test::IovecBuffers	file:	access:private
bumpHandlingTime	.\io\async\EventBase.cpp	/^bool EventBase::bumpHandlingTime() {$/;"	f	class:folly::EventBase	signature:()
bumpHandlingTime	.\io\async\EventBase.h	/^  bool bumpHandlingTime();$/;"	p	class:folly::EventBase	access:public	signature:()
bumpHandlingTime	.\io\async\TimeoutManager.h	/^  virtual bool bumpHandlingTime() = 0;$/;"	p	class:folly::TimeoutManager	access:public	signature:()
byteCount	.\IPAddress.h	/^  size_t byteCount() const {$/;"	f	class:folly::IPAddress	access:public	signature:() const
byteCount	.\IPAddressV4.h	/^  static size_t byteCount() { return 4; }$/;"	f	class:folly::IPAddressV4	access:public	signature:()
byteCount	.\IPAddressV6.h	/^  static constexpr size_t byteCount() { return 16; }$/;"	f	class:folly::IPAddressV6	access:public	signature:()
bytes	.\IPAddress.h	/^  const unsigned char* bytes() const {$/;"	f	class:folly::IPAddress	access:public	signature:() const
bytes	.\IPAddressV4.h	/^  const unsigned char* bytes() const { return addr_.bytes_.data(); }$/;"	f	class:folly::IPAddressV4	access:public	signature:() const
bytes	.\IPAddressV6.h	/^  const unsigned char* bytes() const { return addr_.in6Addr_.s6_addr; }$/;"	f	class:folly::IPAddressV6	access:public	signature:() const
bytes	.\MacAddress.h	/^  const uint8_t* bytes() const {$/;"	f	class:folly::MacAddress	access:public	signature:() const
bytes	.\test\IPAddressTest.h	/^  ByteVector bytes;$/;"	m	struct:folly::AddressData	access:public
bytes	.\test\IPAddressTest.h	/^  ByteVector bytes;$/;"	m	struct:folly::SerializeData	access:public
bytesUsed	.\Arena.h	/^  size_t bytesUsed() const {$/;"	f	class:folly::Arena	access:public	signature:() const
bytesUsed_	.\Arena.h	/^  size_t bytesUsed_;$/;"	m	class:folly::Arena	access:private
bytes_	.\IPAddressV4.h	/^    ByteArray4 bytes_;$/;"	m	union:folly::IPAddressV4::AddressStorage	access:public
bytes_	.\IPAddressV6.h	/^    ByteArray16 bytes_;$/;"	m	union:folly::IPAddressV6::AddressStorage	access:public
bytes_	.\MacAddress.h	/^  unsigned char bytes_[8];$/;"	m	class:folly::MacAddress	access:private
c	.\Portability.h	/^struct MaxAlign { char c; } __attribute__((__aligned__));$/;"	m	struct:MaxAlign	access:public
c	.\test\OptionalTest.cpp	/^  char a, b, c;$/;"	m	struct:folly::NoDefault	file:	access:public
c	.\test\PackedSyncPtrTest.cpp	/^struct ignore { PackedSyncPtr<int> foo; char c; } FOLLY_PACK_ATTR;$/;"	m	struct:__anon126::ignore	file:	access:public
cEscape	.\String-inl.h	/^void cEscape(StringPiece str, String& out) {$/;"	f	namespace:folly	signature:(StringPiece str, String& out)
cEscape	.\String.h	/^String cEscape(StringPiece str) {$/;"	f	namespace:folly	signature:(StringPiece str)
cEscape	.\String.h	/^void cEscape(StringPiece str, String& out);$/;"	p	namespace:folly	signature:(StringPiece str, String& out)
cEscapedString	.\test\StringTest.cpp	/^fbstring cEscapedString;$/;"	m	namespace:__anon136	file:
cUnescape	.\String-inl.h	/^void cUnescape(StringPiece str, String& out, bool strict) {$/;"	f	namespace:folly	signature:(StringPiece str, String& out, bool strict)
cUnescape	.\String.h	/^String cUnescape(StringPiece str, bool strict = true) {$/;"	f	namespace:folly	signature:(StringPiece str, bool strict = true)
cUnescape	.\String.h	/^void cUnescape(StringPiece str, String& out, bool strict = true);$/;"	p	namespace:folly	signature:(StringPiece str, String& out, bool strict = true)
cUnescapedString	.\test\StringTest.cpp	/^fbstring cUnescapedString;$/;"	m	namespace:__anon136	file:
c_	.\CpuId.h	/^  uint32_t c_;  \/\/ ECX$/;"	m	class:folly::CpuId	access:private
c_	.\Padded.h	/^  Container c_;  \/\/ container of Nodes$/;"	m	class:folly::Adaptor	access:private
c_str	.\dynamic-inl.h	/^inline const char* dynamic::c_str() const { return get<fbstring>().c_str(); }$/;"	f	class:folly::dynamic	signature:() const
c_str	.\dynamic.h	/^  const char* c_str() const;$/;"	p	struct:folly::dynamic	access:public	signature:() const
cacheChainLength	.\io\IOBufQueue.h	/^    bool cacheChainLength;$/;"	m	struct:folly::IOBufQueue::Options	access:public
cacheChainLength	.\io\IOBufQueue.h	/^  static Options cacheChainLength() {$/;"	f	class:folly::IOBufQueue	access:public	signature:()
cacheSize_	.\ThreadCachedInt.h	/^  std::atomic<uint32_t> cacheSize_;$/;"	m	class:folly::ThreadCachedInt	access:private
cache_	.\DynamicConverter.h	/^  mutable ttype cache_;$/;"	m	class:folly::dynamicconverter_detail::Transformer	access:private
cache_	.\ThreadCachedInt.h	/^  ThreadLocalPtr<IntCache,Tag> cache_; \/\/ Must be last for dtor ordering$/;"	m	class:folly::ThreadCachedInt	access:private
cache_	.\experimental\symbolizer\Symbolizer.h	/^  ElfCacheBase* cache_;$/;"	m	class:folly::symbolizer::Symbolizer	access:private
cachedCount_	.\stats\MultiLevelTimeSeries.h	/^  int cachedCount_;$/;"	m	class:folly::MultiLevelTimeSeries	access:private
cachedSum_	.\stats\MultiLevelTimeSeries.h	/^  ValueType cachedSum_;$/;"	m	class:folly::MultiLevelTimeSeries	access:private
cachedTime_	.\stats\MultiLevelTimeSeries.h	/^  TimeType cachedTime_;$/;"	m	class:folly::MultiLevelTimeSeries	access:private
callPreviousSignalHandler	.\experimental\symbolizer\SignalHandler.cpp	/^void callPreviousSignalHandler(int signum) {$/;"	f	namespace:folly::symbolizer::__anon36	signature:(int signum)
call_fn	.\ExceptionWrapper.h	/^  void call_fn(F&& fn) {$/;"	f	class:folly::try_and_catch	access:protected	signature:(F&& fn)
callback	.\TimeoutQueue.h	/^    Callback callback;$/;"	m	struct:folly::TimeoutQueue::Event	access:public
callback	.\wangle\OpaqueCallbackShunt.h	/^  static void callback(void* arg) {$/;"	f	class:folly::wangle::OpaqueCallbackLaterShunt	access:public	signature:(void* arg)
callback	.\wangle\OpaqueCallbackShunt.h	/^  static void callback(void* arg) {$/;"	f	class:folly::wangle::OpaqueCallbackShunt	access:public	signature:(void* arg)
callback1	.\experimental\symbolizer\test\SignalHandlerTest.cpp	/^void callback1() {$/;"	f	namespace:folly::symbolizer::test::__anon44	signature:()
callback2	.\experimental\symbolizer\test\SignalHandlerTest.cpp	/^void callback2() {$/;"	f	namespace:folly::symbolizer::test::__anon44	signature:()
callback_	.\experimental\wangle\ConnectionManager.h	/^  Callback* callback_;$/;"	m	class:folly::wangle::ConnectionManager	access:private
callback_	.\wangle\detail\State.h	/^  std::function<void(Try<T>&&)> callback_;$/;"	m	class:folly::wangle::detail::State	access:private
calledBack_	.\wangle\detail\State.h	/^  bool calledBack_ = false;$/;"	m	class:folly::wangle::detail::State	access:private
cancelLoopCallback	.\io\async\EventBase.h	/^    void cancelLoopCallback() {$/;"	f	class:folly::EventBase::LoopCallback	access:public	signature:()
cancelTimeout	.\io\async\AsyncTimeout.cpp	/^void AsyncTimeout::cancelTimeout() {$/;"	f	class:folly::AsyncTimeout	signature:()
cancelTimeout	.\io\async\AsyncTimeout.h	/^  void cancelTimeout();$/;"	p	class:folly::AsyncTimeout	access:public	signature:()
cancelTimeout	.\io\async\EventBase.cpp	/^void EventBase::cancelTimeout(AsyncTimeout* obj) {$/;"	f	class:folly::EventBase	signature:(AsyncTimeout* obj)
cancelTimeout	.\io\async\EventBase.h	/^  void cancelTimeout(AsyncTimeout* obj);$/;"	p	class:folly::EventBase	access:private	signature:(AsyncTimeout* obj)
cancelTimeout	.\io\async\HHWheelTimer.h	/^    void cancelTimeout() {$/;"	f	class:folly::HHWheelTimer::Callback	access:public	signature:()
cancelTimeout	.\io\async\TimeoutManager.h	/^  virtual void cancelTimeout(AsyncTimeout* obj) = 0;$/;"	p	class:folly::TimeoutManager	access:public	signature:(AsyncTimeout* obj)
cancelTimeoutImpl	.\io\async\HHWheelTimer.cpp	/^void HHWheelTimer::Callback::cancelTimeoutImpl() {$/;"	f	class:folly::HHWheelTimer::Callback	signature:()
cancelTimeoutImpl	.\io\async\HHWheelTimer.h	/^    void cancelTimeoutImpl();$/;"	p	class:folly::HHWheelTimer::Callback	access:private	signature:()
canonical_parent	.\experimental\io\FsUtil.cpp	/^path canonical_parent(const path& pth, const path& base) {$/;"	f	namespace:folly::fs	signature:(const path& pth, const path& base)
canonical_parent	.\experimental\io\FsUtil.h	/^path canonical_parent(const path& p, const path& basePath = current_path());$/;"	p	namespace:folly::fs	signature:(const path& p, const path& basePath = current_path())
capacity	.\AtomicHashArray.h	/^    size_t capacity; \/\/ if positive, overrides maxLoadFactor$/;"	m	struct:folly::AtomicHashArray::Config	access:public
capacity	.\AtomicHashMap-inl.h	/^capacity() const {$/;"	f	class:folly::AtomicHashMap	signature:() const
capacity	.\AtomicHashMap.h	/^  size_t capacity() const;$/;"	p	class:folly::AtomicHashMap	access:public	signature:() const
capacity	.\IndexedMemPool.h	/^  size_t capacity() {$/;"	f	struct:folly::IndexedMemPool	access:public	signature:()
capacity	.\Padded.h	/^  size_type capacity() const {$/;"	f	class:folly::Adaptor	access:public	signature:() const
capacity	.\experimental\io\AsyncIO.h	/^  size_t capacity() const { return capacity_; }$/;"	f	class:folly::AsyncIO	access:public	signature:() const
capacity	.\experimental\wangle\concurrent\LifoSemMPMCQueue.h	/^  size_t capacity() {$/;"	f	class:folly::wangle::LifoSemMPMCQueue	access:public	signature:()
capacity	.\io\IOBuf.h	/^  uint64_t capacity() const {$/;"	f	class:folly::IOBuf	access:public	signature:() const
capacity	.\io\TypedIOBuf.h	/^  uint32_t capacity() const {$/;"	f	class:folly::TypedIOBuf	access:public	signature:() const
capacity	.\small_vector.h	/^  size_type capacity() const {$/;"	f	class:folly::small_vector	access:public	signature:() const
capacity	.\sorted_vector_types.h	/^  size_type capacity() const    { return m_.cont_.capacity(); }$/;"	f	class:folly::sorted_vector_map	access:public	signature:() const
capacity	.\sorted_vector_types.h	/^  size_type capacity() const    { return m_.cont_.capacity(); }$/;"	f	class:folly::sorted_vector_set	access:public	signature:() const
capacityForMaxIndex	.\IndexedMemPool.h	/^  static constexpr uint32_t capacityForMaxIndex(uint32_t maxIndex) {$/;"	f	struct:folly::IndexedMemPool	access:public	signature:(uint32_t maxIndex)
capacity_	.\AtomicHashArray.h	/^  const size_t  capacity_;$/;"	m	class:folly::AtomicHashArray	access:public
capacity_	.\MPMCQueue.h	/^    : capacity_(rhs.capacity_)$/;"	p	class:folly::MPMCQueue	access:public	signature:(rhs.capacity_)
capacity_	.\MPMCQueue.h	/^  size_t FOLLY_ALIGN_TO_AVOID_FALSE_SHARING capacity_;$/;"	m	class:folly::MPMCQueue	access:private
capacity_	.\experimental\io\AsyncIO.h	/^  const size_t capacity_;$/;"	m	class:folly::AsyncIO	access:private
capacity_	.\experimental\symbolizer\ElfCache.h	/^  size_t capacity_;$/;"	m	class:folly::symbolizer::ElfCache	access:private
capacity_	.\small_vector.h	/^    InternalSizeType capacity_;$/;"	m	struct:folly::small_vector::HeapPtrWithCapacity	access:public
cas	.\SmallLocks.h	/^  bool cas(uint8_t compare, uint8_t newVal) {$/;"	f	struct:folly::MicroSpinLock	access:public	signature:(uint8_t compare, uint8_t newVal)
cascadeTimers	.\io\async\HHWheelTimer.cpp	/^bool HHWheelTimer::cascadeTimers(int bucket, int tick) {$/;"	f	class:folly::HHWheelTimer	signature:(int bucket, int tick)
cascadeTimers	.\io\async\HHWheelTimer.h	/^  bool cascadeTimers(int bucket, int tick);$/;"	p	class:folly::HHWheelTimer	access:private	signature:(int bucket, int tick)
cast	.\io\TypedIOBuf.h	/^  static T* cast(uint8_t* p) {$/;"	f	class:folly::TypedIOBuf	access:private	signature:(uint8_t* p)
cast	.\io\TypedIOBuf.h	/^  static const T* cast(const uint8_t* p) {$/;"	f	class:folly::TypedIOBuf	access:private	signature:(const uint8_t* p)
castToConst	.\Range.h	/^  const_range_type castToConst() const {$/;"	f	class:folly::Range	access:public	signature:() const
cat	.\gen\test\ParallelBenchmark.cpp	/^auto cat = concat;$/;"	v
catchTemp	.\experimental\exception_tracer\ExceptionAbi.h	/^  void* catchTemp;$/;"	m	struct:__cxxabiv1::__cxa_exception	access:public
catchupEveryN_	.\io\async\HHWheelTimer.h	/^  uint32_t catchupEveryN_;$/;"	m	class:folly::HHWheelTimer	access:private
caughtExceptions	.\experimental\exception_tracer\ExceptionAbi.h	/^  __cxa_exception* caughtExceptions;$/;"	m	struct:__cxxabiv1::__cxa_eh_globals	access:public
caughtExceptions	.\experimental\exception_tracer\ExceptionTracerLib.cpp	/^FOLLY_TLS StackTraceStack caughtExceptions;$/;"	m	namespace:__anon25	file:
cb_	.\Subprocess.h	/^      Callback& cb_;$/;"	m	struct:folly::Subprocess::ReadLinesCallback::StreamSplitterCallback	access:public
cb_	.\experimental\io\AsyncIO.h	/^  NotificationCallback cb_;$/;"	m	class:folly::AsyncIOOp	access:private
cbegin	.\ConcurrentSkipList.h	/^  const_iterator cbegin() const { return begin(); }$/;"	f	class:folly::ConcurrentSkipList::Accessor	access:public	signature:() const
cbegin	.\EvictingCacheMap.h	/^  const_iterator cbegin() const {$/;"	f	class:folly::EvictingCacheMap	access:public	signature:() const
cbegin	.\Padded.h	/^  const_iterator cbegin() const {$/;"	f	class:folly::Adaptor	access:public	signature:() const
cbegin	.\Padded.h	/^Iterator<typename Container::const_iterator> cbegin(const Container& c) {$/;"	f	namespace:folly	signature:(const Container& c)
cbegin	.\Range.h	/^  Iter cbegin() const { return b_; }$/;"	f	class:folly::Range	access:public	signature:() const
cbegin	.\io\IOBuf.cpp	/^IOBuf::Iterator IOBuf::cbegin() const {$/;"	f	class:folly::IOBuf	signature:() const
cbegin	.\io\IOBuf.h	/^  Iterator cbegin() const;$/;"	p	class:folly::IOBuf	access:public	signature:() const
cbegin	.\io\RecordIO.h	/^  Iterator cbegin() const;$/;"	p	class:folly::RecordIOReader	access:public	signature:() const
cbegin	.\io\TypedIOBuf.h	/^  const T* cbegin() const { return data(); }$/;"	f	class:folly::TypedIOBuf	access:public	signature:() const
cbegin	.\small_vector.h	/^  const_iterator cbegin()  const { return begin(); }$/;"	f	class:folly::small_vector	access:public	signature:() const
cbmEscapedString	.\test\StringTest.cpp	/^fbstring cbmEscapedString;$/;"	m	namespace:__anon136	file:
cbmString	.\test\StringTest.cpp	/^fbstring cbmString;$/;"	m	namespace:__anon136	file:
cellKeyPtr	.\AtomicHashArray.h	/^  static std::atomic<KeyT>* cellKeyPtr(const value_type& r) {$/;"	f	class:folly::AtomicHashArray	access:private	signature:(const value_type& r)
cells_	.\AtomicHashArray.h	/^  value_type cells_[0];  \/\/ This must be the last field of this class$/;"	m	class:folly::AtomicHashArray	access:private
cend	.\ConcurrentSkipList.h	/^  const_iterator cend() const { return end(); }$/;"	f	class:folly::ConcurrentSkipList::Accessor	access:public	signature:() const
cend	.\EvictingCacheMap.h	/^  const_iterator cend() const {$/;"	f	class:folly::EvictingCacheMap	access:public	signature:() const
cend	.\Padded.h	/^  const_iterator cend() const {$/;"	f	class:folly::Adaptor	access:public	signature:() const
cend	.\Padded.h	/^Iterator<typename Container::const_iterator> cend(const Container& c) {$/;"	f	namespace:folly	signature:(const Container& c)
cend	.\Range.h	/^  Iter cend() const { return e_; }$/;"	f	class:folly::Range	access:public	signature:() const
cend	.\io\IOBuf.cpp	/^IOBuf::Iterator IOBuf::cend() const {$/;"	f	class:folly::IOBuf	signature:() const
cend	.\io\IOBuf.h	/^  Iterator cend() const;$/;"	p	class:folly::IOBuf	access:public	signature:() const
cend	.\io\RecordIO.h	/^  Iterator cend() const;$/;"	p	class:folly::RecordIOReader	access:public	signature:() const
cend	.\io\TypedIOBuf.h	/^  const T* cend() const { return tail(); }$/;"	f	class:folly::TypedIOBuf	access:public	signature:() const
cend	.\small_vector.h	/^  const_iterator cend()    const { return end(); }$/;"	f	class:folly::small_vector	access:public	signature:() const
ch	.\gen\String-inl.h	/^inline const char* ch(const unsigned char* p) {$/;"	f	namespace:folly::gen::detail	signature:(const unsigned char* p)
ch	.\gen\test\ParallelBenchmark.cpp	/^auto ch = chunks;$/;"	v
chainLength	.\io\IOBufQueue.h	/^  size_t chainLength() const {$/;"	f	class:folly::IOBufQueue	access:public	signature:() const
chainLength_	.\io\IOBufQueue.h	/^  size_t chainLength_;$/;"	m	class:folly::IOBufQueue	access:private
changeHandlerFD	.\io\async\EventHandler.cpp	/^void EventHandler::changeHandlerFD(int fd) {$/;"	f	class:folly::EventHandler	signature:(int fd)
changeHandlerFD	.\io\async\EventHandler.h	/^  void changeHandlerFD(int fd);$/;"	p	class:folly::EventHandler	access:public	signature:(int fd)
chdir	.\Subprocess.h	/^    Options& chdir(const std::string& dir) { childDir_ = dir; return *this; }$/;"	f	class:folly::Subprocess::Options	access:public	signature:(const std::string& dir)
check	.\Traits.h	/^  constexpr static bool check(T x) { return false; }$/;"	f	struct:folly::detail::is_negative_impl	access:public	signature:(T x)
check	.\Traits.h	/^  constexpr static bool check(T x) { return x < 0; }$/;"	f	struct:folly::detail::is_negative_impl	access:public	signature:(T x)
check	.\io\test\IOBufTest.cpp	/^  void check(std::unique_ptr<IOBuf>& buf) {$/;"	f	class:MoveToFbStringTest	access:protected	signature:(std::unique_ptr<IOBuf>& buf)
check	.\test\ThreadLocalTest.cpp	/^  void check() {$/;"	f	class:__anon146::FillObject	access:public	signature:()
checkAdvanceToNextSubmap	.\AtomicHashMap-inl.h	/^  void checkAdvanceToNextSubmap() {$/;"	f	struct:folly::AtomicHashMap::ahm_iterator	access:private	signature:()
checkBuf	.\io\test\IOBufTest.cpp	/^void checkBuf(ByteRange buf, boost::mt19937& gen) {$/;"	f	signature:(ByteRange buf, boost::mt19937& gen)
checkBuf	.\io\test\IOBufTest.cpp	/^void checkBuf(IOBuf* buf, boost::mt19937& gen) {$/;"	f	signature:(IOBuf* buf, boost::mt19937& gen)
checkBuf	.\io\test\IOBufTest.cpp	/^void checkBuf(const uint8_t* buf, uint32_t length, boost::mt19937& gen) {$/;"	f	signature:(const uint8_t* buf, uint32_t length, boost::mt19937& gen)
checkChain	.\io\test\IOBufTest.cpp	/^void checkChain(IOBuf* buf, boost::mt19937& gen) {$/;"	f	signature:(IOBuf* buf, boost::mt19937& gen)
checkConsistency	.\io\test\IOBufQueueTest.cpp	/^void checkConsistency(const IOBufQueue& queue) {$/;"	f	namespace:__anon70	signature:(const IOBufQueue& queue)
checkFdLeak	.\test\SubprocessTest.cpp	/^void checkFdLeak(const Runnable& r) {$/;"	f	namespace:__anon140	signature:(const Runnable& r)
checkFopenError	.\Exception.h	/^void checkFopenError(FILE* fp, Args&&... args) {$/;"	f	namespace:folly	signature:(FILE* fp, Args&&... args)
checkFopenErrorExplicit	.\Exception.h	/^void checkFopenErrorExplicit(FILE* fp, int savedErrno, Args&&... args) {$/;"	f	namespace:folly	signature:(FILE* fp, int savedErrno, Args&&... args)
checkGuard	.\experimental\exception_tracer\StackTrace.h	/^  void checkGuard() const {$/;"	f	class:folly::exception_tracer::StackTraceStack	access:private	signature:() const
checkIt	.\test\BitIteratorTest.cpp	/^void checkIt(INT exp, IT& it) {$/;"	f	namespace:__anon109	signature:(INT exp, IT& it)
checkJenkins	.\test\HashTest.cpp	/^void checkJenkins(uint32_t r) {$/;"	f	namespace:__anon123	signature:(uint32_t r)
checkKernelError	.\Exception.h	/^void checkKernelError(ssize_t ret, Args&&... args) {$/;"	f	namespace:folly	signature:(ssize_t ret, Args&&... args)
checkPid	.\io\async\NotificationQueue.h	/^  void checkPid() const {$/;"	f	class:folly::NotificationQueue	access:public	signature:() const
checkPosixError	.\Exception.h	/^void checkPosixError(int err, Args&&... args) {$/;"	f	namespace:folly	signature:(int err, Args&&... args)
checkQueueSize	.\io\async\NotificationQueue.h	/^  inline bool checkQueueSize(size_t maxSize, bool throws=true) const {$/;"	f	class:folly::NotificationQueue	access:private	signature:(size_t maxSize, bool throws=true) const
checkRange	.\test\BitIteratorTest.cpp	/^void checkRange(INT exp, IT begin, IT end) {$/;"	f	namespace:__anon109	signature:(INT exp, IT begin, IT end)
checkResplitMaxLength	.\gen\test\StringTest.cpp	/^void checkResplitMaxLength(vector<string> ins,$/;"	f	signature:(vector<string> ins, char delim, uint64_t maxLength, vector<string> outs)
checkStatus	.\Subprocess.cpp	/^void checkStatus(ProcessReturnCode returnCode) {$/;"	f	namespace:folly::__anon97	signature:(ProcessReturnCode returnCode)
checkTWang	.\test\HashTest.cpp	/^void checkTWang(uint64_t r) {$/;"	f	namespace:__anon122	signature:(uint64_t r)
checkUnixError	.\Exception.h	/^void checkUnixError(ssize_t ret, Args&&... args) {$/;"	f	namespace:folly	signature:(ssize_t ret, Args&&... args)
checkUnixErrorExplicit	.\Exception.h	/^void checkUnixErrorExplicit(ssize_t ret, int savedErrno, Args&&... args) {$/;"	f	namespace:folly	signature:(ssize_t ret, int savedErrno, Args&&... args)
check_invariant	.\test\sorted_vector_test.cpp	/^void check_invariant(Container& c) {$/;"	f	namespace:__anon133	signature:(Container& c)
childDir_	.\Subprocess.h	/^    std::string childDir_;  \/\/ "" keeps the parent's working directory$/;"	m	class:folly::Subprocess::Options	access:private
childError	.\Subprocess.cpp	/^FOLLY_NORETURN void childError(int errFd, int errCode, int errnoValue);$/;"	p	namespace:folly::__anon98	file:	signature:(int errFd, int errCode, int errnoValue)
childError	.\Subprocess.cpp	/^void childError(int errFd, int errCode, int errnoValue) {$/;"	f	namespace:folly::__anon98	signature:(int errFd, int errCode, int errnoValue)
childFd	.\Subprocess.h	/^    int childFd = -1;$/;"	m	struct:folly::Subprocess::PipeInfo	access:public
chrono	.\Chrono.h	/^namespace std { namespace chrono {$/;"	n	namespace:std
chunkSize_	.\gen\Parallel-inl.h	/^  int chunkSize_;$/;"	m	class:folly::gen::detail::ChunkedRangeSource	access:private
chunked	.\gen\Parallel.h	/^Chunked chunked(Container& container, int chunkSize = 256) {$/;"	f	namespace:folly::gen	signature:(Container& container, int chunkSize = 256)
chunked	.\gen\Parallel.h	/^Chunked chunked(const Container& container, int chunkSize = 256) {$/;"	f	namespace:folly::gen	signature:(const Container& container, int chunkSize = 256)
chunks	.\gen\test\ParallelBenchmark.cpp	/^auto chunks = chunked(v);$/;"	v
clOptions	.\io\test\IOBufQueueTest.cpp	/^IOBufQueue::Options clOptions;$/;"	m	namespace:__anon70	file:
class_is_container	.\DynamicConverter.h	/^template <typename T> struct class_is_container {$/;"	s	namespace:folly::dynamicconverter_detail
class_is_range	.\DynamicConverter.h	/^template <typename T> struct class_is_range {$/;"	s	namespace:folly::dynamicconverter_detail
clause11_21_4_2_a	.\test\FBStringTest.cpp	/^template <class String> void clause11_21_4_2_a(String & test) {$/;"	f	signature:(String & test)
clause11_21_4_2_b	.\test\FBStringTest.cpp	/^template <class String> void clause11_21_4_2_b(String & test) {$/;"	f	signature:(String & test)
clause11_21_4_2_c	.\test\FBStringTest.cpp	/^template <class String> void clause11_21_4_2_c(String & test) {$/;"	f	signature:(String & test)
clause11_21_4_2_d	.\test\FBStringTest.cpp	/^template <class String> void clause11_21_4_2_d(String & test) {$/;"	f	signature:(String & test)
clause11_21_4_2_e	.\test\FBStringTest.cpp	/^template <class String> void clause11_21_4_2_e(String & test) {$/;"	f	signature:(String & test)
clause11_21_4_2_f	.\test\FBStringTest.cpp	/^template <class String> void clause11_21_4_2_f(String & test) {$/;"	f	signature:(String & test)
clause11_21_4_2_g	.\test\FBStringTest.cpp	/^template <class String> void clause11_21_4_2_g(String & test) {$/;"	f	signature:(String & test)
clause11_21_4_2_h	.\test\FBStringTest.cpp	/^template <class String> void clause11_21_4_2_h(String & test) {$/;"	f	signature:(String & test)
clause11_21_4_2_i	.\test\FBStringTest.cpp	/^template <class String> void clause11_21_4_2_i(String & test) {$/;"	f	signature:(String & test)
clause11_21_4_2_j	.\test\FBStringTest.cpp	/^template <class String> void clause11_21_4_2_j(String & test) {$/;"	f	signature:(String & test)
clause11_21_4_2_k	.\test\FBStringTest.cpp	/^template <class String> void clause11_21_4_2_k(String & test) {$/;"	f	signature:(String & test)
clause11_21_4_2_l	.\test\FBStringTest.cpp	/^template <class String> void clause11_21_4_2_l(String & test) {$/;"	f	signature:(String & test)
clause11_21_4_2_lprime	.\test\FBStringTest.cpp	/^template <class String> void clause11_21_4_2_lprime(String & test) {$/;"	f	signature:(String & test)
clause11_21_4_2_m	.\test\FBStringTest.cpp	/^template <class String> void clause11_21_4_2_m(String & test) {$/;"	f	signature:(String & test)
clause11_21_4_2_n	.\test\FBStringTest.cpp	/^template <class String> void clause11_21_4_2_n(String & test) {$/;"	f	signature:(String & test)
clause11_21_4_3	.\test\FBStringTest.cpp	/^template <class String> void clause11_21_4_3(String & test) {$/;"	f	signature:(String & test)
clause11_21_4_4	.\test\FBStringTest.cpp	/^template <class String> void clause11_21_4_4(String & test) {$/;"	f	signature:(String & test)
clause11_21_4_5	.\test\FBStringTest.cpp	/^template <class String> void clause11_21_4_5(String & test) {$/;"	f	signature:(String & test)
clause11_21_4_6_1	.\test\FBStringTest.cpp	/^template <class String> void clause11_21_4_6_1(String & test) {$/;"	f	signature:(String & test)
clause11_21_4_6_2	.\test\FBStringTest.cpp	/^template <class String> void clause11_21_4_6_2(String & test) {$/;"	f	signature:(String & test)
clause11_21_4_6_3_a	.\test\FBStringTest.cpp	/^template <class String> void clause11_21_4_6_3_a(String & test) {$/;"	f	signature:(String & test)
clause11_21_4_6_3_b	.\test\FBStringTest.cpp	/^template <class String> void clause11_21_4_6_3_b(String & test) {$/;"	f	signature:(String & test)
clause11_21_4_6_3_c	.\test\FBStringTest.cpp	/^template <class String> void clause11_21_4_6_3_c(String & test) {$/;"	f	signature:(String & test)
clause11_21_4_6_3_d	.\test\FBStringTest.cpp	/^template <class String> void clause11_21_4_6_3_d(String & test) {$/;"	f	signature:(String & test)
clause11_21_4_6_3_e	.\test\FBStringTest.cpp	/^template <class String> void clause11_21_4_6_3_e(String & test) {$/;"	f	signature:(String & test)
clause11_21_4_6_3_f	.\test\FBStringTest.cpp	/^template <class String> void clause11_21_4_6_3_f(String & test) {$/;"	f	signature:(String & test)
clause11_21_4_6_3_g	.\test\FBStringTest.cpp	/^template <class String> void clause11_21_4_6_3_g(String & test) {$/;"	f	signature:(String & test)
clause11_21_4_6_3_h	.\test\FBStringTest.cpp	/^template <class String> void clause11_21_4_6_3_h(String & test) {$/;"	f	signature:(String & test)
clause11_21_4_6_3_i	.\test\FBStringTest.cpp	/^template <class String> void clause11_21_4_6_3_i(String & test) {$/;"	f	signature:(String & test)
clause11_21_4_6_3_j	.\test\FBStringTest.cpp	/^template <class String> void clause11_21_4_6_3_j(String & test) {$/;"	f	signature:(String & test)
clause11_21_4_6_3_k	.\test\FBStringTest.cpp	/^template <class String> void clause11_21_4_6_3_k(String & test) {$/;"	f	signature:(String & test)
clause11_21_4_6_4	.\test\FBStringTest.cpp	/^template <class String> void clause11_21_4_6_4(String & test) {$/;"	f	signature:(String & test)
clause11_21_4_6_5	.\test\FBStringTest.cpp	/^template <class String> void clause11_21_4_6_5(String & test) {$/;"	f	signature:(String & test)
clause11_21_4_6_6	.\test\FBStringTest.cpp	/^template <class String> void clause11_21_4_6_6(String & test) {$/;"	f	signature:(String & test)
clause11_21_4_6_7	.\test\FBStringTest.cpp	/^template <class String> void clause11_21_4_6_7(String & test) {$/;"	f	signature:(String & test)
clause11_21_4_6_8	.\test\FBStringTest.cpp	/^template <class String> void clause11_21_4_6_8(String & test) {$/;"	f	signature:(String & test)
clause11_21_4_7_1	.\test\FBStringTest.cpp	/^template <class String> void clause11_21_4_7_1(String & test) {$/;"	f	signature:(String & test)
clause11_21_4_7_2_a	.\test\FBStringTest.cpp	/^template <class String> void clause11_21_4_7_2_a(String & test) {$/;"	f	signature:(String & test)
clause11_21_4_7_2_b	.\test\FBStringTest.cpp	/^template <class String> void clause11_21_4_7_2_b(String & test) {$/;"	f	signature:(String & test)
clause11_21_4_7_2_c	.\test\FBStringTest.cpp	/^template <class String> void clause11_21_4_7_2_c(String & test) {$/;"	f	signature:(String & test)
clause11_21_4_7_2_d	.\test\FBStringTest.cpp	/^template <class String> void clause11_21_4_7_2_d(String & test) {$/;"	f	signature:(String & test)
clause11_21_4_7_3_a	.\test\FBStringTest.cpp	/^template <class String> void clause11_21_4_7_3_a(String & test) {$/;"	f	signature:(String & test)
clause11_21_4_7_3_b	.\test\FBStringTest.cpp	/^template <class String> void clause11_21_4_7_3_b(String & test) {$/;"	f	signature:(String & test)
clause11_21_4_7_3_c	.\test\FBStringTest.cpp	/^template <class String> void clause11_21_4_7_3_c(String & test) {$/;"	f	signature:(String & test)
clause11_21_4_7_3_d	.\test\FBStringTest.cpp	/^template <class String> void clause11_21_4_7_3_d(String & test) {$/;"	f	signature:(String & test)
clause11_21_4_7_4_a	.\test\FBStringTest.cpp	/^template <class String> void clause11_21_4_7_4_a(String & test) {$/;"	f	signature:(String & test)
clause11_21_4_7_4_b	.\test\FBStringTest.cpp	/^template <class String> void clause11_21_4_7_4_b(String & test) {$/;"	f	signature:(String & test)
clause11_21_4_7_4_c	.\test\FBStringTest.cpp	/^template <class String> void clause11_21_4_7_4_c(String & test) {$/;"	f	signature:(String & test)
clause11_21_4_7_4_d	.\test\FBStringTest.cpp	/^template <class String> void clause11_21_4_7_4_d(String & test) {$/;"	f	signature:(String & test)
clause11_21_4_7_5_a	.\test\FBStringTest.cpp	/^template <class String> void clause11_21_4_7_5_a(String & test) {$/;"	f	signature:(String & test)
clause11_21_4_7_5_b	.\test\FBStringTest.cpp	/^template <class String> void clause11_21_4_7_5_b(String & test) {$/;"	f	signature:(String & test)
clause11_21_4_7_5_c	.\test\FBStringTest.cpp	/^template <class String> void clause11_21_4_7_5_c(String & test) {$/;"	f	signature:(String & test)
clause11_21_4_7_5_d	.\test\FBStringTest.cpp	/^template <class String> void clause11_21_4_7_5_d(String & test) {$/;"	f	signature:(String & test)
clause11_21_4_7_6_a	.\test\FBStringTest.cpp	/^template <class String> void clause11_21_4_7_6_a(String & test) {$/;"	f	signature:(String & test)
clause11_21_4_7_6_b	.\test\FBStringTest.cpp	/^template <class String> void clause11_21_4_7_6_b(String & test) {$/;"	f	signature:(String & test)
clause11_21_4_7_6_c	.\test\FBStringTest.cpp	/^template <class String> void clause11_21_4_7_6_c(String & test) {$/;"	f	signature:(String & test)
clause11_21_4_7_6_d	.\test\FBStringTest.cpp	/^template <class String> void clause11_21_4_7_6_d(String & test) {$/;"	f	signature:(String & test)
clause11_21_4_7_7_a	.\test\FBStringTest.cpp	/^template <class String> void clause11_21_4_7_7_a(String & test) {$/;"	f	signature:(String & test)
clause11_21_4_7_7_b	.\test\FBStringTest.cpp	/^template <class String> void clause11_21_4_7_7_b(String & test) {$/;"	f	signature:(String & test)
clause11_21_4_7_7_c	.\test\FBStringTest.cpp	/^template <class String> void clause11_21_4_7_7_c(String & test) {$/;"	f	signature:(String & test)
clause11_21_4_7_7_d	.\test\FBStringTest.cpp	/^template <class String> void clause11_21_4_7_7_d(String & test) {$/;"	f	signature:(String & test)
clause11_21_4_7_8	.\test\FBStringTest.cpp	/^template <class String> void clause11_21_4_7_8(String & test) {$/;"	f	signature:(String & test)
clause11_21_4_7_9_a	.\test\FBStringTest.cpp	/^template <class String> void clause11_21_4_7_9_a(String & test) {$/;"	f	signature:(String & test)
clause11_21_4_7_9_b	.\test\FBStringTest.cpp	/^template <class String> void clause11_21_4_7_9_b(String & test) {$/;"	f	signature:(String & test)
clause11_21_4_7_9_c	.\test\FBStringTest.cpp	/^template <class String> void clause11_21_4_7_9_c(String & test) {$/;"	f	signature:(String & test)
clause11_21_4_7_9_d	.\test\FBStringTest.cpp	/^template <class String> void clause11_21_4_7_9_d(String & test) {$/;"	f	signature:(String & test)
clause11_21_4_7_9_e	.\test\FBStringTest.cpp	/^template <class String> void clause11_21_4_7_9_e(String & test) {$/;"	f	signature:(String & test)
clause11_21_4_8_1_a	.\test\FBStringTest.cpp	/^template <class String> void clause11_21_4_8_1_a(String & test) {$/;"	f	signature:(String & test)
clause11_21_4_8_1_b	.\test\FBStringTest.cpp	/^template <class String> void clause11_21_4_8_1_b(String & test) {$/;"	f	signature:(String & test)
clause11_21_4_8_1_c	.\test\FBStringTest.cpp	/^template <class String> void clause11_21_4_8_1_c(String & test) {$/;"	f	signature:(String & test)
clause11_21_4_8_1_d	.\test\FBStringTest.cpp	/^template <class String> void clause11_21_4_8_1_d(String & test) {$/;"	f	signature:(String & test)
clause11_21_4_8_1_e	.\test\FBStringTest.cpp	/^template <class String> void clause11_21_4_8_1_e(String & test) {$/;"	f	signature:(String & test)
clause11_21_4_8_1_f	.\test\FBStringTest.cpp	/^template <class String> void clause11_21_4_8_1_f(String & test) {$/;"	f	signature:(String & test)
clause11_21_4_8_9_a	.\test\FBStringTest.cpp	/^template <class String> void clause11_21_4_8_9_a(String & test) {$/;"	f	signature:(String & test)
cleanup	.\detail\ThreadLocalDetail.h	/^  void cleanup() {$/;"	f	struct:folly::threadlocal_detail::ElementWrapper	access:public	signature:()
clear	.\AtomicHashArray-inl.h	/^clear() {$/;"	f	class:folly::AtomicHashArray	signature:()
clear	.\AtomicHashArray.h	/^  void clear();$/;"	p	class:folly::AtomicHashArray	access:public	signature:()
clear	.\AtomicHashMap-inl.h	/^clear() {$/;"	f	class:folly::AtomicHashMap	signature:()
clear	.\AtomicHashMap.h	/^  void clear();$/;"	p	class:folly::AtomicHashMap	access:public	signature:()
clear	.\DiscriminatedPtr.h	/^  void clear() {$/;"	f	class:folly::DiscriminatedPtr	access:public	signature:()
clear	.\EvictingCacheMap.h	/^  void clear() {$/;"	f	class:folly::EvictingCacheMap	access:public	signature:()
clear	.\GroupVarint.h	/^  void clear() {$/;"	f	class:folly::GroupVarintEncoder	access:public	signature:()
clear	.\Optional.h	/^  void clear() {$/;"	f	class:folly::Optional	access:public	signature:()
clear	.\Padded.h	/^  void clear() {$/;"	f	class:folly::Adaptor	access:public	signature:()
clear	.\Range.h	/^  void clear() {$/;"	f	class:folly::Range	access:public	signature:()
clear	.\detail\BitIteratorDetail.h	/^  void clear() {$/;"	f	class:folly::bititerator_detail::BitReference	access:public	signature:()
clear	.\detail\Stats.h	/^  void clear() {$/;"	f	struct:folly::detail::Bucket	access:public	signature:()
clear	.\experimental\Bits.h	/^  static void clear(T* p, size_t bit);$/;"	p	struct:folly::Bits	access:public	signature:(T* p, size_t bit)
clear	.\experimental\Bits.h	/^inline void Bits<T, Traits>::clear(T* p, size_t bit) {$/;"	f	class:folly::Bits	signature:(T* p, size_t bit)
clear	.\experimental\exception_tracer\StackTrace.cpp	/^void StackTraceStack::clear() {$/;"	f	class:folly::exception_tracer::StackTraceStack	signature:()
clear	.\experimental\exception_tracer\StackTrace.h	/^  void clear();$/;"	p	class:folly::exception_tracer::StackTraceStack	access:public	signature:()
clear	.\experimental\symbolizer\Symbolizer.h	/^  void clear() { *this = SymbolizedFrame(); }$/;"	f	struct:folly::symbolizer::SymbolizedFrame	access:public	signature:()
clear	.\io\IOBuf.h	/^  void clear() {$/;"	f	class:folly::IOBuf	access:public	signature:()
clear	.\io\IOBufQueue.cpp	/^void IOBufQueue::clear() {$/;"	f	class:folly::IOBufQueue	signature:()
clear	.\io\IOBufQueue.h	/^  void clear();$/;"	p	class:folly::IOBufQueue	access:public	signature:()
clear	.\io\TypedIOBuf.h	/^  void clear() {$/;"	f	class:folly::TypedIOBuf	access:public	signature:()
clear	.\small_vector.h	/^  void clear() {$/;"	f	class:folly::small_vector	access:public	signature:()
clear	.\sorted_vector_types.h	/^  void clear()                  { return m_.cont_.clear();    }$/;"	f	class:folly::sorted_vector_map	access:public	signature:()
clear	.\sorted_vector_types.h	/^  void clear()                  { return m_.cont_.clear();    }$/;"	f	class:folly::sorted_vector_set	access:public	signature:()
clear	.\stats\BucketedTimeSeries-defs.h	/^void BucketedTimeSeries<VT, TT>::clear() {$/;"	f	class:folly::BucketedTimeSeries	signature:()
clear	.\stats\BucketedTimeSeries.h	/^  void clear();$/;"	p	class:folly::BucketedTimeSeries	access:public	signature:()
clear	.\stats\Histogram.h	/^  void clear() {$/;"	f	class:folly::Histogram	access:public	signature:()
clear	.\stats\MultiLevelTimeSeries-defs.h	/^void MultiLevelTimeSeries<VT, TT>::clear() {$/;"	f	class:folly::MultiLevelTimeSeries	signature:()
clear	.\stats\MultiLevelTimeSeries.h	/^  void clear();$/;"	p	class:folly::MultiLevelTimeSeries	access:public	signature:()
clear	.\stats\TimeseriesHistogram-defs.h	/^void TimeseriesHistogram<T, TT, C>::clear() {$/;"	f	class:folly::TimeseriesHistogram	signature:()
clear	.\stats\TimeseriesHistogram.h	/^  void clear();$/;"	p	class:folly::TimeseriesHistogram	access:public	signature:()
clearContextData	.\io\async\Request.h	/^  void clearContextData(const std::string& val) {$/;"	f	class:folly::RequestContext	access:public	signature:(const std::string& val)
clearFlags	.\io\IOBuf.h	/^  inline void clearFlags(uintptr_t flags) const {$/;"	f	class:folly::IOBuf	access:private	signature:(uintptr_t flags) const
clearShutdownNotice	.\LifoSem.h	/^  void clearShutdownNotice() { next = 0; }$/;"	f	struct:folly::detail::LifoSemRawNode	access:public	signature:()
clearSize_	.\EvictingCacheMap.h	/^  std::size_t clearSize_;$/;"	m	class:folly::EvictingCacheMap	access:private
clibAtoiMeasure	.\test\ConvTest.cpp	/^void clibAtoiMeasure(unsigned int n, unsigned int digits) {$/;"	f	signature:(unsigned int n, unsigned int digits)
clibStrtoulMeasure	.\test\ConvTest.cpp	/^void clibStrtoulMeasure(unsigned int n, unsigned int digits) {$/;"	f	signature:(unsigned int n, unsigned int digits)
clock_getres	.\detail\Clock.cpp	/^int clock_getres(clockid_t clk_id, struct timespec* ts) {$/;"	f	signature:(clockid_t clk_id, struct timespec* ts)
clock_getres	.\detail\Clock.h	/^int clock_getres(clockid_t clk_id, struct timespec* ts);$/;"	p	signature:(clockid_t clk_id, struct timespec* ts)
clock_gettime	.\detail\Clock.cpp	/^int clock_gettime(clockid_t clk_id, struct timespec* ts) {$/;"	f	signature:(clockid_t clk_id, struct timespec* ts)
clock_gettime	.\detail\Clock.h	/^int clock_gettime(clockid_t clk_id, struct timespec* ts);$/;"	p	signature:(clockid_t clk_id, struct timespec* ts)
clockid_t	.\detail\Clock.h	/^typedef uint8_t clockid_t;$/;"	t
clone	.\gen\Base-inl.h	/^    virtual std::unique_ptr<const WrapperBase> clone() const = 0;$/;"	p	class:folly::gen::VirtualGen::WrapperBase	access:public	signature:() const
clone	.\gen\Base-inl.h	/^    virtual std::unique_ptr<const WrapperBase> clone() const {$/;"	f	class:folly::gen::VirtualGen::WrapperImpl	access:public	signature:() const
clone	.\io\Cursor.h	/^  void clone(folly::IOBuf& buf, size_t len) {$/;"	f	class:folly::io::detail::CursorBase	access:public	signature:(folly::IOBuf& buf, size_t len)
clone	.\io\Cursor.h	/^  void clone(std::unique_ptr<folly::IOBuf>& buf, size_t len) {$/;"	f	class:folly::io::detail::CursorBase	access:public	signature:(std::unique_ptr<folly::IOBuf>& buf, size_t len)
clone	.\io\IOBuf.cpp	/^unique_ptr<IOBuf> IOBuf::clone() const {$/;"	f	class:folly::IOBuf	signature:() const
clone	.\io\IOBuf.h	/^  std::unique_ptr<IOBuf> clone() const;$/;"	p	class:folly::IOBuf	access:public	signature:() const
cloneAtMost	.\io\Cursor.h	/^  size_t cloneAtMost(folly::IOBuf& buf, size_t len) {$/;"	f	class:folly::io::detail::CursorBase	access:public	signature:(folly::IOBuf& buf, size_t len)
cloneAtMost	.\io\Cursor.h	/^  size_t cloneAtMost(std::unique_ptr<folly::IOBuf>& buf, size_t len) {$/;"	f	class:folly::io::detail::CursorBase	access:public	signature:(std::unique_ptr<folly::IOBuf>& buf, size_t len)
cloneInto	.\io\IOBuf.cpp	/^void IOBuf::cloneInto(IOBuf& other) const {$/;"	f	class:folly::IOBuf	signature:(IOBuf& other) const
cloneInto	.\io\IOBuf.h	/^  void cloneInto(IOBuf& other) const;$/;"	p	class:folly::IOBuf	access:public	signature:(IOBuf& other) const
cloneOne	.\io\IOBuf.cpp	/^unique_ptr<IOBuf> IOBuf::cloneOne() const {$/;"	f	class:folly::IOBuf	signature:() const
cloneOne	.\io\IOBuf.h	/^  std::unique_ptr<IOBuf> cloneOne() const;$/;"	p	class:folly::IOBuf	access:public	signature:() const
cloneOneInto	.\io\IOBuf.cpp	/^void IOBuf::cloneOneInto(IOBuf& other) const {$/;"	f	class:folly::IOBuf	signature:(IOBuf& other) const
cloneOneInto	.\io\IOBuf.h	/^  void cloneOneInto(IOBuf& other) const;$/;"	p	class:folly::IOBuf	access:public	signature:(IOBuf& other) const
cloneStrings	.\Subprocess.cpp	/^std::unique_ptr<const char*[]> cloneStrings(const std::vector<std::string>& s) {$/;"	f	namespace:folly::__anon97	signature:(const std::vector<std::string>& s)
close	.\File.cpp	/^void File::close() {$/;"	f	class:folly::File	signature:()
close	.\File.h	/^  void close();$/;"	p	class:folly::File	access:public	signature:()
closeAll	.\Subprocess.cpp	/^void Subprocess::closeAll() {$/;"	f	class:folly::Subprocess	signature:()
closeAll	.\Subprocess.h	/^  void closeAll();$/;"	p	class:folly::Subprocess	access:private	signature:()
closeChecked	.\Subprocess.cpp	/^void closeChecked(int fd) {$/;"	f	namespace:folly::__anon98	signature:(int fd)
closeInputProducer	.\gen\Parallel-inl.h	/^      void closeInputProducer() { inQueue_.closeInputProducer(); }$/;"	f	class:folly::gen::detail::Parallel::Generator::Executor	access:public	signature:()
closeInputProducer	.\gen\Parallel-inl.h	/^  void closeInputProducer() {$/;"	f	class:folly::gen::detail::ClosableMPMCQueue	access:public	signature:()
closeNoInt	.\FileUtil.cpp	/^int closeNoInt(int fd) {$/;"	f	namespace:folly	signature:(int fd)
closeNoInt	.\FileUtil.h	/^int closeNoInt(int fd);$/;"	p	namespace:folly	signature:(int fd)
closeNoThrow	.\File.cpp	/^bool File::closeNoThrow() {$/;"	f	class:folly::File	signature:()
closeNoThrow	.\File.h	/^  bool closeNoThrow();$/;"	p	class:folly::File	access:public	signature:()
closeOnDestruction_	.\experimental\TestUtil.h	/^  bool closeOnDestruction_;$/;"	m	class:folly::test::TemporaryFile	access:private
closeOtherFds	.\Subprocess.h	/^    Options& closeOtherFds() { closeOtherFds_ = true; return *this; }$/;"	f	class:folly::Subprocess::Options	access:public	signature:()
closeOtherFds_	.\Subprocess.h	/^    bool closeOtherFds_;$/;"	m	class:folly::Subprocess::Options	access:private
closeOutputConsumer	.\gen\Parallel-inl.h	/^      void closeOutputConsumer() { outQueue_.closeOutputConsumer(); }$/;"	f	class:folly::gen::detail::Parallel::Generator::Executor	access:public	signature:()
closeOutputConsumer	.\gen\Parallel-inl.h	/^  void closeOutputConsumer() {$/;"	f	class:folly::gen::detail::ClosableMPMCQueue	access:public	signature:()
closeParentFd	.\Subprocess.cpp	/^void Subprocess::closeParentFd(int childFd) {$/;"	f	class:folly::Subprocess	signature:(int childFd)
closeParentFd	.\Subprocess.h	/^  void closeParentFd(int childFd);$/;"	p	class:folly::Subprocess	access:public	signature:(int childFd)
closeWhenIdle	.\experimental\wangle\ManagedConnection.h	/^  virtual void closeWhenIdle() = 0;$/;"	p	class:folly::wangle::ManagedConnection	access:public	signature:()
coalesce	.\io\IOBuf.h	/^  ByteRange coalesce() {$/;"	f	class:folly::IOBuf	access:public	signature:()
coalesceAndReallocate	.\io\IOBuf.cpp	/^void IOBuf::coalesceAndReallocate(size_t newHeadroom,$/;"	f	class:folly::IOBuf	signature:(size_t newHeadroom, size_t newLength, IOBuf* end, size_t newTailroom)
coalesceAndReallocate	.\io\IOBuf.h	/^  void coalesceAndReallocate($/;"	p	class:folly::IOBuf	access:private	signature:( size_t newHeadroom, size_t newLength, IOBuf* end, size_t newTailroom)
coalesceAndReallocate	.\io\IOBuf.h	/^  void coalesceAndReallocate(size_t newLength, IOBuf* end) {$/;"	f	class:folly::IOBuf	access:private	signature:(size_t newLength, IOBuf* end)
coalesceSlow	.\io\IOBuf.cpp	/^void IOBuf::coalesceSlow() {$/;"	f	class:folly::IOBuf	signature:()
coalesceSlow	.\io\IOBuf.cpp	/^void IOBuf::coalesceSlow(size_t maxLength) {$/;"	f	class:folly::IOBuf	signature:(size_t maxLength)
coalesceSlow	.\io\IOBuf.h	/^  void coalesceSlow();$/;"	p	class:folly::IOBuf	access:private	signature:()
coalesceSlow	.\io\IOBuf.h	/^  void coalesceSlow(size_t maxLength);$/;"	p	class:folly::IOBuf	access:private	signature:(size_t maxLength)
cob_	.\io\async\EventBase.h	/^    Cob cob_;$/;"	m	class:folly::EventBase::CobTimeout	access:private
code	.\experimental\symbolizer\Dwarf.h	/^    uint64_t code;$/;"	m	struct:folly::symbolizer::Dwarf::DIEAbbreviation	access:public
codePointToUtf8	.\Unicode.cpp	/^fbstring codePointToUtf8(char32_t cp) {$/;"	f	namespace:folly	signature:(char32_t cp)
codePointToUtf8	.\Unicode.h	/^fbstring codePointToUtf8(char32_t cp);$/;"	p	namespace:folly	signature:(char32_t cp)
codec_	.\io\test\CompressionTest.cpp	/^   std::unique_ptr<Codec> codec_;$/;"	m	class:folly::io::test::CompressionTest	file:	access:protected
codec_	.\io\test\CompressionTest.cpp	/^  std::unique_ptr<Codec> codec_;$/;"	m	class:folly::io::test::CompressionCorruptionTest	file:	access:protected
collection_	.\gen\Base-inl.h	/^  Collection* collection_;$/;"	m	class:folly::gen::detail::Append	access:private
color	.\experimental\symbolizer\Symbolizer.cpp	/^void SymbolizePrinter::color(SymbolizePrinter::Color color) {$/;"	f	class:folly::symbolizer::SymbolizePrinter	signature:(SymbolizePrinter::Color color)
color	.\experimental\symbolizer\Symbolizer.h	/^  void color(Color c);$/;"	p	class:folly::symbolizer::SymbolizePrinter	access:public	signature:(Color c)
column_	.\experimental\symbolizer\Dwarf.h	/^    uint64_t column_;$/;"	m	class:folly::symbolizer::Dwarf::LineNumberVM	access:private
communicate	.\Subprocess.cpp	/^std::pair<std::string, std::string> Subprocess::communicate($/;"	f	class:folly::Subprocess	signature:( StringPiece input)
communicate	.\Subprocess.cpp	/^void Subprocess::communicate(FdCallback readCallback,$/;"	f	class:folly::Subprocess	signature:(FdCallback readCallback, FdCallback writeCallback)
communicate	.\Subprocess.h	/^  std::pair<std::string, std::string> communicate($/;"	p	class:folly::Subprocess	access:public	signature:( StringPiece input = StringPiece())
communicate	.\Subprocess.h	/^  void communicate(FdCallback readCallback, FdCallback writeCallback);$/;"	p	class:folly::Subprocess	access:public	signature:(FdCallback readCallback, FdCallback writeCallback)
communicateIOBuf	.\Subprocess.cpp	/^std::pair<IOBufQueue, IOBufQueue> Subprocess::communicateIOBuf($/;"	f	class:folly::Subprocess	signature:( IOBufQueue input)
communicateIOBuf	.\Subprocess.h	/^  std::pair<IOBufQueue, IOBufQueue> communicateIOBuf($/;"	p	class:folly::Subprocess	access:public	signature:( IOBufQueue input = IOBufQueue())
comp	.\dynamic-inl.h	/^  static bool comp(ObjectImpl const& a, ObjectImpl const& b) {$/;"	f	struct:folly::dynamic::CompareOp	access:public	signature:(ObjectImpl const& a, ObjectImpl const& b)
comp	.\dynamic-inl.h	/^  static bool comp(T const& a, T const& b) { return a < b; }$/;"	f	struct:folly::dynamic::CompareOp	access:public	signature:(T const& a, T const& b)
comparator	.\experimental\symbolizer\test\SymbolizerTest.cpp	/^int comparator(const void* ap, const void* bp) {$/;"	f	namespace:folly::symbolizer::test	signature:(const void* ap, const void* bp)
compare	.\Range.h	/^  int compare(const const_range_type& o) const {$/;"	f	class:folly::Range	access:public	signature:(const const_range_type& o) const
compare	.\experimental\wangle\concurrent\ThreadPoolExecutor.h	/^    static bool compare(const ThreadPtr& ts1, const ThreadPtr& ts2) {$/;"	f	class:folly::wangle::ThreadPoolExecutor::ThreadList	access:private	signature:(const ThreadPtr& ts1, const ThreadPtr& ts2)
compareBinary	.\test\FormatTest.cpp	/^void compareBinary(Uint u) {$/;"	f	signature:(Uint u)
compareHex	.\test\FormatTest.cpp	/^void compareHex(Uint u) {$/;"	f	signature:(Uint u)
compareOctal	.\test\FormatTest.cpp	/^void compareOctal(Uint u) {$/;"	f	signature:(Uint u)
comparer_	.\gen\Base-inl.h	/^    Comparer comparer_;$/;"	m	class:folly::gen::detail::Order::Generator	access:private
comparer_	.\gen\Base-inl.h	/^  Comparer comparer_;$/;"	m	class:folly::gen::detail::Min	access:private
comparer_	.\gen\Base-inl.h	/^  Comparer comparer_;$/;"	m	class:folly::gen::detail::Order	access:private
compilationDirectory_	.\experimental\symbolizer\Dwarf.h	/^    folly::StringPiece compilationDirectory_;$/;"	m	class:folly::symbolizer::Dwarf::LineNumberVM	access:private
complete	.\experimental\io\AsyncIO.cpp	/^void AsyncIOOp::complete(ssize_t result) {$/;"	f	class:folly::AsyncIOOp	signature:(ssize_t result)
complete	.\experimental\io\AsyncIO.h	/^  void complete(ssize_t result);$/;"	p	class:folly::AsyncIOOp	access:private	signature:(ssize_t result)
completed_	.\experimental\io\AsyncIO.h	/^  std::vector<Op*> completed_;$/;"	m	class:folly::AsyncIO	access:private
compose	.\gen\Base-inl.h	/^  Collection compose(const GenImpl<Value, Source>& source) const {$/;"	f	class:folly::gen::detail::Collect	access:public	signature:(const GenImpl<Value, Source>& source) const
compose	.\gen\Base-inl.h	/^  Collection compose(const GenImpl<Value, Source>& source) const {$/;"	f	class:folly::gen::detail::CollectTemplate	access:public	signature:(const GenImpl<Value, Source>& source) const
compose	.\gen\Base-inl.h	/^  Collection& compose(const GenImpl<Value, Source>& source) const {$/;"	f	class:folly::gen::detail::Append	access:public	signature:(const GenImpl<Value, Source>& source) const
compose	.\gen\Base-inl.h	/^  Gen compose(GenImpl<Value, Source>&& source) const {$/;"	f	class:folly::gen::detail::Batch	access:public	signature:(GenImpl<Value, Source>&& source) const
compose	.\gen\Base-inl.h	/^  Gen compose(GenImpl<Value, Source>&& source) const {$/;"	f	class:folly::gen::detail::Concat	access:public	signature:(GenImpl<Value, Source>&& source) const
compose	.\gen\Base-inl.h	/^  Gen compose(GenImpl<Value, Source>&& source) const {$/;"	f	class:folly::gen::detail::Cycle	access:public	signature:(GenImpl<Value, Source>&& source) const
compose	.\gen\Base-inl.h	/^  Gen compose(GenImpl<Value, Source>&& source) const {$/;"	f	class:folly::gen::detail::Dereference	access:public	signature:(GenImpl<Value, Source>&& source) const
compose	.\gen\Base-inl.h	/^  Gen compose(GenImpl<Value, Source>&& source) const {$/;"	f	class:folly::gen::detail::Distinct	access:public	signature:(GenImpl<Value, Source>&& source) const
compose	.\gen\Base-inl.h	/^  Gen compose(GenImpl<Value, Source>&& source) const {$/;"	f	class:folly::gen::detail::Filter	access:public	signature:(GenImpl<Value, Source>&& source) const
compose	.\gen\Base-inl.h	/^  Gen compose(GenImpl<Value, Source>&& source) const {$/;"	f	class:folly::gen::detail::GuardImpl	access:public	signature:(GenImpl<Value, Source>&& source) const
compose	.\gen\Base-inl.h	/^  Gen compose(GenImpl<Value, Source>&& source) const {$/;"	f	class:folly::gen::detail::Map	access:public	signature:(GenImpl<Value, Source>&& source) const
compose	.\gen\Base-inl.h	/^  Gen compose(GenImpl<Value, Source>&& source) const {$/;"	f	class:folly::gen::detail::Order	access:public	signature:(GenImpl<Value, Source>&& source) const
compose	.\gen\Base-inl.h	/^  Gen compose(GenImpl<Value, Source>&& source) const {$/;"	f	class:folly::gen::detail::RangeConcat	access:public	signature:(GenImpl<Value, Source>&& source) const
compose	.\gen\Base-inl.h	/^  Gen compose(GenImpl<Value, Source>&& source) const {$/;"	f	class:folly::gen::detail::Sample	access:public	signature:(GenImpl<Value, Source>&& source) const
compose	.\gen\Base-inl.h	/^  Gen compose(GenImpl<Value, Source>&& source) const {$/;"	f	class:folly::gen::detail::Skip	access:public	signature:(GenImpl<Value, Source>&& source) const
compose	.\gen\Base-inl.h	/^  Gen compose(GenImpl<Value, Source>&& source) const {$/;"	f	class:folly::gen::detail::Stride	access:public	signature:(GenImpl<Value, Source>&& source) const
compose	.\gen\Base-inl.h	/^  Gen compose(GenImpl<Value, Source>&& source) const {$/;"	f	class:folly::gen::detail::Take	access:public	signature:(GenImpl<Value, Source>&& source) const
compose	.\gen\Base-inl.h	/^  Gen compose(GenImpl<Value, Source>&& source) const {$/;"	f	class:folly::gen::detail::Until	access:public	signature:(GenImpl<Value, Source>&& source) const
compose	.\gen\Base-inl.h	/^  Gen compose(const GenImpl<Value, Source>& source) const {$/;"	f	class:folly::gen::detail::Batch	access:public	signature:(const GenImpl<Value, Source>& source) const
compose	.\gen\Base-inl.h	/^  Gen compose(const GenImpl<Value, Source>& source) const {$/;"	f	class:folly::gen::detail::Concat	access:public	signature:(const GenImpl<Value, Source>& source) const
compose	.\gen\Base-inl.h	/^  Gen compose(const GenImpl<Value, Source>& source) const {$/;"	f	class:folly::gen::detail::Cycle	access:public	signature:(const GenImpl<Value, Source>& source) const
compose	.\gen\Base-inl.h	/^  Gen compose(const GenImpl<Value, Source>& source) const {$/;"	f	class:folly::gen::detail::Dereference	access:public	signature:(const GenImpl<Value, Source>& source) const
compose	.\gen\Base-inl.h	/^  Gen compose(const GenImpl<Value, Source>& source) const {$/;"	f	class:folly::gen::detail::Distinct	access:public	signature:(const GenImpl<Value, Source>& source) const
compose	.\gen\Base-inl.h	/^  Gen compose(const GenImpl<Value, Source>& source) const {$/;"	f	class:folly::gen::detail::Filter	access:public	signature:(const GenImpl<Value, Source>& source) const
compose	.\gen\Base-inl.h	/^  Gen compose(const GenImpl<Value, Source>& source) const {$/;"	f	class:folly::gen::detail::GuardImpl	access:public	signature:(const GenImpl<Value, Source>& source) const
compose	.\gen\Base-inl.h	/^  Gen compose(const GenImpl<Value, Source>& source) const {$/;"	f	class:folly::gen::detail::Map	access:public	signature:(const GenImpl<Value, Source>& source) const
compose	.\gen\Base-inl.h	/^  Gen compose(const GenImpl<Value, Source>& source) const {$/;"	f	class:folly::gen::detail::Order	access:public	signature:(const GenImpl<Value, Source>& source) const
compose	.\gen\Base-inl.h	/^  Gen compose(const GenImpl<Value, Source>& source) const {$/;"	f	class:folly::gen::detail::RangeConcat	access:public	signature:(const GenImpl<Value, Source>& source) const
compose	.\gen\Base-inl.h	/^  Gen compose(const GenImpl<Value, Source>& source) const {$/;"	f	class:folly::gen::detail::Sample	access:public	signature:(const GenImpl<Value, Source>& source) const
compose	.\gen\Base-inl.h	/^  Gen compose(const GenImpl<Value, Source>& source) const {$/;"	f	class:folly::gen::detail::Skip	access:public	signature:(const GenImpl<Value, Source>& source) const
compose	.\gen\Base-inl.h	/^  Gen compose(const GenImpl<Value, Source>& source) const {$/;"	f	class:folly::gen::detail::Stride	access:public	signature:(const GenImpl<Value, Source>& source) const
compose	.\gen\Base-inl.h	/^  Gen compose(const GenImpl<Value, Source>& source) const {$/;"	f	class:folly::gen::detail::Take	access:public	signature:(const GenImpl<Value, Source>& source) const
compose	.\gen\Base-inl.h	/^  Gen compose(const GenImpl<Value, Source>& source) const {$/;"	f	class:folly::gen::detail::Until	access:public	signature:(const GenImpl<Value, Source>& source) const
compose	.\gen\Base-inl.h	/^  Seed compose(const GenImpl<Value, Source>& source) const {$/;"	f	class:folly::gen::detail::FoldLeft	access:public	signature:(const GenImpl<Value, Source>& source) const
compose	.\gen\Base-inl.h	/^  Source&& compose(GenImpl<Value, Source>&& source) const {$/;"	f	class:folly::gen::detail::TypeAssertion	access:public	signature:(GenImpl<Value, Source>&& source) const
compose	.\gen\Base-inl.h	/^  StorageType compose(const GenImpl<Value, Source>& source) const {$/;"	f	class:folly::gen::detail::First	access:public	signature:(const GenImpl<Value, Source>& source) const
compose	.\gen\Base-inl.h	/^  StorageType compose(const GenImpl<Value, Source>& source) const {$/;"	f	class:folly::gen::detail::Min	access:public	signature:(const GenImpl<Value, Source>& source) const
compose	.\gen\Base-inl.h	/^  StorageType compose(const GenImpl<Value, Source>& source) const {$/;"	f	class:folly::gen::detail::Reduce	access:public	signature:(const GenImpl<Value, Source>& source) const
compose	.\gen\Base-inl.h	/^  StorageType compose(const GenImpl<Value, Source>& source) const {$/;"	f	class:folly::gen::detail::Sum	access:public	signature:(const GenImpl<Value, Source>& source) const
compose	.\gen\Base-inl.h	/^  bool compose(const GenImpl<Value, Source>& source) const {$/;"	f	class:folly::gen::detail::All	access:public	signature:(const GenImpl<Value, Source>& source) const
compose	.\gen\Base-inl.h	/^  bool compose(const GenImpl<Value, Source>& source) const {$/;"	f	class:folly::gen::detail::Any	access:public	signature:(const GenImpl<Value, Source>& source) const
compose	.\gen\Base-inl.h	/^  bool compose(const GenImpl<Value, Source>& source) const {$/;"	f	class:folly::gen::detail::Contains	access:public	signature:(const GenImpl<Value, Source>& source) const
compose	.\gen\Base-inl.h	/^  const Source& compose(const GenImpl<Value, Source>& source) const {$/;"	f	class:folly::gen::detail::TypeAssertion	access:public	signature:(const GenImpl<Value, Source>& source) const
compose	.\gen\Base-inl.h	/^  size_t compose(const GenImpl<Value, Source>& source) const {$/;"	f	class:folly::gen::detail::Count	access:public	signature:(const GenImpl<Value, Source>& source) const
compose	.\gen\Combine-inl.h	/^  Gen compose(GenImpl<Value, Source>&& source) const {$/;"	f	class:folly::gen::detail::Zip	access:public	signature:(GenImpl<Value, Source>&& source) const
compose	.\gen\Combine-inl.h	/^  Gen compose(GenImpl<Value2, Source>&& source) const {$/;"	f	class:folly::gen::detail::Interleave	access:public	signature:(GenImpl<Value2, Source>&& source) const
compose	.\gen\Combine-inl.h	/^  Gen compose(const GenImpl<Value, Source>& source) const {$/;"	f	class:folly::gen::detail::Zip	access:public	signature:(const GenImpl<Value, Source>& source) const
compose	.\gen\Combine-inl.h	/^  Gen compose(const GenImpl<Value2, Source>& source) const {$/;"	f	class:folly::gen::detail::Interleave	access:public	signature:(const GenImpl<Value2, Source>& source) const
compose	.\gen\Core-inl.h	/^  ResultGen compose(const GenImpl<Value, Source>& source) const;$/;"	p	class:folly::gen::Operator	access:public	signature:(const GenImpl<Value, Source>& source) const
compose	.\gen\Core-inl.h	/^  SecondRet compose(GenImpl<Value, Source>&& source) const {$/;"	f	class:folly::gen::detail::Composed	access:public	signature:(GenImpl<Value, Source>&& source) const
compose	.\gen\Core-inl.h	/^  SecondRet compose(const GenImpl<Value, Source>& source) const {$/;"	f	class:folly::gen::detail::Composed	access:public	signature:(const GenImpl<Value, Source>& source) const
compose	.\gen\File-inl.h	/^  void compose(const GenImpl<Value, Source>& source) const {$/;"	f	class:folly::gen::detail::FileWriter	access:public	signature:(const GenImpl<Value, Source>& source) const
compose	.\gen\Parallel-inl.h	/^      void compose(const GenImpl<Value, InnerSource>& source) const {$/;"	f	class:folly::gen::detail::Parallel::Generator::Pusher	access:public	signature:(const GenImpl<Value, InnerSource>& source) const
compose	.\gen\Parallel-inl.h	/^  Generator<Value, Source> compose(GenImpl<Value, Source>&& source) const {$/;"	f	class:folly::gen::detail::Parallel	access:public	signature:(GenImpl<Value, Source>&& source) const
compose	.\gen\Parallel-inl.h	/^  Generator<Value, Source> compose(const GenImpl<Value, Source>& source) const {$/;"	f	class:folly::gen::detail::Parallel	access:public	signature:(const GenImpl<Value, Source>& source) const
compose	.\gen\Parallel-inl.h	/^  Just compose(const GenImpl<Value, Source>& source) const {$/;"	f	class:folly::gen::detail::Sub	access:public	signature:(const GenImpl<Value, Source>& source) const
compose	.\gen\ParallelMap-inl.h	/^  Gen compose(GenImpl<Value, Source>&& source) const {$/;"	f	class:folly::gen::detail::PMap	access:public	signature:(GenImpl<Value, Source>&& source) const
compose	.\gen\ParallelMap-inl.h	/^  Gen compose(const GenImpl<Value, Source>& source) const {$/;"	f	class:folly::gen::detail::PMap	access:public	signature:(const GenImpl<Value, Source>& source) const
compose	.\gen\String-inl.h	/^  Gen compose(GenImpl<Value, Source>&& source) const {$/;"	f	class:folly::gen::detail::StringResplitter	access:public	signature:(GenImpl<Value, Source>&& source) const
compose	.\gen\String-inl.h	/^  Gen compose(const GenImpl<Value, Source>& source) const {$/;"	f	class:folly::gen::detail::StringResplitter	access:public	signature:(const GenImpl<Value, Source>& source) const
compose	.\gen\String-inl.h	/^  Output compose(const GenImpl<Value, Source>& source) const {$/;"	f	class:folly::gen::detail::Unsplit	access:public	signature:(const GenImpl<Value, Source>& source) const
compose	.\gen\String-inl.h	/^  void compose(const GenImpl<Value, Source>& source) const {$/;"	f	class:folly::gen::detail::UnsplitBuffer	access:public	signature:(const GenImpl<Value, Source>& source) const
compress	.\io\Compression.cpp	/^std::unique_ptr<IOBuf> Codec::compress(const IOBuf* data) {$/;"	f	class:folly::io::Codec	signature:(const IOBuf* data)
compress	.\io\Compression.h	/^  std::unique_ptr<IOBuf> compress(const folly::IOBuf* data);$/;"	p	class:folly::io::Codec	access:public	signature:(const folly::IOBuf* data)
compression	.\experimental\EliasFanoCoding.h	/^namespace folly { namespace compression {$/;"	n	namespace:folly
compression	.\experimental\test\CodingTestUtils.h	/^namespace folly { namespace compression {$/;"	n	namespace:folly
computeChainDataLength	.\io\IOBuf.cpp	/^uint64_t IOBuf::computeChainDataLength() const {$/;"	f	class:folly::IOBuf	signature:() const
computeChainDataLength	.\io\IOBuf.h	/^  uint64_t computeChainDataLength() const;$/;"	p	class:folly::IOBuf	access:public	signature:() const
computeInsertCapacity	.\FBVector.h	/^  size_type computeInsertCapacity(size_type n) {$/;"	f	signature:(size_type n)
computePushBackCapacity	.\FBVector.h	/^  size_type computePushBackCapacity() const {$/;"	f	signature:() const
computeTables	.\build\GenerateFingerprintTables.cpp	/^void computeTables(FILE* file, const FingerprintPolynomial<DEG>& poly) {$/;"	f	namespace:__anon4	signature:(FILE* file, const FingerprintPolynomial<DEG>& poly)
computeTimeCost	.\test\ProducerConsumerQueueBenchmark.cpp	/^  void computeTimeCost() {$/;"	f	struct:__anon127::LatencyTest	access:public	signature:()
concat	.\gen\Base-inl.h	/^static const detail::Concat concat;$/;"	m	namespace:folly::gen
concurrentSkip	.\test\ConcurrentSkipListTest.cpp	/^static void concurrentSkip(const vector<ValueType> *values,$/;"	f	namespace:__anon114	signature:(const vector<ValueType> *values, SkipListAccessor skipList)
config	.\test\AtomicHashMapTest.cpp	/^AHArrayT::Config config;$/;"	v
configRace	.\test\AtomicHashMapTest.cpp	/^AHA::Config configRace;$/;"	v
connTimeouts_	.\experimental\wangle\ConnectionManager.h	/^  folly::HHWheelTimer::UniquePtr connTimeouts_;$/;"	m	class:folly::wangle::ConnectionManager	access:private
connectionManager_	.\experimental\wangle\ManagedConnection.h	/^  ConnectionManager* connectionManager_;$/;"	m	class:folly::wangle::ManagedConnection	access:private
conns_	.\experimental\wangle\ConnectionManager.h	/^    ManagedConnection,&ManagedConnection::listHook_> conns_;$/;"	m	class:folly::wangle::ConnectionManager	access:private
const_item_iterator	.\dynamic-inl.h	/^  \/* implicit *\/ const_item_iterator(base_type b) : iterator_adaptor_(b) { }$/;"	f	struct:folly::dynamic::const_item_iterator	access:public	signature:(base_type b)
const_item_iterator	.\dynamic-inl.h	/^struct dynamic::const_item_iterator$/;"	s	class:folly::dynamic	inherits:boost::iterator_adaptor
const_item_iterator	.\dynamic.h	/^  struct const_item_iterator;$/;"	x
const_iterator	.\AtomicHashArray.h	/^  typedef aha_iterator<const AtomicHashArray,const value_type> const_iterator;$/;"	t	class:folly::AtomicHashArray	access:public
const_iterator	.\AtomicHashMap.h	/^    const_iterator;$/;"	t	class:folly::AtomicHashMap	access:public
const_iterator	.\ConcurrentSkipList.h	/^  typedef detail::csl_iterator<const value_type, const NodeType> const_iterator;$/;"	t	class:folly::ConcurrentSkipList	access:public
const_iterator	.\ConcurrentSkipList.h	/^  typedef typename SkipListType::const_iterator const_iterator;$/;"	t	class:folly::ConcurrentSkipList::Accessor	access:public
const_iterator	.\EvictingCacheMap.h	/^    const TPair, typename NodeList::const_iterator> const_iterator;$/;"	t	class:folly::EvictingCacheMap	access:public
const_iterator	.\FBVector.h	/^  typedef const T*                                    const_iterator;$/;"	t	class:folly::fbvector	access:public
const_iterator	.\Padded.h	/^  typedef Iterator<typename Container::const_iterator> const_iterator;$/;"	t	class:folly::Adaptor	access:public
const_iterator	.\Range.h	/^  typedef Iter const_iterator;$/;"	t	class:folly::Range	access:public
const_iterator	.\dynamic-inl.h	/^  typedef It const_iterator;$/;"	t	struct:folly::dynamic::IterableProxy	access:public
const_iterator	.\dynamic.h	/^  typedef Array::const_iterator const_iterator;$/;"	t	struct:folly::dynamic	access:public
const_iterator	.\io\IOBuf.h	/^  typedef Iterator const_iterator;$/;"	t	class:folly::IOBuf	access:public
const_iterator	.\io\RecordIO.h	/^  typedef Iterator const_iterator;$/;"	t	class:folly::RecordIOReader	access:public
const_iterator	.\io\TypedIOBuf.h	/^  typedef const value_type* const_iterator;$/;"	t	class:folly::TypedIOBuf	access:public
const_iterator	.\small_vector.h	/^  typedef value_type const*  const_iterator;$/;"	t	class:folly::small_vector	access:public
const_iterator	.\sorted_vector_types.h	/^  typedef typename ContainerT::const_iterator         const_iterator;$/;"	t	class:folly::sorted_vector_map	access:public
const_iterator	.\sorted_vector_types.h	/^  typedef typename ContainerT::const_iterator         const_iterator;$/;"	t	class:folly::sorted_vector_set	access:public
const_key_iterator	.\dynamic-inl.h	/^  \/* implicit *\/ const_key_iterator(base_type b) : iterator_adaptor_(b) { }$/;"	f	struct:folly::dynamic::const_key_iterator	access:public	signature:(base_type b)
const_key_iterator	.\dynamic-inl.h	/^struct dynamic::const_key_iterator$/;"	s	class:folly::dynamic	inherits:boost::iterator_adaptor
const_key_iterator	.\dynamic.h	/^  struct const_key_iterator;$/;"	x
const_pointer	.\AtomicHashArray.h	/^  typedef const value_type*   const_pointer;$/;"	t	class:folly::AtomicHashArray	access:public
const_pointer	.\ConcurrentSkipList.h	/^  typedef const T* const_pointer;$/;"	t	class:folly::ConcurrentSkipList::Accessor	access:public
const_pointer	.\FBVector.h	/^  typedef typename A::const_pointer                   const_pointer;$/;"	t	class:folly::fbvector	access:public
const_pointer	.\Memory.h	/^  typedef const T* const_pointer;$/;"	t	class:folly::StlAllocator	access:public
const_pointer	.\Memory.h	/^  typedef const void* const_pointer;$/;"	t	class:folly::StlAllocator	access:public
const_pointer	.\test\AtomicHashArrayTest.cpp	/^  typedef const T* const_pointer;$/;"	t	class:MmapAllocator	file:	access:public
const_pointer	.\test\stl_tests\StlVectorTest.cpp	/^  typedef typename std::allocator<T>::const_pointer const_pointer;$/;"	t	struct:Alloc	file:	access:public
const_range_type	.\Range.h	/^    Range<Iter>>::type const_range_type;$/;"	t	class:folly::Range	access:public
const_reference	.\AtomicHashArray.h	/^  typedef const value_type&   const_reference;$/;"	t	class:folly::AtomicHashArray	access:public
const_reference	.\AtomicHashMap.h	/^  typedef const value_type&   const_reference;$/;"	t	class:folly::AtomicHashMap	access:public
const_reference	.\ConcurrentSkipList.h	/^  typedef const T& const_reference;$/;"	t	class:folly::ConcurrentSkipList::Accessor	access:public
const_reference	.\FBVector.h	/^  typedef const value_type&                           const_reference;$/;"	t	class:folly::fbvector	access:public
const_reference	.\Memory.h	/^  typedef const T& const_reference;$/;"	t	class:folly::StlAllocator	access:public
const_reference	.\Padded.h	/^  typedef const value_type& const_reference;$/;"	t	class:folly::Adaptor	access:public
const_reference	.\io\RecordIO.h	/^  typedef const value_type& const_reference;$/;"	t	class:folly::RecordIOReader	access:public
const_reference	.\io\TypedIOBuf.h	/^  typedef const value_type& const_reference;$/;"	t	class:folly::TypedIOBuf	access:public
const_reference	.\small_vector.h	/^  typedef value_type const&  const_reference;$/;"	t	class:folly::small_vector	access:public
const_reference	.\sorted_vector_types.h	/^  typedef typename ContainerT::const_reference        const_reference;$/;"	t	class:folly::sorted_vector_map	access:public
const_reference	.\sorted_vector_types.h	/^  typedef typename ContainerT::const_reference        const_reference;$/;"	t	class:folly::sorted_vector_set	access:public
const_reference	.\test\AtomicHashArrayTest.cpp	/^  typedef const T& const_reference;$/;"	t	class:MmapAllocator	file:	access:public
const_reverse_iterator	.\EvictingCacheMap.h	/^    typename NodeList::const_reverse_iterator> const_reverse_iterator;$/;"	t	class:folly::EvictingCacheMap	access:public
const_reverse_iterator	.\FBVector.h	/^  typedef std::reverse_iterator<const_iterator>       const_reverse_iterator;$/;"	t	class:folly::fbvector	access:public
const_reverse_iterator	.\small_vector.h	/^  typedef std::reverse_iterator<const_iterator> const_reverse_iterator;$/;"	t	class:folly::small_vector	access:public
const_reverse_iterator	.\sorted_vector_types.h	/^  typedef typename ContainerT::const_reverse_iterator const_reverse_iterator;$/;"	t	class:folly::sorted_vector_map	access:public
const_reverse_iterator	.\sorted_vector_types.h	/^  typedef typename ContainerT::const_reverse_iterator const_reverse_iterator;$/;"	t	class:folly::sorted_vector_set	access:public
const_value_iterator	.\dynamic-inl.h	/^  \/* implicit *\/ const_value_iterator(base_type b) : iterator_adaptor_(b) { }$/;"	f	struct:folly::dynamic::const_value_iterator	access:public	signature:(base_type b)
const_value_iterator	.\dynamic-inl.h	/^struct dynamic::const_value_iterator$/;"	s	class:folly::dynamic	inherits:boost::iterator_adaptor
const_value_iterator	.\dynamic.h	/^  struct const_value_iterator;$/;"	x
constantDataHolder	.\io\test\CompressionTest.cpp	/^ConstantDataHolder constantDataHolder(dataSizeLog2);$/;"	p	namespace:folly::io::test	file:	signature:(dataSizeLog2)
construct	.\DynamicConverter.h	/^  static dynamic construct(const C& x) {$/;"	f	struct:folly::DynamicConstructor	access:public	signature:(const C& x)
construct	.\DynamicConverter.h	/^  static dynamic construct(const std::pair<A, B>& x) {$/;"	f	struct:folly::DynamicConstructor	access:public	signature:(const std::pair<A, B>& x)
construct	.\Memory.h	/^  void construct(T* p, Args&&... args) {$/;"	f	class:folly::StlAllocator	access:public	signature:(T* p, Args&&... args)
construct	.\Optional.h	/^  void construct(Args&&... args) {$/;"	f	class:folly::Optional	access:private	signature:(Args&&.... args)
construct	.\test\AtomicHashArrayTest.cpp	/^  void construct(T* p, Args&&... args) {$/;"	f	class:MmapAllocator	access:public	signature:(T* p, Args&&... args)
construct	.\test\stl_tests\StlVectorTest.cpp	/^  void construct(U* p, Args&&... args) {$/;"	f	struct:Alloc	access:public	signature:(U* p, Args&&... args)
constructImpl	.\small_vector.h	/^  void constructImpl(It first, It last, std::false_type) {$/;"	f	class:folly::small_vector	access:private	signature:(It first, It last, std::false_type)
constructImpl	.\small_vector.h	/^  void constructImpl(size_type n, value_type const& val, std::true_type) {$/;"	f	class:folly::small_vector	access:private	signature:(size_type n, value_type const& val, std::true_type)
constructed	.\test\MPMCQueueTest.cpp	/^  Lifecycle(Lifecycle&& rhs) noexcept : constructed(true) {$/;"	f	signature:(true)
constructed	.\test\MPMCQueueTest.cpp	/^  Lifecycle(const Lifecycle& rhs) noexcept : constructed(true) {$/;"	f	signature:(true)
constructed	.\test\MPMCQueueTest.cpp	/^  bool constructed;$/;"	m	struct:Lifecycle	file:	access:public
constructed	.\test\MPMCQueueTest.cpp	/^  explicit Lifecycle(int n, char const* s) noexcept : constructed(true) {$/;"	f	signature:(true)
consume	.\json.cpp	/^  bool consume(StringPiece str) {$/;"	f	struct:folly::json::__anon75::Input	access:public	signature:(StringPiece str)
consumeBufferPlus	.\gen\String-inl.h	/^bool consumeBufferPlus(Callback& cb, IOBuf& buf, StringPiece& s, uint64_t n) {$/;"	f	namespace:folly::gen::detail	signature:(Callback& cb, IOBuf& buf, StringPiece& s, uint64_t n)
consumeFixedSizeChunks	.\gen\String-inl.h	/^bool consumeFixedSizeChunks(Callback& cb, StringPiece& s, uint64_t maxLength) {$/;"	f	namespace:folly::gen::detail	signature:(Callback& cb, StringPiece& s, uint64_t maxLength)
consumer	.\test\ProducerConsumerQueueBenchmark.cpp	/^  void consumer() {$/;"	f	struct:__anon127::LatencyTest	access:public	signature:()
consumer	.\test\ProducerConsumerQueueBenchmark.cpp	/^  void consumer() {$/;"	f	struct:__anon127::ThroughputTest	access:public	signature:()
consumer	.\test\ProducerConsumerQueueTest.cpp	/^  void consumer() {$/;"	f	struct:__anon128::CorrectnessTest	access:public	signature:()
consumer	.\test\ProducerConsumerQueueTest.cpp	/^  void consumer() {$/;"	f	struct:__anon128::PerfTest	access:public	signature:()
consumerPop	.\test\ProducerConsumerQueueTest.cpp	/^  void consumerPop() {$/;"	f	struct:__anon128::CorrectnessTest	access:public	signature:()
consumerRead	.\test\ProducerConsumerQueueTest.cpp	/^  void consumerRead() {$/;"	f	struct:__anon128::CorrectnessTest	access:public	signature:()
consumers	.\gen\Parallel-inl.h	/^  size_t consumers() const {$/;"	f	class:folly::gen::detail::ClosableMPMCQueue	access:public	signature:() const
cont_	.\sorted_vector_types.h	/^    ContainerT cont_;$/;"	m	struct:folly::sorted_vector_map::EBO	access:public
cont_	.\sorted_vector_types.h	/^    ContainerT cont_;$/;"	m	struct:folly::sorted_vector_set::EBO	access:public
container_	.\gen\Base-inl.h	/^  Container* container_;$/;"	m	class:folly::gen::detail::ReferencedSource	access:private
container_	.\gen\Base.h	/^  static Container container_;$/;"	m	struct:folly::gen::detail::ValueTypeOfRange	access:private
container_	.\gen\Combine-inl.h	/^    const std::shared_ptr<const Container> container_;$/;"	m	class:folly::gen::detail::Interleave::Generator	access:private
container_	.\gen\Combine-inl.h	/^    const std::shared_ptr<const Container> container_;$/;"	m	class:folly::gen::detail::Zip::Generator	access:private
container_	.\gen\Combine-inl.h	/^  const std::shared_ptr<const Container> container_;$/;"	m	class:folly::gen::detail::Interleave	access:private
container_	.\gen\Combine-inl.h	/^  const std::shared_ptr<const Container> container_;$/;"	m	class:folly::gen::detail::Zip	access:private
contains	.\ConcurrentSkipList.h	/^  bool contains(const key_type &data) const { return sl_->find(data); }$/;"	f	class:folly::ConcurrentSkipList::Accessor	access:public	signature:(const key_type &data) const
contains	.\Range.cpp	/^  inline bool contains(uint8_t i) const {$/;"	f	class:folly::__anon83::FastByteSet	access:public	signature:(uint8_t i) const
contains	.\Range.h	/^  bool contains(const const_range_type& other) const {$/;"	f	class:folly::Range	access:public	signature:(const const_range_type& other) const
contains	.\Range.h	/^  bool contains(const value_type& other) const {$/;"	f	class:folly::Range	access:public	signature:(const value_type& other) const
contains	.\gen\Base.h	/^Contains contains(Needle&& needle) {$/;"	f	namespace:folly::gen	signature:(Needle&& needle)
contains_	.\wangle\Try.h	/^  Contains contains_;$/;"	m	class:folly::wangle::Try	access:private
contendedUse	.\test\LifoSemTests.cpp	/^static void contendedUse(uint n, int posters, int waiters) {$/;"	f	file:	signature:(uint n, int posters, int waiters)
contentionAtWidth	.\test\CacheLocalityTest.cpp	/^static void contentionAtWidth(size_t iters, size_t stripes, size_t work,$/;"	f	file:	signature:(size_t iters, size_t stripes, size_t work, SpreaderType spreaderType, size_t counterAlignment = 128, size_t numThreads = 32)
contents_	.\MPMCQueue.h	/^  typename std::aligned_storage<sizeof(T),alignof(T)>::type contents_;$/;"	m	struct:folly::SingleElementQueue	access:private
context	.\json.cpp	/^  std::string context() const {$/;"	f	struct:folly::json::__anon75::Input	access:public	signature:() const
context_	.\io\async\AsyncTimeout.h	/^  std::shared_ptr<RequestContext> context_;$/;"	m	class:folly::AsyncTimeout	access:private
context_	.\io\async\EventBase.h	/^    std::shared_ptr<RequestContext> context_;$/;"	m	class:folly::EventBase::LoopCallback	access:private
context_	.\io\async\HHWheelTimer.h	/^    std::shared_ptr<RequestContext> context_;$/;"	m	class:folly::HHWheelTimer::Callback	access:private
conversionIterator	.\DynamicConverter.h	/^conversionIterator(const It& it) {$/;"	f	namespace:folly::dynamicconverter_detail	signature:(const It& it)
convert	.\DynamicConverter.h	/^  static C convert(const dynamic& d) {$/;"	f	struct:folly::DynamicConverter	access:public	signature:(const dynamic& d)
convert	.\DynamicConverter.h	/^  static T convert(const dynamic& d) {$/;"	f	struct:folly::DynamicConverter	access:public	signature:(const dynamic& d)
convert	.\DynamicConverter.h	/^  static bool convert(const dynamic& d) {$/;"	f	struct:folly::DynamicConverter	access:public	signature:(const dynamic& d)
convert	.\DynamicConverter.h	/^  static folly::fbstring convert(const dynamic& d) {$/;"	f	struct:folly::DynamicConverter	access:public	signature:(const dynamic& d)
convert	.\DynamicConverter.h	/^  static std::pair<F, S> convert(const dynamic& d) {$/;"	f	struct:folly::DynamicConverter	access:public	signature:(const dynamic& d)
convert	.\DynamicConverter.h	/^  static std::string convert(const dynamic& d) {$/;"	f	struct:folly::DynamicConverter	access:public	signature:(const dynamic& d)
convert	.\test\DynamicConverterTest.cpp	/^  static A convert(const dynamic & d) {$/;"	f	struct:folly::DynamicConverter	access:public	signature:(const dynamic & d)
convert	.\test\DynamicConverterTest.cpp	/^  static Token convert(const dynamic& d) {$/;"	f	struct:folly::DynamicConverter	access:public	signature:(const dynamic& d)
convertTo	.\DynamicConverter.h	/^  template <typename T> T convertTo(const dynamic&);$/;"	p	namespace:folly	signature:(const dynamic&)
convertTo	.\DynamicConverter.h	/^T convertTo(const dynamic& d) {$/;"	f	namespace:folly	signature:(const dynamic& d)
convertTo	.\String-inl.h	/^struct convertTo {$/;"	s	namespace:folly::detail
convertToIPv4	.\SocketAddress.cpp	/^void SocketAddress::convertToIPv4() {$/;"	f	class:folly::SocketAddress	signature:()
convertToIPv4	.\SocketAddress.h	/^  void convertToIPv4();$/;"	p	class:folly::SocketAddress	access:public	signature:()
convertToInt	.\test\stl_tests\StlVectorTest.cpp	/^int convertToInt(const Alloc<T>& a) {$/;"	f	signature:(const Alloc<T>& a)
convertToInt	.\test\stl_tests\StlVectorTest.cpp	/^int convertToInt(const Data<f, pad>& t) {$/;"	f	signature:(const Data<f, pad>& t)
convertToInt	.\test\stl_tests\StlVectorTest.cpp	/^int convertToInt(const std::allocator<T>&) {$/;"	f	signature:(const std::allocator<T>&)
convertToInt	.\test\stl_tests\StlVectorTest.cpp	/^int convertToInt(int t) {$/;"	f	signature:(int t)
copies	.\gen\test\BaseTest.cpp	/^  int copies;$/;"	m	struct:CopyCounter	file:	access:public
copy	.\SocketAddress.h	/^    void copy(const ExternalUnixAddr &other) {$/;"	f	struct:folly::SocketAddress::ExternalUnixAddr	access:public	signature:(const ExternalUnixAddr &other)
copy	.\Synchronized.h	/^  T copy() const {$/;"	f	struct:folly::Synchronized	access:public	signature:() const
copy	.\Synchronized.h	/^  void copy(T* target) const {$/;"	f	struct:folly::Synchronized	access:public	signature:(T* target) const
copy	.\experimental\io\HugePageUtil.cpp	/^void copy(const char* srcFile, const char* dest) {$/;"	f	namespace:__anon31	signature:(const char* srcFile, const char* dest)
copy	.\stats\Histogram.h	/^  void copy(const Histogram &hist) {$/;"	f	class:folly::Histogram	access:public	signature:(const Histogram &hist)
copyBuffer	.\io\IOBuf.h	/^  static std::unique_ptr<IOBuf> copyBuffer(ByteRange br,$/;"	f	class:folly::IOBuf	access:public	signature:(ByteRange br, uint64_t headroom=0, uint64_t minTailroom=0)
copyBuffer	.\io\IOBuf.h	/^  static std::unique_ptr<IOBuf> copyBuffer(const std::string& buf,$/;"	p	class:folly::IOBuf	access:public	signature:(const std::string& buf, uint64_t headroom=0, uint64_t minTailroom=0)
copyBuffer	.\io\IOBuf.h	/^  static std::unique_ptr<IOBuf> copyBuffer(const void* buf, uint64_t size,$/;"	p	class:folly::IOBuf	access:public	signature:(const void* buf, uint64_t size, uint64_t headroom=0, uint64_t minTailroom=0)
copyBuffer	.\io\IOBuf.h	/^inline std::unique_ptr<IOBuf> IOBuf::copyBuffer($/;"	f	class:folly::IOBuf	signature:( const void* data, uint64_t size, uint64_t headroom, uint64_t minTailroom)
copyBuffer	.\io\IOBuf.h	/^inline std::unique_ptr<IOBuf> IOBuf::copyBuffer(const std::string& buf,$/;"	f	class:folly::IOBuf	signature:(const std::string& buf, uint64_t headroom, uint64_t minTailroom)
copyCtor	.\test\FBStringTestBenchmarks.cpp.h	/^void BENCHFUN(copyCtor)(int iters, int arg) {$/;"	f	signature:(int iters, int arg)
copyHead	.\ConcurrentSkipList-inl.h	/^  SkipListNode* copyHead(SkipListNode* node) {$/;"	f	class:folly::detail::SkipListNode	access:public	signature:(SkipListNode* node)
copyWithSameAlignment	.\test\StringTest.cpp	/^char* copyWithSameAlignment(char* dst, const char* src, size_t length) {$/;"	f	namespace:__anon139	signature:(char* dst, const char* src, size_t length)
copy_	.\gen\Base-inl.h	/^  std::shared_ptr<const Container> copy_;$/;"	m	class:folly::gen::detail::CopiedSource	access:public
coreDumped	.\Subprocess.cpp	/^bool ProcessReturnCode::coreDumped() const {$/;"	f	class:folly::ProcessReturnCode	signature:() const
coreDumped	.\Subprocess.h	/^  bool coreDumped() const;$/;"	p	class:folly::ProcessReturnCode	access:public	signature:() const
correctnessTestType	.\test\ProducerConsumerQueueTest.cpp	/^void correctnessTestType(const std::string& type) {$/;"	f	namespace:__anon128	signature:(const std::string& type)
corrupt	.\io\test\RecordIOTest.cpp	/^void corrupt(int fd, off_t pos) {$/;"	f	namespace:folly::test::__anon74	signature:(int fd, off_t pos)
count	.\AtomicHashMap.h	/^  size_type count(key_type k) const {$/;"	f	class:folly::AtomicHashMap	access:public	signature:(key_type k) const
count	.\ConcurrentSkipList.h	/^  size_type count(const key_type &data) const { return contains(data); }$/;"	f	class:folly::ConcurrentSkipList::Accessor	access:public	signature:(const key_type &data) const
count	.\detail\Stats.h	/^  uint64_t count;$/;"	m	struct:folly::detail::Bucket	access:public
count	.\dynamic-inl.h	/^inline std::size_t dynamic::count(dynamic const& key) const {$/;"	f	class:folly::dynamic	signature:(dynamic const& key) const
count	.\dynamic.h	/^  std::size_t count(dynamic const&) const;$/;"	p	struct:folly::dynamic	access:public	signature:(dynamic const&) const
count	.\experimental\Bits.h	/^  static size_t count(const T* begin, const T* end);$/;"	p	struct:folly::Bits	access:public	signature:(const T* begin, const T* end)
count	.\experimental\Bits.h	/^inline size_t Bits<T, Traits>::count(const T* begin, const T* end) {$/;"	f	class:folly::Bits	signature:(const T* begin, const T* end)
count	.\gen\Base-inl.h	/^static const detail::Count count;$/;"	m	namespace:folly::gen
count	.\io\async\HHWheelTimer.h	/^  uint64_t count() const {$/;"	f	class:folly::HHWheelTimer	access:public	signature:() const
count	.\sorted_vector_types.h	/^  size_type count(const key_type& key) const {$/;"	f	class:folly::sorted_vector_map	access:public	signature:(const key_type& key) const
count	.\sorted_vector_types.h	/^  size_type count(const key_type& key) const {$/;"	f	class:folly::sorted_vector_set	access:public	signature:(const key_type& key) const
count	.\stats\BucketedTimeSeries-defs.h	/^uint64_t BucketedTimeSeries<VT, TT>::count(TimeType start, TimeType end) const {$/;"	f	class:folly::BucketedTimeSeries	signature:(TimeType start, TimeType end) const
count	.\stats\BucketedTimeSeries.h	/^  uint64_t count() const {$/;"	f	class:folly::BucketedTimeSeries	access:public	signature:() const
count	.\stats\BucketedTimeSeries.h	/^  uint64_t count(TimeType start, TimeType end) const;$/;"	p	class:folly::BucketedTimeSeries	access:public	signature:(TimeType start, TimeType end) const
count	.\stats\MultiLevelTimeSeries.h	/^  int64_t count(TimeType start, TimeType end) const {$/;"	f	class:folly::MultiLevelTimeSeries	access:public	signature:(TimeType start, TimeType end) const
count	.\stats\MultiLevelTimeSeries.h	/^  int64_t count(int level) const {$/;"	f	class:folly::MultiLevelTimeSeries	access:public	signature:(int level) const
count	.\stats\TimeseriesHistogram.h	/^  int64_t count(TimeType start, TimeType end) const {$/;"	f	class:folly::TimeseriesHistogram	access:public	signature:(TimeType start, TimeType end) const
count	.\stats\TimeseriesHistogram.h	/^  int64_t count(int level) const {$/;"	f	class:folly::TimeseriesHistogram	access:public	signature:(int level) const
count	.\test\ArenaSmartPtrTest.cpp	/^  unsigned count() const { return count_; }$/;"	f	struct:global_counter	access:public	signature:() const
count	.\test\LazyTest.cpp	/^  static int count;$/;"	m	struct:folly::CopyCount	file:	access:public
count	.\test\LazyTest.cpp	/^int CopyCount::count = 0;$/;"	m	class:folly::CopyCount	file:
count	.\wangle\detail\State.h	/^  std::atomic<size_t> count;$/;"	m	struct:folly::wangle::detail::VariadicContext	access:public
count	.\wangle\detail\State.h	/^  std::atomic<size_t> count;$/;"	m	struct:folly::wangle::detail::WhenAllContext	access:public
count	.\wangle\detail\State.h	/^  std::atomic<size_t> count;$/;"	m	struct:folly::wangle::detail::WhenAllLaterContext	access:public
countChainElements	.\io\IOBuf.cpp	/^size_t IOBuf::countChainElements() const {$/;"	f	class:folly::IOBuf	signature:() const
countChainElements	.\io\IOBuf.h	/^  size_t countChainElements() const;$/;"	p	class:folly::IOBuf	access:public	signature:() const
countRate	.\stats\BucketedTimeSeries.h	/^  ReturnType countRate() const {$/;"	f	class:folly::BucketedTimeSeries	access:public	signature:() const
countRate	.\stats\BucketedTimeSeries.h	/^  ReturnType countRate(TimeType start, TimeType end) const {$/;"	f	class:folly::BucketedTimeSeries	access:public	signature:(TimeType start, TimeType end) const
countRate	.\stats\MultiLevelTimeSeries.h	/^  ReturnType countRate(int level) const {$/;"	f	class:folly::MultiLevelTimeSeries	access:public	signature:(int level) const
count_	.\GroupVarint.h	/^  size_t count_;$/;"	m	class:folly::GroupVarintDecoder	access:private
count_	.\GroupVarint.h	/^  size_t count_;$/;"	m	class:folly::GroupVarintEncoder	access:private
count_	.\gen\Base-inl.h	/^    size_t count_;$/;"	m	class:folly::gen::detail::Sample::Generator	access:private
count_	.\gen\Base-inl.h	/^    size_t count_;$/;"	m	class:folly::gen::detail::Skip::Generator	access:private
count_	.\gen\Base-inl.h	/^    size_t count_;$/;"	m	class:folly::gen::detail::Take::Generator	access:private
count_	.\gen\Base-inl.h	/^  size_t count_;$/;"	m	class:folly::gen::detail::Sample	access:private
count_	.\gen\Base-inl.h	/^  size_t count_;$/;"	m	class:folly::gen::detail::Skip	access:private
count_	.\gen\Base-inl.h	/^  size_t count_;$/;"	m	class:folly::gen::detail::Take	access:private
count_	.\io\async\HHWheelTimer.h	/^  uint64_t count_;$/;"	m	class:folly::HHWheelTimer	access:private
count_	.\test\ArenaSmartPtrTest.cpp	/^  unsigned count_;$/;"	m	struct:global_counter	file:	access:private
count_	.\test\sorted_vector_test.cpp	/^  int count_;$/;"	m	struct:__anon133::CountCopyCtor	file:	access:public
counter_	.\test\ArenaSmartPtrTest.cpp	/^  global_counter& counter_;$/;"	m	struct:Foo	file:	access:private
cplus_demangle_v3_callback	.\Demangle.cpp	/^extern "C" int cplus_demangle_v3_callback($/;"	p	file:	signature:( const char* mangled, int options, void (*callback)(const char*, size_t, void*), void* arg)
cpu0_	.\test\ProducerConsumerQueueBenchmark.cpp	/^  int cpu0_;$/;"	m	struct:__anon127::LatencyTest	file:	access:public
cpu0_	.\test\ProducerConsumerQueueBenchmark.cpp	/^  int cpu0_;$/;"	m	struct:__anon127::ThroughputTest	file:	access:public
cpu1_	.\test\ProducerConsumerQueueBenchmark.cpp	/^  int cpu1_;$/;"	m	struct:__anon127::LatencyTest	file:	access:public
cpu1_	.\test\ProducerConsumerQueueBenchmark.cpp	/^  int cpu1_;$/;"	m	struct:__anon127::ThroughputTest	file:	access:public
crbegin	.\EvictingCacheMap.h	/^  const_reverse_iterator crbegin() const {$/;"	f	class:folly::EvictingCacheMap	access:public	signature:() const
crbegin	.\small_vector.h	/^  const_reverse_iterator crbegin() const { return rbegin(); }$/;"	f	class:folly::small_vector	access:public	signature:() const
crc32c	.\Checksum.cpp	/^uint32_t crc32c(const uint8_t *data, size_t nbytes,$/;"	f	namespace:folly	signature:(const uint8_t *data, size_t nbytes, uint32_t startingChecksum)
crc32c	.\Checksum.h	/^uint32_t crc32c(const uint8_t* data, size_t nbytes,$/;"	p	namespace:folly	signature:(const uint8_t* data, size_t nbytes, uint32_t startingChecksum = ~0U)
crc32c	.\test\ChecksumTest.cpp	/^  uint32_t crc32c;$/;"	m	struct:__anon112::ExpectedResult	file:	access:public
crc32c_hw	.\Checksum.cpp	/^uint32_t crc32c_hw(const uint8_t *data, size_t nbytes,$/;"	f	namespace:folly::detail	signature:(const uint8_t *data, size_t nbytes, uint32_t startingChecksum)
crc32c_hw	.\detail\ChecksumDetail.h	/^uint32_t crc32c_hw(const uint8_t* data, size_t nbytes,$/;"	p	namespace:folly::detail	signature:(const uint8_t* data, size_t nbytes, uint32_t startingChecksum = ~0U)
crc32c_hw_supported	.\Checksum.cpp	/^bool crc32c_hw_supported() {$/;"	f	namespace:folly::detail	signature:()
crc32c_hw_supported	.\detail\ChecksumDetail.h	/^bool crc32c_hw_supported();$/;"	p	namespace:folly::detail	signature:()
crc32c_sw	.\Checksum.cpp	/^uint32_t crc32c_sw(const uint8_t *data, size_t nbytes,$/;"	f	namespace:folly::detail	signature:(const uint8_t *data, size_t nbytes, uint32_t startingChecksum)
crc32c_sw	.\detail\ChecksumDetail.h	/^uint32_t crc32c_sw(const uint8_t* data, size_t nbytes,$/;"	p	namespace:folly::detail	signature:(const uint8_t* data, size_t nbytes, uint32_t startingChecksum = ~0U)
create	.\AtomicHashArray-inl.h	/^create(size_t maxSize, const Config& c) {$/;"	f	class:folly::AtomicHashArray	signature:(size_t maxSize, const Config& c)
create	.\AtomicHashArray.h	/^  static SmartPtr create(size_t maxSize, const Config& = defaultConfig);$/;"	p	class:folly::AtomicHashArray	access:public	signature:(size_t maxSize, const Config& = defaultConfig)
create	.\ConcurrentSkipList-inl.h	/^  static SkipListNode* create($/;"	f	class:folly::detail::SkipListNode	access:public	signature:( NodeAlloc& alloc, int height, U&& data, bool isHead = false)
create	.\ConcurrentSkipList.h	/^  static Accessor create(int height = 1, const NodeAlloc& alloc = NodeAlloc()) {$/;"	f	class:folly::ConcurrentSkipList	access:public	signature:(int height = 1, const NodeAlloc& alloc = NodeAlloc())
create	.\Random.h	/^  static ValidRNG<RNG> create();$/;"	p	class:folly::Random	access:public	signature:()
create	.\detail\ThreadLocalDetail.h	/^  static int create() {$/;"	f	struct:folly::threadlocal_detail::StaticMeta	access:public	signature:()
create	.\experimental\Singleton.h	/^    CreateFunc create = nullptr;$/;"	m	struct:folly::SingletonVault::SingletonEntry	access:public
create	.\io\Compression.cpp	/^  static std::unique_ptr<Codec> create(int level, CodecType type);$/;"	p	class:folly::io::__anon64::FOLLY_FINAL	file:	access:public	signature:(int level, CodecType type)
create	.\io\Compression.cpp	/^std::unique_ptr<Codec> LZ4Codec::create(int level, CodecType type) {$/;"	f	class:folly::io::__anon64::LZ4Codec	signature:(int level, CodecType type)
create	.\io\Compression.cpp	/^std::unique_ptr<Codec> LZMA2Codec::create(int level, CodecType type) {$/;"	f	class:folly::io::__anon64::LZMA2Codec	signature:(int level, CodecType type)
create	.\io\Compression.cpp	/^std::unique_ptr<Codec> NoCompressionCodec::create(int level, CodecType type) {$/;"	f	class:folly::io::__anon64::NoCompressionCodec	signature:(int level, CodecType type)
create	.\io\Compression.cpp	/^std::unique_ptr<Codec> SnappyCodec::create(int level, CodecType type) {$/;"	f	class:folly::io::__anon64::SnappyCodec	signature:(int level, CodecType type)
create	.\io\Compression.cpp	/^std::unique_ptr<Codec> ZlibCodec::create(int level, CodecType type) {$/;"	f	class:folly::io::__anon64::ZlibCodec	signature:(int level, CodecType type)
create	.\io\IOBuf.cpp	/^unique_ptr<IOBuf> IOBuf::create(uint64_t capacity) {$/;"	f	class:folly::IOBuf	signature:(uint64_t capacity)
create	.\io\IOBuf.h	/^  static std::unique_ptr<IOBuf> create(uint64_t capacity);$/;"	p	class:folly::IOBuf	access:public	signature:(uint64_t capacity)
create	.\io\async\Request.h	/^  static bool create() {$/;"	f	class:folly::RequestContext	access:public	signature:()
createChain	.\io\IOBuf.cpp	/^unique_ptr<IOBuf> IOBuf::createChain($/;"	f	class:folly::IOBuf	signature:( size_t totalCapacity, uint64_t maxBufCapacity)
createChain	.\io\IOBuf.h	/^  static std::unique_ptr<IOBuf> createChain($/;"	p	class:folly::IOBuf	access:public	signature:( size_t totalCapacity, uint64_t maxBufCapacity)
createCombined	.\io\IOBuf.cpp	/^unique_ptr<IOBuf> IOBuf::createCombined(uint64_t capacity) {$/;"	f	class:folly::IOBuf	signature:(uint64_t capacity)
createCombined	.\io\IOBuf.h	/^  static std::unique_ptr<IOBuf> createCombined(uint64_t capacity);$/;"	p	class:folly::IOBuf	access:public	signature:(uint64_t capacity)
createEntry	.\test\AtomicHashArrayTest.cpp	/^pair<KeyT,ValueT> createEntry(int i) {$/;"	f	signature:(int i)
createIPv4	.\IPAddress.cpp	/^IPAddressV4 IPAddress::createIPv4(const IPAddress& addr) {$/;"	f	class:folly::IPAddress	signature:(const IPAddress& addr)
createIPv4	.\IPAddress.h	/^  static IPAddressV4 createIPv4(const IPAddress& addr);$/;"	p	class:folly::IPAddress	access:public	signature:(const IPAddress& addr)
createIPv4	.\IPAddressV6.cpp	/^IPAddressV4 IPAddressV6::createIPv4() const {$/;"	f	class:folly::IPAddressV6	signature:() const
createIPv4	.\IPAddressV6.h	/^  IPAddressV4 createIPv4() const;$/;"	p	class:folly::IPAddressV6	access:public	signature:() const
createIPv6	.\IPAddress.cpp	/^IPAddressV6 IPAddress::createIPv6(const IPAddress& addr) {$/;"	f	class:folly::IPAddress	signature:(const IPAddress& addr)
createIPv6	.\IPAddress.h	/^  static IPAddressV6 createIPv6(const IPAddress& addr);$/;"	p	class:folly::IPAddress	access:public	signature:(const IPAddress& addr)
createIPv6	.\IPAddressV4.cpp	/^IPAddressV6 IPAddressV4::createIPv6() const {$/;"	f	class:folly::IPAddressV4	signature:() const
createIPv6	.\IPAddressV4.h	/^  IPAddressV6 createIPv6() const;$/;"	p	class:folly::IPAddressV4	access:public	signature:() const
createInstance	.\ConcurrentSkipList.h	/^  static std::shared_ptr<SkipListType> createInstance($/;"	f	class:folly::ConcurrentSkipList	access:public	signature:( int height = 1, const NodeAlloc& alloc = NodeAlloc())
createMulticast	.\MacAddress.cpp	/^MacAddress MacAddress::createMulticast(IPAddressV6 v6addr) {$/;"	f	class:folly::MacAddress	signature:(IPAddressV6 v6addr)
createMulticast	.\MacAddress.h	/^  static MacAddress createMulticast(IPAddressV6 addr);$/;"	p	class:folly::MacAddress	access:public	signature:(IPAddressV6 addr)
createNetwork	.\IPAddress.cpp	/^CIDRNetwork IPAddress::createNetwork(StringPiece ipSlashCidr,$/;"	f	class:folly::IPAddress	signature:(StringPiece ipSlashCidr, int defaultCidr, bool applyMask )
createNetwork	.\IPAddress.h	/^  static CIDRNetwork createNetwork($/;"	p	class:folly::IPAddress	access:public	signature:( StringPiece ipSlashCidr, int defaultCidr = -1, bool mask = true)
createProtectedBuf	.\test\RangeTest.cpp	/^void createProtectedBuf(StringPiece& contents, char** buf) {$/;"	f	signature:(StringPiece& contents, char** buf)
createSeparate	.\io\IOBuf.cpp	/^unique_ptr<IOBuf> IOBuf::createSeparate(uint64_t capacity) {$/;"	f	class:folly::IOBuf	signature:(uint64_t capacity)
createSeparate	.\io\IOBuf.h	/^  static std::unique_ptr<IOBuf> createSeparate(uint64_t capacity);$/;"	p	class:folly::IOBuf	access:public	signature:(uint64_t capacity)
creating_thread	.\experimental\Singleton.h	/^    std::thread::id creating_thread;$/;"	m	struct:folly::SingletonVault::SingletonEntry	access:public
creation_order	.\experimental\test\SingletonTest.cpp	/^  static std::vector<Watchdog*> creation_order;$/;"	m	struct:Watchdog	file:	access:public
creation_order	.\experimental\test\SingletonTest.cpp	/^std::vector<Watchdog*> Watchdog::creation_order;$/;"	m	class:Watchdog	file:
creation_order_	.\experimental\Singleton.h	/^  std::vector<detail::TypeDescriptor> creation_order_;$/;"	m	class:folly::SingletonVault	access:private
crend	.\EvictingCacheMap.h	/^  const_reverse_iterator crend() const {$/;"	f	class:folly::EvictingCacheMap	access:public	signature:() const
crend	.\small_vector.h	/^  const_reverse_iterator crend()   const { return rend(); }$/;"	f	class:folly::small_vector	access:public	signature:() const
crtBuf_	.\io\Cursor.h	/^  BufType* crtBuf_;$/;"	m	class:folly::io::detail::CursorBase	access:protected
crtBuf_	.\io\Cursor.h	/^  IOBuf* crtBuf_;$/;"	m	class:folly::io::Appender	access:private
csl_iterator	.\ConcurrentSkipList-inl.h	/^template<typename ValT, typename NodeT> class csl_iterator;$/;"	x
csl_iterator	.\ConcurrentSkipList.h	/^  csl_iterator(const csl_iterator<OtherVal, OtherNode> &other,$/;"	f	class:folly::detail::csl_iterator	access:public	signature:(const csl_iterator<OtherVal, OtherNode> &other, typename std::enable_if<std::is_convertible<OtherVal, ValT>::value>::type* = 0)
csl_iterator	.\ConcurrentSkipList.h	/^  explicit csl_iterator(NodeT* node = nullptr) : node_(node) {}$/;"	f	class:folly::detail::csl_iterator	access:public	signature:(NodeT* node = nullptr)
csl_iterator	.\ConcurrentSkipList.h	/^  template<class,class> friend class csl_iterator;$/;"	x
csl_iterator	.\ConcurrentSkipList.h	/^class detail::csl_iterator :$/;"	c	class:folly::detail	inherits:boost::iterator_facade
ctorFromArray	.\test\FBStringTestBenchmarks.cpp.h	/^void BENCHFUN(ctorFromArray)(int iters, int arg) {$/;"	f	signature:(int iters, int arg)
ctorFromChar	.\test\FBStringTestBenchmarks.cpp.h	/^void BENCHFUN(ctorFromChar)(int iters, int arg) {$/;"	f	signature:(int iters, int arg)
ctorFromTwoPointers	.\test\FBStringTestBenchmarks.cpp.h	/^void BENCHFUN(ctorFromTwoPointers)(int iters, int arg) {$/;"	f	signature:(int iters, int arg)
ctored	.\test\small_vector_test.cpp	/^  static int ctored;$/;"	m	struct:__anon132::NontrivialType	file:	access:public
ctored	.\test\small_vector_test.cpp	/^int NontrivialType::ctored = 0;$/;"	m	class:__anon132::NontrivialType	file:
ctxSet_	.\experimental\io\AsyncIO.h	/^  std::atomic<bool> ctxSet_;$/;"	m	class:folly::AsyncIO	access:private
ctx_	.\experimental\io\AsyncIO.h	/^  io_context_t ctx_;$/;"	m	class:folly::AsyncIO	access:private
ctz	.\experimental\EliasFanoCoding.h	/^  static inline int ctz(uint64_t value) {$/;"	f	struct:folly::compression::instructions::Default	access:public	signature:(uint64_t value)
curHeight	.\ConcurrentSkipList.h	/^  int curHeight() const {$/;"	f	class:folly::ConcurrentSkipList::Skipper	access:public	signature:() const
cur_	.\test\AHMIntStressTest.cpp	/^  std::shared_ptr<MyMap> cur_;$/;"	m	struct:__anon102::MyObjectDirectory	file:	access:public
current	.\detail\CacheLocality.h	/^  size_t current() const {$/;"	f	struct:folly::detail::AccessSpreader	access:public	signature:() const
current	.\detail\CacheLocality.h	/^  static size_t current(size_t numStripes) {$/;"	f	struct:folly::detail::AccessSpreader	access:public	signature:(size_t numStripes)
currentId	.\detail\CacheLocality.h	/^  static FOLLY_TLS size_t currentId;$/;"	m	struct:folly::detail::SequentialThreadId	access:private
current_	.\json.cpp	/^  int current_;$/;"	m	struct:folly::json::__anon75::Input	file:	access:private
cursor_	.\io\Compression.cpp	/^  io::Cursor cursor_;$/;"	m	class:folly::io::__anon64::FOLLY_FINAL	file:	access:private
customAllocator	.\test\stl_tests\StlVectorTest.cpp	/^struct customAllocator$/;"	s	file:	inherits:std::integral_constant
customDelete	.\io\test\IOBufTest.cpp	/^void customDelete(OwnershipTestClass* p) {$/;"	f	namespace:__anon71	signature:(OwnershipTestClass* p)
customDeleteArray	.\io\test\IOBufTest.cpp	/^void customDeleteArray(OwnershipTestClass* p) {$/;"	f	namespace:__anon71	signature:(OwnershipTestClass* p)
customDeleter	.\test\ThreadLocalTest.cpp	/^  static void customDeleter(Widget* w, TLPDestructionMode mode) {$/;"	f	struct:Widget	access:public	signature:(Widget* w, TLPDestructionMode mode)
customDeleterCount	.\io\test\IOBufTest.cpp	/^int customDeleterCount = 0;$/;"	m	namespace:__anon71	file:
cycle	.\gen\Base-inl.h	/^static const detail::Cycle cycle;$/;"	m	namespace:folly::gen
dValue	.\test\ConvTest.cpp	/^static double dValue = 345345345.435;$/;"	v	file:
d_	.\CpuId.h	/^  uint32_t d_;  \/\/ EDX$/;"	m	class:folly::CpuId	access:private
dallocx	.\detail\Malloc.h	/^extern void (*dallocx)(void*, int);$/;"	x
dallocx	.\detail\Malloc.h	/^void dallocx(void*, int) __attribute__((__weak__));$/;"	p	signature:(void*, int)
dallocx	.\detail\MallocImpl.cpp	/^void (*dallocx)(void*, int) = nullptr;$/;"	v
dampen	.\io\async\EventBase.h	/^    void dampen(double factor) {$/;"	f	class:folly::EventBase::SmoothLoopTime	access:public	signature:(double factor)
data	.\AtomicStruct.h	/^  Atom<Raw> data;$/;"	m	class:folly::AtomicStruct	access:private
data	.\ConcurrentSkipList-inl.h	/^  const value_type& data() const { return data_; }$/;"	f	class:folly::detail::SkipListNode	access:public	signature:() const
data	.\ConcurrentSkipList-inl.h	/^  value_type& data() { return data_; }$/;"	f	class:folly::detail::SkipListNode	access:public	signature:()
data	.\ConcurrentSkipList.h	/^  const value_type &data() const {$/;"	f	class:folly::ConcurrentSkipList::Skipper	access:public	signature:() const
data	.\MemoryMapping.h	/^  StringPiece data() const {$/;"	f	class:folly::MemoryMapping	access:public	signature:() const
data	.\Range.h	/^  Iter data() const { return b_; }$/;"	f	class:folly::Range	access:public	signature:() const
data	.\dynamic-inl.h	/^inline const char* dynamic::data()  const { return get<fbstring>().data();  }$/;"	f	class:folly::dynamic	signature:() const
data	.\dynamic.h	/^  const char* data()  const;$/;"	p	struct:folly::dynamic	access:public	signature:() const
data	.\experimental\symbolizer\ElfCache.h	/^    const char* data() const {$/;"	f	class:folly::symbolizer::SignalSafeElfCache::Path	access:public	signature:() const
data	.\experimental\test\EliasFanoCodingTest.cpp	/^std::vector<uint32_t> data;$/;"	m	namespace:bm	file:
data	.\io\Cursor.h	/^  const uint8_t* data() const {$/;"	f	class:folly::io::detail::CursorBase	access:public	signature:() const
data	.\io\IOBuf.h	/^  const uint8_t* data() const {$/;"	f	class:folly::IOBuf	access:public	signature:() const
data	.\io\TypedIOBuf.h	/^  const T* data() const {$/;"	f	class:folly::TypedIOBuf	access:public	signature:() const
data	.\io\test\CompressionTest.cpp	/^  ByteRange data(size_t size) const;$/;"	p	class:folly::io::test::DataHolder	file:	access:public	signature:(size_t size) const
data	.\io\test\CompressionTest.cpp	/^ByteRange DataHolder::data(size_t size) const {$/;"	f	class:folly::io::test::DataHolder	signature:(size_t size) const
data	.\test\DeterministicSchedule.h	/^  std::atomic<T> data;$/;"	m	struct:folly::test::DeterministicAtomic	access:public
dataHash	.\io\RecordIO-inl.h	/^  uint64_t dataHash;$/;"	m	struct:folly::recordio_helpers::detail::Header	access:public
dataHash	.\io\RecordIO.cpp	/^uint64_t dataHash(ByteRange range) {$/;"	f	namespace:folly::recordio_helpers::__anon68	signature:(ByteRange range)
dataIsInternal	.\FBVector.h	/^  bool dataIsInternal(const T& t) {$/;"	f	signature:(const T& t)
dataIsInternalAndNotVT	.\FBVector.h	/^  bool dataIsInternalAndNotVT(const T& t) {$/;"	f	signature:(const T& t)
dataLength	.\io\RecordIO-inl.h	/^  uint32_t dataLength;$/;"	m	struct:folly::recordio_helpers::detail::Header	access:public
dataLengthAndHash	.\io\RecordIO.cpp	/^std::pair<size_t, uint64_t> dataLengthAndHash(const IOBuf* buf) {$/;"	f	namespace:folly::recordio_helpers::__anon68	signature:(const IOBuf* buf)
dataSizeLog2	.\io\test\CompressionTest.cpp	/^constexpr size_t dataSizeLog2 = 27;  \/\/ 128MiB$/;"	m	namespace:folly::io::test	file:
data_	.\AtomicBitSet.h	/^  std::array<AtomicBlockType, N> data_;$/;"	m	class:folly::AtomicBitSet	access:private
data_	.\ConcurrentSkipList-inl.h	/^  value_type data_;$/;"	m	class:folly::detail::SkipListNode	access:private
data_	.\DiscriminatedPtr.h	/^  uintptr_t data_;$/;"	m	class:folly::DiscriminatedPtr	access:private
data_	.\MemoryMapping.h	/^  MutableByteRange data_;$/;"	m	class:folly::MemoryMapping	access:private
data_	.\PackedSyncPtr.h	/^  PicoSpinLock<uintptr_t> data_;$/;"	m	class:folly::PackedSyncPtr	access:public
data_	.\SmallLocks.h	/^  std::array<PaddedSpinLock, N> data_;$/;"	m	struct:folly::SpinLockArray	access:private
data_	.\experimental\symbolizer\Dwarf.h	/^    folly::StringPiece data_;$/;"	m	class:folly::symbolizer::Dwarf::LineNumberVM	access:private
data_	.\experimental\symbolizer\Dwarf.h	/^    folly::StringPiece data_;$/;"	m	class:folly::symbolizer::Dwarf::Section	access:private
data_	.\experimental\symbolizer\ElfCache.h	/^    char data_[kMaxSize + 1];$/;"	m	class:folly::symbolizer::SignalSafeElfCache::Path	access:private
data_	.\io\async\Request.h	/^  std::map<std::string, std::unique_ptr<RequestData>> data_;$/;"	m	class:folly::RequestContext	access:private
data_	.\io\test\CompressionTest.cpp	/^  std::unique_ptr<uint8_t[]> data_;$/;"	m	class:folly::io::test::DataHolder	file:	access:protected
data_	.\test\FileUtilTest.cpp	/^  StringPiece data_;$/;"	m	class:folly::test::__anon117::Reader	file:	access:private
data_	.\test\ThreadLocalTest.cpp	/^  uint64_t data_[kFillObjectSize];$/;"	m	class:__anon146::FillObject	file:	access:private
data_	.\test\stl_tests\StlVectorTest.cpp	/^  int* data_;$/;"	m	class:DataState	file:	access:private
datum_	.\Synchronized.h	/^  T datum_;$/;"	m	struct:folly::Synchronized	access:private
dd_	.\io\async\DelayedDestruction.h	/^    DelayedDestruction* dd_;$/;"	m	class:folly::DelayedDestruction::DestructorGuard	access:private
deactivate	.\wangle\Future.h	/^  void deactivate() {$/;"	f	class:folly::wangle::Future	access:public	signature:()
deactivate	.\wangle\detail\State.h	/^  void deactivate() {$/;"	f	class:folly::wangle::detail::State	access:public	signature:()
deallocate	.\Arena-inl.h	/^void Arena<Alloc>::Block::deallocate(Alloc& alloc) {$/;"	f	class:folly::Arena::Block	signature:(Alloc& alloc)
deallocate	.\Arena.h	/^    void deallocate(Alloc& alloc);$/;"	p	struct:folly::Arena::Block	access:public	signature:(Alloc& alloc)
deallocate	.\Arena.h	/^  void deallocate(void* p) {$/;"	f	class:folly::Arena	access:public	signature:(void* p)
deallocate	.\Memory.h	/^  void deallocate(T* p, size_t n) {$/;"	f	class:folly::StlAllocator	access:public	signature:(T* p, size_t n)
deallocate	.\Memory.h	/^  void deallocate(void* p) {$/;"	f	class:folly::SysAlloc	access:public	signature:(void* p)
deallocate	.\ThreadCachedArena.h	/^  void deallocate(void* p) {$/;"	f	class:folly::ThreadCachedArena	access:public	signature:(void* p)
deallocate	.\experimental\exception_tracer\StackTrace.cpp	/^  void deallocate();$/;"	p	class:folly::exception_tracer::StackTraceStack::Node	file:	access:public	signature:()
deallocate	.\experimental\exception_tracer\StackTrace.cpp	/^void StackTraceStack::Node::deallocate() {$/;"	f	class:folly::exception_tracer::StackTraceStack::Node	signature:()
deallocate	.\test\AtomicHashArrayTest.cpp	/^  void deallocate(T *p, size_t n) {$/;"	f	class:MmapAllocator	access:public	signature:(T *p, size_t n)
deallocate	.\test\stl_tests\StlVectorTest.cpp	/^  void deallocate(pointer p, size_type n) {$/;"	f	struct:Alloc	access:public	signature:(pointer p, size_type n)
debugString	.\stats\Histogram-defs.h	/^std::string Histogram<T>::debugString() const {$/;"	f	class:folly::Histogram	signature:() const
debugString	.\stats\Histogram.h	/^  std::string debugString() const;$/;"	p	class:folly::Histogram	access:public	signature:() const
decltype	.\gen\Base.h	/^  decltype(first < second) {$/;"	f	class:folly::gen::Less	access:public	signature:(first < second) { return first < second; } }; class Greater { public: template<class First, class Second> auto operator()(const First& first, const Second& second) const -> decltype(first > second)
decltype	.\gen\Core-inl.h	/^decltype(op.self().compose(gen.self())) {$/;"	f	namespace:folly::gen	signature:(op.self().compose(gen.self()))
decltype	.\gen\Core-inl.h	/^decltype(op.self().compose(std::move(gen.self()))) {$/;"	f	namespace:folly::gen	signature:(op.self().compose(std::move(gen.self())))
decode	.\GroupVarint.h	/^  static const char* decode(const char* p, uint32_t* a, uint32_t* b,$/;"	f	class:folly::GroupVarint	access:public	signature:(const char* p, uint32_t* a, uint32_t* b, uint32_t* c, uint32_t* d)
decode	.\GroupVarint.h	/^  static const char* decode(const char* p, uint32_t* dest) {$/;"	f	class:folly::GroupVarint	access:public	signature:(const char* p, uint32_t* dest)
decode	.\GroupVarint.h	/^  static const char* decode(const char* p, uint64_t* a, uint64_t* b,$/;"	f	class:folly::GroupVarint	access:public	signature:(const char* p, uint64_t* a, uint64_t* b, uint64_t* c, uint64_t* d, uint64_t* e)
decode	.\GroupVarint.h	/^  static const char* decode(const char* p, uint64_t* dest) {$/;"	f	class:folly::GroupVarint	access:public	signature:(const char* p, uint64_t* dest)
decodeUnicodeEscape	.\json.cpp	/^fbstring decodeUnicodeEscape(Input& in) {$/;"	f	namespace:folly::json::__anon75	signature:(Input& in)
decodeUtf8	.\json.cpp	/^char32_t decodeUtf8($/;"	f	namespace:folly::json::__anon75	signature:( const unsigned char*& p, const unsigned char* const e, bool skipOnError)
decodeVarint	.\Varint.h	/^inline uint64_t decodeVarint(ByteRange& data) {$/;"	f	namespace:folly	signature:(ByteRange& data)
decodeVarint	.\Varint.h	/^uint64_t decodeVarint(ByteRange& data);$/;"	p	namespace:folly	signature:(ByteRange& data)
decodeVarintFromCursor	.\io\Compression.cpp	/^uint64_t decodeVarintFromCursor(folly::io::Cursor& cursor) {$/;"	f	namespace:folly::io::__anon64::__anon65	signature:(folly::io::Cursor& cursor)
decodeZigZag	.\Varint.h	/^inline int64_t decodeZigZag(uint64_t val) {$/;"	f	namespace:folly	signature:(uint64_t val)
decode_simple	.\GroupVarint.h	/^  static const char* decode_simple(const char* p, uint32_t* a, uint32_t* b,$/;"	f	class:folly::GroupVarint	access:public	signature:(const char* p, uint32_t* a, uint32_t* b, uint32_t* c, uint32_t* d)
decode_simple	.\GroupVarint.h	/^  static const char* decode_simple(const char* p, uint32_t* dest) {$/;"	f	class:folly::GroupVarint	access:public	signature:(const char* p, uint32_t* dest)
decrOrPush	.\LifoSem.h	/^  WaitResult decrOrPush(uint32_t& n, uint32_t idx) {$/;"	f	struct:folly::detail::LifoSemBase	access:private	signature:(uint32_t& n, uint32_t idx)
decrease	.\test\ArenaSmartPtrTest.cpp	/^  void decrease() {$/;"	f	struct:global_counter	access:public	signature:()
decref	.\wangle\detail\State.h	/^  void decref() {$/;"	f	struct:folly::wangle::detail::WhenAnyContext	access:public	signature:()
decrement	.\Padded.h	/^  void decrement() {$/;"	f	namespace:folly::padded	access:private	signature:()
decrement	.\ThreadLocal.h	/^      void decrement() {$/;"	f	class:folly::ThreadLocalPtr::Accessor::Iterator	access:private	signature:()
decrementPending	.\experimental\io\AsyncIO.cpp	/^void AsyncIO::decrementPending() {$/;"	f	class:folly::AsyncIO	signature:()
decrementPending	.\experimental\io\AsyncIO.h	/^  void decrementPending();$/;"	p	class:folly::AsyncIO	access:private	signature:()
decrementRefcount	.\io\IOBuf.cpp	/^void IOBuf::decrementRefcount() {$/;"	f	class:folly::IOBuf	signature:()
decrementRefcount	.\io\IOBuf.h	/^  void decrementRefcount();$/;"	p	class:folly::IOBuf	access:private	signature:()
decrementToValid	.\ThreadLocal.h	/^      void decrementToValid() {$/;"	f	class:folly::ThreadLocalPtr::Accessor::Iterator	access:private	signature:()
defaultConfig	.\AtomicHashArray-inl.h	/^AtomicHashArray<KeyT, ValueT, HashFcn, EqualFcn, Allocator>::defaultConfig;$/;"	m	class:folly::AtomicHashArray
defaultConfig	.\AtomicHashArray.h	/^  static const Config defaultConfig;$/;"	m	class:folly::AtomicHashArray	access:public
defaultConfig	.\AtomicHashMap-inl.h	/^AtomicHashMap<KeyT, ValueT, HashFcn, EqualFcn, Allocator>::defaultConfig;$/;"	m	class:folly::AtomicHashMap
defaultConfig	.\AtomicHashMap.h	/^  static const Config defaultConfig;$/;"	m	class:folly::AtomicHashMap	access:public
defaultContext	.\io\async\Request.cpp	/^RequestContext* defaultContext;$/;"	m	namespace:folly	file:
defaultCtor	.\test\FBStringTestBenchmarks.cpp.h	/^void BENCHFUN(defaultCtor)(int iters, int) {$/;"	f	signature:(int iters, int)
defaultElfCache	.\experimental\symbolizer\Symbolizer.cpp	/^ElfCache* defaultElfCache() {$/;"	f	namespace:folly::symbolizer::__anon40	signature:()
defaultIdleTimeout	.\detail\MemoryIdler.h	/^  static AtomicStruct<std::chrono::steady_clock::duration> defaultIdleTimeout;$/;"	m	struct:folly::detail::MemoryIdler	access:public
defaultIsStmt_	.\experimental\symbolizer\Dwarf.h	/^    bool defaultIsStmt_;$/;"	m	class:folly::symbolizer::Dwarf::LineNumberVM	access:private
defaultNumLowerBits	.\experimental\EliasFanoCoding.h	/^  static uint8_t defaultNumLowerBits(size_t upperBound, size_t size) {$/;"	f	struct:folly::compression::EliasFanoEncoder	access:public	signature:(size_t upperBound, size_t size)
degenerateGetcpu	.\detail\CacheLocality.cpp	/^static int degenerateGetcpu(unsigned* cpu, unsigned* node, void* unused) {$/;"	f	namespace:folly::detail	signature:(unsigned* cpu, unsigned* node, void* unused)
deleteArrayBuffer	.\io\test\IOBufTest.cpp	/^void deleteArrayBuffer(void *buf, void* arg) {$/;"	f	signature:(void *buf, void* arg)
deleteValues_	.\test\ConcurrentSkipListBenchmark.cpp	/^  std::vector<ValueType> deleteValues_;$/;"	m	class:__anon113::ConcurrentAccessData	file:	access:private
deleter	.\detail\ThreadLocalDetail.h	/^  DeleterBase* deleter;$/;"	m	struct:folly::threadlocal_detail::ElementWrapper	access:public
deleter_	.\detail\ThreadLocalDetail.h	/^  Deleter deleter_;$/;"	m	class:folly::threadlocal_detail::CustomDeleter	access:private
deleter_	.\io\IOBuf.h	/^    Deleter deleter_;$/;"	m	struct:folly::IOBuf::UniquePtrDeleter	access:private
delimFront	.\String-inl.h	/^inline char delimFront(StringPiece s) {$/;"	f	namespace:folly::detail	signature:(StringPiece s)
delimFront	.\String-inl.h	/^inline char delimFront(char c) {$/;"	f	namespace:folly::detail	signature:(char c)
delimSize	.\String-inl.h	/^inline size_t delimSize(StringPiece s) { return s.size(); }$/;"	f	namespace:folly::detail	signature:(StringPiece s)
delimSize	.\String-inl.h	/^inline size_t delimSize(char)          { return 1; }$/;"	f	namespace:folly::detail	signature:(char)
delimiter_	.\Subprocess.h	/^    const char delimiter_;$/;"	m	class:folly::Subprocess::ReadLinesCallback	access:private
delimiter_	.\gen\String-inl.h	/^    char delimiter_;$/;"	m	class:folly::gen::detail::StringResplitter::Generator	access:private
delimiter_	.\gen\String-inl.h	/^  Delimiter delimiter_;$/;"	m	class:folly::gen::detail::SplitTo	access:private
delimiter_	.\gen\String-inl.h	/^  Delimiter delimiter_;$/;"	m	class:folly::gen::detail::Unsplit	access:private
delimiter_	.\gen\String-inl.h	/^  Delimiter delimiter_;$/;"	m	class:folly::gen::detail::UnsplitBuffer	access:private
delimiter_	.\gen\String-inl.h	/^  DelimiterType delimiter_;$/;"	m	class:folly::gen::detail::SplitStringSource	access:private
delimiter_	.\gen\String-inl.h	/^  char delimiter_;$/;"	m	class:folly::gen::detail::StringResplitter	access:private
delimiter_	.\gen\String.h	/^  char delimiter_;$/;"	m	class:folly::gen::StreamSplitter	access:private
delims16	.\test\RangeFindBenchmark.cpp	/^const string delims16 = "0123456789bcdefg";$/;"	v
delims2	.\test\RangeFindBenchmark.cpp	/^const string delims2 = "bc";$/;"	v
delims32	.\test\RangeFindBenchmark.cpp	/^const string delims32 = "!bcdefghijklmnopqrstuvwxyz_012345";$/;"	v
delims4	.\test\RangeFindBenchmark.cpp	/^const string delims4 = "bcde";$/;"	v
delims64	.\test\RangeFindBenchmark.cpp	/^const string delims64 = "!bcdefghijklmnopqrstuvwxyz_"$/;"	v
delims8	.\test\RangeFindBenchmark.cpp	/^const string delims8 = "0123456b";$/;"	v
demangle	.\Demangle.cpp	/^fbstring demangle(const char* name) {$/;"	f	namespace:folly	signature:(const char* name)
demangle	.\Demangle.cpp	/^size_t demangle(const char* name, char* out, size_t outSize) {$/;"	f	namespace:folly	signature:(const char* name, char* out, size_t outSize)
demangle	.\Demangle.h	/^fbstring demangle(const char* name);$/;"	p	namespace:folly	signature:(const char* name)
demangle	.\Demangle.h	/^inline fbstring demangle(const std::type_info& type) {$/;"	f	namespace:folly	signature:(const std::type_info& type)
demangle	.\Demangle.h	/^inline size_t demangle(const std::type_info& type, char* buf, size_t bufSize) {$/;"	f	namespace:folly	signature:(const std::type_info& type, char* buf, size_t bufSize)
demangle	.\Demangle.h	/^size_t demangle(const char* name, char* buf, size_t bufSize);$/;"	p	namespace:folly	signature:(const char* name, char* buf, size_t bufSize)
demangleCallback	.\Demangle.cpp	/^void demangleCallback(const char* str, size_t size, void* p) {$/;"	f	namespace:folly::__anon10	signature:(const char* str, size_t size, void* p)
demangledName	.\experimental\symbolizer\Symbolizer.h	/^  fbstring demangledName() const {$/;"	f	struct:folly::symbolizer::SymbolizedFrame	access:public	signature:() const
dense_	.\Range.cpp	/^  uint8_t dense_[256];$/;"	m	class:folly::__anon83::FastByteSet	file:	access:private
density	.\Benchmark.cpp	/^static double density(const double * begin, const double *const end,$/;"	f	namespace:folly	signature:(const double * begin, const double *const end, const double where, const double bandwidth)
deque	.\Traits.h	/^  class deque;$/;"	x
deque	.\Traits.h	/^FOLLY_ASSUME_FBVECTOR_COMPATIBLE_2(std::deque);$/;"	v
derefToCache	.\DynamicConverter.h	/^  derefToCache(T* mem, const dynamic::const_item_iterator& it) {$/;"	f	struct:folly::dynamicconverter_detail::Dereferencer	access:public	signature:(T* mem, const dynamic::const_item_iterator& it)
derefToCache	.\DynamicConverter.h	/^  derefToCache(std::pair<F, S>* mem, const dynamic::const_item_iterator& it) {$/;"	f	struct:folly::dynamicconverter_detail::Dereferencer	access:public	signature:(std::pair<F, S>* mem, const dynamic::const_item_iterator& it)
derefToCache	.\DynamicConverter.h	/^  static inline void derefToCache(T* mem, const dynamic::const_iterator& it) {$/;"	f	struct:folly::dynamicconverter_detail::Dereferencer	access:public	signature:(T* mem, const dynamic::const_iterator& it)
dereference	.\AtomicHashArray-inl.h	/^  IterVal& dereference() const {$/;"	f	struct:folly::AtomicHashArray::aha_iterator	access:private	signature:() const
dereference	.\AtomicHashMap-inl.h	/^  IterVal& dereference() const {$/;"	f	struct:folly::AtomicHashMap::ahm_iterator	access:private	signature:() const
dereference	.\ConcurrentSkipList.h	/^  value_type& dereference() const { return node_->data(); }$/;"	f	class:folly::detail::csl_iterator	access:private	signature:() const
dereference	.\DynamicConverter.h	/^  ttype& dereference() const {$/;"	f	class:folly::dynamicconverter_detail::Transformer	access:private	signature:() const
dereference	.\EvictingCacheMap.h	/^    Value& dereference() const {$/;"	f	class:folly::EvictingCacheMap::iterator_base	access:public	signature:() const
dereference	.\Padded.h	/^  typename Super::reference dereference() const {$/;"	f	namespace:folly::padded	access:private	signature:() const
dereference	.\ThreadLocal.h	/^      T& dereference() const {$/;"	f	class:folly::ThreadLocalPtr::Accessor::Iterator	access:private	signature:() const
dereference	.\dynamic-inl.h	/^  dynamic const& dereference() const {$/;"	f	struct:folly::dynamic::const_key_iterator	access:private	signature:() const
dereference	.\dynamic-inl.h	/^  dynamic const& dereference() const {$/;"	f	struct:folly::dynamic::const_value_iterator	access:private	signature:() const
dereference	.\gen\Base-inl.h	/^static const detail::Dereference dereference;$/;"	m	namespace:folly::gen
dereference	.\io\IOBuf.h	/^  const ByteRange& dereference() const {$/;"	f	class:folly::IOBuf::Iterator	access:private	signature:() const
dereference	.\io\RecordIO-inl.h	/^  reference dereference() const { return recordAndPos_; }$/;"	f	class:folly::RecordIOReader::Iterator	access:private	signature:() const
dereference	.\test\stl_tests\StlVectorTest.cpp	/^  typename iterator_traits<It>::value_type& dereference() const {$/;"	f	class:Transformer	access:public	signature:() const
dereferenced	.\test\stl_tests\StlVectorTest.cpp	/^  shared_ptr<set<It>> dereferenced;$/;"	m	class:Transformer	file:	access:private
describe	.\SocketAddress.cpp	/^std::string SocketAddress::describe() const {$/;"	f	class:folly::SocketAddress	signature:() const
describe	.\SocketAddress.h	/^  std::string describe() const;$/;"	p	class:folly::SocketAddress	access:public	signature:() const
describe	.\experimental\wangle\ManagedConnection.h	/^  virtual void describe(std::ostream& os) const = 0;$/;"	p	class:folly::wangle::ManagedConnection	access:public	signature:(std::ostream& os) const
dest	.\Demangle.cpp	/^  char* dest;$/;"	m	struct:folly::__anon10::DemangleBuf	file:	access:public
destroy	.\AtomicHashArray-inl.h	/^destroy(AtomicHashArray* p) {$/;"	f	class:folly::AtomicHashArray	signature:(AtomicHashArray* p)
destroy	.\AtomicHashArray.h	/^  static void destroy(AtomicHashArray*);$/;"	p	class:folly::AtomicHashArray	access:public	signature:(AtomicHashArray*)
destroy	.\ConcurrentSkipList-inl.h	/^  static void destroy(NodeAlloc& alloc, SkipListNode* node) {$/;"	f	class:folly::detail::SkipListNode	access:public	signature:(NodeAlloc& alloc, SkipListNode* node)
destroy	.\FBVector.h	/^      std::allocator_traits<Allocator>::destroy(impl_, p);$/;"	p	class:folly::__anon50::std::allocator_traits	access:private	signature:(impl_, p)
destroy	.\LifoSem.h	/^  void destroy() {$/;"	f	struct:folly::detail::LifoSemNode	access:public	signature:()
destroy	.\Memory.h	/^  void destroy(T* p) {$/;"	f	class:folly::StlAllocator	access:public	signature:(T* p)
destroy	.\ThreadLocal.h	/^  void destroy() {$/;"	f	class:folly::ThreadLocalPtr	access:private	signature:()
destroy	.\detail\ThreadLocalDetail.h	/^  static void destroy(size_t id) {$/;"	f	struct:folly::threadlocal_detail::StaticMeta	access:public	signature:(size_t id)
destroy	.\dynamic-inl.h	/^    template<class T> static void destroy(T* t) { t->~T(); }$/;"	f	struct:folly::detail::Destroy	access:public	signature:(T* t)
destroy	.\dynamic-inl.h	/^inline void dynamic::destroy() {$/;"	f	class:folly::dynamic	signature:()
destroy	.\dynamic.h	/^  void destroy();$/;"	p	struct:folly::dynamic	access:private	signature:()
destroy	.\experimental\symbolizer\Elf.cpp	/^void ElfFile::destroy() {$/;"	f	class:folly::symbolizer::ElfFile	signature:()
destroy	.\experimental\symbolizer\Elf.h	/^  void destroy();$/;"	p	class:folly::symbolizer::ElfFile	access:private	signature:()
destroy	.\io\IOBuf.h	/^  static void destroy(std::unique_ptr<IOBuf>&& data) {$/;"	f	class:folly::IOBuf	access:public	signature:(std::unique_ptr<IOBuf>&& data)
destroy	.\io\async\DelayedDestruction.h	/^  virtual void destroy() {$/;"	f	class:folly::DelayedDestruction	access:public	signature:()
destroy	.\io\async\HHWheelTimer.cpp	/^void HHWheelTimer::destroy() {$/;"	f	class:folly::HHWheelTimer	signature:()
destroy	.\io\async\HHWheelTimer.h	/^  virtual void destroy();$/;"	p	class:folly::HHWheelTimer	access:public	signature:()
destroy	.\test\AtomicHashArrayTest.cpp	/^  void destroy(T* p) {$/;"	f	class:MmapAllocator	access:public	signature:(T* p)
destroy	.\test\stl_tests\StlVectorTest.cpp	/^  void destroy(U* p) {$/;"	f	struct:Alloc	access:public	signature:(U* p)
destroyInstances	.\experimental\Singleton.cpp	/^void SingletonVault::destroyInstances() {$/;"	f	class:folly::SingletonVault	signature:()
destroyInstances	.\experimental\Singleton.h	/^  void destroyInstances();$/;"	p	class:folly::SingletonVault	access:public	signature:()
destroyIsNoOp	.\ConcurrentSkipList-inl.h	/^  static constexpr bool destroyIsNoOp() {$/;"	f	class:folly::detail::SkipListNode	access:public	signature:()
destroyNow	.\io\async\DelayedDestruction.h	/^  virtual void destroyNow(bool delayed) {$/;"	f	class:folly::DelayedDestruction	access:protected	signature:(bool delayed)
destroyPending_	.\io\async\DelayedDestruction.h	/^  bool destroyPending_;$/;"	m	class:folly::DelayedDestruction	access:private
destroyedFlagPtr_	.\io\async\NotificationQueue.h	/^    bool* destroyedFlagPtr_;$/;"	m	class:folly::NotificationQueue::Consumer	access:private
destructorCount	.\io\test\IOBufTest.cpp	/^int destructorCount = 0;$/;"	m	namespace:__anon71	file:
detach	.\wangle\Future-inl.h	/^void Future<T>::detach() {$/;"	f	class:folly::wangle::Future	signature:()
detach	.\wangle\Future.h	/^  void detach();$/;"	p	class:folly::wangle::Future	access:private	signature:()
detach	.\wangle\Promise-inl.h	/^void Promise<T>::detach() {$/;"	f	class:folly::wangle::Promise	signature:()
detach	.\wangle\Promise.h	/^  void detach();$/;"	p	class:folly::wangle::Promise	access:private	signature:()
detachEventBase	.\io\async\AsyncTimeout.cpp	/^void AsyncTimeout::detachEventBase() {$/;"	f	class:folly::AsyncTimeout	signature:()
detachEventBase	.\io\async\AsyncTimeout.h	/^  void detachEventBase();$/;"	p	class:folly::AsyncTimeout	access:public	signature:()
detachEventBase	.\io\async\EventHandler.cpp	/^void EventHandler::detachEventBase() {$/;"	f	class:folly::EventHandler	signature:()
detachEventBase	.\io\async\EventHandler.h	/^  void detachEventBase();$/;"	p	class:folly::EventHandler	access:public	signature:()
detachFuture	.\wangle\detail\State.h	/^  void detachFuture() {$/;"	f	class:folly::wangle::detail::State	access:public	signature:()
detachOne	.\wangle\detail\State.h	/^  void detachOne() {$/;"	f	class:folly::wangle::detail::State	access:private	signature:()
detachPromise	.\wangle\detail\State.h	/^  void detachPromise() {$/;"	f	class:folly::wangle::detail::State	access:public	signature:()
detachTimeoutManager	.\io\async\AsyncTimeout.cpp	/^void AsyncTimeout::detachTimeoutManager() {$/;"	f	class:folly::AsyncTimeout	signature:()
detachTimeoutManager	.\io\async\AsyncTimeout.h	/^  void detachTimeoutManager();$/;"	p	class:folly::AsyncTimeout	access:public	signature:()
detachTimeoutManager	.\io\async\EventBase.cpp	/^void EventBase::detachTimeoutManager(AsyncTimeout* obj) {$/;"	f	class:folly::EventBase	signature:(AsyncTimeout* obj)
detachTimeoutManager	.\io\async\EventBase.h	/^  void detachTimeoutManager(AsyncTimeout* obj);$/;"	p	class:folly::EventBase	access:private	signature:(AsyncTimeout* obj)
detachTimeoutManager	.\io\async\TimeoutManager.h	/^  virtual void detachTimeoutManager(AsyncTimeout* obj) = 0;$/;"	p	class:folly::TimeoutManager	access:public	signature:(AsyncTimeout* obj)
detached_	.\wangle\detail\State.h	/^  unsigned char detached_ = 0;$/;"	m	class:folly::wangle::detail::State	access:private
detail	.\ApplyTuple.h	/^namespace detail {$/;"	n	namespace:folly
detail	.\AtomicStruct.h	/^namespace detail {$/;"	n	namespace:folly
detail	.\Benchmark.h	/^namespace detail {$/;"	n	namespace:folly
detail	.\Bits.cpp	/^namespace detail {$/;"	n	namespace:folly	file:
detail	.\Checksum.cpp	/^namespace detail {$/;"	n	namespace:folly	file:
detail	.\ConcurrentSkipList-inl.h	/^namespace folly { namespace detail {$/;"	n	namespace:folly
detail	.\Conv.cpp	/^namespace detail {$/;"	n	namespace:folly	file:
detail	.\Conv.h	/^namespace detail {$/;"	n	namespace:folly
detail	.\Fingerprint.h	/^namespace detail {$/;"	n	namespace:folly
detail	.\Foreach.h	/^namespace folly { namespace detail {$/;"	n	namespace:folly
detail	.\Format-inl.h	/^namespace detail {$/;"	n	namespace:folly
detail	.\Format.cpp	/^namespace detail {$/;"	n	namespace:folly	file:
detail	.\Format.h	/^namespace detail {$/;"	n	namespace:folly
detail	.\GroupVarint.h	/^namespace detail {$/;"	n	namespace:folly
detail	.\IndexedMemPool.h	/^namespace detail {$/;"	n	namespace:folly
detail	.\IndexedMemPool.h	/^namespace detail {$/;"	n
detail	.\Lazy.h	/^namespace detail {$/;"	n	namespace:folly
detail	.\LifoSem.h	/^namespace detail {$/;"	n	namespace:folly
detail	.\MPMCQueue.h	/^namespace detail {$/;"	n	namespace:folly
detail	.\Optional.h	/^namespace detail { struct NoneHelper {}; }$/;"	n	namespace:folly
detail	.\Padded.h	/^namespace detail {$/;"	n	namespace:folly::padded
detail	.\RWSpinLock.h	/^namespace detail {$/;"	n	namespace:folly
detail	.\Random-inl.h	/^namespace detail {$/;"	n	namespace:folly
detail	.\Range.cpp	/^namespace detail {$/;"	n	namespace:folly	file:
detail	.\Range.h	/^namespace detail {$/;"	n	namespace:folly
detail	.\SafeAssert.cpp	/^namespace folly { namespace detail {$/;"	n	namespace:folly	file:
detail	.\SafeAssert.h	/^namespace folly { namespace detail {$/;"	n	namespace:folly
detail	.\ScopeGuard.h	/^namespace detail {$/;"	n	namespace:folly
detail	.\SmallLocks.h	/^namespace detail {$/;"	n	namespace:folly
detail	.\String-inl.h	/^namespace detail {$/;"	n	namespace:folly
detail	.\String.cpp	/^namespace detail {$/;"	n	namespace:folly	file:
detail	.\Synchronized.h	/^namespace detail {$/;"	n	namespace:folly
detail	.\Traits.h	/^namespace detail {$/;"	n	namespace:folly
detail	.\Version.cpp	/^namespace folly { namespace detail {$/;"	n	namespace:folly	file:
detail	.\detail\BitsDetail.h	/^namespace detail {$/;"	n	namespace:folly
detail	.\detail\CacheLocality.cpp	/^namespace folly { namespace detail {$/;"	n	namespace:folly	file:
detail	.\detail\CacheLocality.h	/^namespace folly { namespace detail {$/;"	n	namespace:folly
detail	.\detail\ChecksumDetail.h	/^namespace folly { namespace detail {$/;"	n	namespace:folly
detail	.\detail\ExceptionWrapper.h	/^namespace folly { namespace detail {$/;"	n	namespace:folly
detail	.\detail\FingerprintPolynomial.h	/^namespace detail {$/;"	n	namespace:folly
detail	.\detail\Futex.cpp	/^namespace folly { namespace detail {$/;"	n	namespace:folly	file:
detail	.\detail\Futex.h	/^namespace folly { namespace detail {$/;"	n	namespace:folly
detail	.\detail\GroupVarintDetail.h	/^namespace detail {$/;"	n	namespace:folly
detail	.\detail\IPAddress.h	/^namespace folly { namespace detail {$/;"	n	namespace:folly
detail	.\detail\MPMCPipelineDetail.h	/^namespace detail {$/;"	n	namespace:folly
detail	.\detail\MemoryIdler.cpp	/^namespace folly { namespace detail {$/;"	n	namespace:folly	file:
detail	.\detail\MemoryIdler.h	/^namespace folly { namespace detail {$/;"	n	namespace:folly
detail	.\detail\SlowFingerprint.h	/^namespace detail {$/;"	n	namespace:folly
detail	.\detail\Stats.h	/^namespace folly { namespace detail {$/;"	n	namespace:folly
detail	.\detail\UncaughtExceptionCounter.h	/^namespace folly { namespace detail {$/;"	n	namespace:folly
detail	.\dynamic-inl.h	/^namespace detail {$/;"	n	namespace:folly
detail	.\experimental\Bits.h	/^namespace detail {$/;"	n	namespace:folly
detail	.\experimental\EliasFanoCoding.h	/^namespace detail {$/;"	n	namespace:folly::compression
detail	.\experimental\EventCount.h	/^namespace detail {$/;"	n	namespace:folly
detail	.\experimental\Singleton.h	/^namespace detail {$/;"	n	namespace:folly
detail	.\experimental\symbolizer\Symbolizer.h	/^namespace detail {$/;"	n	namespace:folly::symbolizer
detail	.\gen\Base-inl.h	/^namespace detail {$/;"	n	namespace:folly::gen
detail	.\gen\Base.h	/^namespace detail {$/;"	n	namespace:folly::gen
detail	.\gen\Combine-inl.h	/^namespace detail {$/;"	n	namespace:folly::gen
detail	.\gen\Combine.h	/^namespace detail {$/;"	n	namespace:folly::gen
detail	.\gen\Core-inl.h	/^namespace detail {$/;"	n	namespace:folly::gen
detail	.\gen\Core.h	/^namespace detail {$/;"	n	namespace:folly::gen
detail	.\gen\File-inl.h	/^namespace detail {$/;"	n	namespace:folly::gen
detail	.\gen\File.h	/^namespace detail {$/;"	n	namespace:folly::gen
detail	.\gen\Parallel-inl.h	/^namespace detail {$/;"	n	namespace:folly::gen
detail	.\gen\Parallel.h	/^namespace detail {$/;"	n	namespace:folly::gen
detail	.\gen\ParallelMap-inl.h	/^namespace folly { namespace gen { namespace detail {$/;"	n	namespace:folly::gen
detail	.\gen\ParallelMap.h	/^namespace detail {$/;"	n	namespace:folly::gen
detail	.\gen\String-inl.h	/^namespace detail {$/;"	n	namespace:folly::gen
detail	.\gen\String.h	/^namespace detail {$/;"	n	namespace:folly::gen
detail	.\io\Cursor.h	/^namespace detail {$/;"	n	namespace:folly::io
detail	.\io\IOBuf.h	/^namespace detail {$/;"	n	namespace:folly
detail	.\io\RecordIO-inl.h	/^namespace detail {$/;"	n	namespace:folly::recordio_helpers
detail	.\small_vector.h	/^namespace detail {$/;"	n	namespace:folly
detail	.\sorted_vector_types.h	/^namespace detail {$/;"	n	namespace:folly
detail	.\stats\Histogram-defs.h	/^namespace detail {$/;"	n	namespace:folly
detail	.\stats\Histogram.h	/^namespace detail {$/;"	n	namespace:folly
detail	.\test\DeterministicSchedule.cpp	/^namespace folly { namespace detail {$/;"	n	namespace:folly	file:
detail	.\test\MemoryIdlerTest.cpp	/^namespace folly { namespace detail {$/;"	n	namespace:folly	file:
detail	.\test\RangeFindBenchmark.cpp	/^namespace folly { namespace detail {$/;"	n	namespace:folly	file:
detail	.\test\RangeTest.cpp	/^namespace folly { namespace detail {$/;"	n	namespace:folly	file:
detail	.\wangle\detail\State.h	/^namespace folly { namespace wangle { namespace detail {$/;"	n	namespace:folly::wangle
detail::IndexedMemPoolRecycler	.\IndexedMemPool.h	/^struct IndexedMemPoolRecycler {$/;"	s	namespace:detail
detail::IndexedMemPoolRecycler::IndexedMemPoolRecycler	.\IndexedMemPool.h	/^  explicit IndexedMemPoolRecycler(Pool* pool) : pool(pool) {}$/;"	f	struct:detail::IndexedMemPoolRecycler	access:public	signature:(Pool* pool)
detail::IndexedMemPoolRecycler::operator ()	.\IndexedMemPool.h	/^  void operator()(typename Pool::value_type* elem) const {$/;"	f	struct:detail::IndexedMemPoolRecycler	access:public	signature:(typename Pool::value_type* elem) const
detail::IndexedMemPoolRecycler::pool	.\IndexedMemPool.h	/^  Pool* pool;$/;"	m	struct:detail::IndexedMemPoolRecycler	access:public
detail::IndexedMemPoolRecycler::rhs	.\IndexedMemPool.h	/^  IndexedMemPoolRecycler& operator= (const IndexedMemPoolRecycler<Pool>& rhs)$/;"	m	struct:detail::IndexedMemPoolRecycler	access:public
detail::IndexedMemPoolRecycler::rhs	.\IndexedMemPool.h	/^  IndexedMemPoolRecycler(const IndexedMemPoolRecycler<Pool>& rhs)$/;"	m	struct:detail::IndexedMemPoolRecycler	access:public
deterministicAtomicWaitUntilTests	.\test\FutexTest.cpp	/^void deterministicAtomicWaitUntilTests() {$/;"	f	signature:()
device	.\experimental\io\HugePages.h	/^  dev_t device = 0;$/;"	m	struct:folly::HugePageSize	access:public
diff	.\test\FutexTest.cpp	/^uint64_t diff(uint64_t a, uint64_t b) {$/;"	f	signature:(uint64_t a, uint64_t b)
difference_type	.\AtomicHashArray.h	/^  typedef std::ptrdiff_t      difference_type;$/;"	t	class:folly::AtomicHashArray	access:public
difference_type	.\AtomicHashMap.h	/^  typedef std::ptrdiff_t      difference_type;$/;"	t	class:folly::AtomicHashMap	access:public
difference_type	.\ConcurrentSkipList.h	/^  typedef ptrdiff_t difference_type;$/;"	t	class:folly::ConcurrentSkipList::Skipper	access:public
difference_type	.\ConcurrentSkipList.h	/^  typedef ptrdiff_t difference_type;$/;"	t	class:folly::detail::csl_iterator	access:public
difference_type	.\FBVector.h	/^  typedef typename std::make_signed<size_type>::type  difference_type;$/;"	t	class:folly::fbvector	access:public
difference_type	.\Memory.h	/^  typedef ptrdiff_t difference_type;$/;"	t	class:folly::StlAllocator	access:public
difference_type	.\Padded.h	/^  typedef typename const_iterator::difference_type difference_type;$/;"	t	class:folly::Adaptor	access:public
difference_type	.\small_vector.h	/^  typedef std::ptrdiff_t     difference_type;$/;"	t	class:folly::small_vector	access:public
difference_type	.\sorted_vector_types.h	/^  typedef typename ContainerT::difference_type        difference_type;$/;"	t	class:folly::sorted_vector_map	access:public
difference_type	.\sorted_vector_types.h	/^  typedef typename ContainerT::difference_type        difference_type;$/;"	t	class:folly::sorted_vector_set	access:public
difference_type	.\test\AtomicHashArrayTest.cpp	/^  typedef ptrdiff_t difference_type;$/;"	t	class:MmapAllocator	file:	access:public
digit1	.\Conv.cpp	/^extern const char digit1[101] =$/;"	m	namespace:folly::detail	file:
digit2	.\Conv.cpp	/^extern const char digit2[101] =$/;"	m	namespace:folly::detail	file:
digits10	.\Conv.h	/^inline uint32_t digits10(uint64_t v) {$/;"	f	namespace:folly	signature:(uint64_t v)
digitsEnough	.\Conv.h	/^digitsEnough() {$/;"	f	namespace:folly::detail	signature:()
direction	.\Subprocess.h	/^    int direction = PIPE_IN;  \/\/ one of PIPE_IN \/ PIPE_OUT$/;"	m	struct:folly::Subprocess::PipeInfo	access:public
directoryIndex	.\experimental\symbolizer\Dwarf.h	/^      uint64_t directoryIndex;$/;"	m	struct:folly::symbolizer::Dwarf::LineNumberVM::FileName	access:public
dirty_	.\ConcurrentSkipList-inl.h	/^  std::atomic<bool> dirty_; \/\/ whether *nodes_ is non-empty$/;"	m	class:folly::detail::NodeRecycler	access:private
discardRead	.\Subprocess.cpp	/^bool discardRead(int fd) {$/;"	f	namespace:folly::__anon99	signature:(int fd)
discriminator_	.\experimental\symbolizer\Dwarf.h	/^    uint64_t discriminator_;$/;"	m	class:folly::symbolizer::Dwarf::LineNumberVM	access:private
dismiss	.\Benchmark.h	/^  void dismiss() {$/;"	f	struct:folly::BenchmarkSuspender	access:public	signature:()
dismissed_	.\ScopeGuard.h	/^  bool dismissed_;$/;"	m	class:folly::ScopeGuardImplBase	access:protected
dispose	.\detail\ThreadLocalDetail.h	/^  virtual void dispose(void* ptr, TLPDestructionMode mode) const = 0;$/;"	p	class:folly::threadlocal_detail::DeleterBase	access:public	signature:(void* ptr, TLPDestructionMode mode) const
dispose	.\detail\ThreadLocalDetail.h	/^  virtual void dispose(void* ptr, TLPDestructionMode mode) const {$/;"	f	class:folly::threadlocal_detail::CustomDeleter	access:public	signature:(void* ptr, TLPDestructionMode mode) const
dispose	.\detail\ThreadLocalDetail.h	/^  virtual void dispose(void* ptr, TLPDestructionMode mode) const {$/;"	f	class:folly::threadlocal_detail::SimpleDeleter	access:public	signature:(void* ptr, TLPDestructionMode mode) const
dispose	.\detail\ThreadLocalDetail.h	/^  void dispose(TLPDestructionMode mode) {$/;"	f	struct:folly::threadlocal_detail::ElementWrapper	access:public	signature:(TLPDestructionMode mode)
dispose	.\io\IOBuf.h	/^    virtual void dispose(void* p) = 0;$/;"	p	struct:folly::IOBuf::DeleterBase	access:public	signature:(void* p)
dispose	.\io\IOBuf.h	/^    void dispose(void* p) {$/;"	f	struct:folly::IOBuf::UniquePtrDeleter	access:public	signature:(void* p)
distance_if_multipass	.\sorted_vector_types.h	/^  int distance_if_multipass(Iterator first, Iterator last) {$/;"	f	namespace:folly::detail	signature:(Iterator first, Iterator last)
distance_to	.\Bits.h	/^  ssize_t distance_to(const BitIterator& other) const {$/;"	f	signature:(const BitIterator& other) const
distance_to	.\Padded.h	/^  typename Super::difference_type distance_to(const Iterator& other) const {$/;"	f	namespace:folly::padded	access:private	signature:(const Iterator& other) const
distinct	.\gen\Base-inl.h	/^static const detail::Distinct<Identity> distinct;$/;"	m	namespace:folly::gen
distinctBy	.\gen\Base.h	/^Distinct distinctBy(Selector selector = Identity()) {$/;"	f	namespace:folly::gen	signature:(Selector selector = Identity())
doCompress	.\io\Compression.cpp	/^std::unique_ptr<IOBuf> LZ4Codec::doCompress(const IOBuf* data) {$/;"	f	class:folly::io::__anon64::LZ4Codec	signature:(const IOBuf* data)
doCompress	.\io\Compression.cpp	/^std::unique_ptr<IOBuf> LZMA2Codec::doCompress(const IOBuf* data) {$/;"	f	class:folly::io::__anon64::LZMA2Codec	signature:(const IOBuf* data)
doCompress	.\io\Compression.cpp	/^std::unique_ptr<IOBuf> NoCompressionCodec::doCompress($/;"	f	class:folly::io::__anon64::NoCompressionCodec	signature:( const IOBuf* data)
doCompress	.\io\Compression.cpp	/^std::unique_ptr<IOBuf> SnappyCodec::doCompress(const IOBuf* data) {$/;"	f	class:folly::io::__anon64::SnappyCodec	signature:(const IOBuf* data)
doCompress	.\io\Compression.cpp	/^std::unique_ptr<IOBuf> ZlibCodec::doCompress(const IOBuf* data) {$/;"	f	class:folly::io::__anon64::ZlibCodec	signature:(const IOBuf* data)
doCompress	.\io\Compression.h	/^  virtual std::unique_ptr<IOBuf> doCompress(const folly::IOBuf* data) = 0;$/;"	p	class:folly::io::Codec	access:private	signature:(const folly::IOBuf* data)
doConstruct	.\small_vector.h	/^  void doConstruct(size_type n, value_type const& val) {$/;"	f	class:folly::small_vector	access:private	signature:(size_type n, value_type const& val)
doFormat	.\Format-inl.h	/^  void doFormat(FormatArg& arg, FormatCallback& cb) const {$/;"	f	class:folly::FormatValue	access:public	signature:(FormatArg& arg, FormatCallback& cb) const
doFormat	.\Format.h	/^  void doFormat(size_t i, FormatArg& arg, Callback& cb) const {$/;"	f	signature:(size_t i, FormatArg& arg, Callback& cb) const
doFormatArg	.\Format.h	/^      static_cast<const Derived*>(this)->template doFormatArg<K>(arg, cb);$/;"	p	class:folly::BaseFormatter::std	access:private	signature:(arg, cb)
doFormatArg	.\test\FormatTest.cpp	/^  void doFormatArg(FormatArg& arg, Callback& cb) const {$/;"	f	class:TestExtendingFormatter	file:	access:private	signature:(FormatArg& arg, Callback& cb) const
doFormatFrom	.\Format.h	/^      doFormatFrom<K+1>(i, arg, cb);$/;"	p	class:folly::__anon53	access:private	signature:(i, arg, cb)
doFormatFrom	.\Format.h	/^  doFormatFrom(size_t i, FormatArg& arg, Callback& cb) const {$/;"	f	class:folly::BaseFormatter	access:private	signature:(size_t i, FormatArg& arg, Callback& cb) const
doInflate	.\io\Compression.cpp	/^  bool doInflate(lzma_stream* stream, IOBuf* head, size_t bufferLength);$/;"	p	class:folly::io::__anon64::FOLLY_FINAL	file:	access:private	signature:(lzma_stream* stream, IOBuf* head, size_t bufferLength)
doInflate	.\io\Compression.cpp	/^  bool doInflate(z_stream* stream, IOBuf* head, uint32_t bufferLength);$/;"	p	class:folly::io::__anon64::FOLLY_FINAL	file:	access:private	signature:(z_stream* stream, IOBuf* head, uint32_t bufferLength)
doInflate	.\io\Compression.cpp	/^bool LZMA2Codec::doInflate(lzma_stream* stream,$/;"	f	class:folly::io::__anon64::LZMA2Codec	signature:(lzma_stream* stream, IOBuf* head, size_t bufferLength)
doInflate	.\io\Compression.cpp	/^bool ZlibCodec::doInflate(z_stream* stream,$/;"	f	class:folly::io::__anon64::ZlibCodec	signature:(z_stream* stream, IOBuf* head, uint32_t bufferLength)
doLock	.\File.cpp	/^void File::doLock(int op) {$/;"	f	class:folly::File	signature:(int op)
doLock	.\File.h	/^  void doLock(int op);$/;"	p	class:folly::File	access:private	signature:(int op)
doMaxUncompressedLength	.\io\Compression.cpp	/^uint64_t Codec::doMaxUncompressedLength() const {$/;"	f	class:folly::io::Codec	signature:() const
doMaxUncompressedLength	.\io\Compression.cpp	/^uint64_t LZ4Codec::doMaxUncompressedLength() const {$/;"	f	class:folly::io::__anon64::LZ4Codec	signature:() const
doMaxUncompressedLength	.\io\Compression.cpp	/^uint64_t LZMA2Codec::doMaxUncompressedLength() const {$/;"	f	class:folly::io::__anon64::LZMA2Codec	signature:() const
doMaxUncompressedLength	.\io\Compression.cpp	/^uint64_t SnappyCodec::doMaxUncompressedLength() const {$/;"	f	class:folly::io::__anon64::SnappyCodec	signature:() const
doMaxUncompressedLength	.\io\Compression.h	/^  virtual uint64_t doMaxUncompressedLength() const;$/;"	p	class:folly::io::Codec	access:private	signature:() const
doNeedsUncompressedLength	.\io\Compression.cpp	/^bool Codec::doNeedsUncompressedLength() const {$/;"	f	class:folly::io::Codec	signature:() const
doNeedsUncompressedLength	.\io\Compression.cpp	/^bool LZ4Codec::doNeedsUncompressedLength() const {$/;"	f	class:folly::io::__anon64::LZ4Codec	signature:() const
doNeedsUncompressedLength	.\io\Compression.cpp	/^bool LZMA2Codec::doNeedsUncompressedLength() const {$/;"	f	class:folly::io::__anon64::LZMA2Codec	signature:() const
doNeedsUncompressedLength	.\io\Compression.h	/^  virtual bool doNeedsUncompressedLength() const;$/;"	p	class:folly::io::Codec	access:private	signature:() const
doNotOptimizeAway	.\Benchmark.h	/^void doNotOptimizeAway(T&& datum) {$/;"	f	namespace:folly	signature:(T&& datum)
doNothing	.\test\function_benchmark\test_functions.cpp	/^void TestClass::doNothing() {$/;"	f	class:TestClass	signature:()
doNothing	.\test\function_benchmark\test_functions.cpp	/^void VirtualClass::doNothing() {$/;"	f	class:VirtualClass	signature:()
doNothing	.\test\function_benchmark\test_functions.cpp	/^void doNothing() {$/;"	f	signature:()
doNothing	.\test\function_benchmark\test_functions.h	/^  virtual void doNothing();$/;"	p	class:VirtualClass	access:public	signature:()
doNothing	.\test\function_benchmark\test_functions.h	/^  void doNothing();$/;"	p	class:TestClass	access:public	signature:()
doNothing	.\test\function_benchmark\test_functions.h	/^void doNothing();$/;"	p	signature:()
doPrint	.\experimental\symbolizer\Symbolizer.cpp	/^void FDSymbolizePrinter::doPrint(StringPiece sp) {$/;"	f	class:folly::symbolizer::FDSymbolizePrinter	signature:(StringPiece sp)
doPrint	.\experimental\symbolizer\Symbolizer.cpp	/^void FILESymbolizePrinter::doPrint(StringPiece sp) {$/;"	f	class:folly::symbolizer::FILESymbolizePrinter	signature:(StringPiece sp)
doPrint	.\experimental\symbolizer\Symbolizer.cpp	/^void OStreamSymbolizePrinter::doPrint(StringPiece sp) {$/;"	f	class:folly::symbolizer::OStreamSymbolizePrinter	signature:(StringPiece sp)
doPrint	.\experimental\symbolizer\Symbolizer.cpp	/^void StringSymbolizePrinter::doPrint(StringPiece sp) {$/;"	f	class:folly::symbolizer::StringSymbolizePrinter	signature:(StringPiece sp)
doPrint	.\experimental\symbolizer\Symbolizer.h	/^  virtual void doPrint(StringPiece sp) = 0;$/;"	p	class:folly::symbolizer::SymbolizePrinter	access:private	signature:(StringPiece sp)
doPslTest	.\test\SmallLocksTest.cpp	/^void doPslTest() {$/;"	f	namespace:__anon131	signature:()
doSize	.\small_vector.h	/^    std::size_t doSize() const {$/;"	f	struct:folly::detail::IntegralSizePolicy	access:protected	signature:() const
doSplitKey	.\FormatArg.h	/^  StringPiece doSplitKey();$/;"	p	struct:folly::FormatArg	access:private	signature:()
doSplitKey	.\FormatArg.h	/^inline StringPiece FormatArg::doSplitKey() {$/;"	f	class:folly::FormatArg	signature:()
doTest	.\test\ProducerConsumerQueueTest.cpp	/^template<class TestType> void doTest(const char* name) {$/;"	f	namespace:__anon128	signature:(const char* name)
doTest	.\test\SmallLocksTest.cpp	/^  void doTest() {$/;"	f	struct:__anon131::PslTest	access:public	signature:()
doTestAll	.\experimental\test\EliasFanoCodingTest.cpp	/^  void doTestAll() {$/;"	f	class:EliasFanoCodingTest	access:public	signature:()
doTestEmpty	.\experimental\test\EliasFanoCodingTest.cpp	/^  void doTestEmpty() {$/;"	f	class:EliasFanoCodingTest	access:public	signature:()
doThrow	.\detail\ExceptionWrapper.h	/^  static void doThrow(std::exception* obj) {$/;"	f	class:folly::detail::Thrower	access:public	signature:(std::exception* obj)
doTryLock	.\File.cpp	/^bool File::doTryLock(int op) {$/;"	f	class:folly::File	signature:(int op)
doTryLock	.\File.h	/^  bool doTryLock(int op);$/;"	p	class:folly::File	access:private	signature:(int op)
doUncompress	.\io\Compression.cpp	/^std::unique_ptr<IOBuf> LZ4Codec::doUncompress($/;"	f	class:folly::io::__anon64::LZ4Codec	signature:( const IOBuf* data, uint64_t uncompressedLength)
doUncompress	.\io\Compression.cpp	/^std::unique_ptr<IOBuf> LZMA2Codec::doUncompress(const IOBuf* data,$/;"	f	class:folly::io::__anon64::LZMA2Codec	signature:(const IOBuf* data, uint64_t uncompressedLength)
doUncompress	.\io\Compression.cpp	/^std::unique_ptr<IOBuf> NoCompressionCodec::doUncompress($/;"	f	class:folly::io::__anon64::NoCompressionCodec	signature:( const IOBuf* data, uint64_t uncompressedLength)
doUncompress	.\io\Compression.cpp	/^std::unique_ptr<IOBuf> SnappyCodec::doUncompress(const IOBuf* data,$/;"	f	class:folly::io::__anon64::SnappyCodec	signature:(const IOBuf* data, uint64_t uncompressedLength)
doUncompress	.\io\Compression.cpp	/^std::unique_ptr<IOBuf> ZlibCodec::doUncompress(const IOBuf* data,$/;"	f	class:folly::io::__anon64::ZlibCodec	signature:(const IOBuf* data, uint64_t uncompressedLength)
doUncompress	.\io\Compression.h	/^  virtual std::unique_ptr<IOBuf> doUncompress(const folly::IOBuf* data,$/;"	p	class:folly::io::Codec	access:private	signature:(const folly::IOBuf* data, uint64_t uncompressedLength)
doWait	.\experimental\io\AsyncIO.cpp	/^Range<AsyncIO::Op**> AsyncIO::doWait(size_t minRequests, size_t maxRequests) {$/;"	f	class:folly::AsyncIO	signature:(size_t minRequests, size_t maxRequests)
doWait	.\experimental\io\AsyncIO.h	/^  Range<Op**> doWait(size_t minRequests, size_t maxRequests);$/;"	p	class:folly::AsyncIO	access:private	signature:(size_t minRequests, size_t maxRequests)
doWorkStatic	.\wangle\test\FutureTest.cpp	/^static string doWorkStatic(Try<string>&& t) {$/;"	f	file:	signature:(Try<string>&& t)
doWorkStatic	.\wangle\test\LaterTest.cpp	/^static Later<std::string> doWorkStatic(Try<std::string>&& t) {$/;"	f	file:	signature:(Try<std::string>&& t)
doWorkStaticFuture	.\wangle\test\FutureTest.cpp	/^static Future<string> doWorkStaticFuture(Try<string>&& t) {$/;"	f	file:	signature:(Try<string>&& t)
done	.\wangle\detail\State.h	/^  std::atomic<bool> done;$/;"	m	struct:folly::wangle::detail::WhenAnyContext	access:public
done	.\wangle\test\LaterTest.cpp	/^  bool done;$/;"	m	struct:LaterFixture	file:	access:public
done	.\wangle\test\ThreadGateTest.cpp	/^  bool done;$/;"	m	struct:GenericThreadGateFixture	file:	access:public
done_	.\test\ProducerConsumerQueueBenchmark.cpp	/^  std::atomic<bool> done_;$/;"	m	struct:__anon127::LatencyTest	file:	access:public
done_	.\test\ProducerConsumerQueueBenchmark.cpp	/^  std::atomic<bool> done_;$/;"	m	struct:__anon127::ThroughputTest	file:	access:public
done_	.\test\ProducerConsumerQueueTest.cpp	/^  std::atomic<bool> done_;$/;"	m	struct:__anon128::CorrectnessTest	file:	access:public
done_	.\test\ProducerConsumerQueueTest.cpp	/^  std::atomic<bool> done_;$/;"	m	struct:__anon128::PerfTest	file:	access:public
doubl	.\dynamic.h	/^    double doubl;$/;"	m	union:folly::dynamic::Data	access:public
double_mode	.\json.h	/^    double_conversion::DoubleToStringConverter::DtoaMode double_mode;$/;"	m	struct:folly::json::serialization_opts	access:public
double_num_digits	.\json.h	/^    unsigned int double_num_digits;$/;"	m	struct:folly::json::serialization_opts	access:public
down	.\experimental\test\EventCountTest.cpp	/^  void down() {$/;"	f	class:__anon46::Semaphore	access:public	signature:()
downTo	.\Foreach.h	/^downTo(T& iter, const U& begin) {$/;"	f	namespace:folly::detail	signature:(T& iter, const U& begin)
dptr_detail	.\detail\DiscriminatedPtrDetail.h	/^namespace dptr_detail {$/;"	n	namespace:folly
drainAllConnections	.\experimental\wangle\ConnectionManager.cpp	/^ConnectionManager::drainAllConnections() {$/;"	f	class:folly::wangle::ConnectionManager	signature:()
drainAllConnections	.\experimental\wangle\ConnectionManager.h	/^  void drainAllConnections();$/;"	p	class:folly::wangle::ConnectionManager	access:private	signature:()
dropAllConnections	.\experimental\wangle\ConnectionManager.cpp	/^ConnectionManager::dropAllConnections() {$/;"	f	class:folly::wangle::ConnectionManager	signature:()
dropAllConnections	.\experimental\wangle\ConnectionManager.h	/^  void dropAllConnections();$/;"	p	class:folly::wangle::ConnectionManager	access:public	signature:()
dropConnection	.\experimental\wangle\ManagedConnection.h	/^  virtual void dropConnection() = 0;$/;"	p	class:folly::wangle::ManagedConnection	access:public	signature:()
dumpConnectionState	.\experimental\wangle\ManagedConnection.h	/^  virtual void dumpConnectionState(uint8_t loglevel) = 0;$/;"	p	class:folly::wangle::ManagedConnection	access:public	signature:(uint8_t loglevel)
dumpExceptionStack	.\experimental\exception_tracer\ExceptionTracer.cpp	/^void dumpExceptionStack(const char* prefix) {$/;"	f	namespace:folly::exception_tracer::__anon24	signature:(const char* prefix)
dumpExceptions	.\experimental\exception_tracer\ExceptionTracerTest.cpp	/^void dumpExceptions(const char* prefix) {$/;"	f	signature:(const char* prefix)
dumpSignalInfo	.\experimental\symbolizer\SignalHandler.cpp	/^void dumpSignalInfo(int signum, siginfo_t* siginfo) {$/;"	f	namespace:folly::symbolizer::__anon36	signature:(int signum, siginfo_t* siginfo)
dumpStackTrace	.\experimental\symbolizer\SignalHandler.cpp	/^FOLLY_NOINLINE void dumpStackTrace(bool symbolize);$/;"	p	namespace:folly::symbolizer::__anon36	file:	signature:(bool symbolize)
dumpStackTrace	.\experimental\symbolizer\SignalHandler.cpp	/^void dumpStackTrace(bool symbolize) {$/;"	f	namespace:folly::symbolizer::__anon36	signature:(bool symbolize)
dumpTimeInfo	.\experimental\symbolizer\SignalHandler.cpp	/^void dumpTimeInfo() {$/;"	f	namespace:folly::symbolizer::__anon36	signature:()
dup	.\File.cpp	/^File File::dup() const {$/;"	f	class:folly::File	signature:() const
dup	.\File.h	/^  File dup() const;$/;"	p	class:folly::File	access:public	signature:() const
dup2NoInt	.\FileUtil.cpp	/^int dup2NoInt(int oldfd, int newfd) {$/;"	f	namespace:folly	signature:(int oldfd, int newfd)
dup2NoInt	.\FileUtil.h	/^int dup2NoInt(int oldfd, int newfd);$/;"	p	namespace:folly	signature:(int oldfd, int newfd)
dupNoInt	.\FileUtil.cpp	/^int dupNoInt(int fd) {$/;"	f	namespace:folly	signature:(int fd)
dupNoInt	.\FileUtil.h	/^int dupNoInt(int fd);$/;"	p	namespace:folly	signature:(int fd)
duration	.\stats\BucketedTimeSeries.h	/^  TimeType duration() const {$/;"	f	class:folly::BucketedTimeSeries	access:public	signature:() const
duration	.\test\MemoryIdlerTest.cpp	/^  typedef std::chrono::steady_clock::duration duration;$/;"	t	struct:MockClock	file:	access:public
duration	.\test\TimeseriesTest.cpp	/^  size_t duration;$/;"	m	struct:TestData	file:	access:public
duration_	.\stats\BucketedTimeSeries.h	/^  TimeType duration_;    \/\/ total duration ("window length") of the time series$/;"	m	class:folly::BucketedTimeSeries	access:private
dynamic	.\dynamic-inl.h	/^  friend struct dynamic;$/;"	x
dynamic	.\dynamic-inl.h	/^dynamic::dynamic(Iterator first, Iterator last)$/;"	f	class:folly::dynamic	signature:(Iterator first, Iterator last)
dynamic	.\dynamic-inl.h	/^dynamic::dynamic(T t) {$/;"	f	class:folly::dynamic	signature:(T t)
dynamic	.\dynamic-inl.h	/^inline dynamic::dynamic(ObjectMaker (*)())$/;"	f	class:folly::dynamic	signature:(ObjectMaker ()))
dynamic	.\dynamic-inl.h	/^inline dynamic::dynamic(ObjectMaker&& maker)$/;"	f	class:folly::dynamic	signature:(ObjectMaker&& maker)
dynamic	.\dynamic-inl.h	/^inline dynamic::dynamic(StringPiece s)$/;"	f	class:folly::dynamic	signature:(StringPiece s)
dynamic	.\dynamic-inl.h	/^inline dynamic::dynamic(char const* s)$/;"	f	class:folly::dynamic	signature:(char const* s)
dynamic	.\dynamic-inl.h	/^inline dynamic::dynamic(dynamic const& o)$/;"	f	class:folly::dynamic	signature:(dynamic const& o)
dynamic	.\dynamic-inl.h	/^inline dynamic::dynamic(dynamic&& o)$/;"	f	class:folly::dynamic	signature:(dynamic&& o)
dynamic	.\dynamic-inl.h	/^inline dynamic::dynamic(fbstring const& s)$/;"	f	class:folly::dynamic	signature:(fbstring const& s)
dynamic	.\dynamic-inl.h	/^inline dynamic::dynamic(fbstring&& s)$/;"	f	class:folly::dynamic	signature:(fbstring&& s)
dynamic	.\dynamic-inl.h	/^inline dynamic::dynamic(std::initializer_list<dynamic> il)$/;"	f	class:folly::dynamic	signature:(std::initializer_list<dynamic> il)
dynamic	.\dynamic-inl.h	/^inline dynamic::dynamic(std::string const& s)$/;"	f	class:folly::dynamic	signature:(std::string const& s)
dynamic	.\dynamic.h	/^  \/* implicit *\/ dynamic(ObjectMaker (*)());$/;"	p	struct:folly::dynamic	access:public	signature:(ObjectMaker ()))
dynamic	.\dynamic.h	/^  \/* implicit *\/ dynamic(ObjectMaker const&) = delete;$/;"	p	struct:folly::dynamic	access:public	signature:(ObjectMaker const&)
dynamic	.\dynamic.h	/^  \/* implicit *\/ dynamic(ObjectMaker&&);$/;"	p	struct:folly::dynamic	access:public	signature:(ObjectMaker&&)
dynamic	.\dynamic.h	/^  \/* implicit *\/ dynamic(StringPiece val);$/;"	p	struct:folly::dynamic	access:public	signature:(StringPiece val)
dynamic	.\dynamic.h	/^  \/* implicit *\/ dynamic(char const* val);$/;"	p	struct:folly::dynamic	access:public	signature:(char const* val)
dynamic	.\dynamic.h	/^  \/* implicit *\/ dynamic(fbstring const& val);$/;"	p	struct:folly::dynamic	access:public	signature:(fbstring const& val)
dynamic	.\dynamic.h	/^  \/* implicit *\/ dynamic(fbstring&& val);$/;"	p	struct:folly::dynamic	access:public	signature:(fbstring&& val)
dynamic	.\dynamic.h	/^  \/* implicit *\/ dynamic(std::initializer_list<dynamic> il);$/;"	p	struct:folly::dynamic	access:public	signature:(std::initializer_list<dynamic> il)
dynamic	.\dynamic.h	/^  \/* implicit *\/ dynamic(std::string const& val);$/;"	p	struct:folly::dynamic	access:public	signature:(std::string const& val)
dynamic	.\dynamic.h	/^  dynamic(dynamic const&);$/;"	p	struct:folly::dynamic	access:public	signature:(dynamic const&)
dynamic	.\dynamic.h	/^  dynamic(dynamic&&);$/;"	p	struct:folly::dynamic	access:public	signature:(dynamic&&)
dynamic	.\dynamic.h	/^  template<class Iterator> dynamic(Iterator first, Iterator last);$/;"	p	struct:folly::dynamic	access:public	signature:(Iterator first, Iterator last)
dynamic	.\dynamic.h	/^  template<class T> \/* implicit *\/ dynamic(T t);$/;"	p	struct:folly::dynamic	access:public	signature:(T t)
dynamic	.\dynamic.h	/^struct dynamic : private boost::operators<dynamic> {$/;"	s	namespace:folly	inherits:boost::operators
dynamic	.\dynamic.h	/^struct dynamic;$/;"	x
dynamicconverter_detail	.\DynamicConverter.h	/^namespace dynamicconverter_detail {$/;"	n	namespace:folly
e_	.\FBVector.h	/^        b_(other.b_), e_(other.e_), z_(other.z_)$/;"	p	struct:folly::fbvector::Impl	access:public	signature:(other.e_)
e_	.\FBVector.h	/^    pointer b_, e_, z_;$/;"	m	struct:folly::fbvector::Impl	access:public
e_	.\Range.h	/^  Iter b_, e_;$/;"	m	class:folly::Range	access:private
e_	.\ThreadLocal.h	/^      threadlocal_detail::ThreadEntry* e_;$/;"	m	class:folly::ThreadLocalPtr::Accessor::Iterator	access:private
e_	.\wangle\Try.h	/^    std::exception_ptr e_;$/;"	m	union:folly::wangle::Try::__anon154	access:public
e_	.\wangle\Try.h	/^  std::exception_ptr e_;$/;"	m	class:folly::wangle::Try	access:private
eachAs	.\gen\Base.h	/^Cast eachAs() {$/;"	f	namespace:folly::gen	signature:()
eachTo	.\gen\Base.h	/^To eachTo() {$/;"	f	namespace:folly::gen	signature:()
eachToPair	.\gen\String.h	/^eachToPair(StringPiece delim) {$/;"	f	namespace:folly::gen	signature:(StringPiece delim)
eachToPair	.\gen\String.h	/^eachToPair(char delim) {$/;"	f	namespace:folly::gen	signature:(char delim)
eachToTuple	.\gen\String.h	/^eachToTuple(StringPiece delim) {$/;"	f	namespace:folly::gen	signature:(StringPiece delim)
eachToTuple	.\gen\String.h	/^eachToTuple(char delim) {$/;"	f	namespace:folly::gen	signature:(char delim)
eastExecutor	.\wangle\GenericThreadGate.h	/^  EastExecutorPtr eastExecutor;$/;"	m	class:folly::wangle::GenericThreadGate	access:public
eastExecutor	.\wangle\test\LaterTest.cpp	/^  std::shared_ptr<ManualExecutor> eastExecutor;$/;"	m	struct:LaterFixture	file:	access:public
eastExecutor	.\wangle\test\ThreadGateTest.cpp	/^  shared_ptr<ManualExecutor> eastExecutor;$/;"	m	struct:GenericThreadGateFixture	file:	access:public
ec_	.\experimental\test\EventCountTest.cpp	/^  EventCount ec_;$/;"	m	class:__anon46::Semaphore	file:	access:private
eggs_t	.\wangle\test\FutureTest.cpp	/^typedef WangleException eggs_t;$/;"	t	file:
elapsed	.\stats\BucketedTimeSeries-defs.h	/^TT BucketedTimeSeries<VT, TT>::elapsed() const {$/;"	f	class:folly::BucketedTimeSeries	signature:() const
elapsed	.\stats\BucketedTimeSeries-defs.h	/^TT BucketedTimeSeries<VT, TT>::elapsed(TimeType start, TimeType end) const {$/;"	f	class:folly::BucketedTimeSeries	signature:(TimeType start, TimeType end) const
elapsed	.\stats\BucketedTimeSeries.h	/^  TimeType elapsed() const;$/;"	p	class:folly::BucketedTimeSeries	access:public	signature:() const
elapsed	.\stats\BucketedTimeSeries.h	/^  TimeType elapsed(TimeType start, TimeType end) const;$/;"	p	class:folly::BucketedTimeSeries	access:public	signature:(TimeType start, TimeType end) const
elem	.\IndexedMemPool.h	/^    T elem;$/;"	m	struct:folly::IndexedMemPool::Slot	access:public
elementCount_	.\io\test\IOBufTest.cpp	/^  int elementCount_;$/;"	m	class:MoveToFbStringTest	file:	access:protected
elementSize_	.\io\test\IOBufTest.cpp	/^  int elementSize_;$/;"	m	class:MoveToFbStringTest	file:	access:protected
element_type	.\wangle\Try.h	/^  typedef T element_type;$/;"	t	class:folly::wangle::Try	access:public
elements	.\detail\ThreadLocalDetail.h	/^  ElementWrapper* elements;$/;"	m	struct:folly::threadlocal_detail::ThreadEntry	access:public
elementsCapacity	.\detail\ThreadLocalDetail.h	/^  size_t elementsCapacity;$/;"	m	struct:folly::threadlocal_detail::ThreadEntry	access:public
elfFile_	.\experimental\symbolizer\test\ElfTests.cpp	/^  ElfFile elfFile_;$/;"	m	class:ElfTest	file:	access:protected
elfHeader	.\experimental\symbolizer\Elf.h	/^  const ElfW(Ehdr)& elfHeader() const {$/;"	f	class:folly::symbolizer::ElfFile	access:public	signature:() const
elf_	.\experimental\symbolizer\Dwarf.h	/^  const ElfFile* elf_;$/;"	m	class:folly::symbolizer::Dwarf	access:private
emplace	.\FBVector.h	/^  iterator emplace(const_iterator cpos, Args&&... args) {$/;"	f	signature:(const_iterator cpos, Args&&... args)
emplace	.\Optional.h	/^  void emplace(Args&&... args) {$/;"	f	class:folly::Optional	access:public	signature:(Args&&.... args)
emplace	.\small_vector.h	/^  iterator emplace(const_iterator p, Args&&... args) {$/;"	f	class:folly::small_vector	access:public	signature:(const_iterator p, Args&&... args)
emplaceBack	.\small_vector.h	/^  void emplaceBack(Args&&... args) {$/;"	f	class:folly::small_vector	access:private	signature:(Args&&.... args)
emplaceBack	.\small_vector.h	/^  void emplaceBack(value_type&& t) {$/;"	f	class:folly::small_vector	access:private	signature:(value_type&& t)
emplace_back	.\FBVector.h	/^  void emplace_back(Args&&... args)  {$/;"	f	signature:(Args&&.... args)
emplace_back	.\small_vector.h	/^  void emplace_back(Args&&... args) {$/;"	f	class:folly::small_vector	access:public	signature:(Args&&.... args)
emplace_back_aux	.\FBVector.h	/^  void emplace_back_aux(Args&&... args);$/;"	p	signature:(Args&&.... args)
empty	.\AtomicHashArray.h	/^  bool empty() const { return size() == 0; }$/;"	f	class:folly::AtomicHashArray	access:public	signature:() const
empty	.\AtomicHashMap.h	/^  bool empty() const { return size() == 0; }$/;"	f	class:folly::AtomicHashMap	access:public	signature:() const
empty	.\ConcurrentSkipList.h	/^  bool empty() const { return sl_->size() == 0; }$/;"	f	class:folly::ConcurrentSkipList::Accessor	access:public	signature:() const
empty	.\DiscriminatedPtr.h	/^  bool empty() const {$/;"	f	class:folly::DiscriminatedPtr	access:public	signature:() const
empty	.\EvictingCacheMap.h	/^  bool empty() const {$/;"	f	class:folly::EvictingCacheMap	access:public	signature:() const
empty	.\IPAddress.h	/^  bool empty() const { return (family_ == AF_UNSPEC); }$/;"	f	class:folly::IPAddress	access:public	signature:() const
empty	.\Padded.h	/^  bool empty() const {$/;"	f	class:folly::Adaptor	access:public	signature:() const
empty	.\Range.h	/^  bool empty() const { return b_ == e_; }$/;"	f	class:folly::Range	access:public	signature:() const
empty	.\SocketAddress.h	/^  bool empty() const {$/;"	f	class:folly::SocketAddress	access:public	signature:() const
empty	.\dynamic-inl.h	/^inline bool dynamic::empty() const {$/;"	f	class:folly::dynamic	signature:() const
empty	.\dynamic.h	/^  bool empty() const;$/;"	p	struct:folly::dynamic	access:public	signature:() const
empty	.\experimental\exception_tracer\StackTrace.h	/^  bool empty() const { return !top_; }$/;"	f	class:folly::exception_tracer::StackTraceStack	access:public	signature:() const
empty	.\gen\Base.h	/^detail::Empty<Value> empty() {$/;"	f	namespace:folly::gen	signature:()
empty	.\io\IOBuf.cpp	/^bool IOBuf::empty() const {$/;"	f	class:folly::IOBuf	signature:() const
empty	.\io\IOBuf.h	/^  bool empty() const;$/;"	p	class:folly::IOBuf	access:public	signature:() const
empty	.\io\IOBufQueue.h	/^  bool empty() const {$/;"	f	class:folly::IOBufQueue	access:public	signature:() const
empty	.\io\TypedIOBuf.h	/^  bool empty() const {$/;"	f	class:folly::TypedIOBuf	access:public	signature:() const
empty	.\small_vector.h	/^  bool      empty()        const { return !size(); }$/;"	f	class:folly::small_vector	access:public	signature:() const
empty	.\sorted_vector_types.h	/^  bool empty() const            { return m_.cont_.empty();    }$/;"	f	class:folly::sorted_vector_map	access:public	signature:() const
empty	.\sorted_vector_types.h	/^  bool empty() const            { return m_.cont_.empty();    }$/;"	f	class:folly::sorted_vector_set	access:public	signature:() const
empty	.\stats\BucketedTimeSeries.h	/^  bool empty() const {$/;"	f	class:folly::BucketedTimeSeries	access:public	signature:() const
emptyKey	.\AtomicHashArray.h	/^    KeyT   emptyKey;$/;"	m	struct:folly::AtomicHashArray::Config	access:public
empty_callback	.\wangle\detail\State.h	/^void empty_callback(Try<T>&&) { }$/;"	f	namespace:folly::wangle::detail	signature:(Try<T>&&)
enableNotifications	.\Subprocess.cpp	/^void Subprocess::enableNotifications(int childFd, bool enabled) {$/;"	f	class:folly::Subprocess	signature:(int childFd, bool enabled)
enableNotifications	.\Subprocess.h	/^  void enableNotifications(int childFd, bool enabled);$/;"	p	class:folly::Subprocess	access:public	signature:(int childFd, bool enabled)
enable_if	.\Conv.h	/^  typedef typename std::enable_if<$/;"	t	class:folly::detail::last_element::std	access:public
enable_request_context	.\io\async\Request.h	/^  DECLARE_bool(enable_request_context);$/;"	v
enabled	.\Subprocess.h	/^    bool enabled = true;$/;"	m	struct:folly::Subprocess::PipeInfo	access:public
encode	.\AtomicStruct.h	/^  constexpr \/* implicit *\/ AtomicStruct(T v) noexcept : data(encode(v)) {}$/;"	f	class:folly::AtomicStruct	access:public	signature:(v)
encode	.\GroupVarint.h	/^  static char* encode(char* p, const uint32_t* src) {$/;"	f	class:folly::GroupVarint	access:public	signature:(char* p, const uint32_t* src)
encode	.\GroupVarint.h	/^  static char* encode(char* p, const uint64_t* src) {$/;"	f	class:folly::GroupVarint	access:public	signature:(char* p, const uint64_t* src)
encode	.\GroupVarint.h	/^  static char* encode(char* p, uint32_t a, uint32_t b, uint32_t c, uint32_t d) {$/;"	f	class:folly::GroupVarint	access:public	signature:(char* p, uint32_t a, uint32_t b, uint32_t c, uint32_t d)
encode	.\GroupVarint.h	/^  static char* encode(char* p, uint64_t a, uint64_t b, uint64_t c,$/;"	f	class:folly::GroupVarint	access:public	signature:(char* p, uint64_t a, uint64_t b, uint64_t c, uint64_t d, uint64_t e)
encode	.\experimental\EliasFanoCoding.h	/^  static EliasFanoCompressedList encode(RandomAccessIterator begin,$/;"	f	struct:folly::compression::EliasFanoEncoder	access:public	signature:(RandomAccessIterator begin, RandomAccessIterator end)
encodeIndex	.\AtomicHashMap-inl.h	/^encodeIndex(uint32_t subMap, uint32_t offset) {$/;"	f	class:folly::AtomicHashMap	signature:(uint32_t subMap, uint32_t offset)
encodeIndex	.\AtomicHashMap.h	/^  static inline uint32_t encodeIndex(uint32_t subMap, uint32_t subMapIdx);$/;"	p	class:folly::AtomicHashMap	access:private	signature:(uint32_t subMap, uint32_t subMapIdx)
encodeLargeData	.\experimental\test\EliasFanoCodingTest.cpp	/^std::vector<uint32_t> encodeLargeData;$/;"	m	namespace:bm	file:
encodeSize	.\io\Compression.cpp	/^  bool encodeSize() const { return type() == CodecType::LZ4_VARINT_SIZE; }$/;"	f	class:folly::io::__anon64::FOLLY_FINAL	file:	access:private	signature:() const
encodeSize	.\io\Compression.cpp	/^  bool encodeSize() const { return type() == CodecType::LZMA2_VARINT_SIZE; }$/;"	f	class:folly::io::__anon64::FOLLY_FINAL	file:	access:private	signature:() const
encodeSmallData	.\experimental\test\EliasFanoCodingTest.cpp	/^std::vector<uint32_t> encodeSmallData;$/;"	m	namespace:bm	file:
encodeVarint	.\Varint.h	/^inline size_t encodeVarint(uint64_t val, uint8_t* buf) {$/;"	f	namespace:folly	signature:(uint64_t val, uint8_t* buf)
encodeVarint	.\Varint.h	/^size_t encodeVarint(uint64_t val, uint8_t* buf);$/;"	p	namespace:folly	signature:(uint64_t val, uint8_t* buf)
encodeVarintToIOBuf	.\io\Compression.cpp	/^void encodeVarintToIOBuf(uint64_t val, folly::IOBuf* out) {$/;"	f	namespace:folly::io::__anon64::__anon65	signature:(uint64_t val, folly::IOBuf* out)
encodeZigZag	.\Varint.h	/^inline uint64_t encodeZigZag(int64_t val) {$/;"	f	namespace:folly	signature:(int64_t val)
encode_non_ascii	.\json.h	/^    bool encode_non_ascii;$/;"	m	struct:folly::json::serialization_opts	access:public
encodedSize	.\GroupVarint.h	/^  static size_t encodedSize(const char* p) {$/;"	f	class:folly::GroupVarint	access:public	signature:(const char* p)
end	.\AtomicHashArray.h	/^  const_iterator end() const   { return const_iterator(this, capacity_); }$/;"	f	class:folly::AtomicHashArray	access:public	signature:() const
end	.\AtomicHashArray.h	/^  iterator end()               { return iterator(this, capacity_); }$/;"	f	class:folly::AtomicHashArray	access:public	signature:()
end	.\AtomicHashMap.h	/^  const_iterator end() const {$/;"	f	class:folly::AtomicHashMap	access:public	signature:() const
end	.\AtomicHashMap.h	/^  iterator end() {$/;"	f	class:folly::AtomicHashMap	access:public	signature:()
end	.\ConcurrentSkipList.h	/^  iterator end() const { return iterator(nullptr); }$/;"	f	class:folly::ConcurrentSkipList::Accessor	access:public	signature:() const
end	.\EvictingCacheMap.h	/^  const_iterator end() const {$/;"	f	class:folly::EvictingCacheMap	access:public	signature:() const
end	.\EvictingCacheMap.h	/^  iterator end() {$/;"	f	class:folly::EvictingCacheMap	access:public	signature:()
end	.\Padded.h	/^  const_iterator end() const { return cend(); }$/;"	f	class:folly::Adaptor	access:public	signature:() const
end	.\Padded.h	/^  iterator end() {$/;"	f	class:folly::Adaptor	access:public	signature:()
end	.\Padded.h	/^Iterator<typename Container::const_iterator> end(const Container& c) {$/;"	f	namespace:folly	signature:(const Container& c)
end	.\Padded.h	/^Iterator<typename Container::iterator> end(Container& c) {$/;"	f	namespace:folly	signature:(Container& c)
end	.\Range.h	/^  Iter end() const { return e_; }$/;"	f	class:folly::Range	access:public	signature:() const
end	.\ThreadLocal.h	/^    Iterator end() const {$/;"	f	class:folly::ThreadLocalPtr::Accessor	access:public	signature:() const
end	.\dynamic-inl.h	/^  It end() const {$/;"	f	struct:folly::dynamic::IterableProxy	access:public	signature:() const
end	.\dynamic-inl.h	/^inline dynamic::const_iterator dynamic::end() const {$/;"	f	class:folly::dynamic	signature:() const
end	.\dynamic.h	/^  const_iterator end()    const;$/;"	p	struct:folly::dynamic	access:public	signature:() const
end	.\io\IOBuf.h	/^  Iterator end() const;$/;"	p	class:folly::IOBuf	access:public	signature:() const
end	.\io\IOBuf.h	/^inline IOBuf::Iterator IOBuf::end() const { return cend(); }$/;"	f	class:folly::IOBuf	signature:() const
end	.\io\RecordIO.h	/^  Iterator end() const;$/;"	p	class:folly::RecordIOReader	access:public	signature:() const
end	.\io\TypedIOBuf.h	/^  T* end() { return writableTail(); }$/;"	f	class:folly::TypedIOBuf	access:public	signature:()
end	.\io\TypedIOBuf.h	/^  const T* end() const { return cend(); }$/;"	f	class:folly::TypedIOBuf	access:public	signature:() const
end	.\small_vector.h	/^  const_iterator end()     const { return data() + size(); }$/;"	f	class:folly::small_vector	access:public	signature:() const
end	.\small_vector.h	/^  iterator       end()           { return data() + size(); }$/;"	f	class:folly::small_vector	access:public	signature:()
end	.\sorted_vector_types.h	/^  const_iterator end() const            { return m_.cont_.end();    }$/;"	f	class:folly::sorted_vector_map	access:public	signature:() const
end	.\sorted_vector_types.h	/^  const_iterator end() const            { return m_.cont_.end();    }$/;"	f	class:folly::sorted_vector_set	access:public	signature:() const
end	.\sorted_vector_types.h	/^  iterator end()                        { return m_.cont_.end();    }$/;"	f	class:folly::sorted_vector_map	access:public	signature:()
end	.\sorted_vector_types.h	/^  iterator end()                        { return m_.cont_.end();    }$/;"	f	class:folly::sorted_vector_set	access:public	signature:()
end	.\stats\Histogram.h	/^  typename std::vector<BucketType>::const_iterator end() const {$/;"	f	class:folly::detail::HistogramBuckets	access:public	signature:() const
end	.\stats\Histogram.h	/^  typename std::vector<BucketType>::iterator end() {$/;"	f	class:folly::detail::HistogramBuckets	access:public	signature:()
end	.\test\PackedSyncPtrTest.cpp	/^  T* end() const { return base.get() + base.extra(); }$/;"	f	struct:SyncVec	access:public	signature:() const
endSequence_	.\experimental\symbolizer\Dwarf.h	/^    bool endSequence_;$/;"	m	class:folly::symbolizer::Dwarf::LineNumberVM	access:private
end_	.\Arena.h	/^  char* end_;$/;"	m	class:folly::Arena	access:private
end_	.\GroupVarint.h	/^  const char* end_;$/;"	m	class:folly::GroupVarintDecoder	access:private
end_	.\experimental\symbolizer\LineReader.h	/^  char* end_;$/;"	m	class:folly::symbolizer::LineReader	access:private
end_	.\gen\Base-inl.h	/^  Value end_;$/;"	m	class:folly::gen::detail::RangeImpl	access:private
end_	.\gen\Base-inl.h	/^  Value end_;$/;"	m	class:folly::gen::detail::RangeWithStepImpl	access:private
end_	.\gen\Base-inl.h	/^  Value end_;$/;"	m	class:folly::gen::detail::SeqImpl	access:private
end_	.\gen\Base-inl.h	/^  Value end_;$/;"	m	class:folly::gen::detail::SeqWithStepImpl	access:private
end_	.\io\IOBuf.h	/^  const IOBuf* end_;$/;"	m	class:folly::IOBuf::Iterator	access:private
end_	.\stats\TimeseriesHistogram.h	/^    TimeType end_;$/;"	m	struct:folly::TimeseriesHistogram::AvgFromInterval	access:private
end_	.\stats\TimeseriesHistogram.h	/^    TimeType end_;$/;"	m	struct:folly::TimeseriesHistogram::CountFromInterval	access:private
endsWith	.\Range.h	/^  bool endsWith(const const_range_type& other) const {$/;"	f	class:folly::Range	access:public	signature:(const const_range_type& other) const
endsWith	.\Range.h	/^  bool endsWith(value_type c) const {$/;"	f	class:folly::Range	access:public	signature:(value_type c) const
enforce	.\FormatArg.h	/^  void enforce(bool v, Args&&... args) const {$/;"	f	struct:folly::FormatArg	access:public	signature:(bool v, Args&&... args) const
enforce	.\Subprocess.cpp	/^void ProcessReturnCode::enforce(State expected) const {$/;"	f	class:folly::ProcessReturnCode	signature:(State expected) const
enforce	.\Subprocess.h	/^  void enforce(State state) const;$/;"	p	class:folly::ProcessReturnCode	access:public	signature:(State state) const
ensure	.\io\Cursor.h	/^  void ensure(uint64_t n) { queue_->preallocate(n, growth_); }$/;"	f	class:folly::io::QueueAppender	access:public	signature:(uint64_t n)
ensure	.\io\Cursor.h	/^  void ensure(uint64_t n) {$/;"	f	class:folly::io::Appender	access:public	signature:(uint64_t n)
ensureNotRegistered	.\io\async\EventHandler.cpp	/^void EventHandler::ensureNotRegistered(const char* fn) {$/;"	f	class:folly::EventHandler	signature:(const char* fn)
ensureNotRegistered	.\io\async\EventHandler.h	/^  void ensureNotRegistered(const char* fn);$/;"	p	class:folly::EventHandler	access:private	signature:(const char* fn)
entryCountThreadCacheSize	.\AtomicHashArray.h	/^    int    entryCountThreadCacheSize;$/;"	m	struct:folly::AtomicHashArray::Config	access:public
environ	.\Subprocess.cpp	/^extern char** environ;$/;"	x
eol_	.\experimental\symbolizer\LineReader.h	/^  char* eol_;$/;"	m	class:folly::symbolizer::LineReader	access:private
epilogueBegin_	.\experimental\symbolizer\Dwarf.h	/^    bool epilogueBegin_;$/;"	m	class:folly::symbolizer::Dwarf::LineNumberVM	access:private
epoch_	.\experimental\EventCount.h	/^    explicit Key(uint32_t e) noexcept : epoch_(e) { }$/;"	f	class:folly::EventCount::Key	access:private	signature:(e)
epoch_	.\experimental\EventCount.h	/^    uint32_t epoch_;$/;"	m	class:folly::EventCount::Key	access:private
eptr_	.\ExceptionWrapper.h	/^  std::exception_ptr eptr_;$/;"	m	class:folly::exception_wrapper	access:protected
equal	.\AtomicHashArray-inl.h	/^  bool equal(const aha_iterator& o) const {$/;"	f	struct:folly::AtomicHashArray::aha_iterator	access:private	signature:(const aha_iterator& o) const
equal	.\AtomicHashMap-inl.h	/^  bool equal(const ahm_iterator& other) const {$/;"	f	struct:folly::AtomicHashMap::ahm_iterator	access:private	signature:(const ahm_iterator& other) const
equal	.\ConcurrentSkipList.h	/^  bool equal(const csl_iterator& other) const { return node_ == other.node_; }$/;"	f	class:folly::detail::csl_iterator	access:private	signature:(const csl_iterator& other) const
equal	.\Padded.h	/^  bool equal(const Iterator& other) const {$/;"	f	namespace:folly::padded	access:private	signature:(const Iterator& other) const
equal	.\ThreadLocal.h	/^      bool equal(const Iterator& other) const {$/;"	f	class:folly::ThreadLocalPtr::Accessor::Iterator	access:private	signature:(const Iterator& other) const
equal	.\io\IOBuf.h	/^  bool equal(const Iterator& other) const {$/;"	f	class:folly::IOBuf::Iterator	access:private	signature:(const Iterator& other) const
equal	.\io\RecordIO-inl.h	/^  bool equal(const Iterator& other) const { return range_ == other.range_; }$/;"	f	class:folly::RecordIOReader::Iterator	access:private	signature:(const Iterator& other) const
equal_range	.\sorted_vector_types.h	/^  equal_range(const key_type& key) const {$/;"	f	class:folly::sorted_vector_map	access:public	signature:(const key_type& key) const
equal_range	.\sorted_vector_types.h	/^  equal_range(const key_type& key) const {$/;"	f	class:folly::sorted_vector_set	access:public	signature:(const key_type& key) const
equal_range	.\sorted_vector_types.h	/^  std::pair<iterator,iterator> equal_range(const key_type& key) {$/;"	f	class:folly::sorted_vector_map	access:public	signature:(const key_type& key)
equal_range	.\sorted_vector_types.h	/^  std::pair<iterator,iterator> equal_range(const key_type& key) {$/;"	f	class:folly::sorted_vector_set	access:public	signature:(const key_type& key)
equality	.\test\FBStringTestBenchmarks.cpp.h	/^void BENCHFUN(equality)(int iters, int arg) {$/;"	f	signature:(int iters, int arg)
erase	.\AtomicHashArray-inl.h	/^erase(KeyT key_in) {$/;"	f	class:folly::AtomicHashArray	signature:(KeyT key_in)
erase	.\AtomicHashArray.h	/^  size_t erase(KeyT k);$/;"	p	class:folly::AtomicHashArray	access:public	signature:(KeyT k)
erase	.\AtomicHashMap-inl.h	/^erase(const KeyT k) {$/;"	f	class:folly::AtomicHashMap	signature:(const KeyT k)
erase	.\AtomicHashMap.h	/^  size_type erase(key_type k);$/;"	p	class:folly::AtomicHashMap	access:public	signature:(key_type k)
erase	.\ConcurrentSkipList.h	/^  size_t erase(const key_type &data) { return remove(data); }$/;"	f	class:folly::ConcurrentSkipList::Accessor	access:public	signature:(const key_type &data)
erase	.\EvictingCacheMap.h	/^  bool erase(const TKey& key) {$/;"	f	class:folly::EvictingCacheMap	access:public	signature:(const TKey& key)
erase	.\FBVector.h	/^  iterator erase(const_iterator first, const_iterator last) {$/;"	f	signature:(const_iterator first, const_iterator last)
erase	.\FBVector.h	/^  iterator erase(const_iterator position) {$/;"	f	signature:(const_iterator position)
erase	.\TimeoutQueue.cpp	/^bool TimeoutQueue::erase(Id id) {$/;"	f	class:folly::TimeoutQueue	signature:(Id id)
erase	.\TimeoutQueue.h	/^  bool erase(Id id);$/;"	p	class:folly::TimeoutQueue	access:public	signature:(Id id)
erase	.\detail\ThreadLocalDetail.h	/^  void erase(ThreadEntry* t) {$/;"	f	struct:folly::threadlocal_detail::StaticMeta	access:public	signature:(ThreadEntry* t)
erase	.\dynamic-inl.h	/^dynamic::erase(const_iterator first, const_iterator last) {$/;"	f	class:folly::dynamic	signature:(const_iterator first, const_iterator last)
erase	.\dynamic-inl.h	/^inline dynamic::const_item_iterator dynamic::erase(const_item_iterator first,$/;"	f	class:folly::dynamic	signature:(const_item_iterator first, const_item_iterator last)
erase	.\dynamic-inl.h	/^inline dynamic::const_item_iterator dynamic::erase(const_item_iterator it) {$/;"	f	class:folly::dynamic	signature:(const_item_iterator it)
erase	.\dynamic-inl.h	/^inline dynamic::const_iterator dynamic::erase(const_iterator it) {$/;"	f	class:folly::dynamic	signature:(const_iterator it)
erase	.\dynamic-inl.h	/^inline dynamic::const_key_iterator dynamic::erase(const_key_iterator first,$/;"	f	class:folly::dynamic	signature:(const_key_iterator first, const_key_iterator last)
erase	.\dynamic-inl.h	/^inline dynamic::const_key_iterator dynamic::erase(const_key_iterator it) {$/;"	f	class:folly::dynamic	signature:(const_key_iterator it)
erase	.\dynamic-inl.h	/^inline dynamic::const_value_iterator dynamic::erase(const_value_iterator first,$/;"	f	class:folly::dynamic	signature:(const_value_iterator first, const_value_iterator last)
erase	.\dynamic-inl.h	/^inline dynamic::const_value_iterator dynamic::erase(const_value_iterator it) {$/;"	f	class:folly::dynamic	signature:(const_value_iterator it)
erase	.\dynamic-inl.h	/^inline std::size_t dynamic::erase(dynamic const& key) {$/;"	f	class:folly::dynamic	signature:(dynamic const& key)
erase	.\dynamic.h	/^  const_item_iterator erase(const_item_iterator first,$/;"	p	struct:folly::dynamic	access:public	signature:(const_item_iterator first, const_item_iterator last)
erase	.\dynamic.h	/^  const_item_iterator erase(const_item_iterator it);$/;"	p	struct:folly::dynamic	access:public	signature:(const_item_iterator it)
erase	.\dynamic.h	/^  const_iterator erase(const_iterator first, const_iterator last);$/;"	p	struct:folly::dynamic	access:public	signature:(const_iterator first, const_iterator last)
erase	.\dynamic.h	/^  const_iterator erase(const_iterator it);$/;"	p	struct:folly::dynamic	access:public	signature:(const_iterator it)
erase	.\dynamic.h	/^  const_key_iterator erase(const_key_iterator first, const_key_iterator last);$/;"	p	struct:folly::dynamic	access:public	signature:(const_key_iterator first, const_key_iterator last)
erase	.\dynamic.h	/^  const_key_iterator erase(const_key_iterator it);$/;"	p	struct:folly::dynamic	access:public	signature:(const_key_iterator it)
erase	.\dynamic.h	/^  const_value_iterator erase(const_value_iterator first,$/;"	p	struct:folly::dynamic	access:public	signature:(const_value_iterator first, const_value_iterator last)
erase	.\dynamic.h	/^  const_value_iterator erase(const_value_iterator it);$/;"	p	struct:folly::dynamic	access:public	signature:(const_value_iterator it)
erase	.\dynamic.h	/^  std::size_t erase(dynamic const& key);$/;"	p	struct:folly::dynamic	access:public	signature:(dynamic const& key)
erase	.\small_vector.h	/^  iterator erase(const_iterator q) {$/;"	f	class:folly::small_vector	access:public	signature:(const_iterator q)
erase	.\small_vector.h	/^  iterator erase(const_iterator q1, const_iterator q2) {$/;"	f	class:folly::small_vector	access:public	signature:(const_iterator q1, const_iterator q2)
erase	.\sorted_vector_types.h	/^  size_type erase(const key_type& key) {$/;"	f	class:folly::sorted_vector_map	access:public	signature:(const key_type& key)
erase	.\sorted_vector_types.h	/^  size_type erase(const key_type& key) {$/;"	f	class:folly::sorted_vector_set	access:public	signature:(const key_type& key)
erase	.\sorted_vector_types.h	/^  void erase(iterator first, iterator last) {$/;"	f	class:folly::sorted_vector_map	access:public	signature:(iterator first, iterator last)
erase	.\sorted_vector_types.h	/^  void erase(iterator first, iterator last) {$/;"	f	class:folly::sorted_vector_set	access:public	signature:(iterator first, iterator last)
erase	.\sorted_vector_types.h	/^  void erase(iterator it) {$/;"	f	class:folly::sorted_vector_map	access:public	signature:(iterator it)
erase	.\sorted_vector_types.h	/^  void erase(iterator it) {$/;"	f	class:folly::sorted_vector_set	access:public	signature:(iterator it)
erase	.\test\FBVectorTestBenchmarks.cpp.h	/^void BENCHFUN(erase)(int iters, int size) {$/;"	f	signature:(int iters, int size)
eraseCheck	.\test\stl_tests\StlVectorTest.cpp	/^void eraseCheck(Vector& a, DataState<Vector>& dsa, int idx, int n) {$/;"	f	signature:(Vector& a, DataState<Vector>& dsa, int idx, int n)
erasedKey	.\AtomicHashArray.h	/^    KeyT   erasedKey;$/;"	m	struct:folly::AtomicHashArray::Config	access:public
errCode	.\Subprocess.cpp	/^  int errCode;$/;"	m	struct:folly::__anon98::ChildErrorInfo	file:	access:public
errnoStr	.\String.cpp	/^fbstring errnoStr(int err) {$/;"	f	namespace:folly	signature:(int err)
errnoStr	.\String.h	/^fbstring errnoStr(int err);$/;"	p	class:folly::UriEscapeMode	access:private	signature:(int err)
errnoValue	.\Subprocess.cpp	/^  int errnoValue;$/;"	m	struct:folly::__anon98::ChildErrorInfo	file:	access:public
errnoValue	.\Subprocess.h	/^  int errnoValue() const { return errnoValue_; }$/;"	f	class:folly::SubprocessSpawnError	access:public	signature:() const
errnoValue_	.\Subprocess.h	/^  int errnoValue_;$/;"	m	class:folly::SubprocessSpawnError	access:private
error	.\FormatArg.h	/^  FOLLY_NORETURN void error(Args&&... args) const;$/;"	p	struct:folly::FormatArg	access:public	signature:(Args&&.... args) const
error	.\FormatArg.h	/^inline void FormatArg::error(Args&&... args) const {$/;"	f	class:folly::FormatArg	signature:(Args&&.... args) const
error	.\json.cpp	/^  dynamic error(char const* what) const {$/;"	f	struct:folly::json::__anon75::Input	access:public	signature:(char const* what) const
errorStr	.\FormatArg.h	/^  std::string errorStr(Args&&... args) const;$/;"	p	struct:folly::FormatArg	access:public	signature:(Args&&.... args) const
errorStr	.\FormatArg.h	/^inline std::string FormatArg::errorStr(Args&&... args) const {$/;"	f	class:folly::FormatArg	signature:(Args&&.... args) const
escapeString	.\json.cpp	/^void escapeString(StringPiece input,$/;"	f	namespace:folly::json	signature:(StringPiece input, fbstring& out, const serialization_opts& opts)
escapeString	.\json.h	/^  void escapeString(StringPiece input,$/;"	p	namespace:folly::json	signature:(StringPiece input, fbstring& out, const serialization_opts& opts)
estimateSpaceNeeded	.\Conv.h	/^estimateSpaceNeeded(Src value) {$/;"	f	namespace:folly	signature:(Src value)
estimateSpaceNeeded	.\Conv.h	/^estimateSpaceNeeded(T) {$/;"	f	namespace:folly	signature:(T)
estimateTime	.\Benchmark.cpp	/^static double estimateTime(double * begin, double * end) {$/;"	f	namespace:folly	signature:(double * begin, double * end)
estr_	.\ExceptionWrapper.h	/^  std::string estr_;$/;"	m	class:folly::exception_wrapper	access:protected
evb_	.\io\async\EventBase.h	/^  event_base* evb_;$/;"	m	class:folly::EventBase	access:private
even	.\gen\test\ParallelTest.cpp	/^const auto even = [](int i) { return 0 == i % 2; };$/;"	v
eventBase	.\experimental\wangle\concurrent\IOThreadPoolExecutor.h	/^    EventBase eventBase;$/;"	m	struct:folly::wangle::IOThreadPoolExecutor::IOThread	access:public
eventBase_	.\experimental\wangle\ConnectionManager.h	/^  folly::EventBase* eventBase_;$/;"	m	class:folly::wangle::ConnectionManager	access:private
eventBase_	.\io\async\EventHandler.h	/^  EventBase* eventBase_;$/;"	m	class:folly::EventHandler	access:private
event_	.\io\async\AsyncTimeout.h	/^  struct event event_;$/;"	m	class:folly::AsyncTimeout	typeref:struct:folly::AsyncTimeout::event	access:private
event_	.\io\async\EventHandler.h	/^  struct event event_;$/;"	m	class:folly::EventHandler	typeref:struct:folly::EventHandler::event	access:private
eventfd	.\io\async\EventFDWrapper.h	73;"	d
eventfd_	.\io\async\NotificationQueue.h	/^  int eventfd_;$/;"	m	class:folly::NotificationQueue	access:private
ex	.\IPAddressException.h	/^    const InvalidAddressFamilyException& ex) = default;$/;"	m	class:folly::InvalidAddressFamilyException	access:public
ex	.\wangle\test\LaterTest.cpp	/^  std::shared_ptr<ManualExecutor> ex;$/;"	m	struct:ManualWaiter	file:	access:public
ex	.\wangle\test\ThreadGateTest.cpp	/^  shared_ptr<ManualExecutor> ex;$/;"	m	struct:ManualWaiter	file:	access:public
exceptionCount_	.\detail\UncaughtExceptionCounter.h	/^  int exceptionCount_;$/;"	m	class:folly::detail::UncaughtExceptionCounter	access:private
exceptionCounter_	.\ScopeGuard.h	/^  UncaughtExceptionCounter exceptionCounter_;$/;"	m	class:folly::detail::ScopeGuardForNewException	access:private
exceptionDestructor	.\experimental\exception_tracer\ExceptionAbi.h	/^  void (*exceptionDestructor) (void*);$/;"	m	struct:__cxxabiv1::__cxa_exception	access:public
exceptionPtrReturnParam	.\test\function_benchmark\test_functions.cpp	/^void exceptionPtrReturnParam(std::exception_ptr* excReturn) {$/;"	f	signature:(std::exception_ptr* excReturn)
exceptionPtrReturnParam	.\test\function_benchmark\test_functions.h	/^void exceptionPtrReturnParam(std::exception_ptr* excReturn);$/;"	p	signature:(std::exception_ptr* excReturn)
exceptionStr	.\String.h	/^inline fbstring exceptionStr(const std::exception& e) {$/;"	f	class:folly::UriEscapeMode	access:private	signature:(const std::exception& e)
exceptionStr	.\String.h	/^inline fbstring exceptionStr(std::exception_ptr ep) {$/;"	f	class:folly::UriEscapeMode	access:private	signature:(std::exception_ptr ep)
exceptionType	.\experimental\exception_tracer\ExceptionAbi.h	/^  std::type_info* exceptionType;$/;"	m	struct:__cxxabiv1::__cxa_exception	access:public
exception_	.\IPAddressException.h	/^    const IPAddressFormatException& exception_) = default;$/;"	m	class:folly::IPAddressFormatException	access:public
exception_tracer	.\experimental\exception_tracer\ExceptionTracer.cpp	/^namespace exception_tracer {$/;"	n	namespace:folly	file:
exception_tracer	.\experimental\exception_tracer\ExceptionTracer.h	/^namespace exception_tracer {$/;"	n	namespace:folly
exception_tracer	.\experimental\exception_tracer\StackTrace.cpp	/^namespace folly { namespace exception_tracer {$/;"	n	namespace:folly	file:
exception_tracer	.\experimental\exception_tracer\StackTrace.h	/^namespace folly { namespace exception_tracer {$/;"	n	namespace:folly
exception_wrapper	.\ExceptionWrapper.h	/^  exception_wrapper() : throwfn_(nullptr) { }$/;"	f	class:folly::exception_wrapper	access:public	signature:()
exception_wrapper	.\ExceptionWrapper.h	/^class exception_wrapper {$/;"	c	namespace:folly
exists	.\EvictingCacheMap.h	/^  bool exists(const TKey& key) const  {$/;"	f	class:folly::EvictingCacheMap	access:public	signature:(const TKey& key) const
exitStatus	.\Subprocess.cpp	/^int ProcessReturnCode::exitStatus() const {$/;"	f	class:folly::ProcessReturnCode	signature:() const
exitStatus	.\Subprocess.h	/^  int exitStatus() const;$/;"	p	class:folly::ProcessReturnCode	access:public	signature:() const
exited	.\Subprocess.h	/^  bool exited() const { return state() == EXITED; }$/;"	f	class:folly::ProcessReturnCode	access:public	signature:() const
expCoeff_	.\io\async\EventBase.h	/^    double  expCoeff_;$/;"	m	class:folly::EventBase::SmoothLoopTime	access:private
expect	.\experimental\symbolizer\test\LineReaderTest.cpp	/^void expect(LineReader& lr, const char* expected) {$/;"	f	namespace:folly::symbolizer::test	signature:(LineReader& lr, const char* expected)
expect	.\json.cpp	/^  void expect(char c) {$/;"	f	struct:folly::json::__anon75::Input	access:public	signature:(char c)
expectEQ	.\test\RangeTest.cpp	/^void expectEQ(const T& a, const T& b) {$/;"	f	signature:(const T& a, const T& b)
expectLT	.\test\RangeTest.cpp	/^void expectLT(const T& a, const T& b) {$/;"	f	signature:(const T& a, const T& b)
expectOK	.\test\FileTest.cpp	/^void expectOK(ssize_t r) {$/;"	f	namespace:__anon116	signature:(ssize_t r)
expectPathEq	.\experimental\io\test\FsUtilTest.cpp	/^void expectPathEq(const path& a, const path& b) {$/;"	f	namespace:__anon33	signature:(const path& a, const path& b)
expectPrintable	.\test\StringTest.cpp	/^void expectPrintable(StringPiece s) {$/;"	f	namespace:__anon134	signature:(StringPiece s)
expectWouldBlock	.\test\FileTest.cpp	/^void expectWouldBlock(ssize_t r) {$/;"	f	namespace:__anon116	signature:(ssize_t r)
expectedResults	.\test\ChecksumTest.cpp	/^ExpectedResult expectedResults[] = {$/;"	m	namespace:__anon112	file:
expiration	.\TimeoutQueue.h	/^    int64_t expiration;$/;"	m	struct:folly::TimeoutQueue::Event	access:public
expiration_	.\io\async\HHWheelTimer.h	/^    std::chrono::milliseconds expiration_;$/;"	m	class:folly::HHWheelTimer::Callback	access:private
expirationsSinceCatchup_	.\io\async\HHWheelTimer.h	/^  uint32_t expirationsSinceCatchup_;$/;"	m	class:folly::HHWheelTimer	access:private
extra	.\PackedSyncPtr.h	/^  uint16_t extra() const {$/;"	f	class:folly::PackedSyncPtr	access:public	signature:() const
extract	.\json.cpp	/^  T extract() {$/;"	f	struct:folly::json::__anon75::Input	access:public	signature:()
fValue	.\test\ConvTest.cpp	/^static float fValue = 1.2355;$/;"	v	file:
f_	.\test\ApplyTupleTest.cpp	/^  F f_;$/;"	m	struct:__anon104::GuardObj	file:	access:private
factors	.\gen\test\ParallelBenchmark.cpp	/^static auto factors = [](int n) {$/;"	v	file:
factorsSlow	.\gen\test\ParallelBenchmark.cpp	/^static auto factorsSlow = [](int n) {$/;"	v	file:
fail	.\test\SafeAssertTest.cpp	/^void fail() {$/;"	f	signature:()
failHard	.\experimental\symbolizer\test\SignalHandlerTest.h	/^inline void failHard() {$/;"	f	namespace:folly::symbolizer::test	signature:()
failed	.\test\SpookyHashV1Test.cpp	/^static bool failed = false;$/;"	v	file:
failed	.\test\SpookyHashV2Test.cpp	/^static bool failed = false;$/;"	v	file:
fakeSysfsTree	.\test\CacheLocalityTest.cpp	/^static std::unordered_map<std::string,std::string> fakeSysfsTree = {$/;"	v	file:
family	.\IPAddress.h	/^  sa_family_t family() const { return family_; }$/;"	f	class:folly::IPAddress	access:public	signature:() const
familyNameStr	.\detail\IPAddress.h	/^inline std::string familyNameStr(sa_family_t family) {$/;"	f	namespace:folly::detail	signature:(sa_family_t family)
family_	.\IPAddress.h	/^  sa_family_t family_;$/;"	m	class:folly::IPAddress	access:private
fastIpv4ToString	.\detail\IPAddress.h	/^inline std::string fastIpv4ToString($/;"	f	namespace:folly::detail	signature:( const in_addr& inAddr)
fastIpv6ToString	.\detail\IPAddress.h	/^inline std::string fastIpv6ToString(const in6_addr& in6Addr) {$/;"	f	namespace:folly::detail	signature:(const in6_addr& in6Addr)
fbstr	.\Format.h	/^  fbstring fbstr() const {$/;"	f	class:folly::BaseFormatter	access:public	signature:() const
fbstr	.\Range.h	/^  fbstring fbstr() const { return fbstring(b_, size()); }$/;"	f	class:folly::Range	access:public	signature:() const
fbstr	.\Uri.h	/^  fbstring fbstr() const { return toString<fbstring>(); }$/;"	f	class:folly::Uri	access:public	signature:() const
fbstr	.\experimental\symbolizer\Symbolizer.h	/^  const fbstring& fbstr() const { return buf_; }$/;"	f	class:folly::symbolizer::StringSymbolizePrinter	access:public	signature:() const
fbstringIdenticalToBM	.\test\ConvTest.cpp	/^static const StringIdenticalToBM<fbstring> fbstringIdenticalToBM;$/;"	v	file:
fbstringVariadicToBM	.\test\ConvTest.cpp	/^static const StringVariadicToBM<fbstring> fbstringVariadicToBM;$/;"	v	file:
fbvector	.\FBVector.h	/^  \/* may throw *\/ fbvector(fbvector&& other, const Allocator& a) : impl_(a) {$/;"	f	signature:(fbvector&& other, const Allocator& a)
fbvector	.\FBVector.h	/^  class fbvector;$/;"	x
fbvector	.\FBVector.h	/^  explicit fbvector(const Allocator& a) : impl_(a) {}$/;"	f	signature:(const Allocator& a)
fbvector	.\FBVector.h	/^  explicit fbvector(size_type n, const Allocator& a = Allocator())$/;"	f	signature:(size_type n, const Allocator& a = Allocator())
fbvector	.\FBVector.h	/^  fbvector(ForwardIterator first, ForwardIterator last,$/;"	f	signature:(ForwardIterator first, ForwardIterator last, const Allocator& a, std::forward_iterator_tag)
fbvector	.\FBVector.h	/^  fbvector(InputIterator first, InputIterator last,$/;"	f	signature:(InputIterator first, InputIterator last, const Allocator& a, std::input_iterator_tag)
fbvector	.\FBVector.h	/^  fbvector(It first, It last, const Allocator& a = Allocator())$/;"	f	signature:(It first, It last, const Allocator& a = Allocator())
fbvector	.\FBVector.h	/^  fbvector(const fbvector& other)$/;"	f	signature:(const fbvector& other)
fbvector	.\FBVector.h	/^  fbvector(const fbvector& other, const Allocator& a)$/;"	f	signature:(const fbvector& other, const Allocator& a)
fbvector	.\FBVector.h	/^  fbvector(size_type n, VT value, const Allocator& a = Allocator())$/;"	f	signature:(size_type n, VT value, const Allocator& a = Allocator())
fbvector	.\FBVector.h	/^  fbvector(std::initializer_list<T> il, const Allocator& a = Allocator())$/;"	f	signature:(std::initializer_list<T> il, const Allocator& a = Allocator())
fbvector	.\FBVector.h	/^class fbvector : private boost::totally_ordered<fbvector<T, Allocator>> {$/;"	c	namespace:folly	inherits:boost::totally_ordered
fd	.\File.h	/^  int fd() const { return fd_; }$/;"	f	class:folly::File	access:public	signature:() const
fd	.\MemoryMapping.h	/^  int fd() const { return file_.fd(); }$/;"	f	class:folly::MemoryMapping	access:public	signature:() const
fd	.\Subprocess.cpp	/^Subprocess::Options& Subprocess::Options::fd(int fd, int action) {$/;"	f	class:folly::Subprocess::Options	signature:(int fd, int action)
fd	.\Subprocess.h	/^    Options& fd(int fd, int action);$/;"	p	class:folly::Subprocess::Options	access:public	signature:(int fd, int action)
fd	.\experimental\TestUtil.h	/^  int fd() const { return fd_; }$/;"	f	class:folly::test::TemporaryFile	access:public	signature:() const
fd2name	.\experimental\io\AsyncIO.cpp	/^std::string fd2name(int fd) {$/;"	f	namespace:folly::__anon28	signature:(int fd)
fdActions_	.\Subprocess.h	/^    FdMap fdActions_;$/;"	m	class:folly::Subprocess::Options	access:private
fdLineCb_	.\Subprocess.h	/^    Callback fdLineCb_;$/;"	m	class:folly::Subprocess::ReadLinesCallback	access:private
fdToSplitter_	.\Subprocess.h	/^    std::unordered_map<int, LineSplitter> fdToSplitter_;$/;"	m	class:folly::Subprocess::ReadLinesCallback	access:private
fd_	.\File.h	/^  int fd_;$/;"	m	class:folly::File	access:private
fd_	.\Subprocess.h	/^      int fd_;$/;"	m	struct:folly::Subprocess::ReadLinesCallback::StreamSplitterCallback	access:public
fd_	.\experimental\TestUtil.h	/^  int fd_;$/;"	m	class:folly::test::TemporaryFile	access:private
fd_	.\experimental\symbolizer\Elf.cpp	/^  : fd_(other.fd_),$/;"	p	namespace:folly::symbolizer	file:	signature:(other.fd_)
fd_	.\experimental\symbolizer\Elf.h	/^  int fd_;$/;"	m	class:folly::symbolizer::ElfFile	access:private
fd_	.\experimental\symbolizer\LineReader.h	/^  int const fd_;$/;"	m	class:folly::symbolizer::LineReader	access:private
fd_	.\experimental\symbolizer\Symbolizer.h	/^  int fd_;$/;"	m	class:folly::symbolizer::FDSymbolizePrinter	access:private
fdatasyncNoInt	.\FileUtil.cpp	/^int fdatasyncNoInt(int fd) {$/;"	f	namespace:folly	signature:(int fd)
fdatasyncNoInt	.\FileUtil.h	/^int fdatasyncNoInt(int fd);$/;"	p	namespace:folly	signature:(int fd)
fetchMask	.\IPAddressV4.cpp	/^const ByteArray4 IPAddressV4::fetchMask(size_t numBits) {$/;"	f	class:folly::IPAddressV4	signature:(size_t numBits)
fetchMask	.\IPAddressV4.h	/^  static const ByteArray4 fetchMask(size_t numBits);$/;"	p	class:folly::IPAddressV4	access:public	signature:(size_t numBits)
fetchMask	.\IPAddressV6.cpp	/^const ByteArray16 IPAddressV6::fetchMask(size_t numBits) {$/;"	f	class:folly::IPAddressV6	signature:(size_t numBits)
fetchMask	.\IPAddressV6.h	/^  static const ByteArray16 fetchMask(size_t numBits);$/;"	p	class:folly::IPAddressV6	access:public	signature:(size_t numBits)
fetchStackLimits	.\detail\MemoryIdler.cpp	/^static void fetchStackLimits() {$/;"	f	namespace:folly::detail	signature:()
ffoDelim	.\test\RangeFindBenchmark.cpp	/^vector<string> ffoDelim;$/;"	m	namespace:__anon129	file:
ffoDelimSize	.\test\RangeFindBenchmark.cpp	/^const size_t ffoDelimSize = 128;$/;"	m	namespace:__anon129	file:
ffoTestString	.\test\RangeFindBenchmark.cpp	/^string ffoTestString;$/;"	m	namespace:__anon129	file:
fib	.\gen\test\ParallelBenchmark.cpp	/^size_t fib(int n) { return n <= 1 ? 1 : fib(n - 1) + fib(n - 2); }$/;"	f	signature:(int n)
fib	.\gen\test\ParallelMapBenchmark.cpp	/^size_t fib(int n) { return n <= 1 ? 1 : fib(n-1) * fib(n-2); }$/;"	f	signature:(int n)
fibs	.\gen\test\ParallelBenchmark.cpp	/^const int fibs = 1000;$/;"	v
field	.\gen\Base.h	/^Map field(FieldType Class::*field) {$/;"	f	namespace:folly::gen	signature:(FieldType Class::*field)
field_	.\gen\Base.h	/^  FieldPtr field_;$/;"	m	class:folly::gen::Field	access:private
file	.\experimental\symbolizer\Dwarf.h	/^    Path file;$/;"	m	struct:folly::symbolizer::Dwarf::LocationInfo	access:public
file	.\experimental\symbolizer\Dwarf.h	/^    folly::StringPiece file() const { return file_; }$/;"	f	class:folly::symbolizer::Dwarf::Path	access:public	signature:() const
file	.\experimental\symbolizer\ElfCache.h	/^    ElfFile file;$/;"	m	struct:folly::symbolizer::ElfCache::Entry	access:public
fileId	.\io\RecordIO-inl.h	/^  uint32_t fileId;        \/\/ unique file ID$/;"	m	struct:folly::recordio_helpers::detail::Header	access:public
fileId	.\io\RecordIO.h	/^  uint32_t fileId;$/;"	m	struct:folly::recordio_helpers::RecordInfo	access:public
fileId_	.\io\RecordIO-inl.h	/^  uint32_t fileId_;$/;"	m	class:folly::RecordIOReader::Iterator	access:private
fileId_	.\io\RecordIO.h	/^  uint32_t fileId_;$/;"	m	class:folly::RecordIOReader	access:private
fileId_	.\io\RecordIO.h	/^  uint32_t fileId_;$/;"	m	class:folly::RecordIOWriter	access:private
fileNameCount_	.\experimental\symbolizer\Dwarf.h	/^    size_t fileNameCount_;$/;"	m	class:folly::symbolizer::Dwarf::LineNumberVM	access:private
fileNames_	.\experimental\symbolizer\Dwarf.h	/^    folly::StringPiece fileNames_;$/;"	m	class:folly::symbolizer::Dwarf::LineNumberVM	access:private
filePath	.\experimental\io\HugePages.h	/^  fs::path filePath(const fs::path& relpath) const {$/;"	f	struct:folly::HugePageSize	access:public	signature:(const fs::path& relpath) const
filePos	.\io\RecordIO.h	/^  off_t filePos() const { return filePos_; }$/;"	f	class:folly::RecordIOWriter	access:public	signature:() const
filePos_	.\io\RecordIO.h	/^  std::atomic<off_t> filePos_;$/;"	m	class:folly::RecordIOWriter	access:private
filePtr	.\experimental\symbolizer\ElfCache.cpp	/^std::shared_ptr<ElfFile> ElfCache::filePtr(const std::shared_ptr<Entry>& e) {$/;"	f	class:folly::symbolizer::ElfCache	signature:(const std::shared_ptr<Entry>& e)
filePtr	.\experimental\symbolizer\ElfCache.h	/^  static std::shared_ptr<ElfFile> filePtr(const std::shared_ptr<Entry>& e);$/;"	p	class:folly::symbolizer::ElfCache	access:private	signature:(const std::shared_ptr<Entry>& e)
file_	.\MemoryMapping.h	/^  File file_;$/;"	m	class:folly::MemoryMapping	access:private
file_	.\experimental\symbolizer\Dwarf.h	/^    folly::StringPiece file_;$/;"	m	class:folly::symbolizer::Dwarf::Path	access:private
file_	.\experimental\symbolizer\Dwarf.h	/^    uint64_t file_;$/;"	m	class:folly::symbolizer::Dwarf::LineNumberVM	access:private
file_	.\experimental\symbolizer\Elf.cpp	/^    file_(other.file_),$/;"	p	namespace:folly::symbolizer	file:	signature:(other.file_)
file_	.\experimental\symbolizer\Elf.h	/^  char* file_;     \/\/ mmap() location$/;"	m	class:folly::symbolizer::ElfFile	access:private
file_	.\experimental\symbolizer\Symbolizer.h	/^  FILE* file_;$/;"	m	class:folly::symbolizer::FILESymbolizePrinter	access:private
file_	.\experimental\symbolizer\Symbolizer.h	/^  std::shared_ptr<ElfFile> file_;$/;"	m	struct:folly::symbolizer::SymbolizedFrame	access:private
file_	.\gen\File-inl.h	/^  File file_;$/;"	m	class:folly::gen::detail::FileReader	access:private
file_	.\gen\File-inl.h	/^  mutable File file_;$/;"	m	class:folly::gen::detail::FileWriter	access:private
file_	.\io\RecordIO.h	/^  File file_;$/;"	m	class:folly::RecordIOWriter	access:private
files_	.\experimental\symbolizer\ElfCache.h	/^    StringPieceHash> files_;$/;"	m	class:folly::symbolizer::ElfCache	access:private
fileutil_detail	.\detail\FileUtilDetail.h	/^namespace folly { namespace fileutil_detail {$/;"	n	namespace:folly
fill	.\FormatArg.h	/^  char fill;$/;"	m	struct:folly::FormatArg	access:public
fillBuf	.\io\test\IOBufTest.cpp	/^void fillBuf(IOBuf* buf, boost::mt19937& gen) {$/;"	f	signature:(IOBuf* buf, boost::mt19937& gen)
fillBuf	.\io\test\IOBufTest.cpp	/^void fillBuf(uint8_t* buf, uint32_t length, boost::mt19937& gen) {$/;"	f	signature:(uint8_t* buf, uint32_t length, boost::mt19937& gen)
fillCtor	.\test\FBVectorTestBenchmarks.cpp.h	/^void BENCHFUN(fillCtor)(int iters, int size) {$/;"	f	signature:(int iters, int size)
filter	.\gen\Base.h	/^Filter filter(Predicate pred = Predicate()) {$/;"	f	namespace:folly::gen	signature:(Predicate pred = Predicate())
find	.\AtomicHashArray.h	/^  const_iterator find(KeyT k) const {$/;"	f	class:folly::AtomicHashArray	access:public	signature:(KeyT k) const
find	.\AtomicHashArray.h	/^  iterator find(KeyT k) {$/;"	f	class:folly::AtomicHashArray	access:public	signature:(KeyT k)
find	.\AtomicHashMap-inl.h	/^find(KeyT k) const {$/;"	f	class:folly::AtomicHashMap	signature:(KeyT k) const
find	.\AtomicHashMap-inl.h	/^find(KeyT k) {$/;"	f	class:folly::AtomicHashMap	signature:(KeyT k)
find	.\AtomicHashMap.h	/^  const_iterator find(key_type k) const;$/;"	p	class:folly::AtomicHashMap	access:public	signature:(key_type k) const
find	.\AtomicHashMap.h	/^  iterator find(key_type k);$/;"	p	class:folly::AtomicHashMap	access:public	signature:(key_type k)
find	.\ConcurrentSkipList.h	/^  NodeType* find(const value_type &data) {$/;"	f	class:folly::ConcurrentSkipList	access:private	signature:(const value_type &data)
find	.\ConcurrentSkipList.h	/^  const_iterator find(const key_type &value) const {$/;"	f	class:folly::ConcurrentSkipList::Accessor	access:public	signature:(const key_type &value) const
find	.\ConcurrentSkipList.h	/^  iterator find(const key_type &value) { return iterator(sl_->find(value)); }$/;"	f	class:folly::ConcurrentSkipList::Accessor	access:public	signature:(const key_type &value)
find	.\EvictingCacheMap.h	/^  iterator find(const TKey& key) {$/;"	f	class:folly::EvictingCacheMap	access:public	signature:(const TKey& key)
find	.\Range.h	/^  size_type find(Iter s, size_t pos, size_t n) const {$/;"	f	class:folly::Range	access:public	signature:(Iter s, size_t pos, size_t n) const
find	.\Range.h	/^  size_type find(const Iter s) const {$/;"	f	class:folly::Range	access:public	signature:(const Iter s) const
find	.\Range.h	/^  size_type find(const Iter s, size_t pos) const {$/;"	f	class:folly::Range	access:public	signature:(const Iter s, size_t pos) const
find	.\Range.h	/^  size_type find(const_range_type str) const {$/;"	f	class:folly::Range	access:public	signature:(const_range_type str) const
find	.\Range.h	/^  size_type find(const_range_type str, size_t pos) const {$/;"	f	class:folly::Range	access:public	signature:(const_range_type str, size_t pos) const
find	.\Range.h	/^  size_type find(value_type c) const {$/;"	f	class:folly::Range	access:public	signature:(value_type c) const
find	.\Range.h	/^  size_type find(value_type c, size_t pos) const {$/;"	f	class:folly::Range	access:public	signature:(value_type c, size_t pos) const
find	.\dynamic-inl.h	/^inline dynamic::const_item_iterator dynamic::find(dynamic const& key) const {$/;"	f	class:folly::dynamic	signature:(dynamic const& key) const
find	.\dynamic.h	/^  const_item_iterator find(dynamic const&) const;$/;"	p	struct:folly::dynamic	access:public	signature:(dynamic const&) const
find	.\sorted_vector_types.h	/^  const_iterator find(const key_type& key) const {$/;"	f	class:folly::sorted_vector_map	access:public	signature:(const key_type& key) const
find	.\sorted_vector_types.h	/^  const_iterator find(const key_type& key) const {$/;"	f	class:folly::sorted_vector_set	access:public	signature:(const key_type& key) const
find	.\sorted_vector_types.h	/^  iterator find(const key_type& key) {$/;"	f	class:folly::sorted_vector_map	access:public	signature:(const key_type& key)
find	.\sorted_vector_types.h	/^  iterator find(const key_type& key) {$/;"	f	class:folly::sorted_vector_set	access:public	signature:(const key_type& key)
findAddress	.\experimental\symbolizer\Dwarf.cpp	/^bool Dwarf::LineNumberVM::findAddress(uintptr_t target, Path& file,$/;"	f	class:folly::symbolizer::Dwarf::LineNumberVM	signature:(uintptr_t target, Path& file, uint64_t& line)
findAddress	.\experimental\symbolizer\Dwarf.cpp	/^bool Dwarf::findAddress(uintptr_t address, LocationInfo& locationInfo) const {$/;"	f	class:folly::symbolizer::Dwarf	signature:(uintptr_t address, LocationInfo& locationInfo) const
findAddress	.\experimental\symbolizer\Dwarf.h	/^    bool findAddress(uintptr_t address, Path& file, uint64_t& line);$/;"	p	class:folly::symbolizer::Dwarf::LineNumberVM	access:public	signature:(uintptr_t address, Path& file, uint64_t& line)
findAddress	.\experimental\symbolizer\Dwarf.h	/^  bool findAddress(uintptr_t address, LocationInfo& info) const;$/;"	p	class:folly::symbolizer::Dwarf	access:public	signature:(uintptr_t address, LocationInfo& info) const
findAt	.\AtomicHashArray.h	/^  const_iterator findAt(uint32_t idx) const {$/;"	f	class:folly::AtomicHashArray	access:public	signature:(uint32_t idx) const
findAt	.\AtomicHashArray.h	/^  iterator findAt(uint32_t idx) {$/;"	f	class:folly::AtomicHashArray	access:public	signature:(uint32_t idx)
findAt	.\AtomicHashMap.h	/^  const_iterator findAt(uint32_t idx) const {$/;"	f	class:folly::AtomicHashMap	access:public	signature:(uint32_t idx) const
findAt	.\AtomicHashMap.h	/^  iterator findAt(uint32_t idx) {$/;"	f	class:folly::AtomicHashMap	access:public	signature:(uint32_t idx)
findAtInternal	.\AtomicHashMap-inl.h	/^findAtInternal(uint32_t idx) const {$/;"	f	class:folly::AtomicHashMap	signature:(uint32_t idx) const
findAtInternal	.\AtomicHashMap.h	/^  SimpleRetT findAtInternal(uint32_t idx) const;$/;"	p	class:folly::AtomicHashMap	access:private	signature:(uint32_t idx) const
findByChildFd	.\Subprocess.cpp	/^int Subprocess::findByChildFd(int childFd) const {$/;"	f	class:folly::Subprocess	signature:(int childFd) const
findByChildFd	.\Subprocess.h	/^  int findByChildFd(int childFd) const;$/;"	p	class:folly::Subprocess	access:private	signature:(int childFd) const
findFirstOfRandom	.\test\RangeFindBenchmark.cpp	/^void findFirstOfRandom(Func func, size_t iters) {$/;"	f	signature:(Func func, size_t iters)
findFirstOfRange	.\test\RangeFindBenchmark.cpp	/^void findFirstOfRange(StringPiece needles, Func func, size_t n) {$/;"	f	signature:(StringPiece needles, Func func, size_t n)
findInIndex	.\EvictingCacheMap.h	/^  typename NodeMap::const_iterator findInIndex(const TKey& key) const {$/;"	f	class:folly::EvictingCacheMap	access:private	signature:(const TKey& key) const
findInIndex	.\EvictingCacheMap.h	/^  typename NodeMap::iterator findInIndex(const TKey& key) {$/;"	f	class:folly::EvictingCacheMap	access:private	signature:(const TKey& key)
findInsertionPoint	.\ConcurrentSkipList.h	/^  static int findInsertionPoint(NodeType *cur, int cur_layer,$/;"	f	class:folly::ConcurrentSkipList	access:private	signature:(NodeType *cur, int cur_layer, const value_type &data, NodeType *preds[], NodeType *succs[])
findInsertionPointGetMaxLayer	.\ConcurrentSkipList.h	/^  int findInsertionPointGetMaxLayer(const value_type &data,$/;"	f	class:folly::ConcurrentSkipList	access:private	signature:(const value_type &data, NodeType *preds[], NodeType *succs[], int *max_layer) const
findInternal	.\AtomicHashArray-inl.h	/^findInternal(const KeyT key_in) {$/;"	f	class:folly::AtomicHashArray	signature:(const KeyT key_in)
findInternal	.\AtomicHashArray.h	/^  SimpleRetT findInternal(const KeyT key);$/;"	p	class:folly::AtomicHashArray	access:private	signature:(const KeyT key)
findInternal	.\AtomicHashMap-inl.h	/^findInternal(const KeyT k) const {$/;"	f	class:folly::AtomicHashMap	signature:(const KeyT k) const
findInternal	.\AtomicHashMap.h	/^  SimpleRetT findInternal(const KeyT k) const;$/;"	p	class:folly::AtomicHashMap	access:private	signature:(const KeyT k) const
findNode	.\ConcurrentSkipList.h	/^  std::pair<NodeType*, int> findNode(const value_type &data) const {$/;"	f	class:folly::ConcurrentSkipList	access:private	signature:(const value_type &data) const
findNodeDownRight	.\ConcurrentSkipList.h	/^  std::pair<NodeType*, int> findNodeDownRight(const value_type &data) const {$/;"	f	class:folly::ConcurrentSkipList	access:private	signature:(const value_type &data) const
findNodeRightDown	.\ConcurrentSkipList.h	/^  std::pair<NodeType*, int> findNodeRightDown(const value_type &data) const {$/;"	f	class:folly::ConcurrentSkipList	access:private	signature:(const value_type &data) const
findRecord	.\io\RecordIO-inl.h	/^inline RecordInfo findRecord(ByteRange range, uint32_t fileId) {$/;"	f	namespace:folly::recordio_helpers	signature:(ByteRange range, uint32_t fileId)
findRecord	.\io\RecordIO.cpp	/^RecordInfo findRecord(ByteRange searchRange,$/;"	f	namespace:folly::recordio_helpers	signature:(ByteRange searchRange, ByteRange wholeRange, uint32_t fileId)
findRecord	.\io\RecordIO.h	/^RecordInfo findRecord(ByteRange range, uint32_t fileId);$/;"	p	namespace:folly::recordio_helpers	signature:(ByteRange range, uint32_t fileId)
findRecord	.\io\RecordIO.h	/^RecordInfo findRecord(ByteRange searchRange,$/;"	p	namespace:folly::recordio_helpers	signature:(ByteRange searchRange, ByteRange wholeRange, uint32_t fileId)
findSuccessful	.\test\FBStringTestBenchmarks.cpp.h	/^void BENCHFUN(findSuccessful)(int iters, int arg) {$/;"	f	signature:(int iters, int arg)
findUnsuccessful	.\test\FBStringTestBenchmarks.cpp.h	/^void BENCHFUN(findUnsuccessful)(int iters, int arg) {$/;"	f	signature:(int iters, int arg)
findWithoutPromotion	.\EvictingCacheMap.h	/^  const_iterator findWithoutPromotion(const TKey& key) const {$/;"	f	class:folly::EvictingCacheMap	access:public	signature:(const TKey& key) const
findWithoutPromotion	.\EvictingCacheMap.h	/^  iterator findWithoutPromotion(const TKey& key) {$/;"	f	class:folly::EvictingCacheMap	access:public	signature:(const TKey& key)
find_first_byte_of	.\test\RangeTest.cpp	/^  static size_t find_first_byte_of(StringPiece haystack, StringPiece needles) {$/;"	f	class:NeedleFinderTest	access:public	signature:(StringPiece haystack, StringPiece needles)
find_first_byte_of	.\test\RangeTest.cpp	/^  static size_t find_first_byte_of(StringPiece haystack, StringPiece needles) {$/;"	f	struct:ByteSetNeedleFinder	access:public	signature:(StringPiece haystack, StringPiece needles)
find_first_byte_of	.\test\RangeTest.cpp	/^  static size_t find_first_byte_of(StringPiece haystack, StringPiece needles) {$/;"	f	struct:MemchrNeedleFinder	access:public	signature:(StringPiece haystack, StringPiece needles)
find_first_byte_of	.\test\RangeTest.cpp	/^  static size_t find_first_byte_of(StringPiece haystack, StringPiece needles) {$/;"	f	struct:NoSseNeedleFinder	access:public	signature:(StringPiece haystack, StringPiece needles)
find_first_byte_of	.\test\RangeTest.cpp	/^  static size_t find_first_byte_of(StringPiece haystack, StringPiece needles) {$/;"	f	struct:SseNeedleFinder	access:public	signature:(StringPiece haystack, StringPiece needles)
find_first_of	.\Range.h	/^  size_type find_first_of(Iter needles) const {$/;"	f	class:folly::Range	access:public	signature:(Iter needles) const
find_first_of	.\Range.h	/^  size_type find_first_of(Iter needles, size_t pos) const {$/;"	f	class:folly::Range	access:public	signature:(Iter needles, size_t pos) const
find_first_of	.\Range.h	/^  size_type find_first_of(Iter needles, size_t pos, size_t n) const {$/;"	f	class:folly::Range	access:public	signature:(Iter needles, size_t pos, size_t n) const
find_first_of	.\Range.h	/^  size_type find_first_of(const_range_type needles) const {$/;"	f	class:folly::Range	access:public	signature:(const_range_type needles) const
find_first_of	.\Range.h	/^  size_type find_first_of(const_range_type needles, size_t pos) const {$/;"	f	class:folly::Range	access:public	signature:(const_range_type needles, size_t pos) const
find_first_of	.\Range.h	/^  size_type find_first_of(value_type c) const {$/;"	f	class:folly::Range	access:public	signature:(value_type c) const
find_first_of	.\Range.h	/^  size_type find_first_of(value_type c, size_t pos) const {$/;"	f	class:folly::Range	access:public	signature:(value_type c, size_t pos) const
fingerprint128	.\Fingerprint.h	/^inline void fingerprint128(StringPiece str,$/;"	f	namespace:folly	signature:(StringPiece str, uint64_t* msb, uint64_t* lsb)
fingerprint64	.\Fingerprint.h	/^inline uint64_t fingerprint64(StringPiece str) {$/;"	f	namespace:folly	signature:(StringPiece str)
fingerprint96	.\Fingerprint.h	/^inline void fingerprint96(StringPiece str,$/;"	f	namespace:folly	signature:(StringPiece str, uint64_t* msb, uint32_t* lsb)
finish	.\GroupVarint.h	/^  void finish() {$/;"	f	class:folly::GroupVarintEncoder	access:public	signature:()
finish	.\experimental\EliasFanoCoding.h	/^  const EliasFanoCompressedList& finish() const {$/;"	f	struct:folly::compression::EliasFanoEncoder	access:public	signature:() const
fireAndForget	.\wangle\Later.h	/^  void fireAndForget() __attribute__ ((__deprecated__)) { launch(); }$/;"	f	class:folly::wangle::Later	access:public	signature:()
first	.\ConcurrentSkipList.h	/^  const key_type *first() const { return sl_->first(); }$/;"	f	class:folly::ConcurrentSkipList::Accessor	access:public	signature:() const
first	.\ConcurrentSkipList.h	/^  const value_type *first() const {$/;"	f	class:folly::ConcurrentSkipList	access:private	signature:() const
first	.\gen\Base-inl.h	/^static const detail::First first;$/;"	m	namespace:folly::gen
firstTime_	.\stats\BucketedTimeSeries.h	/^  TimeType firstTime_;   \/\/ time of first update() since clear()\/constructor$/;"	m	class:folly::BucketedTimeSeries	access:private
firstValue_	.\stats\TimeseriesHistogram.h	/^  ValueType firstValue_;$/;"	m	class:folly::TimeseriesHistogram	access:private
first_	.\gen\Core-inl.h	/^  First first_;$/;"	m	class:folly::gen::detail::Chain	access:private
first_	.\gen\Core-inl.h	/^  First first_;$/;"	m	class:folly::gen::detail::Composed	access:private
fixFrameArray	.\experimental\symbolizer\Symbolizer.h	/^bool fixFrameArray(FrameArray<N>& fa, ssize_t n) {$/;"	f	namespace:folly::symbolizer::detail	signature:(FrameArray<N>& fa, ssize_t n)
flagProvider	.\test\IPAddressTest.cpp	/^static vector<AddressFlags> flagProvider = {$/;"	v	file:
flags	.\io\IOBuf.cpp	/^  std::atomic<uint16_t> flags;$/;"	m	struct:folly::IOBuf::HeapPrefix	file:	access:public
flags	.\io\IOBuf.h	/^  inline uintptr_t flags() const {$/;"	f	class:folly::IOBuf	access:private	signature:() const
flags	.\io\RecordIO-inl.h	/^  uint16_t flags;         \/\/ reserved (must be 0)$/;"	m	struct:folly::recordio_helpers::detail::Header	access:public
flags	.\test\IPAddressTest.h	/^  uint8_t flags;$/;"	m	struct:folly::AddressFlags	access:public
flags	.\test\stl_tests\StlVectorTest.cpp	/^  static const Flags flags = f;$/;"	m	struct:Data	file:	access:public
flags_	.\ConcurrentSkipList-inl.h	/^  std::atomic<uint16_t> flags_;$/;"	m	class:folly::detail::SkipListNode	access:private
flip	.\detail\BitIteratorDetail.h	/^  void flip() {$/;"	f	class:folly::bititerator_detail::BitReference	access:public	signature:()
flockNoInt	.\FileUtil.cpp	/^int flockNoInt(int fd, int operation) {$/;"	f	namespace:folly	signature:(int fd, int operation)
flockNoInt	.\FileUtil.h	/^int flockNoInt(int fd, int operation);$/;"	p	namespace:folly	signature:(int fd, int operation)
flush	.\ThreadCachedInt.h	/^    void flush() const {$/;"	f	struct:folly::ThreadCachedInt::IntCache	access:public	signature:() const
flush	.\experimental\symbolizer\SignalHandler.cpp	/^void flush() {$/;"	f	namespace:folly::symbolizer::__anon36	signature:()
flush	.\experimental\symbolizer\Symbolizer.cpp	/^void FDSymbolizePrinter::flush() {$/;"	f	class:folly::symbolizer::FDSymbolizePrinter	signature:()
flush	.\experimental\symbolizer\Symbolizer.h	/^  void flush();$/;"	p	class:folly::symbolizer::FDSymbolizePrinter	access:public	signature:()
flush	.\gen\String-inl.h	/^bool StreamSplitter<Callback>::flush() {$/;"	f	class:folly::gen::StreamSplitter	signature:()
flush	.\gen\String.h	/^  bool flush();$/;"	p	class:folly::gen::StreamSplitter	access:public	signature:()
flush	.\stats\MultiLevelTimeSeries-defs.h	/^void MultiLevelTimeSeries<VT, TT>::flush() {$/;"	f	class:folly::MultiLevelTimeSeries	signature:()
flush	.\stats\MultiLevelTimeSeries.h	/^  void flush();$/;"	p	class:folly::MultiLevelTimeSeries	access:public	signature:()
flushBuffer	.\gen\File-inl.h	/^  void flushBuffer() const {$/;"	f	class:folly::gen::detail::FileWriter	access:private	signature:() const
flushLocalMallocCaches	.\detail\MemoryIdler.cpp	/^void MemoryIdler::flushLocalMallocCaches() {$/;"	f	class:folly::detail::MemoryIdler	signature:()
flushLocalMallocCaches	.\detail\MemoryIdler.h	/^  static void flushLocalMallocCaches();$/;"	p	struct:folly::detail::MemoryIdler	access:public	signature:()
fn	.\wangle\detail\State.h	/^  std::function<void(std::vector<Try<T>>&&)> fn;$/;"	m	struct:folly::wangle::detail::WhenAllLaterContext	access:public
fnRunner_	.\io\async\EventBase.h	/^  std::unique_ptr<FunctionRunner> fnRunner_;$/;"	m	class:folly::EventBase	access:private
fn_	.\io\async\EventBase.h	/^    void (*fn_)(void*);$/;"	m	class:folly::EventBase::RunInLoopCallback	access:private
fn_	.\wangle\OpaqueCallbackShunt.h	/^  std::function<void(T&&)> fn_;$/;"	m	class:folly::wangle::OpaqueCallbackLaterShunt	access:private
fnv32	.\Hash.h	/^inline uint32_t fnv32(const char* s,$/;"	f	namespace:folly::hash	signature:(const char* s, uint32_t hash = FNV_32_HASH_START)
fnv32	.\Hash.h	/^inline uint32_t fnv32(const std::string& str,$/;"	f	namespace:folly::hash	signature:(const std::string& str, uint32_t hash = FNV_32_HASH_START)
fnv32_buf	.\Hash.h	/^inline uint32_t fnv32_buf(const void* buf,$/;"	f	namespace:folly::hash	signature:(const void* buf, int n, uint32_t hash = FNV_32_HASH_START)
fnv64	.\Hash.h	/^inline uint64_t fnv64(const char* s,$/;"	f	namespace:folly::hash	signature:(const char* s, uint64_t hash = FNV_64_HASH_START)
fnv64	.\Hash.h	/^inline uint64_t fnv64(const std::string& str,$/;"	f	namespace:folly::hash	signature:(const std::string& str, uint64_t hash = FNV_64_HASH_START)
fnv64_buf	.\Hash.h	/^inline uint64_t fnv64_buf(const void* buf,$/;"	f	namespace:folly::hash	signature:(const void* buf, int n, uint64_t hash = FNV_64_HASH_START)
fold_	.\gen\Base-inl.h	/^  Fold fold_;$/;"	m	class:folly::gen::detail::FoldLeft	access:private
foldl	.\gen\Base.h	/^FoldLeft foldl(Seed seed = Seed(),$/;"	f	namespace:folly::gen	signature:(Seed seed = Seed(), Fold fold = Fold())
folly	.\ApplyTuple.h	/^namespace folly {$/;"	n
folly	.\Arena-inl.h	/^namespace folly {$/;"	n
folly	.\Arena.h	/^namespace folly {$/;"	n
folly	.\AtomicBitSet.h	/^namespace folly {$/;"	n
folly	.\AtomicHashArray-inl.h	/^namespace folly {$/;"	n
folly	.\AtomicHashArray.h	/^namespace folly {$/;"	n
folly	.\AtomicHashMap-inl.h	/^namespace folly {$/;"	n
folly	.\AtomicHashMap.h	/^namespace folly {$/;"	n
folly	.\AtomicStruct.h	/^namespace folly {$/;"	n
folly	.\Baton.h	/^namespace folly {$/;"	n
folly	.\Benchmark.cpp	/^namespace folly {$/;"	n	file:
folly	.\Benchmark.h	/^namespace folly {$/;"	n
folly	.\Bits.cpp	/^namespace folly {$/;"	n	file:
folly	.\Bits.h	/^namespace folly {$/;"	n
folly	.\Checksum.cpp	/^namespace folly {$/;"	n	file:
folly	.\Checksum.h	/^namespace folly {$/;"	n
folly	.\ConcurrentSkipList-inl.h	/^namespace folly { namespace detail {$/;"	n
folly	.\ConcurrentSkipList.h	/^namespace folly {$/;"	n
folly	.\Conv.cpp	/^namespace folly {$/;"	n	file:
folly	.\Conv.h	/^namespace folly {$/;"	n
folly	.\CpuId.h	/^namespace folly {$/;"	n
folly	.\Demangle.cpp	/^namespace folly {$/;"	n	file:
folly	.\Demangle.h	/^namespace folly {$/;"	n
folly	.\DiscriminatedPtr.h	/^namespace folly {$/;"	n
folly	.\DynamicConverter.h	/^namespace folly {$/;"	n
folly	.\EvictingCacheMap.h	/^namespace folly {$/;"	n
folly	.\Exception.h	/^namespace folly {$/;"	n
folly	.\ExceptionWrapper.h	/^namespace folly {$/;"	n
folly	.\FBVector.h	/^namespace folly {$/;"	n
folly	.\File.cpp	/^namespace folly {$/;"	n	file:
folly	.\File.h	/^namespace folly {$/;"	n
folly	.\FileUtil.cpp	/^namespace folly {$/;"	n	file:
folly	.\FileUtil.h	/^namespace folly {$/;"	n
folly	.\Fingerprint.h	/^namespace folly {$/;"	n
folly	.\Foreach.h	/^namespace folly { namespace detail {$/;"	n
folly	.\Format-inl.h	/^namespace folly {$/;"	n
folly	.\Format.cpp	/^namespace folly {$/;"	n	file:
folly	.\Format.h	/^namespace folly {$/;"	n
folly	.\FormatArg.h	/^namespace folly {$/;"	n
folly	.\GroupVarint.cpp	/^namespace folly {$/;"	n	file:
folly	.\GroupVarint.h	/^namespace folly {$/;"	n
folly	.\Hash.h	/^namespace folly { namespace hash {$/;"	n
folly	.\IPAddress.cpp	/^namespace folly {$/;"	n	file:
folly	.\IPAddress.h	/^namespace folly {$/;"	n
folly	.\IPAddressException.h	/^namespace folly {$/;"	n
folly	.\IPAddressV4.cpp	/^namespace folly {$/;"	n	file:
folly	.\IPAddressV4.h	/^namespace folly {$/;"	n
folly	.\IPAddressV6.cpp	/^namespace folly {$/;"	n	file:
folly	.\IPAddressV6.h	/^namespace folly {$/;"	n
folly	.\IndexedMemPool.h	/^namespace folly {$/;"	n
folly	.\IntrusiveList.h	/^namespace folly {$/;"	n
folly	.\Lazy.h	/^namespace folly {$/;"	n
folly	.\LifoSem.cpp	/^namespace folly {$/;"	n	file:
folly	.\LifoSem.h	/^namespace folly {$/;"	n
folly	.\MPMCPipeline.h	/^namespace folly {$/;"	n
folly	.\MPMCQueue.h	/^namespace folly {$/;"	n
folly	.\MacAddress.cpp	/^namespace folly {$/;"	n	file:
folly	.\MacAddress.h	/^namespace folly {$/;"	n
folly	.\Malloc.cpp	/^namespace folly {$/;"	n	file:
folly	.\Malloc.h	/^namespace folly {$/;"	n
folly	.\MapUtil.h	/^namespace folly {$/;"	n
folly	.\Memory.h	/^namespace folly {$/;"	n
folly	.\MemoryMapping.cpp	/^namespace folly {$/;"	n	file:
folly	.\MemoryMapping.h	/^namespace folly {$/;"	n
folly	.\Merge.h	/^namespace folly {$/;"	n
folly	.\MoveWrapper.h	/^namespace folly {$/;"	n
folly	.\Optional.h	/^namespace folly {$/;"	n
folly	.\PackedSyncPtr.h	/^namespace folly {$/;"	n
folly	.\Padded.h	/^namespace folly {$/;"	n
folly	.\ProducerConsumerQueue.h	/^namespace folly {$/;"	n
folly	.\RWSpinLock.h	/^namespace folly {$/;"	n
folly	.\Random-inl.h	/^namespace folly {$/;"	n
folly	.\Random.cpp	/^namespace folly {$/;"	n	file:
folly	.\Random.h	/^namespace folly {$/;"	n
folly	.\Range.cpp	/^namespace folly {$/;"	n	file:
folly	.\Range.h	/^namespace folly {$/;"	n
folly	.\SafeAssert.cpp	/^namespace folly { namespace detail {$/;"	n	file:
folly	.\SafeAssert.h	/^namespace folly { namespace detail {$/;"	n
folly	.\ScopeGuard.h	/^namespace folly {$/;"	n
folly	.\SmallLocks.h	/^namespace folly {$/;"	n
folly	.\SocketAddress.cpp	/^namespace folly {$/;"	n	file:
folly	.\SocketAddress.h	/^namespace folly {$/;"	n
folly	.\SpookyHashV1.cpp	/^namespace folly {$/;"	n	file:
folly	.\SpookyHashV1.h	/^namespace folly {$/;"	n
folly	.\SpookyHashV2.cpp	/^namespace folly {$/;"	n	file:
folly	.\SpookyHashV2.h	/^namespace folly {$/;"	n
folly	.\String-inl.h	/^namespace folly {$/;"	n
folly	.\String.cpp	/^namespace folly {$/;"	n	file:
folly	.\String.h	/^namespace folly {$/;"	n
folly	.\Subprocess.cpp	/^namespace folly {$/;"	n	file:
folly	.\Subprocess.h	/^namespace folly {$/;"	n
folly	.\Synchronized.h	/^namespace folly {$/;"	n
folly	.\ThreadCachedArena.cpp	/^namespace folly {$/;"	n	file:
folly	.\ThreadCachedArena.h	/^namespace folly {$/;"	n
folly	.\ThreadCachedInt.h	/^namespace folly {$/;"	n
folly	.\ThreadLocal.h	/^namespace folly {$/;"	n
folly	.\ThreadName.h	/^namespace folly {$/;"	n
folly	.\TimeoutQueue.cpp	/^namespace folly {$/;"	n	file:
folly	.\TimeoutQueue.h	/^namespace folly {$/;"	n
folly	.\Traits.h	/^namespace folly {$/;"	n
folly	.\Unicode.cpp	/^namespace folly {$/;"	n	file:
folly	.\Unicode.h	/^namespace folly {$/;"	n
folly	.\Uri-inl.h	/^namespace folly {$/;"	n
folly	.\Uri.cpp	/^namespace folly {$/;"	n	file:
folly	.\Uri.h	/^namespace folly {$/;"	n
folly	.\Varint.h	/^namespace folly {$/;"	n
folly	.\Version.cpp	/^namespace folly { namespace detail {$/;"	n	file:
folly	.\detail\BitIteratorDetail.h	/^namespace folly {$/;"	n
folly	.\detail\BitsDetail.h	/^namespace folly {$/;"	n
folly	.\detail\CacheLocality.cpp	/^namespace folly { namespace detail {$/;"	n	file:
folly	.\detail\CacheLocality.h	/^namespace folly { namespace detail {$/;"	n
folly	.\detail\ChecksumDetail.h	/^namespace folly { namespace detail {$/;"	n
folly	.\detail\DiscriminatedPtrDetail.h	/^namespace folly {$/;"	n
folly	.\detail\ExceptionWrapper.h	/^namespace folly { namespace detail {$/;"	n
folly	.\detail\FileUtilDetail.h	/^namespace folly { namespace fileutil_detail {$/;"	n
folly	.\detail\FingerprintPolynomial.h	/^namespace folly {$/;"	n
folly	.\detail\Futex.cpp	/^namespace folly { namespace detail {$/;"	n	file:
folly	.\detail\Futex.h	/^namespace folly { namespace detail {$/;"	n
folly	.\detail\GroupVarintDetail.h	/^namespace folly {$/;"	n
folly	.\detail\IPAddress.h	/^namespace folly { namespace detail {$/;"	n
folly	.\detail\MPMCPipelineDetail.h	/^namespace folly {$/;"	n
folly	.\detail\MemoryIdler.cpp	/^namespace folly { namespace detail {$/;"	n	file:
folly	.\detail\MemoryIdler.h	/^namespace folly { namespace detail {$/;"	n
folly	.\detail\MemoryIdler.h	/^namespace folly {$/;"	n
folly	.\detail\SlowFingerprint.h	/^namespace folly {$/;"	n
folly	.\detail\Stats.h	/^namespace folly { namespace detail {$/;"	n
folly	.\detail\ThreadLocalDetail.h	/^namespace folly {$/;"	n
folly	.\detail\UncaughtExceptionCounter.h	/^namespace folly { namespace detail {$/;"	n
folly	.\dynamic-inl.h	/^namespace folly {$/;"	n
folly	.\dynamic.cpp	/^namespace folly {$/;"	n	file:
folly	.\dynamic.h	/^namespace folly {$/;"	n
folly	.\experimental\Bits.h	/^namespace folly {$/;"	n
folly	.\experimental\EliasFanoCoding.h	/^namespace folly { namespace compression {$/;"	n
folly	.\experimental\EventCount.h	/^namespace folly {$/;"	n
folly	.\experimental\Singleton.cpp	/^namespace folly {$/;"	n	file:
folly	.\experimental\Singleton.h	/^namespace folly {$/;"	n
folly	.\experimental\TestUtil.cpp	/^namespace folly {$/;"	n	file:
folly	.\experimental\TestUtil.h	/^namespace folly {$/;"	n
folly	.\experimental\exception_tracer\ExceptionTracer.cpp	/^namespace folly {$/;"	n	file:
folly	.\experimental\exception_tracer\ExceptionTracer.h	/^namespace folly {$/;"	n
folly	.\experimental\exception_tracer\StackTrace.cpp	/^namespace folly { namespace exception_tracer {$/;"	n	file:
folly	.\experimental\exception_tracer\StackTrace.h	/^namespace folly { namespace exception_tracer {$/;"	n
folly	.\experimental\io\AsyncIO.cpp	/^namespace folly {$/;"	n	file:
folly	.\experimental\io\AsyncIO.h	/^namespace folly {$/;"	n
folly	.\experimental\io\FsUtil.cpp	/^namespace folly {$/;"	n	file:
folly	.\experimental\io\FsUtil.h	/^namespace folly {$/;"	n
folly	.\experimental\io\HugePages.cpp	/^namespace folly {$/;"	n	file:
folly	.\experimental\io\HugePages.h	/^namespace folly {$/;"	n
folly	.\experimental\symbolizer\Dwarf.cpp	/^namespace folly {$/;"	n	file:
folly	.\experimental\symbolizer\Dwarf.h	/^namespace folly {$/;"	n
folly	.\experimental\symbolizer\Elf-inl.h	/^namespace folly {$/;"	n
folly	.\experimental\symbolizer\Elf.cpp	/^namespace folly {$/;"	n	file:
folly	.\experimental\symbolizer\Elf.h	/^namespace folly {$/;"	n
folly	.\experimental\symbolizer\ElfCache.cpp	/^namespace folly { namespace symbolizer {$/;"	n	file:
folly	.\experimental\symbolizer\ElfCache.h	/^namespace folly { namespace symbolizer {$/;"	n
folly	.\experimental\symbolizer\LineReader.cpp	/^namespace folly { namespace symbolizer {$/;"	n	file:
folly	.\experimental\symbolizer\LineReader.h	/^namespace folly { namespace symbolizer {$/;"	n
folly	.\experimental\symbolizer\SignalHandler.cpp	/^namespace folly { namespace symbolizer {$/;"	n	file:
folly	.\experimental\symbolizer\SignalHandler.h	/^namespace folly { namespace symbolizer {$/;"	n
folly	.\experimental\symbolizer\StackTrace.cpp	/^namespace folly { namespace symbolizer {$/;"	n	file:
folly	.\experimental\symbolizer\StackTrace.h	/^namespace folly { namespace symbolizer {$/;"	n
folly	.\experimental\symbolizer\Symbolizer.cpp	/^namespace folly {$/;"	n	file:
folly	.\experimental\symbolizer\Symbolizer.h	/^namespace folly {$/;"	n
folly	.\experimental\symbolizer\test\LineReaderTest.cpp	/^namespace folly { namespace symbolizer { namespace test {$/;"	n	file:
folly	.\experimental\symbolizer\test\SignalHandlerTest.cpp	/^namespace folly { namespace symbolizer { namespace test {$/;"	n	file:
folly	.\experimental\symbolizer\test\SignalHandlerTest.h	/^namespace folly { namespace symbolizer { namespace test {$/;"	n
folly	.\experimental\symbolizer\test\SymbolizerTest.cpp	/^namespace folly { namespace symbolizer { namespace test {$/;"	n	file:
folly	.\experimental\test\CodingTestUtils.h	/^namespace folly { namespace compression {$/;"	n
folly	.\experimental\wangle\ConnectionManager.cpp	/^namespace folly { namespace wangle {$/;"	n	file:
folly	.\experimental\wangle\ConnectionManager.h	/^namespace folly { namespace wangle {$/;"	n
folly	.\experimental\wangle\ManagedConnection.cpp	/^namespace folly { namespace wangle {$/;"	n	file:
folly	.\experimental\wangle\ManagedConnection.h	/^namespace folly { namespace wangle {$/;"	n
folly	.\experimental\wangle\concurrent\BlockingQueue.h	/^namespace folly { namespace wangle {$/;"	n
folly	.\experimental\wangle\concurrent\CPUThreadPoolExecutor.cpp	/^namespace folly { namespace wangle {$/;"	n	file:
folly	.\experimental\wangle\concurrent\CPUThreadPoolExecutor.h	/^namespace folly { namespace wangle {$/;"	n
folly	.\experimental\wangle\concurrent\Executor.h	/^namespace folly { namespace wangle {$/;"	n
folly	.\experimental\wangle\concurrent\IOThreadPoolExecutor.cpp	/^namespace folly { namespace wangle {$/;"	n	file:
folly	.\experimental\wangle\concurrent\IOThreadPoolExecutor.h	/^namespace folly { namespace wangle {$/;"	n
folly	.\experimental\wangle\concurrent\LifoSemMPMCQueue.h	/^namespace folly { namespace wangle {$/;"	n
folly	.\experimental\wangle\concurrent\NamedThreadFactory.h	/^namespace folly { namespace wangle {$/;"	n
folly	.\experimental\wangle\concurrent\ThreadFactory.h	/^namespace folly { namespace wangle {$/;"	n
folly	.\experimental\wangle\concurrent\ThreadPoolExecutor.cpp	/^namespace folly { namespace wangle {$/;"	n	file:
folly	.\experimental\wangle\concurrent\ThreadPoolExecutor.h	/^namespace folly { namespace wangle {$/;"	n
folly	.\gen\Base-inl.h	/^namespace folly { namespace gen {$/;"	n
folly	.\gen\Base.h	/^namespace folly { namespace gen {$/;"	n
folly	.\gen\Combine-inl.h	/^namespace folly {$/;"	n
folly	.\gen\Combine.h	/^namespace folly {$/;"	n
folly	.\gen\Core-inl.h	/^namespace folly { namespace gen {$/;"	n
folly	.\gen\Core.h	/^namespace folly { namespace gen {$/;"	n
folly	.\gen\File-inl.h	/^namespace folly {$/;"	n
folly	.\gen\File.h	/^namespace folly {$/;"	n
folly	.\gen\Parallel-inl.h	/^namespace folly {$/;"	n
folly	.\gen\Parallel.h	/^namespace folly { namespace gen {$/;"	n
folly	.\gen\ParallelMap-inl.h	/^namespace folly { namespace gen { namespace detail {$/;"	n
folly	.\gen\ParallelMap.h	/^namespace folly { namespace gen {$/;"	n
folly	.\gen\String-inl.h	/^namespace folly {$/;"	n
folly	.\gen\String.h	/^namespace folly {$/;"	n
folly	.\io\Compression.cpp	/^namespace folly { namespace io {$/;"	n	file:
folly	.\io\Compression.h	/^namespace folly { namespace io {$/;"	n
folly	.\io\Cursor.h	/^namespace folly { namespace io {$/;"	n
folly	.\io\IOBuf.cpp	/^namespace folly {$/;"	n	file:
folly	.\io\IOBuf.h	/^namespace folly {$/;"	n
folly	.\io\IOBufQueue.cpp	/^namespace folly {$/;"	n	file:
folly	.\io\IOBufQueue.h	/^namespace folly {$/;"	n
folly	.\io\RecordIO-inl.h	/^namespace folly {$/;"	n
folly	.\io\RecordIO.cpp	/^namespace folly {$/;"	n	file:
folly	.\io\RecordIO.h	/^namespace folly {$/;"	n
folly	.\io\TypedIOBuf.h	/^namespace folly {$/;"	n
folly	.\io\async\AsyncTimeout.cpp	/^namespace folly {$/;"	n	file:
folly	.\io\async\AsyncTimeout.h	/^namespace folly {$/;"	n
folly	.\io\async\DelayedDestruction.h	/^namespace folly {$/;"	n
folly	.\io\async\EventBase.cpp	/^namespace folly {$/;"	n	file:
folly	.\io\async\EventBase.h	/^namespace folly {$/;"	n
folly	.\io\async\EventHandler.cpp	/^namespace folly {$/;"	n	file:
folly	.\io\async\EventHandler.h	/^namespace folly {$/;"	n
folly	.\io\async\EventUtil.h	/^namespace folly {$/;"	n
folly	.\io\async\HHWheelTimer.cpp	/^namespace folly {$/;"	n	file:
folly	.\io\async\HHWheelTimer.h	/^namespace folly {$/;"	n
folly	.\io\async\NotificationQueue.h	/^namespace folly {$/;"	n
folly	.\io\async\Request.cpp	/^namespace folly {$/;"	n	file:
folly	.\io\async\Request.h	/^namespace folly {$/;"	n
folly	.\io\async\TimeoutManager.h	/^namespace folly {$/;"	n
folly	.\io\test\CompressionTest.cpp	/^namespace folly { namespace io { namespace test {$/;"	n	file:
folly	.\io\test\RecordIOTest.cpp	/^namespace folly { namespace test {$/;"	n	file:
folly	.\json.cpp	/^namespace folly {$/;"	n	file:
folly	.\json.h	/^namespace folly {$/;"	n
folly	.\small_vector.h	/^namespace folly {$/;"	n
folly	.\sorted_vector_types.h	/^namespace folly {$/;"	n
folly	.\stats\BucketedTimeSeries-defs.h	/^namespace folly {$/;"	n
folly	.\stats\BucketedTimeSeries.h	/^namespace folly {$/;"	n
folly	.\stats\Histogram-defs.h	/^namespace folly {$/;"	n
folly	.\stats\Histogram.h	/^namespace folly {$/;"	n
folly	.\stats\Instantiations.cpp	/^namespace folly {$/;"	n	file:
folly	.\stats\MultiLevelTimeSeries-defs.h	/^namespace folly {$/;"	n
folly	.\stats\MultiLevelTimeSeries.h	/^namespace folly {$/;"	n
folly	.\stats\TimeseriesHistogram-defs.h	/^namespace folly {$/;"	n
folly	.\stats\TimeseriesHistogram.h	/^namespace folly {$/;"	n
folly	.\test\AtomicBitSetTest.cpp	/^namespace folly { namespace test {$/;"	n	file:
folly	.\test\DeterministicSchedule.cpp	/^namespace folly { namespace detail {$/;"	n	file:
folly	.\test\DeterministicSchedule.cpp	/^namespace folly { namespace test {$/;"	n	file:
folly	.\test\DeterministicSchedule.h	/^namespace folly { namespace test {$/;"	n
folly	.\test\DynamicConverterTest.cpp	/^namespace folly {$/;"	n	file:
folly	.\test\ExceptionTest.cpp	/^namespace folly { namespace test {$/;"	n	file:
folly	.\test\FileUtilTest.cpp	/^namespace folly { namespace test {$/;"	n	file:
folly	.\test\FormatTest.cpp	/^namespace folly {$/;"	n	file:
folly	.\test\IPAddressTest.h	/^namespace folly {$/;"	n
folly	.\test\LazyTest.cpp	/^namespace folly {$/;"	n	file:
folly	.\test\MPMCPipelineTest.cpp	/^namespace folly { namespace test {$/;"	n	file:
folly	.\test\MemoryIdlerTest.cpp	/^namespace folly { namespace detail {$/;"	n	file:
folly	.\test\MemoryMappingTest.cpp	/^namespace folly {$/;"	n	file:
folly	.\test\MoveWrapperTest.cpp	/^namespace folly {$/;"	n	file:
folly	.\test\OptionalTest.cpp	/^namespace folly {$/;"	n	file:
folly	.\test\RangeFindBenchmark.cpp	/^namespace folly { namespace detail {$/;"	n	file:
folly	.\test\RangeTest.cpp	/^namespace folly { namespace detail {$/;"	n	file:
folly	.\test\RangeTest.cpp	/^namespace folly {$/;"	n	file:
folly	.\test\TraitsTest.cpp	/^namespace folly {$/;"	n	file:
folly	.\test\VarintTest.cpp	/^namespace folly { namespace test {$/;"	n	file:
folly	.\test\stl_tests\StlVectorTest.cpp	/^namespace folly {$/;"	n	file:
folly	.\wangle\Executor.h	/^namespace folly { namespace wangle {$/;"	n
folly	.\wangle\Future-inl.h	/^namespace folly { namespace wangle {$/;"	n
folly	.\wangle\Future.h	/^namespace folly { namespace wangle {$/;"	n
folly	.\wangle\GenericThreadGate.h	/^namespace folly { namespace wangle {$/;"	n
folly	.\wangle\InlineExecutor.h	/^namespace folly { namespace wangle {$/;"	n
folly	.\wangle\Later-inl.h	/^namespace folly { namespace wangle {$/;"	n
folly	.\wangle\Later.h	/^namespace folly { namespace wangle {$/;"	n
folly	.\wangle\ManualExecutor.cpp	/^namespace folly { namespace wangle {$/;"	n	file:
folly	.\wangle\ManualExecutor.h	/^namespace folly { namespace wangle {$/;"	n
folly	.\wangle\OpaqueCallbackShunt.h	/^namespace folly { namespace wangle {$/;"	n
folly	.\wangle\Promise-inl.h	/^namespace folly { namespace wangle {$/;"	n
folly	.\wangle\Promise.h	/^namespace folly { namespace wangle {$/;"	n
folly	.\wangle\QueuedImmediateExecutor.cpp	/^namespace folly { namespace wangle {$/;"	n	file:
folly	.\wangle\QueuedImmediateExecutor.h	/^namespace folly { namespace wangle {$/;"	n
folly	.\wangle\ThreadGate.cpp	/^namespace folly { namespace wangle {$/;"	n	file:
folly	.\wangle\ThreadGate.h	/^namespace folly { namespace wangle {$/;"	n
folly	.\wangle\Try-inl.h	/^namespace folly { namespace wangle {$/;"	n
folly	.\wangle\Try.h	/^namespace folly { namespace wangle {$/;"	n
folly	.\wangle\WangleException.h	/^namespace folly { namespace wangle {$/;"	n
folly	.\wangle\detail\State.h	/^namespace folly { namespace wangle { namespace detail {$/;"	n
folly::Adaptor	.\Padded.h	/^class Adaptor {$/;"	c	namespace:folly
folly::Adaptor::Adaptor	.\Padded.h	/^  Adaptor() : lastCount_(Node::kElementCount) { }$/;"	f	class:folly::Adaptor	access:public	signature:()
folly::Adaptor::Adaptor	.\Padded.h	/^  Adaptor(Adaptor&& other)$/;"	f	class:folly::Adaptor	access:public	signature:(Adaptor&& other)
folly::Adaptor::Adaptor	.\Padded.h	/^  Adaptor(const Adaptor&) = default;$/;"	p	class:folly::Adaptor	access:public	signature:(const Adaptor&)
folly::Adaptor::Adaptor	.\Padded.h	/^  explicit Adaptor(Container c, size_t lastCount=Node::kElementCount)$/;"	f	class:folly::Adaptor	access:public	signature:(Container c, size_t lastCount=Node::kElementCount)
folly::Adaptor::Adaptor	.\Padded.h	/^  explicit Adaptor(size_t n, const value_type& value = value_type())$/;"	f	class:folly::Adaptor	access:public	signature:(size_t n, const value_type& value = value_type())
folly::Adaptor::Node	.\Padded.h	/^  typedef typename Container::value_type Node;$/;"	t	class:folly::Adaptor	access:public
folly::Adaptor::back	.\Padded.h	/^  const value_type& back() const {$/;"	f	class:folly::Adaptor	access:public	signature:() const
folly::Adaptor::back	.\Padded.h	/^  value_type& back() {$/;"	f	class:folly::Adaptor	access:public	signature:()
folly::Adaptor::begin	.\Padded.h	/^  const_iterator begin() const { return cbegin(); }$/;"	f	class:folly::Adaptor	access:public	signature:() const
folly::Adaptor::begin	.\Padded.h	/^  iterator begin() {$/;"	f	class:folly::Adaptor	access:public	signature:()
folly::Adaptor::c_	.\Padded.h	/^  Container c_;  \/\/ container of Nodes$/;"	m	class:folly::Adaptor	access:private
folly::Adaptor::capacity	.\Padded.h	/^  size_type capacity() const {$/;"	f	class:folly::Adaptor	access:public	signature:() const
folly::Adaptor::cbegin	.\Padded.h	/^  const_iterator cbegin() const {$/;"	f	class:folly::Adaptor	access:public	signature:() const
folly::Adaptor::cend	.\Padded.h	/^  const_iterator cend() const {$/;"	f	class:folly::Adaptor	access:public	signature:() const
folly::Adaptor::clear	.\Padded.h	/^  void clear() {$/;"	f	class:folly::Adaptor	access:public	signature:()
folly::Adaptor::const_iterator	.\Padded.h	/^  typedef Iterator<typename Container::const_iterator> const_iterator;$/;"	t	class:folly::Adaptor	access:public
folly::Adaptor::const_reference	.\Padded.h	/^  typedef const value_type& const_reference;$/;"	t	class:folly::Adaptor	access:public
folly::Adaptor::difference_type	.\Padded.h	/^  typedef typename const_iterator::difference_type difference_type;$/;"	t	class:folly::Adaptor	access:public
folly::Adaptor::empty	.\Padded.h	/^  bool empty() const {$/;"	f	class:folly::Adaptor	access:public	signature:() const
folly::Adaptor::end	.\Padded.h	/^  const_iterator end() const { return cend(); }$/;"	f	class:folly::Adaptor	access:public	signature:() const
folly::Adaptor::end	.\Padded.h	/^  iterator end() {$/;"	f	class:folly::Adaptor	access:public	signature:()
folly::Adaptor::front	.\Padded.h	/^  const value_type& front() const {$/;"	f	class:folly::Adaptor	access:public	signature:() const
folly::Adaptor::front	.\Padded.h	/^  value_type& front() {$/;"	f	class:folly::Adaptor	access:public	signature:()
folly::Adaptor::fullNode	.\Padded.h	/^  static Node fullNode(const value_type& value) {$/;"	f	class:folly::Adaptor	access:private	signature:(const value_type& value)
folly::Adaptor::iterator	.\Padded.h	/^  typedef Iterator<typename Container::iterator> iterator;$/;"	t	class:folly::Adaptor	access:public
folly::Adaptor::kElementsPerNode	.\Padded.h	/^  static constexpr size_t kElementsPerNode = Node::kElementCount;$/;"	m	class:folly::Adaptor	access:public
folly::Adaptor::lastCount_	.\Padded.h	/^  size_t lastCount_;  \/\/ number of elements in last Node$/;"	m	class:folly::Adaptor	access:private
folly::Adaptor::max_size	.\Padded.h	/^  size_type max_size() const {$/;"	f	class:folly::Adaptor	access:public	signature:() const
folly::Adaptor::move	.\Padded.h	/^  std::pair<Container, size_t> move() {$/;"	f	class:folly::Adaptor	access:public	signature:()
folly::Adaptor::operator =	.\Padded.h	/^  Adaptor& operator=(Adaptor&& other) {$/;"	f	class:folly::Adaptor	access:public	signature:(Adaptor&& other)
folly::Adaptor::operator =	.\Padded.h	/^  Adaptor& operator=(const Adaptor&) = default;$/;"	p	class:folly::Adaptor	access:public	signature:(const Adaptor&)
folly::Adaptor::operator []	.\Padded.h	/^  const value_type& operator[](size_type idx) const {$/;"	f	class:folly::Adaptor	access:public	signature:(size_type idx) const
folly::Adaptor::operator []	.\Padded.h	/^  value_type& operator[](size_type idx) {$/;"	f	class:folly::Adaptor	access:public	signature:(size_type idx)
folly::Adaptor::padToFullNode	.\Padded.h	/^  void padToFullNode(const value_type& padValue) {$/;"	f	class:folly::Adaptor	access:public	signature:(const value_type& padValue)
folly::Adaptor::peek	.\Padded.h	/^  std::pair<const Container&, size_t> peek() const {$/;"	f	class:folly::Adaptor	access:public	signature:() const
folly::Adaptor::pop_back	.\Padded.h	/^  void pop_back() {$/;"	f	class:folly::Adaptor	access:public	signature:()
folly::Adaptor::push_back	.\Padded.h	/^  void push_back(value_type x) {$/;"	f	class:folly::Adaptor	access:public	signature:(value_type x)
folly::Adaptor::reference	.\Padded.h	/^  typedef value_type& reference;$/;"	t	class:folly::Adaptor	access:public
folly::Adaptor::reserve	.\Padded.h	/^  void reserve(size_type n) {$/;"	f	class:folly::Adaptor	access:public	signature:(size_type n)
folly::Adaptor::size	.\Padded.h	/^  size_type size() const {$/;"	f	class:folly::Adaptor	access:public	signature:() const
folly::Adaptor::size_type	.\Padded.h	/^  typedef typename Container::size_type size_type;$/;"	t	class:folly::Adaptor	access:public
folly::Adaptor::swap	.\Padded.h	/^  void swap(Adaptor& other) {$/;"	f	class:folly::Adaptor	access:public	signature:(Adaptor& other)
folly::Adaptor::value_type	.\Padded.h	/^  typedef typename Node::value_type value_type;$/;"	t	class:folly::Adaptor	access:public
folly::AddressData	.\test\IPAddressTest.h	/^struct AddressData {$/;"	s	namespace:folly
folly::AddressData::AddressData	.\test\IPAddressTest.h	/^  AddressData(): address(""), bytes(), version(0) {}$/;"	f	struct:folly::AddressData	access:public	signature:()
folly::AddressData::AddressData	.\test\IPAddressTest.h	/^  AddressData(const std::string& address, const ByteVector& bytes,$/;"	f	struct:folly::AddressData	access:public	signature:(const std::string& address, const ByteVector& bytes, uint8_t version)
folly::AddressData::AddressData	.\test\IPAddressTest.h	/^  AddressData(const std::string& address, uint8_t version)$/;"	f	struct:folly::AddressData	access:public	signature:(const std::string& address, uint8_t version)
folly::AddressData::AddressData	.\test\IPAddressTest.h	/^  explicit AddressData(const std::string& address)$/;"	f	struct:folly::AddressData	access:public	signature:(const std::string& address)
folly::AddressData::address	.\test\IPAddressTest.h	/^  std::string address;$/;"	m	struct:folly::AddressData	access:public
folly::AddressData::bytes	.\test\IPAddressTest.h	/^  ByteVector bytes;$/;"	m	struct:folly::AddressData	access:public
folly::AddressData::parseAddress4	.\test\IPAddressTest.h	/^  static in_addr parseAddress4(const std::string& src) {$/;"	f	struct:folly::AddressData	access:public	signature:(const std::string& src)
folly::AddressData::parseAddress6	.\test\IPAddressTest.h	/^  static in6_addr parseAddress6(const std::string& src) {$/;"	f	struct:folly::AddressData	access:public	signature:(const std::string& src)
folly::AddressData::version	.\test\IPAddressTest.h	/^  uint8_t version;$/;"	m	struct:folly::AddressData	access:public
folly::AddressFlags	.\test\IPAddressTest.h	/^struct AddressFlags {$/;"	s	namespace:folly
folly::AddressFlags::AddressFlags	.\test\IPAddressTest.h	/^  AddressFlags(const std::string& addr, uint8_t version, uint8_t flags)$/;"	f	struct:folly::AddressFlags	access:public	signature:(const std::string& addr, uint8_t version, uint8_t flags)
folly::AddressFlags::IS_LINK_LOCAL	.\test\IPAddressTest.h	/^  static const uint8_t IS_LINK_LOCAL = 1 << 4;$/;"	m	struct:folly::AddressFlags	access:public
folly::AddressFlags::IS_LINK_LOCAL_BROADCAST	.\test\IPAddressTest.h	/^  static const uint8_t IS_LINK_LOCAL_BROADCAST = 1 << 6;$/;"	m	struct:folly::AddressFlags	access:public
folly::AddressFlags::IS_LOCAL	.\test\IPAddressTest.h	/^  static const uint8_t IS_LOCAL = 1 << 0;$/;"	m	struct:folly::AddressFlags	access:public
folly::AddressFlags::IS_MULTICAST	.\test\IPAddressTest.h	/^  static const uint8_t IS_MULTICAST = 1 << 5;$/;"	m	struct:folly::AddressFlags	access:public
folly::AddressFlags::IS_NONROUTABLE	.\test\IPAddressTest.h	/^  static const uint8_t IS_NONROUTABLE = 1 << 1;$/;"	m	struct:folly::AddressFlags	access:public
folly::AddressFlags::IS_PRIVATE	.\test\IPAddressTest.h	/^  static const uint8_t IS_PRIVATE = 1 << 2;$/;"	m	struct:folly::AddressFlags	access:public
folly::AddressFlags::IS_ZERO	.\test\IPAddressTest.h	/^  static const uint8_t IS_ZERO = 1 << 3;$/;"	m	struct:folly::AddressFlags	access:public
folly::AddressFlags::address	.\test\IPAddressTest.h	/^  std::string address;$/;"	m	struct:folly::AddressFlags	access:public
folly::AddressFlags::flags	.\test\IPAddressTest.h	/^  uint8_t flags;$/;"	m	struct:folly::AddressFlags	access:public
folly::AddressFlags::isLinkLocal	.\test\IPAddressTest.h	/^  bool isLinkLocal() const {$/;"	f	struct:folly::AddressFlags	access:public	signature:() const
folly::AddressFlags::isLinkLocalBroadcast	.\test\IPAddressTest.h	/^  bool isLinkLocalBroadcast() const {$/;"	f	struct:folly::AddressFlags	access:public	signature:() const
folly::AddressFlags::isLoopback	.\test\IPAddressTest.h	/^  bool isLoopback() const {$/;"	f	struct:folly::AddressFlags	access:public	signature:() const
folly::AddressFlags::isNonroutable	.\test\IPAddressTest.h	/^  bool isNonroutable() const {$/;"	f	struct:folly::AddressFlags	access:public	signature:() const
folly::AddressFlags::isPrivate	.\test\IPAddressTest.h	/^  bool isPrivate() const {$/;"	f	struct:folly::AddressFlags	access:public	signature:() const
folly::AddressFlags::isZero	.\test\IPAddressTest.h	/^  bool isZero() const {$/;"	f	struct:folly::AddressFlags	access:public	signature:() const
folly::AddressFlags::version	.\test\IPAddressTest.h	/^  uint8_t version;$/;"	m	struct:folly::AddressFlags	access:public
folly::AllocatorUniquePtr	.\Memory.h	/^struct AllocatorUniquePtr {$/;"	s	namespace:folly
folly::AllocatorUniquePtr::type	.\Memory.h	/^  > type;$/;"	t	struct:folly::AllocatorUniquePtr	access:public
folly::Arena	.\Arena.h	/^class Arena {$/;"	c	namespace:folly
folly::Arena::AllocAndSize	.\Arena.h	/^  struct AllocAndSize : public Alloc {$/;"	s	class:folly::Arena	inherits:Alloc	access:private
folly::Arena::AllocAndSize::AllocAndSize	.\Arena.h	/^    explicit AllocAndSize(const Alloc& a, size_t s)$/;"	f	struct:folly::Arena::AllocAndSize	access:public	signature:(const Alloc& a, size_t s)
folly::Arena::AllocAndSize::minBlockSize	.\Arena.h	/^    size_t minBlockSize;$/;"	m	struct:folly::Arena::AllocAndSize	access:public
folly::Arena::Arena	.\Arena.h	/^  Arena(Arena&&) = default;$/;"	p	class:folly::Arena	access:private	signature:(Arena&&)
folly::Arena::Arena	.\Arena.h	/^  Arena(const Arena&) = delete;$/;"	p	class:folly::Arena	access:private	signature:(const Arena&)
folly::Arena::Arena	.\Arena.h	/^  explicit Arena(const Alloc& alloc,$/;"	f	class:folly::Arena	access:public	signature:(const Alloc& alloc, size_t minBlockSize = kDefaultMinBlockSize, size_t sizeLimit = kNoSizeLimit, size_t maxAlign = kDefaultMaxAlign)
folly::Arena::Block	.\Arena.h	/^  struct Block {$/;"	s	class:folly::Arena	access:private
folly::Arena::Block	.\Arena.h	/^  struct Block;$/;"	x
folly::Arena::Block::Block	.\Arena.h	/^    Block() { }$/;"	f	struct:folly::Arena::Block	access:private	signature:()
folly::Arena::Block::allocate	.\Arena-inl.h	/^Arena<Alloc>::Block::allocate(Alloc& alloc, size_t size, bool allowSlack) {$/;"	f	class:folly::Arena::Block	signature:(Alloc& alloc, size_t size, bool allowSlack)
folly::Arena::Block::allocate	.\Arena.h	/^    static std::pair<Block*, size_t> allocate($/;"	p	struct:folly::Arena::Block	access:public	signature:( Alloc& alloc, size_t size, bool allowSlack)
folly::Arena::Block::deallocate	.\Arena-inl.h	/^void Arena<Alloc>::Block::deallocate(Alloc& alloc) {$/;"	f	class:folly::Arena::Block	signature:(Alloc& alloc)
folly::Arena::Block::deallocate	.\Arena.h	/^    void deallocate(Alloc& alloc);$/;"	p	struct:folly::Arena::Block	access:public	signature:(Alloc& alloc)
folly::Arena::Block::link	.\Arena.h	/^    BlockLink link;$/;"	m	struct:folly::Arena::Block	access:public
folly::Arena::Block::start	.\Arena.h	/^    char* start() {$/;"	f	struct:folly::Arena::Block	access:public	signature:()
folly::Arena::Block::~Block	.\Arena.h	/^    ~Block() { }$/;"	f	struct:folly::Arena::Block	access:private	signature:()
folly::Arena::BlockLink	.\Arena.h	/^    boost::intrusive::tag<Arena>> BlockLink;$/;"	t	class:folly::Arena	access:private
folly::Arena::BlockList	.\Arena.h	/^    boost::intrusive::cache_last<true>> BlockList;$/;"	t	class:folly::Arena	access:private
folly::Arena::alloc	.\Arena.h	/^  Alloc& alloc() { return allocAndSize_; }$/;"	f	class:folly::Arena	access:private	signature:()
folly::Arena::alloc	.\Arena.h	/^  const Alloc& alloc() const { return allocAndSize_; }$/;"	f	class:folly::Arena	access:private	signature:() const
folly::Arena::allocAndSize_	.\Arena.h	/^  AllocAndSize allocAndSize_;$/;"	m	class:folly::Arena	access:private
folly::Arena::allocate	.\Arena.h	/^  void* allocate(size_t size) {$/;"	f	class:folly::Arena	access:public	signature:(size_t size)
folly::Arena::allocateSlow	.\Arena-inl.h	/^void* Arena<Alloc>::allocateSlow(size_t size) {$/;"	f	class:folly::Arena	signature:(size_t size)
folly::Arena::allocateSlow	.\Arena.h	/^  void* allocateSlow(size_t size);$/;"	p	class:folly::Arena	access:private	signature:(size_t size)
folly::Arena::blocks_	.\Arena.h	/^  BlockList blocks_;$/;"	m	class:folly::Arena	access:private
folly::Arena::bytesUsed	.\Arena.h	/^  size_t bytesUsed() const {$/;"	f	class:folly::Arena	access:public	signature:() const
folly::Arena::bytesUsed_	.\Arena.h	/^  size_t bytesUsed_;$/;"	m	class:folly::Arena	access:private
folly::Arena::deallocate	.\Arena.h	/^  void deallocate(void* p) {$/;"	f	class:folly::Arena	access:public	signature:(void* p)
folly::Arena::end_	.\Arena.h	/^  char* end_;$/;"	m	class:folly::Arena	access:private
folly::Arena::isAligned	.\Arena.h	/^  bool isAligned(uintptr_t address) const {$/;"	f	class:folly::Arena	access:private	signature:(uintptr_t address) const
folly::Arena::isAligned	.\Arena.h	/^  bool isAligned(void* p) const {$/;"	f	class:folly::Arena	access:private	signature:(void* p) const
folly::Arena::kBlockOverhead	.\Arena.h	/^  static constexpr size_t kBlockOverhead = sizeof(Block);$/;"	m	class:folly::Arena	access:public
folly::Arena::kDefaultMaxAlign	.\Arena.h	/^  static constexpr size_t kDefaultMaxAlign = alignof(Block);$/;"	m	class:folly::Arena	access:public
folly::Arena::kDefaultMinBlockSize	.\Arena.h	/^  static constexpr size_t kDefaultMinBlockSize = 4096 - sizeof(Block);$/;"	m	class:folly::Arena	access:public
folly::Arena::kNoSizeLimit	.\Arena.h	/^  static constexpr size_t kNoSizeLimit = 0;$/;"	m	class:folly::Arena	access:public
folly::Arena::maxAlign_	.\Arena.h	/^  const size_t maxAlign_;$/;"	m	class:folly::Arena	access:private
folly::Arena::merge	.\Arena-inl.h	/^void Arena<Alloc>::merge(Arena<Alloc>&& other) {$/;"	f	class:folly::Arena	signature:(Arena<Alloc>&& other)
folly::Arena::merge	.\Arena.h	/^  void merge(Arena&& other);$/;"	p	class:folly::Arena	access:public	signature:(Arena&& other)
folly::Arena::minBlockSize	.\Arena.h	/^  size_t minBlockSize() const {$/;"	f	class:folly::Arena	access:private	signature:() const
folly::Arena::operator =	.\Arena.h	/^  Arena& operator=(Arena&&) = default;$/;"	p	class:folly::Arena	access:private	signature:(Arena&&)
folly::Arena::operator =	.\Arena.h	/^  Arena& operator=(const Arena&) = delete;$/;"	p	class:folly::Arena	access:private	signature:(const Arena&)
folly::Arena::ptr_	.\Arena.h	/^  char* ptr_;$/;"	m	class:folly::Arena	access:private
folly::Arena::roundUp	.\Arena.h	/^  size_t roundUp(size_t size) const {$/;"	f	class:folly::Arena	access:private	signature:(size_t size) const
folly::Arena::sizeLimit_	.\Arena.h	/^  const size_t sizeLimit_;$/;"	m	class:folly::Arena	access:private
folly::Arena::totalAllocatedSize_	.\Arena.h	/^  size_t totalAllocatedSize_;$/;"	m	class:folly::Arena	access:private
folly::Arena::totalSize	.\Arena.h	/^  size_t totalSize() const {$/;"	f	class:folly::Arena	access:public	signature:() const
folly::Arena::~Arena	.\Arena-inl.h	/^Arena<Alloc>::~Arena() {$/;"	f	class:folly::Arena	signature:()
folly::Arena::~Arena	.\Arena.h	/^  ~Arena();$/;"	p	class:folly::Arena	access:public	signature:()
folly::ArenaAllocatorTraits	.\Arena.h	/^struct ArenaAllocatorTraits {$/;"	s	namespace:folly
folly::ArenaAllocatorTraits	.\Arena.h	/^struct ArenaAllocatorTraits<SysAlloc> {$/;"	s	namespace:folly
folly::ArenaAllocatorTraits	.\Arena.h	/^template <class Alloc> struct ArenaAllocatorTraits;$/;"	x
folly::ArenaAllocatorTraits::goodSize	.\Arena.h	/^  static size_t goodSize(const Alloc& alloc, size_t size) {$/;"	f	struct:folly::ArenaAllocatorTraits	access:public	signature:(const Alloc& alloc, size_t size)
folly::ArenaAllocatorTraits::goodSize	.\Arena.h	/^  static size_t goodSize(const SysAlloc& alloc, size_t size) {$/;"	f	struct:folly::ArenaAllocatorTraits	access:public	signature:(const SysAlloc& alloc, size_t size)
folly::AsciiCaseInsensitive	.\Range.h	/^struct AsciiCaseInsensitive {$/;"	s	namespace:folly
folly::AsciiCaseInsensitive::operator ()	.\Range.h	/^  bool operator()(char lhs, char rhs) const {$/;"	f	struct:folly::AsciiCaseInsensitive	access:public	signature:(char lhs, char rhs) const
folly::AsciiCaseSensitive	.\Range.h	/^struct AsciiCaseSensitive {$/;"	s	namespace:folly
folly::AsciiCaseSensitive::operator ()	.\Range.h	/^  bool operator()(char lhs, char rhs) const {$/;"	f	struct:folly::AsciiCaseSensitive	access:public	signature:(char lhs, char rhs) const
folly::AsyncIO	.\experimental\io\AsyncIO.h	/^class AsyncIO : private boost::noncopyable {$/;"	c	namespace:folly	inherits:boost::noncopyable
folly::AsyncIO::AsyncIO	.\experimental\io\AsyncIO.cpp	/^AsyncIO::AsyncIO(size_t capacity, PollMode pollMode)$/;"	f	class:folly::AsyncIO	signature:(size_t capacity, PollMode pollMode)
folly::AsyncIO::AsyncIO	.\experimental\io\AsyncIO.h	/^  explicit AsyncIO(size_t capacity, PollMode pollMode=NOT_POLLABLE);$/;"	p	class:folly::AsyncIO	access:public	signature:(size_t capacity, PollMode pollMode=NOT_POLLABLE)
folly::AsyncIO::NOT_POLLABLE	.\experimental\io\AsyncIO.h	/^    NOT_POLLABLE,$/;"	e	enum:folly::AsyncIO::PollMode
folly::AsyncIO::Op	.\experimental\io\AsyncIO.h	/^  typedef AsyncIOOp Op;$/;"	t	class:folly::AsyncIO	access:public
folly::AsyncIO::POLLABLE	.\experimental\io\AsyncIO.h	/^    POLLABLE$/;"	e	enum:folly::AsyncIO::PollMode
folly::AsyncIO::PollMode	.\experimental\io\AsyncIO.h	/^  enum PollMode {$/;"	g	class:folly::AsyncIO	access:public
folly::AsyncIO::capacity	.\experimental\io\AsyncIO.h	/^  size_t capacity() const { return capacity_; }$/;"	f	class:folly::AsyncIO	access:public	signature:() const
folly::AsyncIO::capacity_	.\experimental\io\AsyncIO.h	/^  const size_t capacity_;$/;"	m	class:folly::AsyncIO	access:private
folly::AsyncIO::completed_	.\experimental\io\AsyncIO.h	/^  std::vector<Op*> completed_;$/;"	m	class:folly::AsyncIO	access:private
folly::AsyncIO::ctxSet_	.\experimental\io\AsyncIO.h	/^  std::atomic<bool> ctxSet_;$/;"	m	class:folly::AsyncIO	access:private
folly::AsyncIO::ctx_	.\experimental\io\AsyncIO.h	/^  io_context_t ctx_;$/;"	m	class:folly::AsyncIO	access:private
folly::AsyncIO::decrementPending	.\experimental\io\AsyncIO.cpp	/^void AsyncIO::decrementPending() {$/;"	f	class:folly::AsyncIO	signature:()
folly::AsyncIO::decrementPending	.\experimental\io\AsyncIO.h	/^  void decrementPending();$/;"	p	class:folly::AsyncIO	access:private	signature:()
folly::AsyncIO::doWait	.\experimental\io\AsyncIO.cpp	/^Range<AsyncIO::Op**> AsyncIO::doWait(size_t minRequests, size_t maxRequests) {$/;"	f	class:folly::AsyncIO	signature:(size_t minRequests, size_t maxRequests)
folly::AsyncIO::doWait	.\experimental\io\AsyncIO.h	/^  Range<Op**> doWait(size_t minRequests, size_t maxRequests);$/;"	p	class:folly::AsyncIO	access:private	signature:(size_t minRequests, size_t maxRequests)
folly::AsyncIO::initMutex_	.\experimental\io\AsyncIO.h	/^  std::mutex initMutex_;$/;"	m	class:folly::AsyncIO	access:private
folly::AsyncIO::initializeContext	.\experimental\io\AsyncIO.cpp	/^void AsyncIO::initializeContext() {$/;"	f	class:folly::AsyncIO	signature:()
folly::AsyncIO::initializeContext	.\experimental\io\AsyncIO.h	/^  void initializeContext();$/;"	p	class:folly::AsyncIO	access:private	signature:()
folly::AsyncIO::pending	.\experimental\io\AsyncIO.h	/^  size_t pending() const { return pending_; }$/;"	f	class:folly::AsyncIO	access:public	signature:() const
folly::AsyncIO::pending_	.\experimental\io\AsyncIO.h	/^  std::atomic<size_t> pending_;$/;"	m	class:folly::AsyncIO	access:private
folly::AsyncIO::pollCompleted	.\experimental\io\AsyncIO.cpp	/^Range<AsyncIO::Op**> AsyncIO::pollCompleted() {$/;"	f	class:folly::AsyncIO	signature:()
folly::AsyncIO::pollCompleted	.\experimental\io\AsyncIO.h	/^  Range<Op**> pollCompleted();$/;"	p	class:folly::AsyncIO	access:public	signature:()
folly::AsyncIO::pollFd	.\experimental\io\AsyncIO.h	/^  int pollFd() const { return pollFd_; }$/;"	f	class:folly::AsyncIO	access:public	signature:() const
folly::AsyncIO::pollFd_	.\experimental\io\AsyncIO.h	/^  int pollFd_;$/;"	m	class:folly::AsyncIO	access:private
folly::AsyncIO::submit	.\experimental\io\AsyncIO.cpp	/^void AsyncIO::submit(Op* op) {$/;"	f	class:folly::AsyncIO	signature:(Op* op)
folly::AsyncIO::submit	.\experimental\io\AsyncIO.h	/^  void submit(Op* op);$/;"	p	class:folly::AsyncIO	access:public	signature:(Op* op)
folly::AsyncIO::submitted_	.\experimental\io\AsyncIO.h	/^  std::atomic<size_t> submitted_;$/;"	m	class:folly::AsyncIO	access:private
folly::AsyncIO::totalSubmits	.\experimental\io\AsyncIO.h	/^  size_t totalSubmits() const { return submitted_; }$/;"	f	class:folly::AsyncIO	access:public	signature:() const
folly::AsyncIO::wait	.\experimental\io\AsyncIO.cpp	/^Range<AsyncIO::Op**> AsyncIO::wait(size_t minRequests) {$/;"	f	class:folly::AsyncIO	signature:(size_t minRequests)
folly::AsyncIO::wait	.\experimental\io\AsyncIO.h	/^  Range<Op**> wait(size_t minRequests);$/;"	p	class:folly::AsyncIO	access:public	signature:(size_t minRequests)
folly::AsyncIO::~AsyncIO	.\experimental\io\AsyncIO.cpp	/^AsyncIO::~AsyncIO() {$/;"	f	class:folly::AsyncIO	signature:()
folly::AsyncIO::~AsyncIO	.\experimental\io\AsyncIO.h	/^  ~AsyncIO();$/;"	p	class:folly::AsyncIO	access:public	signature:()
folly::AsyncIOOp	.\experimental\io\AsyncIO.h	/^class AsyncIOOp : private boost::noncopyable {$/;"	c	namespace:folly	inherits:boost::noncopyable
folly::AsyncIOOp::AsyncIO	.\experimental\io\AsyncIO.h	/^  friend class AsyncIO;$/;"	x
folly::AsyncIOOp::AsyncIOOp	.\experimental\io\AsyncIO.cpp	/^AsyncIOOp::AsyncIOOp(NotificationCallback cb)$/;"	f	class:folly::AsyncIOOp	signature:(NotificationCallback cb)
folly::AsyncIOOp::AsyncIOOp	.\experimental\io\AsyncIO.h	/^  explicit AsyncIOOp(NotificationCallback cb = NotificationCallback());$/;"	p	class:folly::AsyncIOOp	access:public	signature:(NotificationCallback cb = NotificationCallback())
folly::AsyncIOOp::NotificationCallback	.\experimental\io\AsyncIO.h	/^  typedef std::function<void(AsyncIOOp*)> NotificationCallback;$/;"	t	class:folly::AsyncIOOp	access:public
folly::AsyncIOOp::State	.\experimental\io\AsyncIO.h	/^  enum class State {$/;"	c	class:folly::AsyncIOOp	access:public
folly::AsyncIOOp::State::INITIALIZED	.\experimental\io\AsyncIO.h	/^    INITIALIZED,$/;"	m	class:folly::AsyncIOOp::State	access:private
folly::AsyncIOOp::State::PENDING	.\experimental\io\AsyncIO.h	/^    PENDING,$/;"	m	class:folly::AsyncIOOp::State	access:private
folly::AsyncIOOp::State::UNINITIALIZED	.\experimental\io\AsyncIO.h	/^    UNINITIALIZED,$/;"	m	class:folly::AsyncIOOp::State	access:private
folly::AsyncIOOp::cb_	.\experimental\io\AsyncIO.h	/^  NotificationCallback cb_;$/;"	m	class:folly::AsyncIOOp	access:private
folly::AsyncIOOp::complete	.\experimental\io\AsyncIO.cpp	/^void AsyncIOOp::complete(ssize_t result) {$/;"	f	class:folly::AsyncIOOp	signature:(ssize_t result)
folly::AsyncIOOp::complete	.\experimental\io\AsyncIO.h	/^  void complete(ssize_t result);$/;"	p	class:folly::AsyncIOOp	access:private	signature:(ssize_t result)
folly::AsyncIOOp::init	.\experimental\io\AsyncIO.cpp	/^void AsyncIOOp::init() {$/;"	f	class:folly::AsyncIOOp	signature:()
folly::AsyncIOOp::init	.\experimental\io\AsyncIO.h	/^  void init();$/;"	p	class:folly::AsyncIOOp	access:private	signature:()
folly::AsyncIOOp::iocb_	.\experimental\io\AsyncIO.h	/^  iocb iocb_;$/;"	m	class:folly::AsyncIOOp	access:private
folly::AsyncIOOp::notificationCallback	.\experimental\io\AsyncIO.h	/^  const NotificationCallback& notificationCallback() const { return cb_; }$/;"	f	class:folly::AsyncIOOp	access:public	signature:() const
folly::AsyncIOOp::operator <<	.\experimental\io\AsyncIO.h	/^  friend std::ostream& operator<<(std::ostream& stream, const AsyncIOOp& o);$/;"	p	class:folly::AsyncIOOp	access:friend	signature:(std::ostream& stream, const AsyncIOOp& o)
folly::AsyncIOOp::pread	.\experimental\io\AsyncIO.cpp	/^void AsyncIOOp::pread(int fd, Range<unsigned char*> range, off_t start) {$/;"	f	class:folly::AsyncIOOp	signature:(int fd, Range<unsigned char*> range, off_t start)
folly::AsyncIOOp::pread	.\experimental\io\AsyncIO.cpp	/^void AsyncIOOp::pread(int fd, void* buf, size_t size, off_t start) {$/;"	f	class:folly::AsyncIOOp	signature:(int fd, void* buf, size_t size, off_t start)
folly::AsyncIOOp::pread	.\experimental\io\AsyncIO.h	/^  void pread(int fd, Range<unsigned char*> range, off_t start);$/;"	p	class:folly::AsyncIOOp	access:public	signature:(int fd, Range<unsigned char*> range, off_t start)
folly::AsyncIOOp::pread	.\experimental\io\AsyncIO.h	/^  void pread(int fd, void* buf, size_t size, off_t start);$/;"	p	class:folly::AsyncIOOp	access:public	signature:(int fd, void* buf, size_t size, off_t start)
folly::AsyncIOOp::preadv	.\experimental\io\AsyncIO.cpp	/^void AsyncIOOp::preadv(int fd, const iovec* iov, int iovcnt, off_t start) {$/;"	f	class:folly::AsyncIOOp	signature:(int fd, const iovec* iov, int iovcnt, off_t start)
folly::AsyncIOOp::preadv	.\experimental\io\AsyncIO.h	/^  void preadv(int fd, const iovec* iov, int iovcnt, off_t start);$/;"	p	class:folly::AsyncIOOp	access:public	signature:(int fd, const iovec* iov, int iovcnt, off_t start)
folly::AsyncIOOp::pwrite	.\experimental\io\AsyncIO.cpp	/^void AsyncIOOp::pwrite(int fd, Range<const unsigned char*> range, off_t start) {$/;"	f	class:folly::AsyncIOOp	signature:(int fd, Range<const unsigned char*> range, off_t start)
folly::AsyncIOOp::pwrite	.\experimental\io\AsyncIO.cpp	/^void AsyncIOOp::pwrite(int fd, const void* buf, size_t size, off_t start) {$/;"	f	class:folly::AsyncIOOp	signature:(int fd, const void* buf, size_t size, off_t start)
folly::AsyncIOOp::pwrite	.\experimental\io\AsyncIO.h	/^  void pwrite(int fd, Range<const unsigned char*> range, off_t start);$/;"	p	class:folly::AsyncIOOp	access:public	signature:(int fd, Range<const unsigned char*> range, off_t start)
folly::AsyncIOOp::pwrite	.\experimental\io\AsyncIO.h	/^  void pwrite(int fd, const void* buf, size_t size, off_t start);$/;"	p	class:folly::AsyncIOOp	access:public	signature:(int fd, const void* buf, size_t size, off_t start)
folly::AsyncIOOp::pwritev	.\experimental\io\AsyncIO.cpp	/^void AsyncIOOp::pwritev(int fd, const iovec* iov, int iovcnt, off_t start) {$/;"	f	class:folly::AsyncIOOp	signature:(int fd, const iovec* iov, int iovcnt, off_t start)
folly::AsyncIOOp::pwritev	.\experimental\io\AsyncIO.h	/^  void pwritev(int fd, const iovec* iov, int iovcnt, off_t start);$/;"	p	class:folly::AsyncIOOp	access:public	signature:(int fd, const iovec* iov, int iovcnt, off_t start)
folly::AsyncIOOp::reset	.\experimental\io\AsyncIO.cpp	/^void AsyncIOOp::reset(NotificationCallback cb) {$/;"	f	class:folly::AsyncIOOp	signature:(NotificationCallback cb)
folly::AsyncIOOp::reset	.\experimental\io\AsyncIO.h	/^  void reset(NotificationCallback cb = NotificationCallback());$/;"	p	class:folly::AsyncIOOp	access:public	signature:(NotificationCallback cb = NotificationCallback())
folly::AsyncIOOp::result	.\experimental\io\AsyncIO.cpp	/^ssize_t AsyncIOOp::result() const {$/;"	f	class:folly::AsyncIOOp	signature:() const
folly::AsyncIOOp::result	.\experimental\io\AsyncIO.h	/^  ssize_t result() const;$/;"	p	class:folly::AsyncIOOp	access:public	signature:() const
folly::AsyncIOOp::result_	.\experimental\io\AsyncIO.h	/^  ssize_t result_;$/;"	m	class:folly::AsyncIOOp	access:private
folly::AsyncIOOp::setNotificationCallback	.\experimental\io\AsyncIO.h	/^  void setNotificationCallback(NotificationCallback cb) { cb_ = std::move(cb); }$/;"	f	class:folly::AsyncIOOp	access:public	signature:(NotificationCallback cb)
folly::AsyncIOOp::start	.\experimental\io\AsyncIO.cpp	/^void AsyncIOOp::start() {$/;"	f	class:folly::AsyncIOOp	signature:()
folly::AsyncIOOp::start	.\experimental\io\AsyncIO.h	/^  void start();$/;"	p	class:folly::AsyncIOOp	access:private	signature:()
folly::AsyncIOOp::state	.\experimental\io\AsyncIO.h	/^  State state() const { return state_; }$/;"	f	class:folly::AsyncIOOp	access:public	signature:() const
folly::AsyncIOOp::state_	.\experimental\io\AsyncIO.h	/^  State state_;$/;"	m	class:folly::AsyncIOOp	access:private
folly::AsyncIOOp::~AsyncIOOp	.\experimental\io\AsyncIO.cpp	/^AsyncIOOp::~AsyncIOOp() {$/;"	f	class:folly::AsyncIOOp	signature:()
folly::AsyncIOOp::~AsyncIOOp	.\experimental\io\AsyncIO.h	/^  ~AsyncIOOp();$/;"	p	class:folly::AsyncIOOp	access:public	signature:()
folly::AsyncIOQueue	.\experimental\io\AsyncIO.h	/^class AsyncIOQueue {$/;"	c	namespace:folly
folly::AsyncIOQueue::AsyncIOQueue	.\experimental\io\AsyncIO.cpp	/^AsyncIOQueue::AsyncIOQueue(AsyncIO* asyncIO)$/;"	f	class:folly::AsyncIOQueue	signature:(AsyncIO* asyncIO)
folly::AsyncIOQueue::AsyncIOQueue	.\experimental\io\AsyncIO.h	/^  explicit AsyncIOQueue(AsyncIO* asyncIO);$/;"	p	class:folly::AsyncIOQueue	access:public	signature:(AsyncIO* asyncIO)
folly::AsyncIOQueue::OpFactory	.\experimental\io\AsyncIO.h	/^  typedef std::function<AsyncIOOp*()> OpFactory;$/;"	t	class:folly::AsyncIOQueue	access:public
folly::AsyncIOQueue::asyncIO_	.\experimental\io\AsyncIO.h	/^  AsyncIO* asyncIO_;$/;"	m	class:folly::AsyncIOQueue	access:private
folly::AsyncIOQueue::maybeDequeue	.\experimental\io\AsyncIO.cpp	/^void AsyncIOQueue::maybeDequeue() {$/;"	f	class:folly::AsyncIOQueue	signature:()
folly::AsyncIOQueue::maybeDequeue	.\experimental\io\AsyncIO.h	/^  void maybeDequeue();$/;"	p	class:folly::AsyncIOQueue	access:private	signature:()
folly::AsyncIOQueue::onCompleted	.\experimental\io\AsyncIO.cpp	/^void AsyncIOQueue::onCompleted(AsyncIOOp* op) {$/;"	f	class:folly::AsyncIOQueue	signature:(AsyncIOOp* op)
folly::AsyncIOQueue::onCompleted	.\experimental\io\AsyncIO.h	/^  void onCompleted(AsyncIOOp* op);$/;"	p	class:folly::AsyncIOQueue	access:private	signature:(AsyncIOOp* op)
folly::AsyncIOQueue::queue_	.\experimental\io\AsyncIO.h	/^  std::deque<OpFactory> queue_;$/;"	m	class:folly::AsyncIOQueue	access:private
folly::AsyncIOQueue::queued	.\experimental\io\AsyncIO.h	/^  size_t queued() const { return queue_.size(); }$/;"	f	class:folly::AsyncIOQueue	access:public	signature:() const
folly::AsyncIOQueue::submit	.\experimental\io\AsyncIO.cpp	/^void AsyncIOQueue::submit(AsyncIOOp* op) {$/;"	f	class:folly::AsyncIOQueue	signature:(AsyncIOOp* op)
folly::AsyncIOQueue::submit	.\experimental\io\AsyncIO.cpp	/^void AsyncIOQueue::submit(OpFactory op) {$/;"	f	class:folly::AsyncIOQueue	signature:(OpFactory op)
folly::AsyncIOQueue::submit	.\experimental\io\AsyncIO.h	/^  void submit(AsyncIOOp* op);$/;"	p	class:folly::AsyncIOQueue	access:public	signature:(AsyncIOOp* op)
folly::AsyncIOQueue::submit	.\experimental\io\AsyncIO.h	/^  void submit(OpFactory op);$/;"	p	class:folly::AsyncIOQueue	access:public	signature:(OpFactory op)
folly::AsyncIOQueue::~AsyncIOQueue	.\experimental\io\AsyncIO.cpp	/^AsyncIOQueue::~AsyncIOQueue() {$/;"	f	class:folly::AsyncIOQueue	signature:()
folly::AsyncIOQueue::~AsyncIOQueue	.\experimental\io\AsyncIO.h	/^  ~AsyncIOQueue();$/;"	p	class:folly::AsyncIOQueue	access:public	signature:()
folly::AsyncTimeout	.\io\async\AsyncTimeout.h	/^class AsyncTimeout : private boost::noncopyable {$/;"	c	namespace:folly	inherits:boost::noncopyable
folly::AsyncTimeout	.\io\async\TimeoutManager.h	/^class AsyncTimeout;$/;"	x
folly::AsyncTimeout::AsyncTimeout	.\io\async\AsyncTimeout.cpp	/^AsyncTimeout::AsyncTimeout(): timeoutManager_(nullptr) {$/;"	f	class:folly::AsyncTimeout	signature:()
folly::AsyncTimeout::AsyncTimeout	.\io\async\AsyncTimeout.cpp	/^AsyncTimeout::AsyncTimeout(EventBase* eventBase)$/;"	f	class:folly::AsyncTimeout	signature:(EventBase* eventBase)
folly::AsyncTimeout::AsyncTimeout	.\io\async\AsyncTimeout.cpp	/^AsyncTimeout::AsyncTimeout(EventBase* eventBase, InternalEnum internal)$/;"	f	class:folly::AsyncTimeout	signature:(EventBase* eventBase, InternalEnum internal)
folly::AsyncTimeout::AsyncTimeout	.\io\async\AsyncTimeout.cpp	/^AsyncTimeout::AsyncTimeout(TimeoutManager* timeoutManager)$/;"	f	class:folly::AsyncTimeout	signature:(TimeoutManager* timeoutManager)
folly::AsyncTimeout::AsyncTimeout	.\io\async\AsyncTimeout.cpp	/^AsyncTimeout::AsyncTimeout(TimeoutManager* timeoutManager,$/;"	f	class:folly::AsyncTimeout	signature:(TimeoutManager* timeoutManager, InternalEnum internal)
folly::AsyncTimeout::AsyncTimeout	.\io\async\AsyncTimeout.h	/^  AsyncTimeout();$/;"	p	class:folly::AsyncTimeout	access:public	signature:()
folly::AsyncTimeout::AsyncTimeout	.\io\async\AsyncTimeout.h	/^  AsyncTimeout(EventBase* eventBase, InternalEnum internal);$/;"	p	class:folly::AsyncTimeout	access:public	signature:(EventBase* eventBase, InternalEnum internal)
folly::AsyncTimeout::AsyncTimeout	.\io\async\AsyncTimeout.h	/^  AsyncTimeout(TimeoutManager* timeoutManager, InternalEnum internal);$/;"	p	class:folly::AsyncTimeout	access:public	signature:(TimeoutManager* timeoutManager, InternalEnum internal)
folly::AsyncTimeout::AsyncTimeout	.\io\async\AsyncTimeout.h	/^  explicit AsyncTimeout(EventBase* eventBase);$/;"	p	class:folly::AsyncTimeout	access:public	signature:(EventBase* eventBase)
folly::AsyncTimeout::AsyncTimeout	.\io\async\AsyncTimeout.h	/^  explicit AsyncTimeout(TimeoutManager* timeoutManager);$/;"	p	class:folly::AsyncTimeout	access:public	signature:(TimeoutManager* timeoutManager)
folly::AsyncTimeout::InternalEnum	.\io\async\AsyncTimeout.h	/^  typedef TimeoutManager::InternalEnum InternalEnum;$/;"	t	class:folly::AsyncTimeout	access:public
folly::AsyncTimeout::attachEventBase	.\io\async\AsyncTimeout.cpp	/^void AsyncTimeout::attachEventBase($/;"	f	class:folly::AsyncTimeout	signature:( EventBase* eventBase, InternalEnum internal)
folly::AsyncTimeout::attachEventBase	.\io\async\AsyncTimeout.h	/^  void attachEventBase(EventBase* eventBase,$/;"	p	class:folly::AsyncTimeout	access:public	signature:(EventBase* eventBase, InternalEnum internal = InternalEnum::NORMAL)
folly::AsyncTimeout::attachTimeoutManager	.\io\async\AsyncTimeout.cpp	/^void AsyncTimeout::attachTimeoutManager($/;"	f	class:folly::AsyncTimeout	signature:( TimeoutManager* timeoutManager, InternalEnum internal)
folly::AsyncTimeout::attachTimeoutManager	.\io\async\AsyncTimeout.h	/^  void attachTimeoutManager(TimeoutManager* timeoutManager,$/;"	p	class:folly::AsyncTimeout	access:public	signature:(TimeoutManager* timeoutManager, InternalEnum internal = InternalEnum::NORMAL)
folly::AsyncTimeout::cancelTimeout	.\io\async\AsyncTimeout.cpp	/^void AsyncTimeout::cancelTimeout() {$/;"	f	class:folly::AsyncTimeout	signature:()
folly::AsyncTimeout::cancelTimeout	.\io\async\AsyncTimeout.h	/^  void cancelTimeout();$/;"	p	class:folly::AsyncTimeout	access:public	signature:()
folly::AsyncTimeout::context_	.\io\async\AsyncTimeout.h	/^  std::shared_ptr<RequestContext> context_;$/;"	m	class:folly::AsyncTimeout	access:private
folly::AsyncTimeout::detachEventBase	.\io\async\AsyncTimeout.cpp	/^void AsyncTimeout::detachEventBase() {$/;"	f	class:folly::AsyncTimeout	signature:()
folly::AsyncTimeout::detachEventBase	.\io\async\AsyncTimeout.h	/^  void detachEventBase();$/;"	p	class:folly::AsyncTimeout	access:public	signature:()
folly::AsyncTimeout::detachTimeoutManager	.\io\async\AsyncTimeout.cpp	/^void AsyncTimeout::detachTimeoutManager() {$/;"	f	class:folly::AsyncTimeout	signature:()
folly::AsyncTimeout::detachTimeoutManager	.\io\async\AsyncTimeout.h	/^  void detachTimeoutManager();$/;"	p	class:folly::AsyncTimeout	access:public	signature:()
folly::AsyncTimeout::event_	.\io\async\AsyncTimeout.h	/^  struct event event_;$/;"	m	class:folly::AsyncTimeout	typeref:struct:folly::AsyncTimeout::event	access:private
folly::AsyncTimeout::getEvent	.\io\async\AsyncTimeout.h	/^  struct event* getEvent() {$/;"	f	class:folly::AsyncTimeout	access:public	signature:()
folly::AsyncTimeout::getTimeoutManager	.\io\async\AsyncTimeout.h	/^  const TimeoutManager* getTimeoutManager() {$/;"	f	class:folly::AsyncTimeout	access:public	signature:()
folly::AsyncTimeout::isScheduled	.\io\async\AsyncTimeout.cpp	/^bool AsyncTimeout::isScheduled() const {$/;"	f	class:folly::AsyncTimeout	signature:() const
folly::AsyncTimeout::isScheduled	.\io\async\AsyncTimeout.h	/^  bool isScheduled() const;$/;"	p	class:folly::AsyncTimeout	access:public	signature:() const
folly::AsyncTimeout::libeventCallback	.\io\async\AsyncTimeout.cpp	/^void AsyncTimeout::libeventCallback(int fd, short events, void* arg) {$/;"	f	class:folly::AsyncTimeout	signature:(int fd, short events, void* arg)
folly::AsyncTimeout::libeventCallback	.\io\async\AsyncTimeout.h	/^  static void libeventCallback(int fd, short events, void* arg);$/;"	p	class:folly::AsyncTimeout	access:private	signature:(int fd, short events, void* arg)
folly::AsyncTimeout::noexcept	.\io\async\AsyncTimeout.h	/^  virtual void timeoutExpired() noexcept = 0;$/;"	m	class:folly::AsyncTimeout	access:public
folly::AsyncTimeout::scheduleTimeout	.\io\async\AsyncTimeout.cpp	/^bool AsyncTimeout::scheduleTimeout(std::chrono::milliseconds timeout) {$/;"	f	class:folly::AsyncTimeout	signature:(std::chrono::milliseconds timeout)
folly::AsyncTimeout::scheduleTimeout	.\io\async\AsyncTimeout.cpp	/^bool AsyncTimeout::scheduleTimeout(uint32_t milliseconds) {$/;"	f	class:folly::AsyncTimeout	signature:(uint32_t milliseconds)
folly::AsyncTimeout::scheduleTimeout	.\io\async\AsyncTimeout.h	/^  bool scheduleTimeout(std::chrono::milliseconds timeout);$/;"	p	class:folly::AsyncTimeout	access:public	signature:(std::chrono::milliseconds timeout)
folly::AsyncTimeout::scheduleTimeout	.\io\async\AsyncTimeout.h	/^  bool scheduleTimeout(uint32_t milliseconds);$/;"	p	class:folly::AsyncTimeout	access:public	signature:(uint32_t milliseconds)
folly::AsyncTimeout::timeoutManager_	.\io\async\AsyncTimeout.h	/^  TimeoutManager* timeoutManager_;$/;"	m	class:folly::AsyncTimeout	access:private
folly::AsyncTimeout::~AsyncTimeout	.\io\async\AsyncTimeout.cpp	/^AsyncTimeout::~AsyncTimeout() {$/;"	f	class:folly::AsyncTimeout	signature:()
folly::AsyncTimeout::~AsyncTimeout	.\io\async\AsyncTimeout.h	/^  virtual ~AsyncTimeout();$/;"	p	class:folly::AsyncTimeout	access:public	signature:()
folly::AtomicBitSet	.\AtomicBitSet.h	/^class AtomicBitSet : private boost::noncopyable {$/;"	c	namespace:folly	inherits:boost::noncopyable
folly::AtomicBitSet::AtomicBitSet	.\AtomicBitSet.h	/^  AtomicBitSet();$/;"	p	class:folly::AtomicBitSet	access:public	signature:()
folly::AtomicBitSet::AtomicBitSet	.\AtomicBitSet.h	/^inline AtomicBitSet<N>::AtomicBitSet() : data_() {$/;"	f	class:folly::AtomicBitSet	signature:()
folly::AtomicBitSet::AtomicBlockType	.\AtomicBitSet.h	/^  typedef std::atomic<BlockType> AtomicBlockType;$/;"	t	class:folly::AtomicBitSet	access:private
folly::AtomicBitSet::BlockType	.\AtomicBitSet.h	/^  typedef unsigned int BlockType;$/;"	t	class:folly::AtomicBitSet	access:private
folly::AtomicBitSet::BlockType	.\AtomicBitSet.h	/^  typedef unsigned long BlockType;$/;"	t	class:folly::AtomicBitSet	access:private
folly::AtomicBitSet::BlockType	.\AtomicBitSet.h	/^  typedef unsigned long long BlockType;$/;"	t	class:folly::AtomicBitSet	access:private
folly::AtomicBitSet::bitOffset	.\AtomicBitSet.h	/^  static constexpr size_t bitOffset(size_t bit) {$/;"	f	class:folly::AtomicBitSet	access:private	signature:(size_t bit)
folly::AtomicBitSet::blockIndex	.\AtomicBitSet.h	/^  static constexpr size_t blockIndex(size_t bit) {$/;"	f	class:folly::AtomicBitSet	access:private	signature:(size_t bit)
folly::AtomicBitSet::data_	.\AtomicBitSet.h	/^  std::array<AtomicBlockType, N> data_;$/;"	m	class:folly::AtomicBitSet	access:private
folly::AtomicBitSet::kBitsPerBlock	.\AtomicBitSet.h	/^  static constexpr size_t kBitsPerBlock =$/;"	m	class:folly::AtomicBitSet	access:private
folly::AtomicBitSet::kOne	.\AtomicBitSet.h	/^  static constexpr BlockType kOne = 1;$/;"	m	class:folly::AtomicBitSet	access:private
folly::AtomicBitSet::operator []	.\AtomicBitSet.h	/^  bool operator[](size_t idx) const;$/;"	p	class:folly::AtomicBitSet	access:public	signature:(size_t idx) const
folly::AtomicBitSet::operator []	.\AtomicBitSet.h	/^inline bool AtomicBitSet<N>::operator[](size_t index) const {$/;"	f	class:folly::AtomicBitSet	signature:(size_t index) const
folly::AtomicBitSet::reset	.\AtomicBitSet.h	/^  bool reset(size_t idx, std::memory_order order = std::memory_order_seq_cst);$/;"	p	class:folly::AtomicBitSet	access:public	signature:(size_t idx, std::memory_order order = std::memory_order_seq_cst)
folly::AtomicBitSet::reset	.\AtomicBitSet.h	/^inline bool AtomicBitSet<N>::reset(size_t idx, std::memory_order order) {$/;"	f	class:folly::AtomicBitSet	signature:(size_t idx, std::memory_order order)
folly::AtomicBitSet::set	.\AtomicBitSet.h	/^  bool set(size_t idx, std::memory_order order = std::memory_order_seq_cst);$/;"	p	class:folly::AtomicBitSet	access:public	signature:(size_t idx, std::memory_order order = std::memory_order_seq_cst)
folly::AtomicBitSet::set	.\AtomicBitSet.h	/^  bool set(size_t idx,$/;"	p	class:folly::AtomicBitSet	access:public	signature:(size_t idx, bool value, std::memory_order order = std::memory_order_seq_cst)
folly::AtomicBitSet::set	.\AtomicBitSet.h	/^inline bool AtomicBitSet<N>::set(size_t idx, std::memory_order order) {$/;"	f	class:folly::AtomicBitSet	signature:(size_t idx, std::memory_order order)
folly::AtomicBitSet::set	.\AtomicBitSet.h	/^inline bool AtomicBitSet<N>::set(size_t idx,$/;"	f	class:folly::AtomicBitSet	signature:(size_t idx, bool value, std::memory_order order)
folly::AtomicBitSet::size	.\AtomicBitSet.h	/^  constexpr size_t size() const {$/;"	f	class:folly::AtomicBitSet	access:public	signature:() const
folly::AtomicBitSet::test	.\AtomicBitSet.h	/^  bool test(size_t idx,$/;"	p	class:folly::AtomicBitSet	access:public	signature:(size_t idx, std::memory_order order = std::memory_order_seq_cst) const
folly::AtomicBitSet::test	.\AtomicBitSet.h	/^inline bool AtomicBitSet<N>::test(size_t idx, std::memory_order order) const {$/;"	f	class:folly::AtomicBitSet	signature:(size_t idx, std::memory_order order) const
folly::AtomicHashArray	.\AtomicHashArray.h	/^class AtomicHashArray : boost::noncopyable {$/;"	c	namespace:folly	inherits:boost::noncopyable
folly::AtomicHashArray::AtomicHashArray	.\AtomicHashArray-inl.h	/^AtomicHashArray(size_t capacity, KeyT emptyKey, KeyT lockedKey,$/;"	f	class:folly::AtomicHashArray	signature:(size_t capacity, KeyT emptyKey, KeyT lockedKey, KeyT erasedKey, double maxLoadFactor, size_t cacheSize)
folly::AtomicHashArray::AtomicHashArray	.\AtomicHashArray.h	/^  AtomicHashArray(size_t capacity, KeyT emptyKey, KeyT lockedKey,$/;"	p	class:folly::AtomicHashArray	access:private	signature:(size_t capacity, KeyT emptyKey, KeyT lockedKey, KeyT erasedKey, double maxLoadFactor, size_t cacheSize)
folly::AtomicHashArray::AtomicHashMap	.\AtomicHashArray.h	/^  friend class AtomicHashMap<KeyT, ValueT, HashFcn, EqualFcn, Allocator>;$/;"	x
folly::AtomicHashArray::Config	.\AtomicHashArray.h	/^  struct Config {$/;"	s	class:folly::AtomicHashArray	access:public
folly::AtomicHashArray::Config::Config	.\AtomicHashArray.h	/^    constexpr Config() : emptyKey((KeyT)-1),$/;"	f	struct:folly::AtomicHashArray::Config	access:public	signature:()
folly::AtomicHashArray::Config::capacity	.\AtomicHashArray.h	/^    size_t capacity; \/\/ if positive, overrides maxLoadFactor$/;"	m	struct:folly::AtomicHashArray::Config	access:public
folly::AtomicHashArray::Config::emptyKey	.\AtomicHashArray.h	/^    KeyT   emptyKey;$/;"	m	struct:folly::AtomicHashArray::Config	access:public
folly::AtomicHashArray::Config::entryCountThreadCacheSize	.\AtomicHashArray.h	/^    int    entryCountThreadCacheSize;$/;"	m	struct:folly::AtomicHashArray::Config	access:public
folly::AtomicHashArray::Config::erasedKey	.\AtomicHashArray.h	/^    KeyT   erasedKey;$/;"	m	struct:folly::AtomicHashArray::Config	access:public
folly::AtomicHashArray::Config::growthFactor	.\AtomicHashArray.h	/^    double growthFactor;$/;"	m	struct:folly::AtomicHashArray::Config	access:public
folly::AtomicHashArray::Config::lockedKey	.\AtomicHashArray.h	/^    KeyT   lockedKey;$/;"	m	struct:folly::AtomicHashArray::Config	access:public
folly::AtomicHashArray::Config::maxLoadFactor	.\AtomicHashArray.h	/^    double maxLoadFactor;$/;"	m	struct:folly::AtomicHashArray::Config	access:public
folly::AtomicHashArray::Deleter	.\AtomicHashArray.h	/^  struct Deleter {$/;"	s	class:folly::AtomicHashArray	access:private
folly::AtomicHashArray::Deleter::operator ()	.\AtomicHashArray.h	/^    void operator()(AtomicHashArray* ptr) {$/;"	f	struct:folly::AtomicHashArray::Deleter	access:public	signature:(AtomicHashArray* ptr)
folly::AtomicHashArray::SimpleRetT	.\AtomicHashArray.h	/^  struct SimpleRetT { size_t idx; bool success;$/;"	s	class:folly::AtomicHashArray	access:private
folly::AtomicHashArray::SimpleRetT::SimpleRetT	.\AtomicHashArray.h	/^    SimpleRetT() {}$/;"	f	struct:folly::AtomicHashArray::SimpleRetT	access:public	signature:()
folly::AtomicHashArray::SimpleRetT::SimpleRetT	.\AtomicHashArray.h	/^    SimpleRetT(size_t i, bool s) : idx(i), success(s) {}$/;"	f	struct:folly::AtomicHashArray::SimpleRetT	access:public	signature:(size_t i, bool s)
folly::AtomicHashArray::SimpleRetT::idx	.\AtomicHashArray.h	/^  struct SimpleRetT { size_t idx; bool success;$/;"	m	struct:folly::AtomicHashArray::SimpleRetT	access:public
folly::AtomicHashArray::SimpleRetT::success	.\AtomicHashArray.h	/^  struct SimpleRetT { size_t idx; bool success;$/;"	m	struct:folly::AtomicHashArray::SimpleRetT	access:public
folly::AtomicHashArray::SmartPtr	.\AtomicHashArray.h	/^  typedef std::unique_ptr<AtomicHashArray, Deleter> SmartPtr;$/;"	t	class:folly::AtomicHashArray	access:public
folly::AtomicHashArray::acquireLoadKey	.\AtomicHashArray.h	/^  static KeyT acquireLoadKey(const value_type& r) {$/;"	f	class:folly::AtomicHashArray	access:private	signature:(const value_type& r)
folly::AtomicHashArray::aha_iterator	.\AtomicHashArray-inl.h	/^struct AtomicHashArray<KeyT, ValueT, HashFcn, EqualFcn, Allocator>::aha_iterator$/;"	s	class:folly::AtomicHashArray	inherits:boost::iterator_facade
folly::AtomicHashArray::aha_iterator	.\AtomicHashArray.h	/^  struct aha_iterator;$/;"	x
folly::AtomicHashArray::aha_iterator::AtomicHashArray	.\AtomicHashArray-inl.h	/^  friend class AtomicHashArray;$/;"	x
folly::AtomicHashArray::aha_iterator::advancePastEmpty	.\AtomicHashArray-inl.h	/^  void advancePastEmpty() {$/;"	f	struct:folly::AtomicHashArray::aha_iterator	access:private	signature:()
folly::AtomicHashArray::aha_iterator::aha_	.\AtomicHashArray-inl.h	/^  ContT* aha_;$/;"	m	struct:folly::AtomicHashArray::aha_iterator	access:private
folly::AtomicHashArray::aha_iterator::aha_iterator	.\AtomicHashArray-inl.h	/^  aha_iterator(const aha_iterator<OtherContT,OtherVal>& o,$/;"	f	struct:folly::AtomicHashArray::aha_iterator	access:public	signature:(const aha_iterator<OtherContT,OtherVal>& o, typename std::enable_if< std::is_convertible<OtherVal*,IterVal*>::value >::type* = 0)
folly::AtomicHashArray::aha_iterator::aha_iterator	.\AtomicHashArray-inl.h	/^  explicit aha_iterator() : aha_(0) {}$/;"	f	struct:folly::AtomicHashArray::aha_iterator	access:public	signature:()
folly::AtomicHashArray::aha_iterator::aha_iterator	.\AtomicHashArray-inl.h	/^  explicit aha_iterator(ContT* array, size_t offset)$/;"	f	struct:folly::AtomicHashArray::aha_iterator	access:public	signature:(ContT* array, size_t offset)
folly::AtomicHashArray::aha_iterator::dereference	.\AtomicHashArray-inl.h	/^  IterVal& dereference() const {$/;"	f	struct:folly::AtomicHashArray::aha_iterator	access:private	signature:() const
folly::AtomicHashArray::aha_iterator::equal	.\AtomicHashArray-inl.h	/^  bool equal(const aha_iterator& o) const {$/;"	f	struct:folly::AtomicHashArray::aha_iterator	access:private	signature:(const aha_iterator& o) const
folly::AtomicHashArray::aha_iterator::getIndex	.\AtomicHashArray-inl.h	/^  uint32_t getIndex() const { return offset_; }$/;"	f	struct:folly::AtomicHashArray::aha_iterator	access:public	signature:() const
folly::AtomicHashArray::aha_iterator::increment	.\AtomicHashArray-inl.h	/^  void increment() {$/;"	f	struct:folly::AtomicHashArray::aha_iterator	access:private	signature:()
folly::AtomicHashArray::aha_iterator::isValid	.\AtomicHashArray-inl.h	/^  bool isValid() const {$/;"	f	struct:folly::AtomicHashArray::aha_iterator	access:private	signature:() const
folly::AtomicHashArray::aha_iterator::offset_	.\AtomicHashArray-inl.h	/^  size_t offset_;$/;"	m	struct:folly::AtomicHashArray::aha_iterator	access:private
folly::AtomicHashArray::begin	.\AtomicHashArray.h	/^  const_iterator begin() const { return const_iterator(this, 0); }$/;"	f	class:folly::AtomicHashArray	access:public	signature:() const
folly::AtomicHashArray::begin	.\AtomicHashArray.h	/^  iterator begin()             { return iterator(this, 0); }$/;"	f	class:folly::AtomicHashArray	access:public	signature:()
folly::AtomicHashArray::capacity_	.\AtomicHashArray.h	/^  const size_t  capacity_;$/;"	m	class:folly::AtomicHashArray	access:public
folly::AtomicHashArray::cellKeyPtr	.\AtomicHashArray.h	/^  static std::atomic<KeyT>* cellKeyPtr(const value_type& r) {$/;"	f	class:folly::AtomicHashArray	access:private	signature:(const value_type& r)
folly::AtomicHashArray::cells_	.\AtomicHashArray.h	/^  value_type cells_[0];  \/\/ This must be the last field of this class$/;"	m	class:folly::AtomicHashArray	access:private
folly::AtomicHashArray::clear	.\AtomicHashArray-inl.h	/^clear() {$/;"	f	class:folly::AtomicHashArray	signature:()
folly::AtomicHashArray::clear	.\AtomicHashArray.h	/^  void clear();$/;"	p	class:folly::AtomicHashArray	access:public	signature:()
folly::AtomicHashArray::const_iterator	.\AtomicHashArray.h	/^  typedef aha_iterator<const AtomicHashArray,const value_type> const_iterator;$/;"	t	class:folly::AtomicHashArray	access:public
folly::AtomicHashArray::const_pointer	.\AtomicHashArray.h	/^  typedef const value_type*   const_pointer;$/;"	t	class:folly::AtomicHashArray	access:public
folly::AtomicHashArray::const_reference	.\AtomicHashArray.h	/^  typedef const value_type&   const_reference;$/;"	t	class:folly::AtomicHashArray	access:public
folly::AtomicHashArray::create	.\AtomicHashArray-inl.h	/^create(size_t maxSize, const Config& c) {$/;"	f	class:folly::AtomicHashArray	signature:(size_t maxSize, const Config& c)
folly::AtomicHashArray::create	.\AtomicHashArray.h	/^  static SmartPtr create(size_t maxSize, const Config& = defaultConfig);$/;"	p	class:folly::AtomicHashArray	access:public	signature:(size_t maxSize, const Config& = defaultConfig)
folly::AtomicHashArray::defaultConfig	.\AtomicHashArray-inl.h	/^AtomicHashArray<KeyT, ValueT, HashFcn, EqualFcn, Allocator>::defaultConfig;$/;"	m	class:folly::AtomicHashArray
folly::AtomicHashArray::defaultConfig	.\AtomicHashArray.h	/^  static const Config defaultConfig;$/;"	m	class:folly::AtomicHashArray	access:public
folly::AtomicHashArray::destroy	.\AtomicHashArray-inl.h	/^destroy(AtomicHashArray* p) {$/;"	f	class:folly::AtomicHashArray	signature:(AtomicHashArray* p)
folly::AtomicHashArray::destroy	.\AtomicHashArray.h	/^  static void destroy(AtomicHashArray*);$/;"	p	class:folly::AtomicHashArray	access:public	signature:(AtomicHashArray*)
folly::AtomicHashArray::difference_type	.\AtomicHashArray.h	/^  typedef std::ptrdiff_t      difference_type;$/;"	t	class:folly::AtomicHashArray	access:public
folly::AtomicHashArray::empty	.\AtomicHashArray.h	/^  bool empty() const { return size() == 0; }$/;"	f	class:folly::AtomicHashArray	access:public	signature:() const
folly::AtomicHashArray::end	.\AtomicHashArray.h	/^  const_iterator end() const   { return const_iterator(this, capacity_); }$/;"	f	class:folly::AtomicHashArray	access:public	signature:() const
folly::AtomicHashArray::end	.\AtomicHashArray.h	/^  iterator end()               { return iterator(this, capacity_); }$/;"	f	class:folly::AtomicHashArray	access:public	signature:()
folly::AtomicHashArray::erase	.\AtomicHashArray-inl.h	/^erase(KeyT key_in) {$/;"	f	class:folly::AtomicHashArray	signature:(KeyT key_in)
folly::AtomicHashArray::erase	.\AtomicHashArray.h	/^  size_t erase(KeyT k);$/;"	p	class:folly::AtomicHashArray	access:public	signature:(KeyT k)
folly::AtomicHashArray::find	.\AtomicHashArray.h	/^  const_iterator find(KeyT k) const {$/;"	f	class:folly::AtomicHashArray	access:public	signature:(KeyT k) const
folly::AtomicHashArray::find	.\AtomicHashArray.h	/^  iterator find(KeyT k) {$/;"	f	class:folly::AtomicHashArray	access:public	signature:(KeyT k)
folly::AtomicHashArray::findAt	.\AtomicHashArray.h	/^  const_iterator findAt(uint32_t idx) const {$/;"	f	class:folly::AtomicHashArray	access:public	signature:(uint32_t idx) const
folly::AtomicHashArray::findAt	.\AtomicHashArray.h	/^  iterator findAt(uint32_t idx) {$/;"	f	class:folly::AtomicHashArray	access:public	signature:(uint32_t idx)
folly::AtomicHashArray::findInternal	.\AtomicHashArray-inl.h	/^findInternal(const KeyT key_in) {$/;"	f	class:folly::AtomicHashArray	signature:(const KeyT key_in)
folly::AtomicHashArray::findInternal	.\AtomicHashArray.h	/^  SimpleRetT findInternal(const KeyT key);$/;"	p	class:folly::AtomicHashArray	access:private	signature:(const KeyT key)
folly::AtomicHashArray::getEntryCountThreadCacheSize	.\AtomicHashArray.h	/^  int getEntryCountThreadCacheSize() const {$/;"	f	class:folly::AtomicHashArray	access:public	signature:() const
folly::AtomicHashArray::insert	.\AtomicHashArray.h	/^  std::pair<iterator,bool> insert(const value_type& r) {$/;"	f	class:folly::AtomicHashArray	access:public	signature:(const value_type& r)
folly::AtomicHashArray::insert	.\AtomicHashArray.h	/^  std::pair<iterator,bool> insert(value_type&& r) {$/;"	f	class:folly::AtomicHashArray	access:public	signature:(value_type&& r)
folly::AtomicHashArray::insertInternal	.\AtomicHashArray-inl.h	/^insertInternal(KeyT key_in, T&& value) {$/;"	f	class:folly::AtomicHashArray	signature:(KeyT key_in, T&& value)
folly::AtomicHashArray::insertInternal	.\AtomicHashArray.h	/^  SimpleRetT insertInternal(KeyT key, T&& value);$/;"	p	class:folly::AtomicHashArray	access:private	signature:(KeyT key, T&& value)
folly::AtomicHashArray::isFull_	.\AtomicHashArray.h	/^  std::atomic<int64_t> isFull_; \/\/ Used by insertInternal$/;"	m	class:folly::AtomicHashArray	access:private
folly::AtomicHashArray::iterator	.\AtomicHashArray.h	/^  typedef aha_iterator<AtomicHashArray,value_type> iterator;$/;"	t	class:folly::AtomicHashArray	access:public
folly::AtomicHashArray::kAnchorMask_	.\AtomicHashArray.h	/^  const size_t  kAnchorMask_;$/;"	m	class:folly::AtomicHashArray	access:private
folly::AtomicHashArray::kEmptyKey_	.\AtomicHashArray.h	/^  const KeyT    kEmptyKey_;$/;"	m	class:folly::AtomicHashArray	access:public
folly::AtomicHashArray::kErasedKey_	.\AtomicHashArray.h	/^  const KeyT    kErasedKey_;$/;"	m	class:folly::AtomicHashArray	access:public
folly::AtomicHashArray::kLockedKey_	.\AtomicHashArray.h	/^  const KeyT    kLockedKey_;$/;"	m	class:folly::AtomicHashArray	access:public
folly::AtomicHashArray::keyToAnchorIdx	.\AtomicHashArray.h	/^  inline size_t keyToAnchorIdx(const KeyT k) const {$/;"	f	class:folly::AtomicHashArray	access:private	signature:(const KeyT k) const
folly::AtomicHashArray::key_type	.\AtomicHashArray.h	/^  typedef KeyT                key_type;$/;"	t	class:folly::AtomicHashArray	access:public
folly::AtomicHashArray::makeIter	.\AtomicHashArray.h	/^  const_iterator makeIter(size_t idx) const {$/;"	f	class:folly::AtomicHashArray	access:public	signature:(size_t idx) const
folly::AtomicHashArray::makeIter	.\AtomicHashArray.h	/^  iterator makeIter(size_t idx) { return iterator(this, idx); }$/;"	f	class:folly::AtomicHashArray	access:public	signature:(size_t idx)
folly::AtomicHashArray::mapped_type	.\AtomicHashArray.h	/^  typedef ValueT              mapped_type;$/;"	t	class:folly::AtomicHashArray	access:public
folly::AtomicHashArray::maxEntries_	.\AtomicHashArray.h	/^  const size_t  maxEntries_;$/;"	m	class:folly::AtomicHashArray	access:public
folly::AtomicHashArray::maxLoadFactor	.\AtomicHashArray.h	/^  double maxLoadFactor() const { return ((double) maxEntries_) \/ capacity_; }$/;"	f	class:folly::AtomicHashArray	access:public	signature:() const
folly::AtomicHashArray::numEntries_	.\AtomicHashArray.h	/^  ThreadCachedInt<int64_t> numEntries_;  \/\/ Successful key inserts$/;"	m	class:folly::AtomicHashArray	access:private
folly::AtomicHashArray::numErases_	.\AtomicHashArray.h	/^  std::atomic<int64_t> numErases_;   \/\/ Successful key erases$/;"	m	class:folly::AtomicHashArray	access:private
folly::AtomicHashArray::numPendingEntries_	.\AtomicHashArray.h	/^  ThreadCachedInt<int64_t> numPendingEntries_; \/\/ Used by insertInternal$/;"	m	class:folly::AtomicHashArray	access:private
folly::AtomicHashArray::pointer	.\AtomicHashArray.h	/^  typedef value_type*         pointer;$/;"	t	class:folly::AtomicHashArray	access:public
folly::AtomicHashArray::probeNext	.\AtomicHashArray.h	/^  inline size_t probeNext(size_t idx, size_t numProbes) {$/;"	f	class:folly::AtomicHashArray	access:private	signature:(size_t idx, size_t numProbes)
folly::AtomicHashArray::reference	.\AtomicHashArray.h	/^  typedef value_type&         reference;$/;"	t	class:folly::AtomicHashArray	access:public
folly::AtomicHashArray::relaxedLoadKey	.\AtomicHashArray.h	/^  static KeyT relaxedLoadKey(const value_type& r) {$/;"	f	class:folly::AtomicHashArray	access:private	signature:(const value_type& r)
folly::AtomicHashArray::setEntryCountThreadCacheSize	.\AtomicHashArray.h	/^  void setEntryCountThreadCacheSize(uint32_t newSize) {$/;"	f	class:folly::AtomicHashArray	access:public	signature:(uint32_t newSize)
folly::AtomicHashArray::size	.\AtomicHashArray.h	/^  size_t size() const {$/;"	f	class:folly::AtomicHashArray	access:public	signature:() const
folly::AtomicHashArray::size_type	.\AtomicHashArray.h	/^  typedef std::size_t         size_type;$/;"	t	class:folly::AtomicHashArray	access:public
folly::AtomicHashArray::static_assert	.\AtomicHashArray.h	/^  static_assert((std::is_convertible<KeyT,int32_t>::value ||$/;"	p	class:folly::AtomicHashArray	access:private	signature:(std::is_convertible<KeyT,int32_t>::value || std::is_convertible<KeyT,int64_t>::value || std::is_convertible<KeyT,const void*>::value),   
folly::AtomicHashArray::tryLockCell	.\AtomicHashArray.h	/^  inline bool tryLockCell(value_type* const cell) {$/;"	f	class:folly::AtomicHashArray	access:private	signature:(value_type* const cell)
folly::AtomicHashArray::unlockCell	.\AtomicHashArray.h	/^  inline void unlockCell(value_type* const cell, KeyT newKey) {$/;"	f	class:folly::AtomicHashArray	access:private	signature:(value_type* const cell, KeyT newKey)
folly::AtomicHashArray::value_type	.\AtomicHashArray.h	/^  typedef std::pair<const KeyT, ValueT> value_type;$/;"	t	class:folly::AtomicHashArray	access:public
folly::AtomicHashArray::~AtomicHashArray	.\AtomicHashArray.h	/^  ~AtomicHashArray() {}$/;"	f	class:folly::AtomicHashArray	access:private	signature:()
folly::AtomicHashMap	.\AtomicHashArray.h	/^class AtomicHashMap;$/;"	x
folly::AtomicHashMap	.\AtomicHashMap.h	/^class AtomicHashMap : boost::noncopyable {$/;"	c	namespace:folly	inherits:boost::noncopyable
folly::AtomicHashMap::AtomicHashMap	.\AtomicHashMap-inl.h	/^AtomicHashMap(size_t size, const Config& config)$/;"	f	class:folly::AtomicHashMap	signature:(size_t size, const Config& config)
folly::AtomicHashMap::AtomicHashMap	.\AtomicHashMap.h	/^  explicit AtomicHashMap(size_t finalSizeEst, const Config& = defaultConfig);$/;"	p	class:folly::AtomicHashMap	access:public	signature:(size_t finalSizeEst, const Config& = defaultConfig)
folly::AtomicHashMap::Config	.\AtomicHashMap.h	/^  typedef typename SubMap::Config Config;$/;"	t	class:folly::AtomicHashMap	access:public
folly::AtomicHashMap::SimpleRetT	.\AtomicHashMap.h	/^  struct SimpleRetT { uint32_t i; size_t j; bool success;$/;"	s	class:folly::AtomicHashMap	access:private
folly::AtomicHashMap::SimpleRetT::SimpleRetT	.\AtomicHashMap.h	/^    SimpleRetT() {}$/;"	f	struct:folly::AtomicHashMap::SimpleRetT	access:public	signature:()
folly::AtomicHashMap::SimpleRetT::SimpleRetT	.\AtomicHashMap.h	/^    SimpleRetT(uint32_t ii, size_t jj, bool s) : i(ii), j(jj), success(s) {}$/;"	f	struct:folly::AtomicHashMap::SimpleRetT	access:public	signature:(uint32_t ii, size_t jj, bool s)
folly::AtomicHashMap::SimpleRetT::i	.\AtomicHashMap.h	/^  struct SimpleRetT { uint32_t i; size_t j; bool success;$/;"	m	struct:folly::AtomicHashMap::SimpleRetT	access:public
folly::AtomicHashMap::SimpleRetT::j	.\AtomicHashMap.h	/^  struct SimpleRetT { uint32_t i; size_t j; bool success;$/;"	m	struct:folly::AtomicHashMap::SimpleRetT	access:public
folly::AtomicHashMap::SimpleRetT::success	.\AtomicHashMap.h	/^  struct SimpleRetT { uint32_t i; size_t j; bool success;$/;"	m	struct:folly::AtomicHashMap::SimpleRetT	access:public
folly::AtomicHashMap::SubMap	.\AtomicHashMap.h	/^  typedef AtomicHashArray<KeyT, ValueT, HashFcn, EqualFcn, Allocator> SubMap;$/;"	t	class:folly::AtomicHashMap	access:private
folly::AtomicHashMap::ahm_iterator	.\AtomicHashMap-inl.h	/^struct AtomicHashMap<KeyT, ValueT, HashFcn, EqualFcn, Allocator>::ahm_iterator$/;"	s	class:folly::AtomicHashMap	inherits:boost::iterator_facade
folly::AtomicHashMap::ahm_iterator	.\AtomicHashMap.h	/^  struct ahm_iterator;$/;"	x
folly::AtomicHashMap::ahm_iterator::AtomicHashMap	.\AtomicHashMap-inl.h	/^  friend class AtomicHashMap;$/;"	x
folly::AtomicHashMap::ahm_iterator::ahm_	.\AtomicHashMap-inl.h	/^  ContT* ahm_;$/;"	m	struct:folly::AtomicHashMap::ahm_iterator	access:private
folly::AtomicHashMap::ahm_iterator::ahm_iterator	.\AtomicHashMap-inl.h	/^  ahm_iterator(const ahm_iterator<OtherContT,OtherVal,OtherSubIt>& o,$/;"	f	struct:folly::AtomicHashMap::ahm_iterator	access:public	signature:(const ahm_iterator<OtherContT,OtherVal,OtherSubIt>& o, typename std::enable_if< std::is_convertible<OtherSubIt,SubIt>::value >::type* = 0)
folly::AtomicHashMap::ahm_iterator::ahm_iterator	.\AtomicHashMap-inl.h	/^  explicit ahm_iterator() : ahm_(0) {}$/;"	f	struct:folly::AtomicHashMap::ahm_iterator	access:public	signature:()
folly::AtomicHashMap::ahm_iterator::ahm_iterator	.\AtomicHashMap-inl.h	/^  explicit ahm_iterator(ContT* ahm,$/;"	f	struct:folly::AtomicHashMap::ahm_iterator	access:private	signature:(ContT* ahm, uint32_t subMap, const SubIt& subIt)
folly::AtomicHashMap::ahm_iterator::checkAdvanceToNextSubmap	.\AtomicHashMap-inl.h	/^  void checkAdvanceToNextSubmap() {$/;"	f	struct:folly::AtomicHashMap::ahm_iterator	access:private	signature:()
folly::AtomicHashMap::ahm_iterator::dereference	.\AtomicHashMap-inl.h	/^  IterVal& dereference() const {$/;"	f	struct:folly::AtomicHashMap::ahm_iterator	access:private	signature:() const
folly::AtomicHashMap::ahm_iterator::equal	.\AtomicHashMap-inl.h	/^  bool equal(const ahm_iterator& other) const {$/;"	f	struct:folly::AtomicHashMap::ahm_iterator	access:private	signature:(const ahm_iterator& other) const
folly::AtomicHashMap::ahm_iterator::getIndex	.\AtomicHashMap-inl.h	/^  uint32_t getIndex() const {$/;"	f	struct:folly::AtomicHashMap::ahm_iterator	access:public	signature:() const
folly::AtomicHashMap::ahm_iterator::increment	.\AtomicHashMap-inl.h	/^  void increment() {$/;"	f	struct:folly::AtomicHashMap::ahm_iterator	access:private	signature:()
folly::AtomicHashMap::ahm_iterator::isEnd	.\AtomicHashMap-inl.h	/^  bool isEnd() const { return ahm_ == nullptr; }$/;"	f	struct:folly::AtomicHashMap::ahm_iterator	access:private	signature:() const
folly::AtomicHashMap::ahm_iterator::subIt_	.\AtomicHashMap-inl.h	/^  SubIt subIt_;$/;"	m	struct:folly::AtomicHashMap::ahm_iterator	access:private
folly::AtomicHashMap::ahm_iterator::subMap_	.\AtomicHashMap-inl.h	/^  uint32_t subMap_;$/;"	m	struct:folly::AtomicHashMap::ahm_iterator	access:private
folly::AtomicHashMap::begin	.\AtomicHashMap.h	/^  const_iterator begin() const {$/;"	f	class:folly::AtomicHashMap	access:public	signature:() const
folly::AtomicHashMap::begin	.\AtomicHashMap.h	/^  iterator begin() {$/;"	f	class:folly::AtomicHashMap	access:public	signature:()
folly::AtomicHashMap::capacity	.\AtomicHashMap-inl.h	/^capacity() const {$/;"	f	class:folly::AtomicHashMap	signature:() const
folly::AtomicHashMap::capacity	.\AtomicHashMap.h	/^  size_t capacity() const;$/;"	p	class:folly::AtomicHashMap	access:public	signature:() const
folly::AtomicHashMap::clear	.\AtomicHashMap-inl.h	/^clear() {$/;"	f	class:folly::AtomicHashMap	signature:()
folly::AtomicHashMap::clear	.\AtomicHashMap.h	/^  void clear();$/;"	p	class:folly::AtomicHashMap	access:public	signature:()
folly::AtomicHashMap::const_iterator	.\AtomicHashMap.h	/^    const_iterator;$/;"	t	class:folly::AtomicHashMap	access:public
folly::AtomicHashMap::const_reference	.\AtomicHashMap.h	/^  typedef const value_type&   const_reference;$/;"	t	class:folly::AtomicHashMap	access:public
folly::AtomicHashMap::count	.\AtomicHashMap.h	/^  size_type count(key_type k) const {$/;"	f	class:folly::AtomicHashMap	access:public	signature:(key_type k) const
folly::AtomicHashMap::defaultConfig	.\AtomicHashMap-inl.h	/^AtomicHashMap<KeyT, ValueT, HashFcn, EqualFcn, Allocator>::defaultConfig;$/;"	m	class:folly::AtomicHashMap
folly::AtomicHashMap::defaultConfig	.\AtomicHashMap.h	/^  static const Config defaultConfig;$/;"	m	class:folly::AtomicHashMap	access:public
folly::AtomicHashMap::difference_type	.\AtomicHashMap.h	/^  typedef std::ptrdiff_t      difference_type;$/;"	t	class:folly::AtomicHashMap	access:public
folly::AtomicHashMap::empty	.\AtomicHashMap.h	/^  bool empty() const { return size() == 0; }$/;"	f	class:folly::AtomicHashMap	access:public	signature:() const
folly::AtomicHashMap::encodeIndex	.\AtomicHashMap-inl.h	/^encodeIndex(uint32_t subMap, uint32_t offset) {$/;"	f	class:folly::AtomicHashMap	signature:(uint32_t subMap, uint32_t offset)
folly::AtomicHashMap::encodeIndex	.\AtomicHashMap.h	/^  static inline uint32_t encodeIndex(uint32_t subMap, uint32_t subMapIdx);$/;"	p	class:folly::AtomicHashMap	access:private	signature:(uint32_t subMap, uint32_t subMapIdx)
folly::AtomicHashMap::end	.\AtomicHashMap.h	/^  const_iterator end() const {$/;"	f	class:folly::AtomicHashMap	access:public	signature:() const
folly::AtomicHashMap::end	.\AtomicHashMap.h	/^  iterator end() {$/;"	f	class:folly::AtomicHashMap	access:public	signature:()
folly::AtomicHashMap::erase	.\AtomicHashMap-inl.h	/^erase(const KeyT k) {$/;"	f	class:folly::AtomicHashMap	signature:(const KeyT k)
folly::AtomicHashMap::erase	.\AtomicHashMap.h	/^  size_type erase(key_type k);$/;"	p	class:folly::AtomicHashMap	access:public	signature:(key_type k)
folly::AtomicHashMap::find	.\AtomicHashMap-inl.h	/^find(KeyT k) const {$/;"	f	class:folly::AtomicHashMap	signature:(KeyT k) const
folly::AtomicHashMap::find	.\AtomicHashMap-inl.h	/^find(KeyT k) {$/;"	f	class:folly::AtomicHashMap	signature:(KeyT k)
folly::AtomicHashMap::find	.\AtomicHashMap.h	/^  const_iterator find(key_type k) const;$/;"	p	class:folly::AtomicHashMap	access:public	signature:(key_type k) const
folly::AtomicHashMap::find	.\AtomicHashMap.h	/^  iterator find(key_type k);$/;"	p	class:folly::AtomicHashMap	access:public	signature:(key_type k)
folly::AtomicHashMap::findAt	.\AtomicHashMap.h	/^  const_iterator findAt(uint32_t idx) const {$/;"	f	class:folly::AtomicHashMap	access:public	signature:(uint32_t idx) const
folly::AtomicHashMap::findAt	.\AtomicHashMap.h	/^  iterator findAt(uint32_t idx) {$/;"	f	class:folly::AtomicHashMap	access:public	signature:(uint32_t idx)
folly::AtomicHashMap::findAtInternal	.\AtomicHashMap-inl.h	/^findAtInternal(uint32_t idx) const {$/;"	f	class:folly::AtomicHashMap	signature:(uint32_t idx) const
folly::AtomicHashMap::findAtInternal	.\AtomicHashMap.h	/^  SimpleRetT findAtInternal(uint32_t idx) const;$/;"	p	class:folly::AtomicHashMap	access:private	signature:(uint32_t idx) const
folly::AtomicHashMap::findInternal	.\AtomicHashMap-inl.h	/^findInternal(const KeyT k) const {$/;"	f	class:folly::AtomicHashMap	signature:(const KeyT k) const
folly::AtomicHashMap::findInternal	.\AtomicHashMap.h	/^  SimpleRetT findInternal(const KeyT k) const;$/;"	p	class:folly::AtomicHashMap	access:private	signature:(const KeyT k) const
folly::AtomicHashMap::hash_function	.\AtomicHashMap.h	/^  hasher hash_function() const { return hasher(); }$/;"	f	class:folly::AtomicHashMap	access:public	signature:() const
folly::AtomicHashMap::hasher	.\AtomicHashMap.h	/^  typedef HashFcn             hasher;$/;"	t	class:folly::AtomicHashMap	access:public
folly::AtomicHashMap::idxToRec	.\AtomicHashMap.h	/^  inline const value_type& idxToRec(uint32_t idx) const {$/;"	f	class:folly::AtomicHashMap	access:public	signature:(uint32_t idx) const
folly::AtomicHashMap::insert	.\AtomicHashMap-inl.h	/^insert(key_type k, const mapped_type& v) {$/;"	f	class:folly::AtomicHashMap	signature:(key_type k, const mapped_type& v)
folly::AtomicHashMap::insert	.\AtomicHashMap-inl.h	/^insert(key_type k, mapped_type&& v) {$/;"	f	class:folly::AtomicHashMap	signature:(key_type k, mapped_type&& v)
folly::AtomicHashMap::insert	.\AtomicHashMap.h	/^  std::pair<iterator,bool> insert(const value_type& r) {$/;"	f	class:folly::AtomicHashMap	access:public	signature:(const value_type& r)
folly::AtomicHashMap::insert	.\AtomicHashMap.h	/^  std::pair<iterator,bool> insert(key_type k, const mapped_type& v);$/;"	p	class:folly::AtomicHashMap	access:public	signature:(key_type k, const mapped_type& v)
folly::AtomicHashMap::insert	.\AtomicHashMap.h	/^  std::pair<iterator,bool> insert(key_type k, mapped_type&& v);$/;"	p	class:folly::AtomicHashMap	access:public	signature:(key_type k, mapped_type&& v)
folly::AtomicHashMap::insert	.\AtomicHashMap.h	/^  std::pair<iterator,bool> insert(value_type&& r) {$/;"	f	class:folly::AtomicHashMap	access:public	signature:(value_type&& r)
folly::AtomicHashMap::insertInternal	.\AtomicHashMap-inl.h	/^insertInternal(key_type key, T&& value) {$/;"	f	class:folly::AtomicHashMap	signature:(key_type key, T&& value)
folly::AtomicHashMap::insertInternal	.\AtomicHashMap.h	/^  SimpleRetT insertInternal(KeyT key, T&& value);$/;"	p	class:folly::AtomicHashMap	access:private	signature:(KeyT key, T&& value)
folly::AtomicHashMap::iterator	.\AtomicHashMap.h	/^    iterator;$/;"	t	class:folly::AtomicHashMap	access:public
folly::AtomicHashMap::kGrowthFrac_	.\AtomicHashMap.h	/^  const float kGrowthFrac_;  \/\/ How much to grow when we run out of capacity.$/;"	m	class:folly::AtomicHashMap	access:public
folly::AtomicHashMap::kLockedPtr_	.\AtomicHashMap.h	/^  static const uintptr_t kLockedPtr_         = 0x88ul << 48; \/\/ invalid pointer$/;"	m	class:folly::AtomicHashMap	access:private
folly::AtomicHashMap::kNumSubMapBits_	.\AtomicHashMap.h	/^  static const uint32_t  kNumSubMapBits_     = 4;$/;"	m	class:folly::AtomicHashMap	access:private
folly::AtomicHashMap::kNumSubMaps_	.\AtomicHashMap.h	/^  static const uint32_t  kNumSubMaps_        = 1 << kNumSubMapBits_;$/;"	m	class:folly::AtomicHashMap	access:private
folly::AtomicHashMap::kSecondaryMapBit_	.\AtomicHashMap.h	/^  static const uint32_t  kSecondaryMapBit_   = 1u << 31; \/\/ Highest bit$/;"	m	class:folly::AtomicHashMap	access:private
folly::AtomicHashMap::kSubMapIndexMask_	.\AtomicHashMap.h	/^  static const uint32_t  kSubMapIndexMask_   = (1 << kSubMapIndexShift_) - 1;$/;"	m	class:folly::AtomicHashMap	access:private
folly::AtomicHashMap::kSubMapIndexShift_	.\AtomicHashMap.h	/^  static const uint32_t  kSubMapIndexShift_  = 32 - kNumSubMapBits_ - 1;$/;"	m	class:folly::AtomicHashMap	access:private
folly::AtomicHashMap::keyToIdx	.\AtomicHashMap.h	/^  inline uint32_t keyToIdx(const KeyT k, bool mayInsert = false) {$/;"	f	class:folly::AtomicHashMap	access:public	signature:(const KeyT k, bool mayInsert = false)
folly::AtomicHashMap::key_eq	.\AtomicHashMap.h	/^  key_equal key_eq() const { return key_equal(); }$/;"	f	class:folly::AtomicHashMap	access:public	signature:() const
folly::AtomicHashMap::key_equal	.\AtomicHashMap.h	/^  typedef EqualFcn            key_equal;$/;"	t	class:folly::AtomicHashMap	access:public
folly::AtomicHashMap::key_type	.\AtomicHashMap.h	/^  typedef KeyT                key_type;$/;"	t	class:folly::AtomicHashMap	access:public
folly::AtomicHashMap::mapped_type	.\AtomicHashMap.h	/^  typedef ValueT              mapped_type;$/;"	t	class:folly::AtomicHashMap	access:public
folly::AtomicHashMap::numMapsAllocated_	.\AtomicHashMap.h	/^  std::atomic<uint32_t> numMapsAllocated_;$/;"	m	class:folly::AtomicHashMap	access:private
folly::AtomicHashMap::numSubMaps	.\AtomicHashMap.h	/^  int numSubMaps() const {$/;"	f	class:folly::AtomicHashMap	access:public	signature:() const
folly::AtomicHashMap::pointer	.\AtomicHashMap.h	/^  typedef value_type*         pointer;$/;"	t	class:folly::AtomicHashMap	access:public
folly::AtomicHashMap::recToIdx	.\AtomicHashMap.h	/^  inline uint32_t recToIdx(const value_type& r, bool mayInsert = true) {$/;"	f	class:folly::AtomicHashMap	access:public	signature:(const value_type& r, bool mayInsert = true)
folly::AtomicHashMap::recToIdx	.\AtomicHashMap.h	/^  inline uint32_t recToIdx(key_type k, const mapped_type& v,$/;"	f	class:folly::AtomicHashMap	access:public	signature:(key_type k, const mapped_type& v, bool mayInsert = true)
folly::AtomicHashMap::recToIdx	.\AtomicHashMap.h	/^  inline uint32_t recToIdx(key_type k, mapped_type&& v, bool mayInsert = true) {$/;"	f	class:folly::AtomicHashMap	access:public	signature:(key_type k, mapped_type&& v, bool mayInsert = true)
folly::AtomicHashMap::recToIdx	.\AtomicHashMap.h	/^  inline uint32_t recToIdx(value_type&& r, bool mayInsert = true) {$/;"	f	class:folly::AtomicHashMap	access:public	signature:(value_type&& r, bool mayInsert = true)
folly::AtomicHashMap::reference	.\AtomicHashMap.h	/^  typedef value_type&         reference;$/;"	t	class:folly::AtomicHashMap	access:public
folly::AtomicHashMap::setEntryCountThreadCacheSize	.\AtomicHashMap.h	/^  void setEntryCountThreadCacheSize(int32_t newSize) {$/;"	f	class:folly::AtomicHashMap	access:public	signature:(int32_t newSize)
folly::AtomicHashMap::size	.\AtomicHashMap-inl.h	/^size() const {$/;"	f	class:folly::AtomicHashMap	signature:() const
folly::AtomicHashMap::size	.\AtomicHashMap.h	/^  size_t size() const;$/;"	p	class:folly::AtomicHashMap	access:public	signature:() const
folly::AtomicHashMap::size_type	.\AtomicHashMap.h	/^  typedef std::size_t         size_type;$/;"	t	class:folly::AtomicHashMap	access:public
folly::AtomicHashMap::spaceRemaining	.\AtomicHashMap-inl.h	/^spaceRemaining() const {$/;"	f	class:folly::AtomicHashMap	signature:() const
folly::AtomicHashMap::spaceRemaining	.\AtomicHashMap.h	/^  size_t spaceRemaining() const;$/;"	p	class:folly::AtomicHashMap	access:public	signature:() const
folly::AtomicHashMap::subMaps_	.\AtomicHashMap.h	/^  std::atomic<SubMap*> subMaps_[kNumSubMaps_];$/;"	m	class:folly::AtomicHashMap	access:private
folly::AtomicHashMap::tryLockMap	.\AtomicHashMap.h	/^  inline bool tryLockMap(int idx) {$/;"	f	class:folly::AtomicHashMap	access:private	signature:(int idx)
folly::AtomicHashMap::value_type	.\AtomicHashMap.h	/^  typedef std::pair<const KeyT, ValueT> value_type;$/;"	t	class:folly::AtomicHashMap	access:public
folly::AtomicHashMap::~AtomicHashMap	.\AtomicHashMap.h	/^  ~AtomicHashMap() {$/;"	f	class:folly::AtomicHashMap	access:public	signature:()
folly::AtomicHashMapFullError	.\AtomicHashMap.h	/^struct AtomicHashMapFullError : std::runtime_error {$/;"	s	namespace:folly	inherits:std::runtime_error
folly::AtomicHashMapFullError::AtomicHashMapFullError	.\AtomicHashMap.h	/^  explicit AtomicHashMapFullError()$/;"	f	struct:folly::AtomicHashMapFullError	access:public	signature:()
folly::AtomicStruct	.\AtomicStruct.h	/^class AtomicStruct {$/;"	c	namespace:folly
folly::AtomicStruct::AtomicStruct	.\AtomicStruct.h	/^  AtomicStruct() = default;$/;"	p	class:folly::AtomicStruct	access:public	signature:()
folly::AtomicStruct::AtomicStruct	.\AtomicStruct.h	/^  AtomicStruct(AtomicStruct<T> const &) = delete;$/;"	p	class:folly::AtomicStruct	access:public	signature:(AtomicStruct<T> const &)
folly::AtomicStruct::alignof	.\AtomicStruct.h	/^  static_assert(alignof(T) <= alignof(Raw),$/;"	p	class:folly::AtomicStruct	access:private	signature:(T)
folly::AtomicStruct::data	.\AtomicStruct.h	/^  Atom<Raw> data;$/;"	m	class:folly::AtomicStruct	access:private
folly::AtomicStruct::encode	.\AtomicStruct.h	/^  constexpr \/* implicit *\/ AtomicStruct(T v) noexcept : data(encode(v)) {}$/;"	f	class:folly::AtomicStruct	access:public	signature:(v)
folly::AtomicStruct::operator =	.\AtomicStruct.h	/^  AtomicStruct<T>& operator= (AtomicStruct<T> const &) = delete;$/;"	p	class:folly::AtomicStruct	access:public	signature:(AtomicStruct<T> const &)
folly::AtomicStruct::sizeof	.\AtomicStruct.h	/^  static_assert(sizeof(T) <= sizeof(Raw),$/;"	p	class:folly::AtomicStruct	access:private	signature:(T)
folly::AtomicStruct::~AtomicStruct	.\AtomicStruct.h	/^  ~AtomicStruct() = default;$/;"	p	class:folly::AtomicStruct	access:public	signature:()
folly::BENCHMARK	.\Benchmark.cpp	/^BENCHMARK(globalBenchmarkBaseline) {$/;"	f	namespace:folly	signature:(globalBenchmarkBaseline)
folly::BadFormatArg	.\FormatArg.h	/^class BadFormatArg : public std::invalid_argument {$/;"	c	namespace:folly	inherits:std::invalid_argument
folly::BadFormatArg::BadFormatArg	.\FormatArg.h	/^  explicit BadFormatArg(const std::string& msg)$/;"	f	class:folly::BadFormatArg	access:public	signature:(const std::string& msg)
folly::BaseFormatter	.\Format.h	/^class BaseFormatter {$/;"	c	namespace:folly
folly::BaseFormatter::BaseFormatter	.\Format-inl.h	/^BaseFormatter<Derived, containerMode, Args...>::BaseFormatter(StringPiece str,$/;"	f	class:folly::BaseFormatter	signature:(StringPiece str, Args&&... args)
folly::BaseFormatter::BaseType	.\Format.h	/^  typedef BaseFormatter BaseType;$/;"	t	class:folly::BaseFormatter	access:public
folly::BaseFormatter::IsFormatter	.\Format.h	/^  typedef detail::FormatterTag IsFormatter;$/;"	t	class:folly::BaseFormatter	access:public
folly::BaseFormatter::ValueTuple	.\Format.h	/^      typename std::decay<Args>::type>...> ValueTuple;$/;"	t	class:folly::BaseFormatter	access:private
folly::BaseFormatter::appendOutput	.\Format-inl.h	/^void BaseFormatter<Derived, containerMode, Args...>::appendOutput(Output& out)$/;"	f	class:folly::BaseFormatter	signature:(Output& out) const
folly::BaseFormatter::appendOutput	.\Format.h	/^  void appendOutput(Output& out) const;$/;"	p	class:folly::BaseFormatter	access:private	signature:(Output& out) const
folly::BaseFormatter::appendTo	.\Format.h	/^  appendTo(Str& str) const {$/;"	f	class:folly::BaseFormatter	access:public	signature:(Str& str) const
folly::BaseFormatter::doFormatFrom	.\Format.h	/^  doFormatFrom(size_t i, FormatArg& arg, Callback& cb) const {$/;"	f	class:folly::BaseFormatter	access:private	signature:(size_t i, FormatArg& arg, Callback& cb) const
folly::BaseFormatter::fbstr	.\Format.h	/^  fbstring fbstr() const {$/;"	f	class:folly::BaseFormatter	access:public	signature:() const
folly::BaseFormatter::handleFormatStrError	.\Format-inl.h	/^void BaseFormatter<Derived, containerMode, Args...>::handleFormatStrError()$/;"	f	class:folly::BaseFormatter	signature:() const
folly::BaseFormatter::handleFormatStrError	.\Format.h	/^  FOLLY_NORETURN void handleFormatStrError() const;$/;"	p	class:folly::BaseFormatter	access:private	signature:() const
folly::BaseFormatter::operator ()	.\Format-inl.h	/^void BaseFormatter<Derived, containerMode, Args...>::operator()(Output& out)$/;"	f	class:folly::BaseFormatter	signature:(Output& out) const
folly::BaseFormatter::operator ()	.\Format.h	/^  void operator()(Output& out) const;$/;"	p	class:folly::BaseFormatter	access:public	signature:(Output& out) const
folly::BaseFormatter::setCrashOnError	.\Format.h	/^  void setCrashOnError(bool crash) {$/;"	f	class:folly::BaseFormatter	access:public	signature:(bool crash)
folly::BaseFormatter::std::doFormatArg	.\Format.h	/^      static_cast<const Derived*>(this)->template doFormatArg<K>(arg, cb);$/;"	p	class:folly::BaseFormatter::std	access:private	signature:(arg, cb)
folly::BaseFormatter::str	.\Format.h	/^  std::string str() const {$/;"	f	class:folly::BaseFormatter	access:public	signature:() const
folly::BaseFormatter::valueCount	.\Format.h	/^  static constexpr size_t valueCount = std::tuple_size<ValueTuple>::value;$/;"	m	class:folly::BaseFormatter	access:private
folly::Baton	.\Baton.h	/^struct Baton : boost::noncopyable {$/;"	s	namespace:folly	inherits:boost::noncopyable
folly::Baton::Baton	.\Baton.h	/^  Baton() : state_(INIT) {}$/;"	f	struct:folly::Baton	access:public	signature:()
folly::Baton::EARLY_DELIVERY	.\Baton.h	/^    EARLY_DELIVERY = 1,$/;"	m	struct:folly::Baton	typeref:enum:folly::Baton::	access:private
folly::Baton::LATE_DELIVERY	.\Baton.h	/^    LATE_DELIVERY = 3,$/;"	m	struct:folly::Baton	typeref:enum:folly::Baton::	access:private
folly::Baton::PreBlockAttempts	.\Baton.h	/^    PreBlockAttempts = 300,$/;"	e	enum:folly::Baton::__anon2
folly::Baton::State	.\Baton.h	/^  enum State : uint32_t {$/;"	x
folly::Baton::TIMED_OUT	.\Baton.h	/^    TIMED_OUT = 4$/;"	m	struct:folly::Baton	typeref:enum:folly::Baton::	access:private
folly::Baton::WAITING	.\Baton.h	/^    WAITING = 2,$/;"	m	struct:folly::Baton	typeref:enum:folly::Baton::	access:private
folly::Baton::post	.\Baton.h	/^  void post() {$/;"	f	struct:folly::Baton	access:public	signature:()
folly::Baton::reset	.\Baton.h	/^  void reset() {$/;"	f	struct:folly::Baton	access:public	signature:()
folly::Baton::spinWaitForEarlyDelivery	.\Baton.h	/^  bool spinWaitForEarlyDelivery() {$/;"	f	struct:folly::Baton	access:private	signature:()
folly::Baton::state_	.\Baton.h	/^  detail::Futex<Atom> state_;$/;"	m	struct:folly::Baton	access:private
folly::Baton::timed_wait	.\Baton.h	/^  bool timed_wait(const std::chrono::time_point<Clock,Duration>& deadline) {$/;"	f	struct:folly::Baton	access:public	signature:(const std::chrono::time_point<Clock,Duration>& deadline)
folly::Baton::try_wait	.\Baton.h	/^  bool try_wait() {$/;"	f	struct:folly::Baton	access:public	signature:()
folly::Baton::wait	.\Baton.h	/^  void wait() {$/;"	f	struct:folly::Baton	access:public	signature:()
folly::Baton::~Baton	.\Baton.h	/^  ~Baton() {$/;"	f	struct:folly::Baton	access:public	signature:()
folly::BenchmarkFun	.\Benchmark.cpp	/^typedef function<detail::TimeIterPair(unsigned int)> BenchmarkFun;$/;"	t	namespace:folly	file:
folly::BenchmarkSuspender	.\Benchmark.h	/^struct BenchmarkSuspender {$/;"	s	namespace:folly
folly::BenchmarkSuspender::BenchmarkSuspender	.\Benchmark.h	/^  BenchmarkSuspender() {$/;"	f	struct:folly::BenchmarkSuspender	access:public	signature:()
folly::BenchmarkSuspender::BenchmarkSuspender	.\Benchmark.h	/^  BenchmarkSuspender(BenchmarkSuspender && rhs) {$/;"	f	struct:folly::BenchmarkSuspender	access:public	signature:(BenchmarkSuspender && rhs)
folly::BenchmarkSuspender::BenchmarkSuspender	.\Benchmark.h	/^  BenchmarkSuspender(const BenchmarkSuspender &) = delete;$/;"	p	struct:folly::BenchmarkSuspender	access:public	signature:(const BenchmarkSuspender &)
folly::BenchmarkSuspender::NanosecondsSpent	.\Benchmark.h	/^  typedef uint64_t NanosecondsSpent;$/;"	t	struct:folly::BenchmarkSuspender	access:public
folly::BenchmarkSuspender::dismiss	.\Benchmark.h	/^  void dismiss() {$/;"	f	struct:folly::BenchmarkSuspender	access:public	signature:()
folly::BenchmarkSuspender::nsSpent	.\Benchmark.cpp	/^BenchmarkSuspender::NanosecondsSpent BenchmarkSuspender::nsSpent;$/;"	m	class:folly::BenchmarkSuspender	file:
folly::BenchmarkSuspender::nsSpent	.\Benchmark.h	/^  static NanosecondsSpent nsSpent;$/;"	m	struct:folly::BenchmarkSuspender	access:public
folly::BenchmarkSuspender::operator =	.\Benchmark.h	/^  BenchmarkSuspender& operator=(BenchmarkSuspender && rhs) {$/;"	f	struct:folly::BenchmarkSuspender	access:public	signature:(BenchmarkSuspender && rhs)
folly::BenchmarkSuspender::operator =	.\Benchmark.h	/^  BenchmarkSuspender& operator=(const BenchmarkSuspender &) = delete;$/;"	p	struct:folly::BenchmarkSuspender	access:public	signature:(const BenchmarkSuspender &)
folly::BenchmarkSuspender::operator int BenchmarkSuspender::*	.\Benchmark.h	/^  operator int BenchmarkSuspender::*() const {$/;"	f	struct:folly::BenchmarkSuspender	access:public	signature:() const
folly::BenchmarkSuspender::rehire	.\Benchmark.h	/^  void rehire() {$/;"	f	struct:folly::BenchmarkSuspender	access:public	signature:()
folly::BenchmarkSuspender::start	.\Benchmark.h	/^  timespec start;$/;"	m	struct:folly::BenchmarkSuspender	access:private
folly::BenchmarkSuspender::tally	.\Benchmark.h	/^  void tally() {$/;"	f	struct:folly::BenchmarkSuspender	access:private	signature:()
folly::BenchmarkSuspender::~BenchmarkSuspender	.\Benchmark.h	/^  ~BenchmarkSuspender() {$/;"	f	struct:folly::BenchmarkSuspender	access:public	signature:()
folly::BitIterator	.\detail\BitIteratorDetail.h	/^template <class BaseIter> class BitIterator;$/;"	x
folly::Bits	.\experimental\Bits.h	/^struct Bits {$/;"	s	namespace:folly
folly::Bits::UnderlyingType	.\experimental\Bits.h	/^  typedef typename Traits::UnderlyingType UnderlyingType;$/;"	t	struct:folly::Bits	access:public
folly::Bits::bitOffset	.\experimental\Bits.h	/^  static constexpr size_t bitOffset(size_t bit) {$/;"	f	struct:folly::Bits	access:public	signature:(size_t bit)
folly::Bits::bitsPerBlock	.\experimental\Bits.h	/^  static constexpr size_t bitsPerBlock = std::numeric_limits<$/;"	m	struct:folly::Bits	access:public
folly::Bits::blockCount	.\experimental\Bits.h	/^  static constexpr size_t blockCount(size_t nbits) {$/;"	f	struct:folly::Bits	access:public	signature:(size_t nbits)
folly::Bits::blockIndex	.\experimental\Bits.h	/^  static constexpr size_t blockIndex(size_t bit) {$/;"	f	struct:folly::Bits	access:public	signature:(size_t bit)
folly::Bits::clear	.\experimental\Bits.h	/^  static void clear(T* p, size_t bit);$/;"	p	struct:folly::Bits	access:public	signature:(T* p, size_t bit)
folly::Bits::clear	.\experimental\Bits.h	/^inline void Bits<T, Traits>::clear(T* p, size_t bit) {$/;"	f	class:folly::Bits	signature:(T* p, size_t bit)
folly::Bits::count	.\experimental\Bits.h	/^  static size_t count(const T* begin, const T* end);$/;"	p	struct:folly::Bits	access:public	signature:(const T* begin, const T* end)
folly::Bits::count	.\experimental\Bits.h	/^inline size_t Bits<T, Traits>::count(const T* begin, const T* end) {$/;"	f	class:folly::Bits	signature:(const T* begin, const T* end)
folly::Bits::get	.\experimental\Bits.h	/^  static UnderlyingType get(const T* p, size_t bitStart, size_t count);$/;"	p	struct:folly::Bits	access:public	signature:(const T* p, size_t bitStart, size_t count)
folly::Bits::innerGet	.\experimental\Bits.h	/^  static UnderlyingType innerGet(const T* p, size_t bitStart, size_t count);$/;"	p	struct:folly::Bits	access:private	signature:(const T* p, size_t bitStart, size_t count)
folly::Bits::innerSet	.\experimental\Bits.h	/^  static void innerSet(T* p, size_t bitStart, size_t count,$/;"	p	struct:folly::Bits	access:private	signature:(T* p, size_t bitStart, size_t count, UnderlyingType value)
folly::Bits::innerSet	.\experimental\Bits.h	/^inline void Bits<T, Traits>::innerSet(T* p, size_t offset, size_t count,$/;"	f	class:folly::Bits	signature:(T* p, size_t offset, size_t count, UnderlyingType value)
folly::Bits::one	.\experimental\Bits.h	/^  static constexpr UnderlyingType one = UnderlyingType(1);$/;"	m	struct:folly::Bits	access:private
folly::Bits::ones	.\experimental\Bits.h	/^  static constexpr UnderlyingType ones(size_t count) {$/;"	f	struct:folly::Bits	access:private	signature:(size_t count)
folly::Bits::set	.\experimental\Bits.h	/^  static void set(T* p, size_t bit);$/;"	p	struct:folly::Bits	access:public	signature:(T* p, size_t bit)
folly::Bits::set	.\experimental\Bits.h	/^  static void set(T* p, size_t bitStart, size_t count, UnderlyingType value);$/;"	p	struct:folly::Bits	access:public	signature:(T* p, size_t bitStart, size_t count, UnderlyingType value)
folly::Bits::set	.\experimental\Bits.h	/^inline void Bits<T, Traits>::set(T* p, size_t bit) {$/;"	f	class:folly::Bits	signature:(T* p, size_t bit)
folly::Bits::set	.\experimental\Bits.h	/^inline void Bits<T, Traits>::set(T* p, size_t bitStart, size_t count,$/;"	f	class:folly::Bits	signature:(T* p, size_t bitStart, size_t count, UnderlyingType value)
folly::Bits::sizeof	.\experimental\Bits.h	/^  static_assert(sizeof(T) == sizeof(UnderlyingType), "Size mismatch");$/;"	m	struct:folly::Bits	access:public
folly::Bits::test	.\experimental\Bits.h	/^  static bool test(const T* p, size_t bit);$/;"	p	struct:folly::Bits	access:public	signature:(const T* p, size_t bit)
folly::Bits::test	.\experimental\Bits.h	/^inline bool Bits<T, Traits>::test(const T* p, size_t bit) {$/;"	f	class:folly::Bits	signature:(const T* p, size_t bit)
folly::Bits::type	.\experimental\Bits.h	/^  typedef T type;$/;"	t	struct:folly::Bits	access:public
folly::Bits::zero	.\experimental\Bits.h	/^  static constexpr UnderlyingType zero = UnderlyingType(0);$/;"	m	struct:folly::Bits	access:private
folly::BucketedTimeSeries	.\stats\BucketedTimeSeries.h	/^class BucketedTimeSeries {$/;"	c	namespace:folly
folly::BucketedTimeSeries	.\stats\Instantiations.cpp	/^template class BucketedTimeSeries<int64_t>;$/;"	x	file:
folly::BucketedTimeSeries::Bucket	.\stats\BucketedTimeSeries.h	/^  typedef detail::Bucket<ValueType> Bucket;$/;"	t	class:folly::BucketedTimeSeries	access:public
folly::BucketedTimeSeries::BucketedTimeSeries	.\stats\BucketedTimeSeries-defs.h	/^BucketedTimeSeries<VT, TT>::BucketedTimeSeries(size_t nBuckets,$/;"	f	class:folly::BucketedTimeSeries	signature:(size_t nBuckets, TimeType maxDuration)
folly::BucketedTimeSeries::BucketedTimeSeries	.\stats\BucketedTimeSeries.h	/^  BucketedTimeSeries(size_t numBuckets, TimeType duration);$/;"	p	class:folly::BucketedTimeSeries	access:public	signature:(size_t numBuckets, TimeType duration)
folly::BucketedTimeSeries::TimeType	.\stats\BucketedTimeSeries.h	/^  typedef TT TimeType;$/;"	t	class:folly::BucketedTimeSeries	access:public
folly::BucketedTimeSeries::ValueType	.\stats\BucketedTimeSeries.h	/^  typedef VT ValueType;$/;"	t	class:folly::BucketedTimeSeries	access:public
folly::BucketedTimeSeries::addValue	.\stats\BucketedTimeSeries-defs.h	/^bool BucketedTimeSeries<VT, TT>::addValue(TimeType now, const ValueType& val) {$/;"	f	class:folly::BucketedTimeSeries	signature:(TimeType now, const ValueType& val)
folly::BucketedTimeSeries::addValue	.\stats\BucketedTimeSeries-defs.h	/^bool BucketedTimeSeries<VT, TT>::addValue(TimeType now,$/;"	f	class:folly::BucketedTimeSeries	signature:(TimeType now, const ValueType& val, int64_t times)
folly::BucketedTimeSeries::addValue	.\stats\BucketedTimeSeries.h	/^  bool addValue(TimeType now, const ValueType& val);$/;"	p	class:folly::BucketedTimeSeries	access:public	signature:(TimeType now, const ValueType& val)
folly::BucketedTimeSeries::addValue	.\stats\BucketedTimeSeries.h	/^  bool addValue(TimeType now, const ValueType& val, int64_t times);$/;"	p	class:folly::BucketedTimeSeries	access:public	signature:(TimeType now, const ValueType& val, int64_t times)
folly::BucketedTimeSeries::addValueAggregated	.\stats\BucketedTimeSeries-defs.h	/^bool BucketedTimeSeries<VT, TT>::addValueAggregated(TimeType now,$/;"	f	class:folly::BucketedTimeSeries	signature:(TimeType now, const ValueType& total, int64_t nsamples)
folly::BucketedTimeSeries::addValueAggregated	.\stats\BucketedTimeSeries.h	/^  bool addValueAggregated(TimeType now, const ValueType& sum, int64_t nsamples);$/;"	p	class:folly::BucketedTimeSeries	access:public	signature:(TimeType now, const ValueType& sum, int64_t nsamples)
folly::BucketedTimeSeries::avg	.\stats\BucketedTimeSeries-defs.h	/^ReturnType BucketedTimeSeries<VT, TT>::avg(TimeType start, TimeType end) const {$/;"	f	class:folly::BucketedTimeSeries	signature:(TimeType start, TimeType end) const
folly::BucketedTimeSeries::avg	.\stats\BucketedTimeSeries.h	/^  ReturnType avg() const {$/;"	f	class:folly::BucketedTimeSeries	access:public	signature:() const
folly::BucketedTimeSeries::avg	.\stats\BucketedTimeSeries.h	/^  ReturnType avg(TimeType start, TimeType end) const;$/;"	p	class:folly::BucketedTimeSeries	access:public	signature:(TimeType start, TimeType end) const
folly::BucketedTimeSeries::buckets_	.\stats\BucketedTimeSeries.h	/^  std::vector<Bucket> buckets_;  \/\/ actual buckets of values$/;"	m	class:folly::BucketedTimeSeries	access:private
folly::BucketedTimeSeries::clear	.\stats\BucketedTimeSeries-defs.h	/^void BucketedTimeSeries<VT, TT>::clear() {$/;"	f	class:folly::BucketedTimeSeries	signature:()
folly::BucketedTimeSeries::clear	.\stats\BucketedTimeSeries.h	/^  void clear();$/;"	p	class:folly::BucketedTimeSeries	access:public	signature:()
folly::BucketedTimeSeries::count	.\stats\BucketedTimeSeries-defs.h	/^uint64_t BucketedTimeSeries<VT, TT>::count(TimeType start, TimeType end) const {$/;"	f	class:folly::BucketedTimeSeries	signature:(TimeType start, TimeType end) const
folly::BucketedTimeSeries::count	.\stats\BucketedTimeSeries.h	/^  uint64_t count() const {$/;"	f	class:folly::BucketedTimeSeries	access:public	signature:() const
folly::BucketedTimeSeries::count	.\stats\BucketedTimeSeries.h	/^  uint64_t count(TimeType start, TimeType end) const;$/;"	p	class:folly::BucketedTimeSeries	access:public	signature:(TimeType start, TimeType end) const
folly::BucketedTimeSeries::countRate	.\stats\BucketedTimeSeries.h	/^  ReturnType countRate() const {$/;"	f	class:folly::BucketedTimeSeries	access:public	signature:() const
folly::BucketedTimeSeries::countRate	.\stats\BucketedTimeSeries.h	/^  ReturnType countRate(TimeType start, TimeType end) const {$/;"	f	class:folly::BucketedTimeSeries	access:public	signature:(TimeType start, TimeType end) const
folly::BucketedTimeSeries::duration	.\stats\BucketedTimeSeries.h	/^  TimeType duration() const {$/;"	f	class:folly::BucketedTimeSeries	access:public	signature:() const
folly::BucketedTimeSeries::duration_	.\stats\BucketedTimeSeries.h	/^  TimeType duration_;    \/\/ total duration ("window length") of the time series$/;"	m	class:folly::BucketedTimeSeries	access:private
folly::BucketedTimeSeries::elapsed	.\stats\BucketedTimeSeries-defs.h	/^TT BucketedTimeSeries<VT, TT>::elapsed() const {$/;"	f	class:folly::BucketedTimeSeries	signature:() const
folly::BucketedTimeSeries::elapsed	.\stats\BucketedTimeSeries-defs.h	/^TT BucketedTimeSeries<VT, TT>::elapsed(TimeType start, TimeType end) const {$/;"	f	class:folly::BucketedTimeSeries	signature:(TimeType start, TimeType end) const
folly::BucketedTimeSeries::elapsed	.\stats\BucketedTimeSeries.h	/^  TimeType elapsed() const;$/;"	p	class:folly::BucketedTimeSeries	access:public	signature:() const
folly::BucketedTimeSeries::elapsed	.\stats\BucketedTimeSeries.h	/^  TimeType elapsed(TimeType start, TimeType end) const;$/;"	p	class:folly::BucketedTimeSeries	access:public	signature:(TimeType start, TimeType end) const
folly::BucketedTimeSeries::empty	.\stats\BucketedTimeSeries.h	/^  bool empty() const {$/;"	f	class:folly::BucketedTimeSeries	access:public	signature:() const
folly::BucketedTimeSeries::firstTime_	.\stats\BucketedTimeSeries.h	/^  TimeType firstTime_;   \/\/ time of first update() since clear()\/constructor$/;"	m	class:folly::BucketedTimeSeries	access:private
folly::BucketedTimeSeries::forEachBucket	.\stats\BucketedTimeSeries-defs.h	/^void BucketedTimeSeries<VT, TT>::forEachBucket(Function fn) const {$/;"	f	class:folly::BucketedTimeSeries	signature:(Function fn) const
folly::BucketedTimeSeries::forEachBucket	.\stats\BucketedTimeSeries-defs.h	/^void BucketedTimeSeries<VT, TT>::forEachBucket(TimeType start, TimeType end,$/;"	f	class:folly::BucketedTimeSeries	signature:(TimeType start, TimeType end, Function fn) const
folly::BucketedTimeSeries::forEachBucket	.\stats\BucketedTimeSeries.h	/^  void forEachBucket(Function fn) const;$/;"	p	class:folly::BucketedTimeSeries	access:public	signature:(Function fn) const
folly::BucketedTimeSeries::forEachBucket	.\stats\BucketedTimeSeries.h	/^  void forEachBucket(TimeType start, TimeType end, Function fn) const;$/;"	p	class:folly::BucketedTimeSeries	access:private	signature:(TimeType start, TimeType end, Function fn) const
folly::BucketedTimeSeries::getBucketByIndex	.\stats\BucketedTimeSeries.h	/^  const Bucket& getBucketByIndex(size_t idx) const {$/;"	f	class:folly::BucketedTimeSeries	access:public	signature:(size_t idx) const
folly::BucketedTimeSeries::getBucketIdx	.\stats\BucketedTimeSeries-defs.h	/^size_t BucketedTimeSeries<VT, TT>::getBucketIdx(TimeType time) const {$/;"	f	class:folly::BucketedTimeSeries	signature:(TimeType time) const
folly::BucketedTimeSeries::getBucketIdx	.\stats\BucketedTimeSeries.h	/^  size_t getBucketIdx(TimeType time) const;$/;"	p	class:folly::BucketedTimeSeries	access:public	signature:(TimeType time) const
folly::BucketedTimeSeries::getBucketInfo	.\stats\BucketedTimeSeries-defs.h	/^void BucketedTimeSeries<VT, TT>::getBucketInfo($/;"	f	class:folly::BucketedTimeSeries	signature:( TimeType time, size_t *bucketIdx, TimeType* bucketStart, TimeType* nextBucketStart) const
folly::BucketedTimeSeries::getBucketInfo	.\stats\BucketedTimeSeries.h	/^  void getBucketInfo(TimeType time, size_t* bucketIdx,$/;"	p	class:folly::BucketedTimeSeries	access:public	signature:(TimeType time, size_t* bucketIdx, TimeType* bucketStart, TimeType* nextBucketStart) const
folly::BucketedTimeSeries::getEarliestTime	.\stats\BucketedTimeSeries-defs.h	/^TT BucketedTimeSeries<VT, TT>::getEarliestTime() const {$/;"	f	class:folly::BucketedTimeSeries	signature:() const
folly::BucketedTimeSeries::getEarliestTime	.\stats\BucketedTimeSeries.h	/^  TimeType getEarliestTime() const;$/;"	p	class:folly::BucketedTimeSeries	access:public	signature:() const
folly::BucketedTimeSeries::getEarliestTimeNonEmpty	.\stats\BucketedTimeSeries-defs.h	/^TT BucketedTimeSeries<VT, TT>::getEarliestTimeNonEmpty() const {$/;"	f	class:folly::BucketedTimeSeries	signature:() const
folly::BucketedTimeSeries::getEarliestTimeNonEmpty	.\stats\BucketedTimeSeries.h	/^  TimeType getEarliestTimeNonEmpty() const;$/;"	p	class:folly::BucketedTimeSeries	access:private	signature:() const
folly::BucketedTimeSeries::getLatestTime	.\stats\BucketedTimeSeries.h	/^  TimeType getLatestTime() const {$/;"	f	class:folly::BucketedTimeSeries	access:public	signature:() const
folly::BucketedTimeSeries::isAllTime	.\stats\BucketedTimeSeries.h	/^  bool isAllTime() const {$/;"	f	class:folly::BucketedTimeSeries	access:public	signature:() const
folly::BucketedTimeSeries::latestTime_	.\stats\BucketedTimeSeries.h	/^  TimeType latestTime_;  \/\/ time of last update()$/;"	m	class:folly::BucketedTimeSeries	access:private
folly::BucketedTimeSeries::numBuckets	.\stats\BucketedTimeSeries.h	/^  size_t numBuckets() const {$/;"	f	class:folly::BucketedTimeSeries	access:public	signature:() const
folly::BucketedTimeSeries::rangeAdjust	.\stats\BucketedTimeSeries-defs.h	/^VT BucketedTimeSeries<VT, TT>::rangeAdjust($/;"	f	class:folly::BucketedTimeSeries	signature:( TimeType bucketStart, TimeType nextBucketStart, TimeType start, TimeType end, ValueType input) const
folly::BucketedTimeSeries::rangeAdjust	.\stats\BucketedTimeSeries.h	/^  ValueType rangeAdjust(TimeType bucketStart, TimeType nextBucketStart,$/;"	p	class:folly::BucketedTimeSeries	access:private	signature:(TimeType bucketStart, TimeType nextBucketStart, TimeType start, TimeType end, ValueType input) const
folly::BucketedTimeSeries::rate	.\stats\BucketedTimeSeries.h	/^  ReturnType rate() const {$/;"	f	class:folly::BucketedTimeSeries	access:public	signature:() const
folly::BucketedTimeSeries::rate	.\stats\BucketedTimeSeries.h	/^  ReturnType rate(TimeType start, TimeType end) const {$/;"	f	class:folly::BucketedTimeSeries	access:public	signature:(TimeType start, TimeType end) const
folly::BucketedTimeSeries::rateHelper	.\stats\BucketedTimeSeries.h	/^  ReturnType rateHelper(ReturnType numerator, TimeType elapsedTime) const {$/;"	f	class:folly::BucketedTimeSeries	access:private	signature:(ReturnType numerator, TimeType elapsedTime) const
folly::BucketedTimeSeries::sum	.\stats\BucketedTimeSeries-defs.h	/^VT BucketedTimeSeries<VT, TT>::sum(TimeType start, TimeType end) const {$/;"	f	class:folly::BucketedTimeSeries	signature:(TimeType start, TimeType end) const
folly::BucketedTimeSeries::sum	.\stats\BucketedTimeSeries.h	/^  ValueType sum(TimeType start, TimeType end) const;$/;"	p	class:folly::BucketedTimeSeries	access:public	signature:(TimeType start, TimeType end) const
folly::BucketedTimeSeries::sum	.\stats\BucketedTimeSeries.h	/^  const ValueType& sum() const {$/;"	f	class:folly::BucketedTimeSeries	access:public	signature:() const
folly::BucketedTimeSeries::total_	.\stats\BucketedTimeSeries.h	/^  Bucket total_;                 \/\/ sum and count of everything in time series$/;"	m	class:folly::BucketedTimeSeries	access:private
folly::BucketedTimeSeries::update	.\stats\BucketedTimeSeries-defs.h	/^size_t BucketedTimeSeries<VT, TT>::update(TimeType now) {$/;"	f	class:folly::BucketedTimeSeries	signature:(TimeType now)
folly::BucketedTimeSeries::update	.\stats\BucketedTimeSeries.h	/^  size_t update(TimeType now);$/;"	p	class:folly::BucketedTimeSeries	access:public	signature:(TimeType now)
folly::BucketedTimeSeries::updateBuckets	.\stats\BucketedTimeSeries-defs.h	/^size_t BucketedTimeSeries<VT, TT>::updateBuckets(TimeType now) {$/;"	f	class:folly::BucketedTimeSeries	signature:(TimeType now)
folly::BucketedTimeSeries::updateBuckets	.\stats\BucketedTimeSeries.h	/^  size_t updateBuckets(TimeType now);$/;"	p	class:folly::BucketedTimeSeries	access:private	signature:(TimeType now)
folly::ByteArray16	.\IPAddressV6.h	/^typedef std::array<uint8_t, 16> ByteArray16;$/;"	t	namespace:folly
folly::ByteArray4	.\IPAddressV4.h	/^typedef std::array<uint8_t, 4> ByteArray4;$/;"	t	namespace:folly
folly::ByteRange	.\Range.h	/^typedef Range<const unsigned char*> ByteRange;$/;"	t	namespace:folly
folly::ByteVector	.\test\IPAddressTest.h	/^typedef std::vector<uint8_t> ByteVector;$/;"	t	namespace:folly
folly::CIDRNetwork	.\IPAddress.h	/^typedef std::pair<IPAddress, uint8_t> CIDRNetwork;$/;"	t	namespace:folly
folly::CIDRNetworkV4	.\IPAddressV4.h	/^typedef std::pair<IPAddressV4, uint8_t> CIDRNetworkV4;$/;"	t	namespace:folly
folly::CIDRNetworkV6	.\IPAddressV6.h	/^typedef std::pair<IPAddressV6, uint8_t> CIDRNetworkV6;$/;"	t	namespace:folly
folly::CalledProcessError	.\Subprocess.h	/^class CalledProcessError : public SubprocessError {$/;"	c	namespace:folly	inherits:SubprocessError
folly::CalledProcessError::CalledProcessError	.\Subprocess.cpp	/^CalledProcessError::CalledProcessError(ProcessReturnCode rc)$/;"	f	class:folly::CalledProcessError	signature:(ProcessReturnCode rc)
folly::CalledProcessError::CalledProcessError	.\Subprocess.h	/^  explicit CalledProcessError(ProcessReturnCode rc);$/;"	p	class:folly::CalledProcessError	access:public	signature:(ProcessReturnCode rc)
folly::CalledProcessError::returnCode	.\Subprocess.h	/^  ProcessReturnCode returnCode() const { return returnCode_; }$/;"	f	class:folly::CalledProcessError	access:public	signature:() const
folly::CalledProcessError::returnCode_	.\Subprocess.h	/^  ProcessReturnCode returnCode_;$/;"	m	class:folly::CalledProcessError	access:private
folly::CalledProcessError::what_	.\Subprocess.h	/^  std::string what_;$/;"	m	class:folly::CalledProcessError	access:private
folly::CalledProcessError::~CalledProcessError	.\Subprocess.h	/^  ~CalledProcessError() throw() { }$/;"	f	class:folly::CalledProcessError	access:public	signature:()
folly::Cob	.\io\async\EventBase.h	/^typedef std::function<void()> Cob;$/;"	t	namespace:folly
folly::ConcurrentSkipList	.\ConcurrentSkipList.h	/^class ConcurrentSkipList {$/;"	c	namespace:folly
folly::ConcurrentSkipList::Accessor	.\ConcurrentSkipList.h	/^  class Accessor;$/;"	x
folly::ConcurrentSkipList::Accessor	.\ConcurrentSkipList.h	/^class ConcurrentSkipList<T, Comp, NodeAlloc, MAX_HEIGHT>::Accessor {$/;"	c	class:folly::ConcurrentSkipList
folly::ConcurrentSkipList::Accessor::Accessor	.\ConcurrentSkipList.h	/^  Accessor(const Accessor &accessor) :$/;"	f	class:folly::ConcurrentSkipList::Accessor	access:public	signature:(const Accessor &accessor)
folly::ConcurrentSkipList::Accessor::Accessor	.\ConcurrentSkipList.h	/^  explicit Accessor(ConcurrentSkipList *skip_list) : sl_(skip_list) {$/;"	f	class:folly::ConcurrentSkipList::Accessor	access:public	signature:(ConcurrentSkipList *skip_list)
folly::ConcurrentSkipList::Accessor::Accessor	.\ConcurrentSkipList.h	/^  explicit Accessor(std::shared_ptr<ConcurrentSkipList> skip_list)$/;"	f	class:folly::ConcurrentSkipList::Accessor	access:public	signature:(std::shared_ptr<ConcurrentSkipList> skip_list)
folly::ConcurrentSkipList::Accessor::NodeType	.\ConcurrentSkipList.h	/^  typedef detail::SkipListNode<T> NodeType;$/;"	t	class:folly::ConcurrentSkipList::Accessor	access:private
folly::ConcurrentSkipList::Accessor::SkipListType	.\ConcurrentSkipList.h	/^  typedef ConcurrentSkipList<T, Comp, NodeAlloc, MAX_HEIGHT> SkipListType;$/;"	t	class:folly::ConcurrentSkipList::Accessor	access:private
folly::ConcurrentSkipList::Accessor::Skipper	.\ConcurrentSkipList.h	/^  typedef typename SkipListType::Skipper Skipper;$/;"	t	class:folly::ConcurrentSkipList::Accessor	access:public
folly::ConcurrentSkipList::Accessor::add	.\ConcurrentSkipList.h	/^  bool add(const key_type &data) { return sl_->addOrGetData(data).second; }$/;"	f	class:folly::ConcurrentSkipList::Accessor	access:public	signature:(const key_type &data)
folly::ConcurrentSkipList::Accessor::addOrGetData	.\ConcurrentSkipList.h	/^  std::pair<key_type*, bool> addOrGetData(const key_type &data) {$/;"	f	class:folly::ConcurrentSkipList::Accessor	access:public	signature:(const key_type &data)
folly::ConcurrentSkipList::Accessor::begin	.\ConcurrentSkipList.h	/^  iterator begin() const {$/;"	f	class:folly::ConcurrentSkipList::Accessor	access:public	signature:() const
folly::ConcurrentSkipList::Accessor::cbegin	.\ConcurrentSkipList.h	/^  const_iterator cbegin() const { return begin(); }$/;"	f	class:folly::ConcurrentSkipList::Accessor	access:public	signature:() const
folly::ConcurrentSkipList::Accessor::cend	.\ConcurrentSkipList.h	/^  const_iterator cend() const { return end(); }$/;"	f	class:folly::ConcurrentSkipList::Accessor	access:public	signature:() const
folly::ConcurrentSkipList::Accessor::const_iterator	.\ConcurrentSkipList.h	/^  typedef typename SkipListType::const_iterator const_iterator;$/;"	t	class:folly::ConcurrentSkipList::Accessor	access:public
folly::ConcurrentSkipList::Accessor::const_pointer	.\ConcurrentSkipList.h	/^  typedef const T* const_pointer;$/;"	t	class:folly::ConcurrentSkipList::Accessor	access:public
folly::ConcurrentSkipList::Accessor::const_reference	.\ConcurrentSkipList.h	/^  typedef const T& const_reference;$/;"	t	class:folly::ConcurrentSkipList::Accessor	access:public
folly::ConcurrentSkipList::Accessor::contains	.\ConcurrentSkipList.h	/^  bool contains(const key_type &data) const { return sl_->find(data); }$/;"	f	class:folly::ConcurrentSkipList::Accessor	access:public	signature:(const key_type &data) const
folly::ConcurrentSkipList::Accessor::count	.\ConcurrentSkipList.h	/^  size_type count(const key_type &data) const { return contains(data); }$/;"	f	class:folly::ConcurrentSkipList::Accessor	access:public	signature:(const key_type &data) const
folly::ConcurrentSkipList::Accessor::empty	.\ConcurrentSkipList.h	/^  bool empty() const { return sl_->size() == 0; }$/;"	f	class:folly::ConcurrentSkipList::Accessor	access:public	signature:() const
folly::ConcurrentSkipList::Accessor::end	.\ConcurrentSkipList.h	/^  iterator end() const { return iterator(nullptr); }$/;"	f	class:folly::ConcurrentSkipList::Accessor	access:public	signature:() const
folly::ConcurrentSkipList::Accessor::erase	.\ConcurrentSkipList.h	/^  size_t erase(const key_type &data) { return remove(data); }$/;"	f	class:folly::ConcurrentSkipList::Accessor	access:public	signature:(const key_type &data)
folly::ConcurrentSkipList::Accessor::find	.\ConcurrentSkipList.h	/^  const_iterator find(const key_type &value) const {$/;"	f	class:folly::ConcurrentSkipList::Accessor	access:public	signature:(const key_type &value) const
folly::ConcurrentSkipList::Accessor::find	.\ConcurrentSkipList.h	/^  iterator find(const key_type &value) { return iterator(sl_->find(value)); }$/;"	f	class:folly::ConcurrentSkipList::Accessor	access:public	signature:(const key_type &value)
folly::ConcurrentSkipList::Accessor::first	.\ConcurrentSkipList.h	/^  const key_type *first() const { return sl_->first(); }$/;"	f	class:folly::ConcurrentSkipList::Accessor	access:public	signature:() const
folly::ConcurrentSkipList::Accessor::height	.\ConcurrentSkipList.h	/^  size_t height() const { return sl_->height(); }$/;"	f	class:folly::ConcurrentSkipList::Accessor	access:public	signature:() const
folly::ConcurrentSkipList::Accessor::insert	.\ConcurrentSkipList.h	/^  std::pair<iterator, bool> insert(U&& data) {$/;"	f	class:folly::ConcurrentSkipList::Accessor	access:public	signature:(U&& data)
folly::ConcurrentSkipList::Accessor::iterator	.\ConcurrentSkipList.h	/^  typedef typename SkipListType::iterator iterator;$/;"	t	class:folly::ConcurrentSkipList::Accessor	access:public
folly::ConcurrentSkipList::Accessor::key_compare	.\ConcurrentSkipList.h	/^  typedef Comp key_compare;$/;"	t	class:folly::ConcurrentSkipList::Accessor	access:public
folly::ConcurrentSkipList::Accessor::key_type	.\ConcurrentSkipList.h	/^  typedef T key_type;$/;"	t	class:folly::ConcurrentSkipList::Accessor	access:public
folly::ConcurrentSkipList::Accessor::last	.\ConcurrentSkipList.h	/^  const key_type *last() const { return sl_->last(); }$/;"	f	class:folly::ConcurrentSkipList::Accessor	access:public	signature:() const
folly::ConcurrentSkipList::Accessor::lower_bound	.\ConcurrentSkipList.h	/^  iterator lower_bound(const key_type &data) const {$/;"	f	class:folly::ConcurrentSkipList::Accessor	access:public	signature:(const key_type &data) const
folly::ConcurrentSkipList::Accessor::max_size	.\ConcurrentSkipList.h	/^  size_type max_size() const { return std::numeric_limits<size_type>::max(); }$/;"	f	class:folly::ConcurrentSkipList::Accessor	access:public	signature:() const
folly::ConcurrentSkipList::Accessor::operator =	.\ConcurrentSkipList.h	/^  Accessor& operator=(const Accessor &accessor) {$/;"	f	class:folly::ConcurrentSkipList::Accessor	access:public	signature:(const Accessor &accessor)
folly::ConcurrentSkipList::Accessor::pointer	.\ConcurrentSkipList.h	/^  typedef T* pointer;$/;"	t	class:folly::ConcurrentSkipList::Accessor	access:public
folly::ConcurrentSkipList::Accessor::pop_back	.\ConcurrentSkipList.h	/^  bool pop_back() {$/;"	f	class:folly::ConcurrentSkipList::Accessor	access:public	signature:()
folly::ConcurrentSkipList::Accessor::reference	.\ConcurrentSkipList.h	/^  typedef T& reference;$/;"	t	class:folly::ConcurrentSkipList::Accessor	access:public
folly::ConcurrentSkipList::Accessor::remove	.\ConcurrentSkipList.h	/^  bool remove(const key_type &data) { return sl_->remove(data); }$/;"	f	class:folly::ConcurrentSkipList::Accessor	access:public	signature:(const key_type &data)
folly::ConcurrentSkipList::Accessor::size	.\ConcurrentSkipList.h	/^  size_t size() const { return sl_->size(); }$/;"	f	class:folly::ConcurrentSkipList::Accessor	access:public	signature:() const
folly::ConcurrentSkipList::Accessor::size_type	.\ConcurrentSkipList.h	/^  typedef size_t size_type;$/;"	t	class:folly::ConcurrentSkipList::Accessor	access:public
folly::ConcurrentSkipList::Accessor::skiplist	.\ConcurrentSkipList.h	/^  SkipListType* skiplist() const { return sl_; }$/;"	f	class:folly::ConcurrentSkipList::Accessor	access:public	signature:() const
folly::ConcurrentSkipList::Accessor::slHolder_	.\ConcurrentSkipList.h	/^  std::shared_ptr<SkipListType> slHolder_;$/;"	m	class:folly::ConcurrentSkipList::Accessor	access:private
folly::ConcurrentSkipList::Accessor::sl_	.\ConcurrentSkipList.h	/^  SkipListType *sl_;$/;"	m	class:folly::ConcurrentSkipList::Accessor	access:private
folly::ConcurrentSkipList::Accessor::value_compare	.\ConcurrentSkipList.h	/^  typedef Comp value_compare;$/;"	t	class:folly::ConcurrentSkipList::Accessor	access:public
folly::ConcurrentSkipList::Accessor::value_type	.\ConcurrentSkipList.h	/^  typedef T value_type;$/;"	t	class:folly::ConcurrentSkipList::Accessor	access:public
folly::ConcurrentSkipList::Accessor::~Accessor	.\ConcurrentSkipList.h	/^  ~Accessor() {$/;"	f	class:folly::ConcurrentSkipList::Accessor	access:public	signature:()
folly::ConcurrentSkipList::ConcurrentSkipList	.\ConcurrentSkipList.h	/^  explicit ConcurrentSkipList(int height, const NodeAlloc& alloc = NodeAlloc())$/;"	f	class:folly::ConcurrentSkipList	access:public	signature:(int height, const NodeAlloc& alloc = NodeAlloc())
folly::ConcurrentSkipList::NodeType	.\ConcurrentSkipList.h	/^  typedef detail::SkipListNode<T> NodeType;$/;"	t	class:folly::ConcurrentSkipList	access:public
folly::ConcurrentSkipList::ScopedLocker	.\ConcurrentSkipList.h	/^  typedef std::unique_lock<folly::MicroSpinLock> ScopedLocker;$/;"	t	class:folly::ConcurrentSkipList	access:private
folly::ConcurrentSkipList::SkipListType	.\ConcurrentSkipList.h	/^  typedef ConcurrentSkipList<T, Comp, NodeAlloc, MAX_HEIGHT> SkipListType;$/;"	t	class:folly::ConcurrentSkipList	access:private
folly::ConcurrentSkipList::Skipper	.\ConcurrentSkipList.h	/^  class Skipper;$/;"	x
folly::ConcurrentSkipList::Skipper	.\ConcurrentSkipList.h	/^class ConcurrentSkipList<T, Comp, NodeAlloc, MAX_HEIGHT>::Skipper {$/;"	c	class:folly::ConcurrentSkipList
folly::ConcurrentSkipList::Skipper::Accessor	.\ConcurrentSkipList.h	/^  typedef typename SkipListType::Accessor Accessor;$/;"	t	class:folly::ConcurrentSkipList::Skipper	access:private
folly::ConcurrentSkipList::Skipper::NodeType	.\ConcurrentSkipList.h	/^  typedef detail::SkipListNode<T> NodeType;$/;"	t	class:folly::ConcurrentSkipList::Skipper	access:private
folly::ConcurrentSkipList::Skipper::SkipListType	.\ConcurrentSkipList.h	/^  typedef ConcurrentSkipList<T, Comp, NodeAlloc, MAX_HEIGHT> SkipListType;$/;"	t	class:folly::ConcurrentSkipList::Skipper	access:private
folly::ConcurrentSkipList::Skipper::Skipper	.\ConcurrentSkipList.h	/^  Skipper(const Accessor& accessor) : accessor_(accessor) {$/;"	f	class:folly::ConcurrentSkipList::Skipper	access:public	signature:(const Accessor& accessor)
folly::ConcurrentSkipList::Skipper::Skipper	.\ConcurrentSkipList.h	/^  Skipper(const std::shared_ptr<SkipListType>& skipList) :$/;"	f	class:folly::ConcurrentSkipList::Skipper	access:public	signature:(const std::shared_ptr<SkipListType>& skipList)
folly::ConcurrentSkipList::Skipper::accessor_	.\ConcurrentSkipList.h	/^  Accessor accessor_;$/;"	m	class:folly::ConcurrentSkipList::Skipper	access:private
folly::ConcurrentSkipList::Skipper::curHeight	.\ConcurrentSkipList.h	/^  int curHeight() const {$/;"	f	class:folly::ConcurrentSkipList::Skipper	access:public	signature:() const
folly::ConcurrentSkipList::Skipper::data	.\ConcurrentSkipList.h	/^  const value_type &data() const {$/;"	f	class:folly::ConcurrentSkipList::Skipper	access:public	signature:() const
folly::ConcurrentSkipList::Skipper::difference_type	.\ConcurrentSkipList.h	/^  typedef ptrdiff_t difference_type;$/;"	t	class:folly::ConcurrentSkipList::Skipper	access:public
folly::ConcurrentSkipList::Skipper::good	.\ConcurrentSkipList.h	/^  bool good() const { return succs_[0] != nullptr; }$/;"	f	class:folly::ConcurrentSkipList::Skipper	access:public	signature:() const
folly::ConcurrentSkipList::Skipper::head	.\ConcurrentSkipList.h	/^  NodeType* head() const {$/;"	f	class:folly::ConcurrentSkipList::Skipper	access:private	signature:() const
folly::ConcurrentSkipList::Skipper::headHeight_	.\ConcurrentSkipList.h	/^  int headHeight_;$/;"	m	class:folly::ConcurrentSkipList::Skipper	access:private
folly::ConcurrentSkipList::Skipper::hints_	.\ConcurrentSkipList.h	/^  uint8_t hints_[MAX_HEIGHT];$/;"	m	class:folly::ConcurrentSkipList::Skipper	access:private
folly::ConcurrentSkipList::Skipper::init	.\ConcurrentSkipList.h	/^  void init() {$/;"	f	class:folly::ConcurrentSkipList::Skipper	access:public	signature:()
folly::ConcurrentSkipList::Skipper::maxLayer	.\ConcurrentSkipList.h	/^  int maxLayer() const { return headHeight_ - 1; }$/;"	f	class:folly::ConcurrentSkipList::Skipper	access:public	signature:() const
folly::ConcurrentSkipList::Skipper::operator *	.\ConcurrentSkipList.h	/^  value_type &operator *() const {$/;"	f	class:folly::ConcurrentSkipList::Skipper	access:public	signature:() const
folly::ConcurrentSkipList::Skipper::operator ++	.\ConcurrentSkipList.h	/^  Skipper& operator ++() {$/;"	f	class:folly::ConcurrentSkipList::Skipper	access:public	signature:()
folly::ConcurrentSkipList::Skipper::operator ->	.\ConcurrentSkipList.h	/^  value_type *operator->() {$/;"	f	class:folly::ConcurrentSkipList::Skipper	access:public	signature:()
folly::ConcurrentSkipList::Skipper::pointer	.\ConcurrentSkipList.h	/^  typedef T* pointer;$/;"	t	class:folly::ConcurrentSkipList::Skipper	access:public
folly::ConcurrentSkipList::Skipper::preds_	.\ConcurrentSkipList.h	/^  NodeType *succs_[MAX_HEIGHT], *preds_[MAX_HEIGHT];$/;"	m	class:folly::ConcurrentSkipList::Skipper	access:private
folly::ConcurrentSkipList::Skipper::reference	.\ConcurrentSkipList.h	/^  typedef T& reference;$/;"	t	class:folly::ConcurrentSkipList::Skipper	access:public
folly::ConcurrentSkipList::Skipper::succs_	.\ConcurrentSkipList.h	/^  NodeType *succs_[MAX_HEIGHT], *preds_[MAX_HEIGHT];$/;"	m	class:folly::ConcurrentSkipList::Skipper	access:private
folly::ConcurrentSkipList::Skipper::to	.\ConcurrentSkipList.h	/^  bool to(const value_type &data) {$/;"	f	class:folly::ConcurrentSkipList::Skipper	access:public	signature:(const value_type &data)
folly::ConcurrentSkipList::Skipper::value_type	.\ConcurrentSkipList.h	/^  typedef T  value_type;$/;"	t	class:folly::ConcurrentSkipList::Skipper	access:public
folly::ConcurrentSkipList::addOrGetData	.\ConcurrentSkipList.h	/^  std::pair<NodeType*, size_t> addOrGetData(U &&data) {$/;"	f	class:folly::ConcurrentSkipList	access:private	signature:(U &&data)
folly::ConcurrentSkipList::const_iterator	.\ConcurrentSkipList.h	/^  typedef detail::csl_iterator<const value_type, const NodeType> const_iterator;$/;"	t	class:folly::ConcurrentSkipList	access:public
folly::ConcurrentSkipList::create	.\ConcurrentSkipList.h	/^  static Accessor create(int height = 1, const NodeAlloc& alloc = NodeAlloc()) {$/;"	f	class:folly::ConcurrentSkipList	access:public	signature:(int height = 1, const NodeAlloc& alloc = NodeAlloc())
folly::ConcurrentSkipList::createInstance	.\ConcurrentSkipList.h	/^  static std::shared_ptr<SkipListType> createInstance($/;"	f	class:folly::ConcurrentSkipList	access:public	signature:( int height = 1, const NodeAlloc& alloc = NodeAlloc())
folly::ConcurrentSkipList::find	.\ConcurrentSkipList.h	/^  NodeType* find(const value_type &data) {$/;"	f	class:folly::ConcurrentSkipList	access:private	signature:(const value_type &data)
folly::ConcurrentSkipList::findInsertionPoint	.\ConcurrentSkipList.h	/^  static int findInsertionPoint(NodeType *cur, int cur_layer,$/;"	f	class:folly::ConcurrentSkipList	access:private	signature:(NodeType *cur, int cur_layer, const value_type &data, NodeType *preds[], NodeType *succs[])
folly::ConcurrentSkipList::findInsertionPointGetMaxLayer	.\ConcurrentSkipList.h	/^  int findInsertionPointGetMaxLayer(const value_type &data,$/;"	f	class:folly::ConcurrentSkipList	access:private	signature:(const value_type &data, NodeType *preds[], NodeType *succs[], int *max_layer) const
folly::ConcurrentSkipList::findNode	.\ConcurrentSkipList.h	/^  std::pair<NodeType*, int> findNode(const value_type &data) const {$/;"	f	class:folly::ConcurrentSkipList	access:private	signature:(const value_type &data) const
folly::ConcurrentSkipList::findNodeDownRight	.\ConcurrentSkipList.h	/^  std::pair<NodeType*, int> findNodeDownRight(const value_type &data) const {$/;"	f	class:folly::ConcurrentSkipList	access:private	signature:(const value_type &data) const
folly::ConcurrentSkipList::findNodeRightDown	.\ConcurrentSkipList.h	/^  std::pair<NodeType*, int> findNodeRightDown(const value_type &data) const {$/;"	f	class:folly::ConcurrentSkipList	access:private	signature:(const value_type &data) const
folly::ConcurrentSkipList::first	.\ConcurrentSkipList.h	/^  const value_type *first() const {$/;"	f	class:folly::ConcurrentSkipList	access:private	signature:() const
folly::ConcurrentSkipList::greater	.\ConcurrentSkipList.h	/^  static bool greater(const value_type &data, const NodeType *node) {$/;"	f	class:folly::ConcurrentSkipList	access:private	signature:(const value_type &data, const NodeType *node)
folly::ConcurrentSkipList::growHeight	.\ConcurrentSkipList.h	/^  void growHeight(int height) {$/;"	f	class:folly::ConcurrentSkipList	access:private	signature:(int height)
folly::ConcurrentSkipList::head_	.\ConcurrentSkipList.h	/^  std::atomic<NodeType*> head_;$/;"	m	class:folly::ConcurrentSkipList	access:private
folly::ConcurrentSkipList::height	.\ConcurrentSkipList.h	/^  int height() const {$/;"	f	class:folly::ConcurrentSkipList	access:private	signature:() const
folly::ConcurrentSkipList::incrementSize	.\ConcurrentSkipList.h	/^  size_t incrementSize(int delta) {$/;"	f	class:folly::ConcurrentSkipList	access:private	signature:(int delta)
folly::ConcurrentSkipList::iterator	.\ConcurrentSkipList.h	/^  typedef detail::csl_iterator<value_type, NodeType> iterator;$/;"	t	class:folly::ConcurrentSkipList	access:public
folly::ConcurrentSkipList::key_type	.\ConcurrentSkipList.h	/^  typedef T key_type;$/;"	t	class:folly::ConcurrentSkipList	access:public
folly::ConcurrentSkipList::last	.\ConcurrentSkipList.h	/^  const value_type *last() const {$/;"	f	class:folly::ConcurrentSkipList	access:private	signature:() const
folly::ConcurrentSkipList::less	.\ConcurrentSkipList.h	/^  static bool less(const value_type &data, const NodeType *node) {$/;"	f	class:folly::ConcurrentSkipList	access:private	signature:(const value_type &data, const NodeType *node)
folly::ConcurrentSkipList::lockNodesForChange	.\ConcurrentSkipList.h	/^  bool lockNodesForChange(int nodeHeight,$/;"	f	class:folly::ConcurrentSkipList	access:private	signature:(int nodeHeight, ScopedLocker guards[MAX_HEIGHT], NodeType *preds[MAX_HEIGHT], NodeType *succs[MAX_HEIGHT], bool adding=true)
folly::ConcurrentSkipList::lower_bound	.\ConcurrentSkipList.h	/^  NodeType* lower_bound(const value_type &data) const {$/;"	f	class:folly::ConcurrentSkipList	access:private	signature:(const value_type &data) const
folly::ConcurrentSkipList::maxLayer	.\ConcurrentSkipList.h	/^  int maxLayer() const { return height() - 1; }$/;"	f	class:folly::ConcurrentSkipList	access:private	signature:() const
folly::ConcurrentSkipList::okToDelete	.\ConcurrentSkipList.h	/^  static bool okToDelete(NodeType *candidate, int layer) {$/;"	f	class:folly::ConcurrentSkipList	access:private	signature:(NodeType *candidate, int layer)
folly::ConcurrentSkipList::recycle	.\ConcurrentSkipList.h	/^  void recycle(NodeType *node) {$/;"	f	class:folly::ConcurrentSkipList	access:private	signature:(NodeType *node)
folly::ConcurrentSkipList::recycler_	.\ConcurrentSkipList.h	/^  detail::NodeRecycler<NodeType, NodeAlloc> recycler_;$/;"	m	class:folly::ConcurrentSkipList	access:private
folly::ConcurrentSkipList::remove	.\ConcurrentSkipList.h	/^  bool remove(const value_type &data) {$/;"	f	class:folly::ConcurrentSkipList	access:private	signature:(const value_type &data)
folly::ConcurrentSkipList::size	.\ConcurrentSkipList.h	/^  size_t size() const { return size_.load(std::memory_order_relaxed); }$/;"	f	class:folly::ConcurrentSkipList	access:private	signature:() const
folly::ConcurrentSkipList::size_	.\ConcurrentSkipList.h	/^  std::atomic<size_t> size_;$/;"	m	class:folly::ConcurrentSkipList	access:private
folly::ConcurrentSkipList::value_type	.\ConcurrentSkipList.h	/^  typedef T value_type;$/;"	t	class:folly::ConcurrentSkipList	access:public
folly::ConcurrentSkipList::~ConcurrentSkipList	.\ConcurrentSkipList.h	/^  ~ConcurrentSkipList() {$/;"	f	class:folly::ConcurrentSkipList	access:public	signature:()
folly::ContainsOptional	.\test\OptionalTest.cpp	/^class ContainsOptional {$/;"	c	namespace:folly	file:
folly::ContainsOptional::ContainsOptional	.\test\OptionalTest.cpp	/^  ContainsOptional() { }$/;"	f	class:folly::ContainsOptional	access:public	signature:()
folly::ContainsOptional::ContainsOptional	.\test\OptionalTest.cpp	/^  explicit ContainsOptional(int x) : opt_(x) { }$/;"	f	class:folly::ContainsOptional	access:public	signature:(int x)
folly::ContainsOptional::hasValue	.\test\OptionalTest.cpp	/^  bool hasValue() const { return opt_.hasValue(); }$/;"	f	class:folly::ContainsOptional	access:public	signature:() const
folly::ContainsOptional::opt_	.\test\OptionalTest.cpp	/^  Optional<int> opt_;$/;"	m	class:folly::ContainsOptional	file:	access:private
folly::ContainsOptional::other	.\test\OptionalTest.cpp	/^  ContainsOptional& operator=(ContainsOptional &&other) = default;$/;"	m	class:folly::ContainsOptional	file:	access:public
folly::ContainsOptional::other	.\test\OptionalTest.cpp	/^  ContainsOptional& operator=(const ContainsOptional &other) = default;$/;"	m	class:folly::ContainsOptional	file:	access:public
folly::ContainsOptional::other	.\test\OptionalTest.cpp	/^  ContainsOptional(ContainsOptional &&other) = default;$/;"	m	class:folly::ContainsOptional	file:	access:public
folly::ContainsOptional::other	.\test\OptionalTest.cpp	/^  ContainsOptional(const ContainsOptional &other) = default;$/;"	m	class:folly::ContainsOptional	file:	access:public
folly::ContainsOptional::value	.\test\OptionalTest.cpp	/^  int value() const { return opt_.value(); }$/;"	f	class:folly::ContainsOptional	access:public	signature:() const
folly::CopyCount	.\test\LazyTest.cpp	/^struct CopyCount {$/;"	s	namespace:folly	file:
folly::CopyCount::CopyCount	.\test\LazyTest.cpp	/^  CopyCount() {}$/;"	f	struct:folly::CopyCount	access:public	signature:()
folly::CopyCount::CopyCount	.\test\LazyTest.cpp	/^  CopyCount(CopyCount&&)      {}$/;"	f	struct:folly::CopyCount	access:public	signature:(CopyCount&&)
folly::CopyCount::CopyCount	.\test\LazyTest.cpp	/^  CopyCount(const CopyCount&) { ++count; }$/;"	f	struct:folly::CopyCount	access:public	signature:(const CopyCount&)
folly::CopyCount::count	.\test\LazyTest.cpp	/^  static int count;$/;"	m	struct:folly::CopyCount	file:	access:public
folly::CopyCount::count	.\test\LazyTest.cpp	/^int CopyCount::count = 0;$/;"	m	class:folly::CopyCount	file:
folly::CopyCount::operator ()	.\test\LazyTest.cpp	/^  bool operator()() const { return true ; }$/;"	f	struct:folly::CopyCount	access:public	signature:() const
folly::CountedIntrusiveList	.\IntrusiveList.h	/^class CountedIntrusiveList : public boost::intrusive::list<$/;"	c	namespace:folly	inherits:boost::intrusive::list
folly::CpuId	.\CpuId.h	/^class CpuId {$/;"	c	namespace:folly
folly::CpuId::CpuId	.\CpuId.h	/^  CpuId() {$/;"	f	class:folly::CpuId	access:public	signature:()
folly::CpuId::c_	.\CpuId.h	/^  uint32_t c_;  \/\/ ECX$/;"	m	class:folly::CpuId	access:private
folly::CpuId::d_	.\CpuId.h	/^  uint32_t d_;  \/\/ EDX$/;"	m	class:folly::CpuId	access:private
folly::DEF_TYPE	.\dynamic.cpp	/^DEF_TYPE(bool,                "boolean", dynamic::BOOL);$/;"	p	namespace:folly	file:	signature:(bool, , dynamic::BOOL)
folly::DEF_TYPE	.\dynamic.cpp	/^DEF_TYPE(double,              "double",  dynamic::DOUBLE);$/;"	p	namespace:folly	file:	signature:(double, , dynamic::DOUBLE)
folly::DEF_TYPE	.\dynamic.cpp	/^DEF_TYPE(dynamic::Array,      "array",   dynamic::ARRAY);$/;"	p	namespace:folly	file:	signature:(dynamic::Array, , dynamic::ARRAY)
folly::DEF_TYPE	.\dynamic.cpp	/^DEF_TYPE(dynamic::ObjectImpl, "object",  dynamic::OBJECT);$/;"	p	namespace:folly	file:	signature:(dynamic::ObjectImpl, , dynamic::OBJECT)
folly::DEF_TYPE	.\dynamic.cpp	/^DEF_TYPE(fbstring,            "string",  dynamic::STRING);$/;"	p	namespace:folly	file:	signature:(fbstring, , dynamic::STRING)
folly::DEF_TYPE	.\dynamic.cpp	/^DEF_TYPE(int64_t,             "int64",   dynamic::INT64);$/;"	p	namespace:folly	file:	signature:(int64_t, , dynamic::INT64)
folly::DEF_TYPE	.\dynamic.cpp	/^DEF_TYPE(void*,               "null",    dynamic::NULLT);$/;"	p	namespace:folly	file:	signature:(void*, , dynamic::NULLT)
folly::DelayedDestruction	.\io\async\DelayedDestruction.h	/^class DelayedDestruction : private boost::noncopyable {$/;"	c	namespace:folly	inherits:boost::noncopyable
folly::DelayedDestruction::DelayedDestruction	.\io\async\DelayedDestruction.h	/^  DelayedDestruction()$/;"	f	class:folly::DelayedDestruction	access:protected	signature:()
folly::DelayedDestruction::Destructor	.\io\async\DelayedDestruction.h	/^  class Destructor {$/;"	c	class:folly::DelayedDestruction	access:public
folly::DelayedDestruction::Destructor::operator ()	.\io\async\DelayedDestruction.h	/^    void operator()(DelayedDestruction* dd) const {$/;"	f	class:folly::DelayedDestruction::Destructor	access:public	signature:(DelayedDestruction* dd) const
folly::DelayedDestruction::DestructorGuard	.\io\async\DelayedDestruction.h	/^  class DestructorGuard {$/;"	c	class:folly::DelayedDestruction	access:public
folly::DelayedDestruction::DestructorGuard::DestructorGuard	.\io\async\DelayedDestruction.h	/^    DestructorGuard(const DestructorGuard& dg) : dd_(dg.dd_) {$/;"	f	class:folly::DelayedDestruction::DestructorGuard	access:public	signature:(const DestructorGuard& dg)
folly::DelayedDestruction::DestructorGuard::DestructorGuard	.\io\async\DelayedDestruction.h	/^    explicit DestructorGuard(DelayedDestruction* dd) : dd_(dd) {$/;"	f	class:folly::DelayedDestruction::DestructorGuard	access:public	signature:(DelayedDestruction* dd)
folly::DelayedDestruction::DestructorGuard::dd_	.\io\async\DelayedDestruction.h	/^    DelayedDestruction* dd_;$/;"	m	class:folly::DelayedDestruction::DestructorGuard	access:private
folly::DelayedDestruction::DestructorGuard::~DestructorGuard	.\io\async\DelayedDestruction.h	/^    ~DestructorGuard() {$/;"	f	class:folly::DelayedDestruction::DestructorGuard	access:public	signature:()
folly::DelayedDestruction::destroy	.\io\async\DelayedDestruction.h	/^  virtual void destroy() {$/;"	f	class:folly::DelayedDestruction	access:public	signature:()
folly::DelayedDestruction::destroyNow	.\io\async\DelayedDestruction.h	/^  virtual void destroyNow(bool delayed) {$/;"	f	class:folly::DelayedDestruction	access:protected	signature:(bool delayed)
folly::DelayedDestruction::destroyPending_	.\io\async\DelayedDestruction.h	/^  bool destroyPending_;$/;"	m	class:folly::DelayedDestruction	access:private
folly::DelayedDestruction::getDestructorGuardCount	.\io\async\DelayedDestruction.h	/^  uint32_t getDestructorGuardCount() const {$/;"	f	class:folly::DelayedDestruction	access:protected	signature:() const
folly::DelayedDestruction::guardCount_	.\io\async\DelayedDestruction.h	/^  uint32_t guardCount_;$/;"	m	class:folly::DelayedDestruction	access:private
folly::DelayedDestruction::~DelayedDestruction	.\io\async\DelayedDestruction.h	/^  virtual ~DelayedDestruction() {}$/;"	f	class:folly::DelayedDestruction	access:protected	signature:()
folly::DiscriminatedPtr	.\DiscriminatedPtr.h	/^class DiscriminatedPtr {$/;"	c	namespace:folly
folly::DiscriminatedPtr::DiscriminatedPtr	.\DiscriminatedPtr.h	/^  DiscriminatedPtr() : data_(0) {$/;"	f	class:folly::DiscriminatedPtr	access:public	signature:()
folly::DiscriminatedPtr::DiscriminatedPtr	.\DiscriminatedPtr.h	/^  explicit DiscriminatedPtr(T* ptr) {$/;"	f	class:folly::DiscriminatedPtr	access:public	signature:(T* ptr)
folly::DiscriminatedPtr::apply	.\DiscriminatedPtr.h	/^  typename dptr_detail::ConstVisitorResult<V, Types...>::type apply(V&& visitor)$/;"	f	class:folly::DiscriminatedPtr	access:public	signature:(V&& visitor) const
folly::DiscriminatedPtr::apply	.\DiscriminatedPtr.h	/^  typename dptr_detail::VisitorResult<V, Types...>::type apply(V&& visitor) {$/;"	f	class:folly::DiscriminatedPtr	access:public	signature:(V&& visitor)
folly::DiscriminatedPtr::clear	.\DiscriminatedPtr.h	/^  void clear() {$/;"	f	class:folly::DiscriminatedPtr	access:public	signature:()
folly::DiscriminatedPtr::data_	.\DiscriminatedPtr.h	/^  uintptr_t data_;$/;"	m	class:folly::DiscriminatedPtr	access:private
folly::DiscriminatedPtr::empty	.\DiscriminatedPtr.h	/^  bool empty() const {$/;"	f	class:folly::DiscriminatedPtr	access:public	signature:() const
folly::DiscriminatedPtr::get	.\DiscriminatedPtr.h	/^  T* get() {$/;"	f	class:folly::DiscriminatedPtr	access:public	signature:()
folly::DiscriminatedPtr::get	.\DiscriminatedPtr.h	/^  const T* get() const {$/;"	f	class:folly::DiscriminatedPtr	access:public	signature:() const
folly::DiscriminatedPtr::hasType	.\DiscriminatedPtr.h	/^  bool hasType() const {$/;"	f	class:folly::DiscriminatedPtr	access:public	signature:() const
folly::DiscriminatedPtr::index	.\DiscriminatedPtr.h	/^  uint16_t index() const { return data_ >> 48; }$/;"	f	class:folly::DiscriminatedPtr	access:private	signature:() const
folly::DiscriminatedPtr::operator =	.\DiscriminatedPtr.h	/^  DiscriminatedPtr& operator=(T* ptr) {$/;"	f	class:folly::DiscriminatedPtr	access:public	signature:(T* ptr)
folly::DiscriminatedPtr::ptr	.\DiscriminatedPtr.h	/^  void* ptr() const {$/;"	f	class:folly::DiscriminatedPtr	access:private	signature:() const
folly::DiscriminatedPtr::set	.\DiscriminatedPtr.h	/^  void set(T* ptr) {$/;"	f	class:folly::DiscriminatedPtr	access:public	signature:(T* ptr)
folly::DiscriminatedPtr::set	.\DiscriminatedPtr.h	/^  void set(void* p, uint16_t v) {$/;"	f	class:folly::DiscriminatedPtr	access:private	signature:(void* p, uint16_t v)
folly::DiscriminatedPtr::static_assert	.\DiscriminatedPtr.h	/^  static_assert(sizeof...(Types) < std::numeric_limits<uint16_t>::max(),$/;"	p	class:folly::DiscriminatedPtr	access:private	signature:(sizeof....(Types) < std::numeric_limits<uint16_t>::max(), )
folly::DiscriminatedPtr::typeIndex	.\DiscriminatedPtr.h	/^  size_t typeIndex() const {$/;"	f	class:folly::DiscriminatedPtr	access:private	signature:() const
folly::DynamicConstructor	.\DynamicConverter.h	/^struct DynamicConstructor {$/;"	s	namespace:folly
folly::DynamicConstructor	.\DynamicConverter.h	/^struct DynamicConstructor<C,$/;"	s	namespace:folly
folly::DynamicConstructor	.\DynamicConverter.h	/^struct DynamicConstructor<std::pair<A, B>, void> {$/;"	s	namespace:folly
folly::DynamicConstructor::construct	.\DynamicConverter.h	/^  static dynamic construct(const C& x) {$/;"	f	struct:folly::DynamicConstructor	access:public	signature:(const C& x)
folly::DynamicConstructor::construct	.\DynamicConverter.h	/^  static dynamic construct(const std::pair<A, B>& x) {$/;"	f	struct:folly::DynamicConstructor	access:public	signature:(const std::pair<A, B>& x)
folly::DynamicConverter	.\DynamicConverter.h	/^struct DynamicConverter<C,$/;"	s	namespace:folly
folly::DynamicConverter	.\DynamicConverter.h	/^struct DynamicConverter<T,$/;"	s	namespace:folly
folly::DynamicConverter	.\DynamicConverter.h	/^struct DynamicConverter<bool> {$/;"	s	namespace:folly
folly::DynamicConverter	.\DynamicConverter.h	/^struct DynamicConverter<folly::fbstring> {$/;"	s	namespace:folly
folly::DynamicConverter	.\DynamicConverter.h	/^struct DynamicConverter<std::pair<F,S>> {$/;"	s	namespace:folly
folly::DynamicConverter	.\DynamicConverter.h	/^struct DynamicConverter<std::string> {$/;"	s	namespace:folly
folly::DynamicConverter	.\DynamicConverter.h	/^template <typename T, typename Enable = void> struct DynamicConverter;$/;"	x
folly::DynamicConverter	.\test\DynamicConverterTest.cpp	/^template <> struct DynamicConverter<A> {$/;"	s	namespace:folly	file:
folly::DynamicConverter	.\test\DynamicConverterTest.cpp	/^template <> struct DynamicConverter<Token> {$/;"	s	namespace:folly	file:
folly::DynamicConverter::convert	.\DynamicConverter.h	/^  static C convert(const dynamic& d) {$/;"	f	struct:folly::DynamicConverter	access:public	signature:(const dynamic& d)
folly::DynamicConverter::convert	.\DynamicConverter.h	/^  static T convert(const dynamic& d) {$/;"	f	struct:folly::DynamicConverter	access:public	signature:(const dynamic& d)
folly::DynamicConverter::convert	.\DynamicConverter.h	/^  static bool convert(const dynamic& d) {$/;"	f	struct:folly::DynamicConverter	access:public	signature:(const dynamic& d)
folly::DynamicConverter::convert	.\DynamicConverter.h	/^  static folly::fbstring convert(const dynamic& d) {$/;"	f	struct:folly::DynamicConverter	access:public	signature:(const dynamic& d)
folly::DynamicConverter::convert	.\DynamicConverter.h	/^  static std::pair<F, S> convert(const dynamic& d) {$/;"	f	struct:folly::DynamicConverter	access:public	signature:(const dynamic& d)
folly::DynamicConverter::convert	.\DynamicConverter.h	/^  static std::string convert(const dynamic& d) {$/;"	f	struct:folly::DynamicConverter	access:public	signature:(const dynamic& d)
folly::DynamicConverter::convert	.\test\DynamicConverterTest.cpp	/^  static A convert(const dynamic & d) {$/;"	f	struct:folly::DynamicConverter	access:public	signature:(const dynamic & d)
folly::DynamicConverter::convert	.\test\DynamicConverterTest.cpp	/^  static Token convert(const dynamic& d) {$/;"	f	struct:folly::DynamicConverter	access:public	signature:(const dynamic& d)
folly::EventBase	.\io\async\AsyncTimeout.h	/^class EventBase;$/;"	x
folly::EventBase	.\io\async\EventBase.h	/^class EventBase : private boost::noncopyable, public TimeoutManager {$/;"	c	namespace:folly	inherits:boost::noncopyable,TimeoutManager
folly::EventBase	.\io\async\EventHandler.h	/^class EventBase;$/;"	x
folly::EventBase::CobTimeout	.\io\async\EventBase.h	/^  class CobTimeout : public AsyncTimeout {$/;"	c	class:folly::EventBase	inherits:AsyncTimeout	access:private
folly::EventBase::CobTimeout::CobTimeout	.\io\async\EventBase.h	/^    CobTimeout(EventBase* b, const Cob& c, TimeoutManager::InternalEnum in)$/;"	f	class:folly::EventBase::CobTimeout	access:public	signature:(EventBase* b, const Cob& c, TimeoutManager::InternalEnum in)
folly::EventBase::CobTimeout::List	.\io\async\EventBase.h	/^      boost::intrusive::constant_time_size<false> > List;$/;"	t	class:folly::EventBase::CobTimeout	access:public
folly::EventBase::CobTimeout::ListHook	.\io\async\EventBase.h	/^      boost::intrusive::link_mode<boost::intrusive::auto_unlink> > ListHook;$/;"	t	class:folly::EventBase::CobTimeout	access:public
folly::EventBase::CobTimeout::cob_	.\io\async\EventBase.h	/^    Cob cob_;$/;"	m	class:folly::EventBase::CobTimeout	access:private
folly::EventBase::CobTimeout::hook	.\io\async\EventBase.h	/^    ListHook hook;$/;"	m	class:folly::EventBase::CobTimeout	access:public
folly::EventBase::CobTimeout::noexcept	.\io\async\EventBase.h	/^    virtual void timeoutExpired() noexcept;$/;"	m	class:folly::EventBase::CobTimeout	access:public
folly::EventBase::EventBase	.\io\async\EventBase.cpp	/^EventBase::EventBase()$/;"	f	class:folly::EventBase	signature:()
folly::EventBase::EventBase	.\io\async\EventBase.cpp	/^EventBase::EventBase(event_base* evb)$/;"	f	class:folly::EventBase	signature:(event_base* evb)
folly::EventBase::EventBase	.\io\async\EventBase.h	/^  EventBase();$/;"	p	class:folly::EventBase	access:public	signature:()
folly::EventBase::EventBase	.\io\async\EventBase.h	/^  explicit EventBase(event_base* evb);$/;"	p	class:folly::EventBase	access:public	signature:(event_base* evb)
folly::EventBase::FunctionRunner	.\io\async\EventBase.cpp	/^class EventBase::FunctionRunner$/;"	c	class:folly::EventBase	file:	inherits:NotificationQueue::Consumer
folly::EventBase::FunctionRunner	.\io\async\EventBase.h	/^  class FunctionRunner;$/;"	x
folly::EventBase::FunctionRunner::messageAvailable	.\io\async\EventBase.cpp	/^  void messageAvailable(std::pair<void (*)(void*), void*>&& msg) {$/;"	f	class:folly::EventBase::FunctionRunner	access:public	signature:(std::pair<void (*)(void*), void*>&& msg)
folly::EventBase::LoopCallback	.\io\async\EventBase.h	/^  class LoopCallback {$/;"	c	class:folly::EventBase	access:public
folly::EventBase::LoopCallback::EventBase	.\io\async\EventBase.h	/^    friend class EventBase;$/;"	x
folly::EventBase::LoopCallback::List	.\io\async\EventBase.h	/^      boost::intrusive::constant_time_size<false> > List;$/;"	t	class:folly::EventBase::LoopCallback	access:private
folly::EventBase::LoopCallback::ListHook	.\io\async\EventBase.h	/^      boost::intrusive::link_mode<boost::intrusive::auto_unlink> > ListHook;$/;"	t	class:folly::EventBase::LoopCallback	access:private
folly::EventBase::LoopCallback::cancelLoopCallback	.\io\async\EventBase.h	/^    void cancelLoopCallback() {$/;"	f	class:folly::EventBase::LoopCallback	access:public	signature:()
folly::EventBase::LoopCallback::context_	.\io\async\EventBase.h	/^    std::shared_ptr<RequestContext> context_;$/;"	m	class:folly::EventBase::LoopCallback	access:private
folly::EventBase::LoopCallback::hook_	.\io\async\EventBase.h	/^    ListHook hook_;$/;"	m	class:folly::EventBase::LoopCallback	access:private
folly::EventBase::LoopCallback::isLoopCallbackScheduled	.\io\async\EventBase.h	/^    bool isLoopCallbackScheduled() const {$/;"	f	class:folly::EventBase::LoopCallback	access:public	signature:() const
folly::EventBase::LoopCallback::noexcept	.\io\async\EventBase.h	/^    virtual void runLoopCallback() noexcept = 0;$/;"	m	class:folly::EventBase::LoopCallback	access:public
folly::EventBase::LoopCallback::~LoopCallback	.\io\async\EventBase.h	/^    virtual ~LoopCallback() {}$/;"	f	class:folly::EventBase::LoopCallback	access:public	signature:()
folly::EventBase::LoopCallbackList	.\io\async\EventBase.h	/^  typedef LoopCallback::List LoopCallbackList;$/;"	t	class:folly::EventBase	access:private
folly::EventBase::RunInLoopCallback	.\io\async\EventBase.h	/^  class RunInLoopCallback : public LoopCallback {$/;"	c	class:folly::EventBase	inherits:LoopCallback	access:private
folly::EventBase::RunInLoopCallback::RunInLoopCallback	.\io\async\EventBase.cpp	/^EventBase::RunInLoopCallback::RunInLoopCallback(void (*fn)(void*), void* arg)$/;"	f	class:folly::EventBase::RunInLoopCallback	signature:(void (*fn)(void*), void* arg)
folly::EventBase::RunInLoopCallback::RunInLoopCallback	.\io\async\EventBase.h	/^    RunInLoopCallback(void (*fn)(void*), void* arg);$/;"	p	class:folly::EventBase::RunInLoopCallback	access:public	signature:(void (*fn)(void*), void* arg)
folly::EventBase::RunInLoopCallback::arg_	.\io\async\EventBase.h	/^    void* arg_;$/;"	m	class:folly::EventBase::RunInLoopCallback	access:private
folly::EventBase::RunInLoopCallback::fn_	.\io\async\EventBase.h	/^    void (*fn_)(void*);$/;"	m	class:folly::EventBase::RunInLoopCallback	access:private
folly::EventBase::RunInLoopCallback::noexcept	.\io\async\EventBase.h	/^    void runLoopCallback() noexcept;$/;"	m	class:folly::EventBase::RunInLoopCallback	access:public
folly::EventBase::SmoothLoopTime	.\io\async\EventBase.h	/^  class SmoothLoopTime {$/;"	c	class:folly::EventBase	access:public
folly::EventBase::SmoothLoopTime::SmoothLoopTime	.\io\async\EventBase.h	/^    explicit SmoothLoopTime(uint64_t timeInterval)$/;"	f	class:folly::EventBase::SmoothLoopTime	access:public	signature:(uint64_t timeInterval)
folly::EventBase::SmoothLoopTime::addSample	.\io\async\EventBase.cpp	/^void EventBase::SmoothLoopTime::addSample(int64_t idle, int64_t busy) {$/;"	f	class:folly::EventBase::SmoothLoopTime	signature:(int64_t idle, int64_t busy)
folly::EventBase::SmoothLoopTime::addSample	.\io\async\EventBase.h	/^    void addSample(int64_t idle, int64_t busy);$/;"	p	class:folly::EventBase::SmoothLoopTime	access:public	signature:(int64_t idle, int64_t busy)
folly::EventBase::SmoothLoopTime::dampen	.\io\async\EventBase.h	/^    void dampen(double factor) {$/;"	f	class:folly::EventBase::SmoothLoopTime	access:public	signature:(double factor)
folly::EventBase::SmoothLoopTime::expCoeff_	.\io\async\EventBase.h	/^    double  expCoeff_;$/;"	m	class:folly::EventBase::SmoothLoopTime	access:private
folly::EventBase::SmoothLoopTime::get	.\io\async\EventBase.h	/^    double get() const {$/;"	f	class:folly::EventBase::SmoothLoopTime	access:public	signature:() const
folly::EventBase::SmoothLoopTime::oldBusyLeftover_	.\io\async\EventBase.h	/^    int64_t oldBusyLeftover_;$/;"	m	class:folly::EventBase::SmoothLoopTime	access:private
folly::EventBase::SmoothLoopTime::reset	.\io\async\EventBase.cpp	/^void EventBase::SmoothLoopTime::reset(double value) {$/;"	f	class:folly::EventBase::SmoothLoopTime	signature:(double value)
folly::EventBase::SmoothLoopTime::reset	.\io\async\EventBase.h	/^    void reset(double value = 0.0);$/;"	p	class:folly::EventBase::SmoothLoopTime	access:public	signature:(double value = 0.0)
folly::EventBase::SmoothLoopTime::setTimeInterval	.\io\async\EventBase.cpp	/^void EventBase::SmoothLoopTime::setTimeInterval(uint64_t timeInterval) {$/;"	f	class:folly::EventBase::SmoothLoopTime	signature:(uint64_t timeInterval)
folly::EventBase::SmoothLoopTime::setTimeInterval	.\io\async\EventBase.h	/^    void setTimeInterval(uint64_t timeInterval);$/;"	p	class:folly::EventBase::SmoothLoopTime	access:public	signature:(uint64_t timeInterval)
folly::EventBase::SmoothLoopTime::value_	.\io\async\EventBase.h	/^    double  value_;$/;"	m	class:folly::EventBase::SmoothLoopTime	access:private
folly::EventBase::attachTimeoutManager	.\io\async\EventBase.cpp	/^void EventBase::attachTimeoutManager(AsyncTimeout* obj,$/;"	f	class:folly::EventBase	signature:(AsyncTimeout* obj, InternalEnum internal)
folly::EventBase::attachTimeoutManager	.\io\async\EventBase.h	/^  void attachTimeoutManager(AsyncTimeout* obj,$/;"	p	class:folly::EventBase	access:private	signature:(AsyncTimeout* obj, TimeoutManager::InternalEnum internal)
folly::EventBase::avgLoopTime_	.\io\async\EventBase.h	/^  SmoothLoopTime avgLoopTime_;$/;"	m	class:folly::EventBase	access:private
folly::EventBase::bumpHandlingTime	.\io\async\EventBase.cpp	/^bool EventBase::bumpHandlingTime() {$/;"	f	class:folly::EventBase	signature:()
folly::EventBase::bumpHandlingTime	.\io\async\EventBase.h	/^  bool bumpHandlingTime();$/;"	p	class:folly::EventBase	access:public	signature:()
folly::EventBase::cancelTimeout	.\io\async\EventBase.cpp	/^void EventBase::cancelTimeout(AsyncTimeout* obj) {$/;"	f	class:folly::EventBase	signature:(AsyncTimeout* obj)
folly::EventBase::cancelTimeout	.\io\async\EventBase.h	/^  void cancelTimeout(AsyncTimeout* obj);$/;"	p	class:folly::EventBase	access:private	signature:(AsyncTimeout* obj)
folly::EventBase::detachTimeoutManager	.\io\async\EventBase.cpp	/^void EventBase::detachTimeoutManager(AsyncTimeout* obj) {$/;"	f	class:folly::EventBase	signature:(AsyncTimeout* obj)
folly::EventBase::detachTimeoutManager	.\io\async\EventBase.h	/^  void detachTimeoutManager(AsyncTimeout* obj);$/;"	p	class:folly::EventBase	access:private	signature:(AsyncTimeout* obj)
folly::EventBase::evb_	.\io\async\EventBase.h	/^  event_base* evb_;$/;"	m	class:folly::EventBase	access:private
folly::EventBase::fnRunner_	.\io\async\EventBase.h	/^  std::unique_ptr<FunctionRunner> fnRunner_;$/;"	m	class:folly::EventBase	access:private
folly::EventBase::getAvgLoopTime	.\io\async\EventBase.h	/^  double getAvgLoopTime() const {$/;"	f	class:folly::EventBase	access:public	signature:() const
folly::EventBase::getLibeventBase	.\io\async\EventBase.h	/^  event_base* getLibeventBase() const { return evb_; }$/;"	f	class:folly::EventBase	access:public	signature:() const
folly::EventBase::getLibeventMethod	.\io\async\EventBase.h	/^  static const char* getLibeventMethod() { return event_get_method(); }$/;"	f	class:folly::EventBase	access:public	signature:()
folly::EventBase::getLibeventVersion	.\io\async\EventBase.h	/^  static const char* getLibeventVersion() { return event_get_version(); }$/;"	f	class:folly::EventBase	access:public	signature:()
folly::EventBase::getName	.\io\async\EventBase.cpp	/^const std::string& EventBase::getName() {$/;"	f	class:folly::EventBase	signature:()
folly::EventBase::getName	.\io\async\EventBase.h	/^  const std::string& getName();$/;"	p	class:folly::EventBase	access:public	signature:()
folly::EventBase::getNotificationQueueSize	.\io\async\EventBase.cpp	/^int EventBase::getNotificationQueueSize() const {$/;"	f	class:folly::EventBase	signature:() const
folly::EventBase::getNotificationQueueSize	.\io\async\EventBase.h	/^  int getNotificationQueueSize() const;$/;"	p	class:folly::EventBase	access:public	signature:() const
folly::EventBase::getObserver	.\io\async\EventBase.h	/^  const std::shared_ptr<EventBaseObserver>& getObserver() {$/;"	f	class:folly::EventBase	access:public	signature:()
folly::EventBase::inRunningEventBaseThread	.\io\async\EventBase.h	/^  bool inRunningEventBaseThread() const {$/;"	f	class:folly::EventBase	access:public	signature:() const
folly::EventBase::initNotificationQueue	.\io\async\EventBase.cpp	/^void EventBase::initNotificationQueue() {$/;"	f	class:folly::EventBase	signature:()
folly::EventBase::initNotificationQueue	.\io\async\EventBase.h	/^  void initNotificationQueue();$/;"	p	class:folly::EventBase	access:private	signature:()
folly::EventBase::isInEventBaseThread	.\io\async\EventBase.h	/^  bool isInEventBaseThread() const {$/;"	f	class:folly::EventBase	access:public	signature:() const
folly::EventBase::isInTimeoutManagerThread	.\io\async\EventBase.h	/^  bool isInTimeoutManagerThread() {$/;"	f	class:folly::EventBase	access:private	signature:()
folly::EventBase::isRunning	.\io\async\EventBase.h	/^  bool isRunning() const {$/;"	f	class:folly::EventBase	access:public	signature:() const
folly::EventBase::kDEFAULT_IDLE_WAIT_USEC	.\io\async\EventBase.h	/^  static const int kDEFAULT_IDLE_WAIT_USEC = 20000; \/\/ 20ms$/;"	m	class:folly::EventBase	access:private
folly::EventBase::latestLoopCnt_	.\io\async\EventBase.h	/^  uint64_t latestLoopCnt_;$/;"	m	class:folly::EventBase	access:private
folly::EventBase::loop	.\io\async\EventBase.cpp	/^bool EventBase::loop() {$/;"	f	class:folly::EventBase	signature:()
folly::EventBase::loop	.\io\async\EventBase.h	/^  bool loop();$/;"	p	class:folly::EventBase	access:public	signature:()
folly::EventBase::loopBody	.\io\async\EventBase.cpp	/^bool EventBase::loopBody(int flags) {$/;"	f	class:folly::EventBase	signature:(int flags)
folly::EventBase::loopBody	.\io\async\EventBase.h	/^  bool loopBody(int flags = 0);$/;"	p	class:folly::EventBase	access:private	signature:(int flags = 0)
folly::EventBase::loopCallbacks_	.\io\async\EventBase.h	/^  LoopCallbackList loopCallbacks_;$/;"	m	class:folly::EventBase	access:private
folly::EventBase::loopForever	.\io\async\EventBase.cpp	/^void EventBase::loopForever() {$/;"	f	class:folly::EventBase	signature:()
folly::EventBase::loopForever	.\io\async\EventBase.h	/^  void loopForever();$/;"	p	class:folly::EventBase	access:public	signature:()
folly::EventBase::loopOnce	.\io\async\EventBase.cpp	/^bool EventBase::loopOnce(int flags) {$/;"	f	class:folly::EventBase	signature:(int flags)
folly::EventBase::loopOnce	.\io\async\EventBase.h	/^  bool loopOnce(int flags = 0);$/;"	p	class:folly::EventBase	access:public	signature:(int flags = 0)
folly::EventBase::loopThread_	.\io\async\EventBase.h	/^  std::atomic<pthread_t> loopThread_;$/;"	m	class:folly::EventBase	access:private
folly::EventBase::maxLatencyCob_	.\io\async\EventBase.h	/^  Cob maxLatencyCob_;$/;"	m	class:folly::EventBase	access:private
folly::EventBase::maxLatencyLoopTime_	.\io\async\EventBase.h	/^  SmoothLoopTime maxLatencyLoopTime_;$/;"	m	class:folly::EventBase	access:private
folly::EventBase::maxLatency_	.\io\async\EventBase.h	/^  int64_t maxLatency_;$/;"	m	class:folly::EventBase	access:private
folly::EventBase::name_	.\io\async\EventBase.h	/^  std::string name_;$/;"	m	class:folly::EventBase	access:private
folly::EventBase::nextLoopCnt_	.\io\async\EventBase.h	/^  uint64_t nextLoopCnt_;$/;"	m	class:folly::EventBase	access:private
folly::EventBase::nothingHandledYet	.\io\async\EventBase.cpp	/^bool EventBase::nothingHandledYet() {$/;"	f	class:folly::EventBase	signature:()
folly::EventBase::nothingHandledYet	.\io\async\EventBase.h	/^  bool nothingHandledYet();$/;"	p	class:folly::EventBase	access:private	signature:()
folly::EventBase::observerSampleCount_	.\io\async\EventBase.h	/^  uint32_t observerSampleCount_;$/;"	m	class:folly::EventBase	access:private
folly::EventBase::observer_	.\io\async\EventBase.h	/^  std::shared_ptr<EventBaseObserver> observer_;$/;"	m	class:folly::EventBase	access:private
folly::EventBase::onDestructionCallbacks_	.\io\async\EventBase.h	/^  LoopCallbackList onDestructionCallbacks_;$/;"	m	class:folly::EventBase	access:private
folly::EventBase::pendingCobTimeouts_	.\io\async\EventBase.h	/^  CobTimeout::List pendingCobTimeouts_;$/;"	m	class:folly::EventBase	access:private
folly::EventBase::queue_	.\io\async\EventBase.h	/^  std::unique_ptr<NotificationQueue<std::pair<void (*)(void*), void*>>> queue_;$/;"	m	class:folly::EventBase	access:private
folly::EventBase::resetLoadAvg	.\io\async\EventBase.cpp	/^void EventBase::resetLoadAvg(double value) {$/;"	f	class:folly::EventBase	signature:(double value)
folly::EventBase::resetLoadAvg	.\io\async\EventBase.h	/^  void resetLoadAvg(double value = 0.0);$/;"	p	class:folly::EventBase	access:public	signature:(double value = 0.0)
folly::EventBase::runAfterDelay	.\io\async\EventBase.cpp	/^bool EventBase::runAfterDelay(const Cob& cob,$/;"	f	class:folly::EventBase	signature:(const Cob& cob, int milliseconds, TimeoutManager::InternalEnum in)
folly::EventBase::runAfterDelay	.\io\async\EventBase.h	/^  bool runAfterDelay($/;"	p	class:folly::EventBase	access:public	signature:( const Cob& c, int milliseconds, TimeoutManager::InternalEnum = TimeoutManager::InternalEnum::NORMAL)
folly::EventBase::runFunctionPtr	.\io\async\EventBase.cpp	/^void EventBase::runFunctionPtr(Cob* fn) {$/;"	f	class:folly::EventBase	signature:(Cob* fn)
folly::EventBase::runFunctionPtr	.\io\async\EventBase.h	/^  static void runFunctionPtr(std::function<void()>* fn);$/;"	p	class:folly::EventBase	access:private	signature:(std::function<void()>* fn)
folly::EventBase::runInEventBaseThread	.\io\async\EventBase.cpp	/^bool EventBase::runInEventBaseThread(const Cob& fn) {$/;"	f	class:folly::EventBase	signature:(const Cob& fn)
folly::EventBase::runInEventBaseThread	.\io\async\EventBase.cpp	/^bool EventBase::runInEventBaseThread(void (*fn)(void*), void* arg) {$/;"	f	class:folly::EventBase	signature:(void (*fn)(void*), void* arg)
folly::EventBase::runInEventBaseThread	.\io\async\EventBase.h	/^  bool runInEventBaseThread(const Cob& fn);$/;"	p	class:folly::EventBase	access:public	signature:(const Cob& fn)
folly::EventBase::runInEventBaseThread	.\io\async\EventBase.h	/^  bool runInEventBaseThread(void (*fn)(T*), T* arg) {$/;"	f	class:folly::EventBase	access:public	signature:(void (*fn)(T*), T* arg)
folly::EventBase::runInEventBaseThread	.\io\async\EventBase.h	/^  bool runInEventBaseThread(void (*fn)(void*), void* arg);$/;"	p	class:folly::EventBase	access:public	signature:(void (*fn)(void*), void* arg)
folly::EventBase::runInLoop	.\io\async\EventBase.cpp	/^void EventBase::runInLoop(Cob&& cob, bool thisIteration) {$/;"	f	class:folly::EventBase	signature:(Cob&& cob, bool thisIteration)
folly::EventBase::runInLoop	.\io\async\EventBase.cpp	/^void EventBase::runInLoop(LoopCallback* callback, bool thisIteration) {$/;"	f	class:folly::EventBase	signature:(LoopCallback* callback, bool thisIteration)
folly::EventBase::runInLoop	.\io\async\EventBase.cpp	/^void EventBase::runInLoop(const Cob& cob, bool thisIteration) {$/;"	f	class:folly::EventBase	signature:(const Cob& cob, bool thisIteration)
folly::EventBase::runInLoop	.\io\async\EventBase.h	/^  void runInLoop(Cob&& c, bool thisIteration = false);$/;"	p	class:folly::EventBase	access:public	signature:(Cob&& c, bool thisIteration = false)
folly::EventBase::runInLoop	.\io\async\EventBase.h	/^  void runInLoop(LoopCallback* callback, bool thisIteration = false);$/;"	p	class:folly::EventBase	access:public	signature:(LoopCallback* callback, bool thisIteration = false)
folly::EventBase::runInLoop	.\io\async\EventBase.h	/^  void runInLoop(const Cob& c, bool thisIteration = false);$/;"	p	class:folly::EventBase	access:public	signature:(const Cob& c, bool thisIteration = false)
folly::EventBase::runLoopCallbacks	.\io\async\EventBase.cpp	/^bool EventBase::runLoopCallbacks(bool setContext) {$/;"	f	class:folly::EventBase	signature:(bool setContext)
folly::EventBase::runLoopCallbacks	.\io\async\EventBase.h	/^  bool runLoopCallbacks(bool setContext = true);$/;"	p	class:folly::EventBase	access:private	signature:(bool setContext = true)
folly::EventBase::runOnDestruction	.\io\async\EventBase.cpp	/^void EventBase::runOnDestruction(LoopCallback* callback) {$/;"	f	class:folly::EventBase	signature:(LoopCallback* callback)
folly::EventBase::runOnDestruction	.\io\async\EventBase.h	/^  void runOnDestruction(LoopCallback* callback);$/;"	p	class:folly::EventBase	access:public	signature:(LoopCallback* callback)
folly::EventBase::runOnceCallbacks_	.\io\async\EventBase.h	/^  LoopCallbackList* runOnceCallbacks_;$/;"	m	class:folly::EventBase	access:private
folly::EventBase::scheduleTimeout	.\io\async\EventBase.cpp	/^bool EventBase::scheduleTimeout(AsyncTimeout* obj,$/;"	f	class:folly::EventBase	signature:(AsyncTimeout* obj, std::chrono::milliseconds timeout)
folly::EventBase::scheduleTimeout	.\io\async\EventBase.h	/^  bool scheduleTimeout(AsyncTimeout* obj, std::chrono::milliseconds timeout);$/;"	p	class:folly::EventBase	access:private	signature:(AsyncTimeout* obj, std::chrono::milliseconds timeout)
folly::EventBase::setLoadAvgMsec	.\io\async\EventBase.cpp	/^void EventBase::setLoadAvgMsec(uint32_t ms) {$/;"	f	class:folly::EventBase	signature:(uint32_t ms)
folly::EventBase::setLoadAvgMsec	.\io\async\EventBase.h	/^  void setLoadAvgMsec(uint32_t ms);$/;"	p	class:folly::EventBase	access:public	signature:(uint32_t ms)
folly::EventBase::setMaxLatency	.\io\async\EventBase.h	/^  void setMaxLatency(int64_t maxLatency, const Cob& maxLatencyCob) {$/;"	f	class:folly::EventBase	access:public	signature:(int64_t maxLatency, const Cob& maxLatencyCob)
folly::EventBase::setMaxReadAtOnce	.\io\async\EventBase.cpp	/^void EventBase::setMaxReadAtOnce(uint32_t maxAtOnce) {$/;"	f	class:folly::EventBase	signature:(uint32_t maxAtOnce)
folly::EventBase::setMaxReadAtOnce	.\io\async\EventBase.h	/^  void setMaxReadAtOnce(uint32_t maxAtOnce);$/;"	p	class:folly::EventBase	access:public	signature:(uint32_t maxAtOnce)
folly::EventBase::setName	.\io\async\EventBase.cpp	/^void EventBase::setName(const std::string& name) {$/;"	f	class:folly::EventBase	signature:(const std::string& name)
folly::EventBase::setName	.\io\async\EventBase.h	/^  void setName(const std::string& name);$/;"	p	class:folly::EventBase	access:public	signature:(const std::string& name)
folly::EventBase::setObserver	.\io\async\EventBase.h	/^  void setObserver($/;"	f	class:folly::EventBase	access:public	signature:( const std::shared_ptr<EventBaseObserver>& observer)
folly::EventBase::startWork_	.\io\async\EventBase.h	/^  uint64_t startWork_;$/;"	m	class:folly::EventBase	access:private
folly::EventBase::stop_	.\io\async\EventBase.h	/^  bool stop_;$/;"	m	class:folly::EventBase	access:private
folly::EventBase::terminateLoopSoon	.\io\async\EventBase.cpp	/^void EventBase::terminateLoopSoon() {$/;"	f	class:folly::EventBase	signature:()
folly::EventBase::terminateLoopSoon	.\io\async\EventBase.h	/^  void terminateLoopSoon();$/;"	p	class:folly::EventBase	access:public	signature:()
folly::EventBase::waitUntilRunning	.\io\async\EventBase.cpp	/^void EventBase::waitUntilRunning() {$/;"	f	class:folly::EventBase	signature:()
folly::EventBase::waitUntilRunning	.\io\async\EventBase.h	/^  void waitUntilRunning();$/;"	p	class:folly::EventBase	access:public	signature:()
folly::EventBase::~EventBase	.\io\async\EventBase.cpp	/^EventBase::~EventBase() {$/;"	f	class:folly::EventBase	signature:()
folly::EventBase::~EventBase	.\io\async\EventBase.h	/^  ~EventBase();$/;"	p	class:folly::EventBase	access:public	signature:()
folly::EventBaseObserver	.\io\async\EventBase.h	/^class EventBaseObserver {$/;"	c	namespace:folly
folly::EventBaseObserver::getSampleRate	.\io\async\EventBase.h	/^  virtual uint32_t getSampleRate() const = 0;$/;"	p	class:folly::EventBaseObserver	access:public	signature:() const
folly::EventBaseObserver::loopSample	.\io\async\EventBase.h	/^  virtual void loopSample($/;"	p	class:folly::EventBaseObserver	access:public	signature:( int64_t busyTime, int64_t idleTime)
folly::EventBaseObserver::~EventBaseObserver	.\io\async\EventBase.h	/^  virtual ~EventBaseObserver() {}$/;"	f	class:folly::EventBaseObserver	access:public	signature:()
folly::EventCount	.\experimental\EventCount.h	/^class EventCount {$/;"	c	namespace:folly
folly::EventCount::EventCount	.\experimental\EventCount.h	/^  EventCount(EventCount&&) = delete;$/;"	p	class:folly::EventCount	access:private	signature:(EventCount&&)
folly::EventCount::EventCount	.\experimental\EventCount.h	/^  EventCount(const EventCount&) = delete;$/;"	p	class:folly::EventCount	access:private	signature:(const EventCount&)
folly::EventCount::Key	.\experimental\EventCount.h	/^  class Key {$/;"	c	class:folly::EventCount	access:public
folly::EventCount::Key::EventCount	.\experimental\EventCount.h	/^    friend class EventCount;$/;"	x
folly::EventCount::Key::epoch_	.\experimental\EventCount.h	/^    explicit Key(uint32_t e) noexcept : epoch_(e) { }$/;"	f	class:folly::EventCount::Key	access:private	signature:(e)
folly::EventCount::Key::epoch_	.\experimental\EventCount.h	/^    uint32_t epoch_;$/;"	m	class:folly::EventCount::Key	access:private
folly::EventCount::await	.\experimental\EventCount.h	/^  void await(Condition condition);$/;"	p	class:folly::EventCount	access:public	signature:(Condition condition)
folly::EventCount::await	.\experimental\EventCount.h	/^void EventCount::await(Condition condition) {$/;"	f	class:folly::EventCount	signature:(Condition condition)
folly::EventCount::kAddEpoch	.\experimental\EventCount.h	/^  static constexpr uint64_t kAddEpoch = uint64_t(1) << kEpochShift;$/;"	m	class:folly::EventCount	access:private
folly::EventCount::kAddWaiter	.\experimental\EventCount.h	/^  static constexpr uint64_t kAddWaiter = uint64_t(1);$/;"	m	class:folly::EventCount	access:private
folly::EventCount::kEpochOffset	.\experimental\EventCount.h	/^  static constexpr size_t kEpochOffset = 0;  \/\/ in units of sizeof(int)$/;"	m	class:folly::EventCount	access:private
folly::EventCount::kEpochOffset	.\experimental\EventCount.h	/^  static constexpr size_t kEpochOffset = 1;$/;"	m	class:folly::EventCount	access:private
folly::EventCount::kEpochShift	.\experimental\EventCount.h	/^  static constexpr size_t  kEpochShift = 32;$/;"	m	class:folly::EventCount	access:private
folly::EventCount::kSubWaiter	.\experimental\EventCount.h	/^  static constexpr uint64_t kSubWaiter = uint64_t(-1);$/;"	m	class:folly::EventCount	access:private
folly::EventCount::kWaiterMask	.\experimental\EventCount.h	/^  static constexpr uint64_t kWaiterMask = kAddEpoch - 1;$/;"	m	class:folly::EventCount	access:private
folly::EventCount::noexcept	.\experimental\EventCount.h	/^  Key prepareWait() noexcept;$/;"	m	class:folly::EventCount	access:public
folly::EventCount::noexcept	.\experimental\EventCount.h	/^  void cancelWait() noexcept;$/;"	m	class:folly::EventCount	access:public
folly::EventCount::noexcept	.\experimental\EventCount.h	/^  void doNotify(int n) noexcept;$/;"	m	class:folly::EventCount	access:private
folly::EventCount::noexcept	.\experimental\EventCount.h	/^  void notify() noexcept;$/;"	m	class:folly::EventCount	access:public
folly::EventCount::noexcept	.\experimental\EventCount.h	/^  void notifyAll() noexcept;$/;"	m	class:folly::EventCount	access:public
folly::EventCount::noexcept	.\experimental\EventCount.h	/^  void wait(Key key) noexcept;$/;"	m	class:folly::EventCount	access:public
folly::EventCount::operator =	.\experimental\EventCount.h	/^  EventCount& operator=(EventCount&&) = delete;$/;"	p	class:folly::EventCount	access:private	signature:(EventCount&&)
folly::EventCount::operator =	.\experimental\EventCount.h	/^  EventCount& operator=(const EventCount&) = delete;$/;"	p	class:folly::EventCount	access:private	signature:(const EventCount&)
folly::EventCount::sizeof	.\experimental\EventCount.h	/^  static_assert(sizeof(int) == 4, "bad platform");$/;"	p	class:folly::EventCount	access:private	signature:(int)
folly::EventCount::sizeof	.\experimental\EventCount.h	/^  static_assert(sizeof(uint32_t) == 4, "bad platform");$/;"	p	class:folly::EventCount	access:private	signature:(uint32_t)
folly::EventCount::sizeof	.\experimental\EventCount.h	/^  static_assert(sizeof(uint64_t) == 8, "bad platform");$/;"	p	class:folly::EventCount	access:private	signature:(uint64_t)
folly::EventCount::val_	.\experimental\EventCount.h	/^  std::atomic<uint64_t> val_;$/;"	m	class:folly::EventCount	access:private
folly::EventHandler	.\io\async\EventHandler.h	/^class EventHandler : private boost::noncopyable {$/;"	c	namespace:folly	inherits:boost::noncopyable
folly::EventHandler::EventFlags	.\io\async\EventHandler.h	/^  enum EventFlags {$/;"	g	class:folly::EventHandler	access:public
folly::EventHandler::EventHandler	.\io\async\EventHandler.cpp	/^EventHandler::EventHandler(EventBase* eventBase, int fd) {$/;"	f	class:folly::EventHandler	signature:(EventBase* eventBase, int fd)
folly::EventHandler::EventHandler	.\io\async\EventHandler.h	/^  explicit EventHandler(EventBase* eventBase = nullptr, int fd = -1);$/;"	p	class:folly::EventHandler	access:public	signature:(EventBase* eventBase = nullptr, int fd = -1)
folly::EventHandler::NONE	.\io\async\EventHandler.h	/^    NONE = 0,$/;"	e	enum:folly::EventHandler::EventFlags
folly::EventHandler::PERSIST	.\io\async\EventHandler.h	/^    PERSIST = EV_PERSIST$/;"	e	enum:folly::EventHandler::EventFlags
folly::EventHandler::READ	.\io\async\EventHandler.h	/^    READ = EV_READ,$/;"	e	enum:folly::EventHandler::EventFlags
folly::EventHandler::READ_WRITE	.\io\async\EventHandler.h	/^    READ_WRITE = (READ | WRITE),$/;"	e	enum:folly::EventHandler::EventFlags
folly::EventHandler::WRITE	.\io\async\EventHandler.h	/^    WRITE = EV_WRITE,$/;"	e	enum:folly::EventHandler::EventFlags
folly::EventHandler::attachEventBase	.\io\async\EventHandler.cpp	/^void EventHandler::attachEventBase(EventBase* eventBase) {$/;"	f	class:folly::EventHandler	signature:(EventBase* eventBase)
folly::EventHandler::attachEventBase	.\io\async\EventHandler.h	/^  void attachEventBase(EventBase* eventBase);$/;"	p	class:folly::EventHandler	access:public	signature:(EventBase* eventBase)
folly::EventHandler::changeHandlerFD	.\io\async\EventHandler.cpp	/^void EventHandler::changeHandlerFD(int fd) {$/;"	f	class:folly::EventHandler	signature:(int fd)
folly::EventHandler::changeHandlerFD	.\io\async\EventHandler.h	/^  void changeHandlerFD(int fd);$/;"	p	class:folly::EventHandler	access:public	signature:(int fd)
folly::EventHandler::detachEventBase	.\io\async\EventHandler.cpp	/^void EventHandler::detachEventBase() {$/;"	f	class:folly::EventHandler	signature:()
folly::EventHandler::detachEventBase	.\io\async\EventHandler.h	/^  void detachEventBase();$/;"	p	class:folly::EventHandler	access:public	signature:()
folly::EventHandler::ensureNotRegistered	.\io\async\EventHandler.cpp	/^void EventHandler::ensureNotRegistered(const char* fn) {$/;"	f	class:folly::EventHandler	signature:(const char* fn)
folly::EventHandler::ensureNotRegistered	.\io\async\EventHandler.h	/^  void ensureNotRegistered(const char* fn);$/;"	p	class:folly::EventHandler	access:private	signature:(const char* fn)
folly::EventHandler::eventBase_	.\io\async\EventHandler.h	/^  EventBase* eventBase_;$/;"	m	class:folly::EventHandler	access:private
folly::EventHandler::event_	.\io\async\EventHandler.h	/^  struct event event_;$/;"	m	class:folly::EventHandler	typeref:struct:folly::EventHandler::event	access:private
folly::EventHandler::getRegisteredEvents	.\io\async\EventHandler.h	/^  uint16_t getRegisteredEvents() const {$/;"	f	class:folly::EventHandler	access:public	signature:() const
folly::EventHandler::initHandler	.\io\async\EventHandler.cpp	/^void EventHandler::initHandler(EventBase* eventBase, int fd) {$/;"	f	class:folly::EventHandler	signature:(EventBase* eventBase, int fd)
folly::EventHandler::initHandler	.\io\async\EventHandler.h	/^  void initHandler(EventBase* eventBase, int fd);$/;"	p	class:folly::EventHandler	access:public	signature:(EventBase* eventBase, int fd)
folly::EventHandler::isHandlerRegistered	.\io\async\EventHandler.h	/^  bool isHandlerRegistered() const {$/;"	f	class:folly::EventHandler	access:public	signature:() const
folly::EventHandler::isPending	.\io\async\EventHandler.cpp	/^bool EventHandler::isPending() const {$/;"	f	class:folly::EventHandler	signature:() const
folly::EventHandler::isPending	.\io\async\EventHandler.h	/^  bool isPending() const;$/;"	p	class:folly::EventHandler	access:public	signature:() const
folly::EventHandler::libeventCallback	.\io\async\EventHandler.cpp	/^void EventHandler::libeventCallback(int fd, short events, void* arg) {$/;"	f	class:folly::EventHandler	signature:(int fd, short events, void* arg)
folly::EventHandler::libeventCallback	.\io\async\EventHandler.h	/^  static void libeventCallback(int fd, short events, void* arg);$/;"	p	class:folly::EventHandler	access:private	signature:(int fd, short events, void* arg)
folly::EventHandler::noexcept	.\io\async\EventHandler.h	/^  virtual void handlerReady(uint16_t events) noexcept = 0;$/;"	m	class:folly::EventHandler	access:public
folly::EventHandler::registerHandler	.\io\async\EventHandler.h	/^  bool registerHandler(uint16_t events) {$/;"	f	class:folly::EventHandler	access:public	signature:(uint16_t events)
folly::EventHandler::registerImpl	.\io\async\EventHandler.cpp	/^bool EventHandler::registerImpl(uint16_t events, bool internal) {$/;"	f	class:folly::EventHandler	signature:(uint16_t events, bool internal)
folly::EventHandler::registerImpl	.\io\async\EventHandler.h	/^  bool registerImpl(uint16_t events, bool internal);$/;"	p	class:folly::EventHandler	access:private	signature:(uint16_t events, bool internal)
folly::EventHandler::registerInternalHandler	.\io\async\EventHandler.h	/^  bool registerInternalHandler(uint16_t events) {$/;"	f	class:folly::EventHandler	access:public	signature:(uint16_t events)
folly::EventHandler::setEventBase	.\io\async\EventHandler.cpp	/^void EventHandler::setEventBase(EventBase* eventBase) {$/;"	f	class:folly::EventHandler	signature:(EventBase* eventBase)
folly::EventHandler::setEventBase	.\io\async\EventHandler.h	/^  void setEventBase(EventBase* eventBase);$/;"	p	class:folly::EventHandler	access:private	signature:(EventBase* eventBase)
folly::EventHandler::unregisterHandler	.\io\async\EventHandler.cpp	/^void EventHandler::unregisterHandler() {$/;"	f	class:folly::EventHandler	signature:()
folly::EventHandler::unregisterHandler	.\io\async\EventHandler.h	/^  void unregisterHandler();$/;"	p	class:folly::EventHandler	access:public	signature:()
folly::EventHandler::~EventHandler	.\io\async\EventHandler.cpp	/^EventHandler::~EventHandler() {$/;"	f	class:folly::EventHandler	signature:()
folly::EventHandler::~EventHandler	.\io\async\EventHandler.h	/^  virtual ~EventHandler();$/;"	p	class:folly::EventHandler	access:public	signature:()
folly::EventUtil	.\io\async\EventUtil.h	/^class EventUtil {$/;"	c	namespace:folly
folly::EventUtil::isEventRegistered	.\io\async\EventUtil.h	/^  static bool isEventRegistered(const struct event* ev) {$/;"	f	class:folly::EventUtil	access:public	signature:(const struct event* ev)
folly::EvictingCacheMap	.\EvictingCacheMap.h	/^class EvictingCacheMap : private boost::noncopyable {$/;"	c	namespace:folly	inherits:boost::noncopyable
folly::EvictingCacheMap::EvictingCacheMap	.\EvictingCacheMap.h	/^  explicit EvictingCacheMap(std::size_t maxSize, std::size_t clearSize = 1)$/;"	f	class:folly::EvictingCacheMap	access:public	signature:(std::size_t maxSize, std::size_t clearSize = 1)
folly::EvictingCacheMap::KeyHasher	.\EvictingCacheMap.h	/^  struct KeyHasher {$/;"	s	class:folly::EvictingCacheMap	access:private
folly::EvictingCacheMap::KeyHasher::operator ()	.\EvictingCacheMap.h	/^    std::size_t operator()(const Node& node) {$/;"	f	struct:folly::EvictingCacheMap::KeyHasher	access:public	signature:(const Node& node)
folly::EvictingCacheMap::KeyHasher::operator ()	.\EvictingCacheMap.h	/^    std::size_t operator()(const TKey& key) {$/;"	f	struct:folly::EvictingCacheMap::KeyHasher	access:public	signature:(const TKey& key)
folly::EvictingCacheMap::KeyValueEqual	.\EvictingCacheMap.h	/^  struct KeyValueEqual {$/;"	s	class:folly::EvictingCacheMap	access:private
folly::EvictingCacheMap::KeyValueEqual::operator ()	.\EvictingCacheMap.h	/^    bool operator()(const Node& lhs, const TKey& rhs) {$/;"	f	struct:folly::EvictingCacheMap::KeyValueEqual	access:public	signature:(const Node& lhs, const TKey& rhs)
folly::EvictingCacheMap::KeyValueEqual::operator ()	.\EvictingCacheMap.h	/^    bool operator()(const TKey& lhs, const Node& rhs) {$/;"	f	struct:folly::EvictingCacheMap::KeyValueEqual	access:public	signature:(const TKey& lhs, const Node& rhs)
folly::EvictingCacheMap::Node	.\EvictingCacheMap.h	/^  struct Node$/;"	s	class:folly::EvictingCacheMap	inherits:boost::intrusive::unordered_set_base_hook,boost::intrusive::list_base_hook	access:private
folly::EvictingCacheMap::Node	.\EvictingCacheMap.h	/^  struct Node;$/;"	x
folly::EvictingCacheMap::Node::Node	.\EvictingCacheMap.h	/^    Node(const TKey& key, TValue&& value)$/;"	f	struct:folly::EvictingCacheMap::Node	access:public	signature:(const TKey& key, TValue&& value)
folly::EvictingCacheMap::Node::hash_value	.\EvictingCacheMap.h	/^    friend std::size_t hash_value(const Node& node) {$/;"	f	struct:folly::EvictingCacheMap::Node	access:friend	signature:(const Node& node)
folly::EvictingCacheMap::Node::operator ==	.\EvictingCacheMap.h	/^    friend bool operator==(const Node& lhs, const Node& rhs) {$/;"	f	struct:folly::EvictingCacheMap::Node	access:friend	signature:(const Node& lhs, const Node& rhs)
folly::EvictingCacheMap::Node::pr	.\EvictingCacheMap.h	/^    TPair pr;$/;"	m	struct:folly::EvictingCacheMap::Node	access:public
folly::EvictingCacheMap::NodeList	.\EvictingCacheMap.h	/^  typedef boost::intrusive::list<Node> NodeList;$/;"	t	class:folly::EvictingCacheMap	access:private
folly::EvictingCacheMap::NodeMap	.\EvictingCacheMap.h	/^  typedef boost::intrusive::unordered_set<Node> NodeMap;$/;"	t	class:folly::EvictingCacheMap	access:private
folly::EvictingCacheMap::PruneHookCall	.\EvictingCacheMap.h	/^  typedef std::function<void(TKey, TValue&&)> PruneHookCall;$/;"	t	class:folly::EvictingCacheMap	access:public
folly::EvictingCacheMap::TPair	.\EvictingCacheMap.h	/^  typedef std::pair<const TKey, TValue> TPair;$/;"	t	class:folly::EvictingCacheMap	access:private
folly::EvictingCacheMap::begin	.\EvictingCacheMap.h	/^  const_iterator begin() const {$/;"	f	class:folly::EvictingCacheMap	access:public	signature:() const
folly::EvictingCacheMap::begin	.\EvictingCacheMap.h	/^  iterator begin() {$/;"	f	class:folly::EvictingCacheMap	access:public	signature:()
folly::EvictingCacheMap::cbegin	.\EvictingCacheMap.h	/^  const_iterator cbegin() const {$/;"	f	class:folly::EvictingCacheMap	access:public	signature:() const
folly::EvictingCacheMap::cend	.\EvictingCacheMap.h	/^  const_iterator cend() const {$/;"	f	class:folly::EvictingCacheMap	access:public	signature:() const
folly::EvictingCacheMap::clear	.\EvictingCacheMap.h	/^  void clear() {$/;"	f	class:folly::EvictingCacheMap	access:public	signature:()
folly::EvictingCacheMap::clearSize_	.\EvictingCacheMap.h	/^  std::size_t clearSize_;$/;"	m	class:folly::EvictingCacheMap	access:private
folly::EvictingCacheMap::const_iterator	.\EvictingCacheMap.h	/^    const TPair, typename NodeList::const_iterator> const_iterator;$/;"	t	class:folly::EvictingCacheMap	access:public
folly::EvictingCacheMap::const_reverse_iterator	.\EvictingCacheMap.h	/^    typename NodeList::const_reverse_iterator> const_reverse_iterator;$/;"	t	class:folly::EvictingCacheMap	access:public
folly::EvictingCacheMap::crbegin	.\EvictingCacheMap.h	/^  const_reverse_iterator crbegin() const {$/;"	f	class:folly::EvictingCacheMap	access:public	signature:() const
folly::EvictingCacheMap::crend	.\EvictingCacheMap.h	/^  const_reverse_iterator crend() const {$/;"	f	class:folly::EvictingCacheMap	access:public	signature:() const
folly::EvictingCacheMap::empty	.\EvictingCacheMap.h	/^  bool empty() const {$/;"	f	class:folly::EvictingCacheMap	access:public	signature:() const
folly::EvictingCacheMap::end	.\EvictingCacheMap.h	/^  const_iterator end() const {$/;"	f	class:folly::EvictingCacheMap	access:public	signature:() const
folly::EvictingCacheMap::end	.\EvictingCacheMap.h	/^  iterator end() {$/;"	f	class:folly::EvictingCacheMap	access:public	signature:()
folly::EvictingCacheMap::erase	.\EvictingCacheMap.h	/^  bool erase(const TKey& key) {$/;"	f	class:folly::EvictingCacheMap	access:public	signature:(const TKey& key)
folly::EvictingCacheMap::exists	.\EvictingCacheMap.h	/^  bool exists(const TKey& key) const  {$/;"	f	class:folly::EvictingCacheMap	access:public	signature:(const TKey& key) const
folly::EvictingCacheMap::find	.\EvictingCacheMap.h	/^  iterator find(const TKey& key) {$/;"	f	class:folly::EvictingCacheMap	access:public	signature:(const TKey& key)
folly::EvictingCacheMap::findInIndex	.\EvictingCacheMap.h	/^  typename NodeMap::const_iterator findInIndex(const TKey& key) const {$/;"	f	class:folly::EvictingCacheMap	access:private	signature:(const TKey& key) const
folly::EvictingCacheMap::findInIndex	.\EvictingCacheMap.h	/^  typename NodeMap::iterator findInIndex(const TKey& key) {$/;"	f	class:folly::EvictingCacheMap	access:private	signature:(const TKey& key)
folly::EvictingCacheMap::findWithoutPromotion	.\EvictingCacheMap.h	/^  const_iterator findWithoutPromotion(const TKey& key) const {$/;"	f	class:folly::EvictingCacheMap	access:public	signature:(const TKey& key) const
folly::EvictingCacheMap::findWithoutPromotion	.\EvictingCacheMap.h	/^  iterator findWithoutPromotion(const TKey& key) {$/;"	f	class:folly::EvictingCacheMap	access:public	signature:(const TKey& key)
folly::EvictingCacheMap::get	.\EvictingCacheMap.h	/^  TValue& get(const TKey& key) {$/;"	f	class:folly::EvictingCacheMap	access:public	signature:(const TKey& key)
folly::EvictingCacheMap::getMaxSize	.\EvictingCacheMap.h	/^  size_t getMaxSize() const {$/;"	f	class:folly::EvictingCacheMap	access:public	signature:() const
folly::EvictingCacheMap::getWithoutPromotion	.\EvictingCacheMap.h	/^  TValue& getWithoutPromotion(const TKey& key) {$/;"	f	class:folly::EvictingCacheMap	access:public	signature:(const TKey& key)
folly::EvictingCacheMap::getWithoutPromotion	.\EvictingCacheMap.h	/^  const TValue& getWithoutPromotion(const TKey& key) const {$/;"	f	class:folly::EvictingCacheMap	access:public	signature:(const TKey& key) const
folly::EvictingCacheMap::indexBuckets_	.\EvictingCacheMap.h	/^  std::unique_ptr<typename NodeMap::bucket_type[]> indexBuckets_;$/;"	m	class:folly::EvictingCacheMap	access:private
folly::EvictingCacheMap::indexTraits_	.\EvictingCacheMap.h	/^  typename NodeMap::bucket_traits indexTraits_;$/;"	m	class:folly::EvictingCacheMap	access:private
folly::EvictingCacheMap::index_	.\EvictingCacheMap.h	/^  NodeMap index_;$/;"	m	class:folly::EvictingCacheMap	access:private
folly::EvictingCacheMap::iterator	.\EvictingCacheMap.h	/^    TPair, typename NodeList::iterator> iterator;$/;"	t	class:folly::EvictingCacheMap	access:public
folly::EvictingCacheMap::iterator_base	.\EvictingCacheMap.h	/^  class iterator_base$/;"	c	class:folly::EvictingCacheMap	inherits:boost::iterator_adaptor	access:public
folly::EvictingCacheMap::iterator_base::dereference	.\EvictingCacheMap.h	/^    Value& dereference() const {$/;"	f	class:folly::EvictingCacheMap::iterator_base	access:public	signature:() const
folly::EvictingCacheMap::iterator_base::iterator_base	.\EvictingCacheMap.h	/^    explicit iterator_base(TIterator it)$/;"	f	class:folly::EvictingCacheMap::iterator_base	access:public	signature:(TIterator it)
folly::EvictingCacheMap::iterator_base::iterator_base	.\EvictingCacheMap.h	/^    iterator_base() {$/;"	f	class:folly::EvictingCacheMap::iterator_base	access:public	signature:()
folly::EvictingCacheMap::kMinNumIndexBuckets	.\EvictingCacheMap.h	/^  static const std::size_t kMinNumIndexBuckets = 100;$/;"	m	class:folly::EvictingCacheMap	access:private
folly::EvictingCacheMap::link_mode	.\EvictingCacheMap.h	/^  typedef boost::intrusive::link_mode<boost::intrusive::safe_link> link_mode;$/;"	t	class:folly::EvictingCacheMap	access:private
folly::EvictingCacheMap::lru_	.\EvictingCacheMap.h	/^  NodeList lru_;$/;"	m	class:folly::EvictingCacheMap	access:private
folly::EvictingCacheMap::maxSize_	.\EvictingCacheMap.h	/^  std::size_t maxSize_;$/;"	m	class:folly::EvictingCacheMap	access:private
folly::EvictingCacheMap::nIndexBuckets_	.\EvictingCacheMap.h	/^  std::size_t nIndexBuckets_;$/;"	m	class:folly::EvictingCacheMap	access:private
folly::EvictingCacheMap::prune	.\EvictingCacheMap.h	/^  void prune(std::size_t pruneSize, PruneHookCall pruneHook = nullptr) {$/;"	f	class:folly::EvictingCacheMap	access:public	signature:(std::size_t pruneSize, PruneHookCall pruneHook = nullptr)
folly::EvictingCacheMap::pruneHook_	.\EvictingCacheMap.h	/^  PruneHookCall pruneHook_;$/;"	m	class:folly::EvictingCacheMap	access:private
folly::EvictingCacheMap::pruneWithFailSafeOption	.\EvictingCacheMap.h	/^  void pruneWithFailSafeOption(std::size_t pruneSize,$/;"	f	class:folly::EvictingCacheMap	access:private	signature:(std::size_t pruneSize, PruneHookCall pruneHook, bool failSafe)
folly::EvictingCacheMap::rbegin	.\EvictingCacheMap.h	/^  const_reverse_iterator rbegin() const {$/;"	f	class:folly::EvictingCacheMap	access:public	signature:() const
folly::EvictingCacheMap::rbegin	.\EvictingCacheMap.h	/^  reverse_iterator rbegin() {$/;"	f	class:folly::EvictingCacheMap	access:public	signature:()
folly::EvictingCacheMap::rend	.\EvictingCacheMap.h	/^  const_reverse_iterator rend() const {$/;"	f	class:folly::EvictingCacheMap	access:public	signature:() const
folly::EvictingCacheMap::rend	.\EvictingCacheMap.h	/^  reverse_iterator rend() {$/;"	f	class:folly::EvictingCacheMap	access:public	signature:()
folly::EvictingCacheMap::reverse_iterator	.\EvictingCacheMap.h	/^    TPair, typename NodeList::reverse_iterator> reverse_iterator;$/;"	t	class:folly::EvictingCacheMap	access:public
folly::EvictingCacheMap::set	.\EvictingCacheMap.h	/^  void set(const TKey& key, TValue value, bool promote = true) {$/;"	f	class:folly::EvictingCacheMap	access:public	signature:(const TKey& key, TValue value, bool promote = true)
folly::EvictingCacheMap::setClearSize	.\EvictingCacheMap.h	/^  void setClearSize(size_t clearSize) {$/;"	f	class:folly::EvictingCacheMap	access:public	signature:(size_t clearSize)
folly::EvictingCacheMap::setMaxSize	.\EvictingCacheMap.h	/^  void setMaxSize(size_t maxSize) {$/;"	f	class:folly::EvictingCacheMap	access:public	signature:(size_t maxSize)
folly::EvictingCacheMap::setPruneHook	.\EvictingCacheMap.h	/^  void setPruneHook(PruneHookCall pruneHook) {$/;"	f	class:folly::EvictingCacheMap	access:public	signature:(PruneHookCall pruneHook)
folly::EvictingCacheMap::size	.\EvictingCacheMap.h	/^  std::size_t size() const {$/;"	f	class:folly::EvictingCacheMap	access:public	signature:() const
folly::EvictingCacheMap::~EvictingCacheMap	.\EvictingCacheMap.h	/^  ~EvictingCacheMap() {$/;"	f	class:folly::EvictingCacheMap	access:public	signature:()
folly::FB_DEC_TYPE	.\dynamic-inl.h	/^FB_DEC_TYPE(bool);$/;"	p	namespace:folly	signature:(bool)
folly::FB_DEC_TYPE	.\dynamic-inl.h	/^FB_DEC_TYPE(double);$/;"	p	namespace:folly	signature:(double)
folly::FB_DEC_TYPE	.\dynamic-inl.h	/^FB_DEC_TYPE(dynamic::Array);$/;"	p	namespace:folly	signature:(dynamic::Array)
folly::FB_DEC_TYPE	.\dynamic-inl.h	/^FB_DEC_TYPE(dynamic::ObjectImpl);$/;"	p	namespace:folly	signature:(dynamic::ObjectImpl)
folly::FB_DEC_TYPE	.\dynamic-inl.h	/^FB_DEC_TYPE(fbstring);$/;"	p	namespace:folly	signature:(fbstring)
folly::FB_DEC_TYPE	.\dynamic-inl.h	/^FB_DEC_TYPE(int64_t);$/;"	p	namespace:folly	signature:(int64_t)
folly::FB_DEC_TYPE	.\dynamic-inl.h	/^FB_DEC_TYPE(void*);$/;"	p	namespace:folly	signature:(void*)
folly::FLAGS_enable_request_context	.\io\async\Request.cpp	/^  bool FLAGS_enable_request_context = true;$/;"	m	namespace:folly	file:
folly::FOLLY_ASSUME_RELOCATABLE	.\test\TraitsTest.cpp	/^  template <> FOLLY_ASSUME_RELOCATABLE(T2);$/;"	p	namespace:folly	file:	signature:(T2)
folly::File	.\File.h	/^class File {$/;"	c	namespace:folly
folly::File::File	.\File.cpp	/^File::File()$/;"	f	class:folly::File	signature:()
folly::File::File	.\File.cpp	/^File::File(File&& other)$/;"	f	class:folly::File	signature:(File&& other)
folly::File::File	.\File.cpp	/^File::File(const char* name, int flags, mode_t mode)$/;"	f	class:folly::File	signature:(const char* name, int flags, mode_t mode)
folly::File::File	.\File.cpp	/^File::File(int fd, bool ownsFd)$/;"	f	class:folly::File	signature:(int fd, bool ownsFd)
folly::File::File	.\File.h	/^  File();$/;"	p	class:folly::File	access:public	signature:()
folly::File::File	.\File.h	/^  File(File&&);$/;"	p	class:folly::File	access:public	signature:(File&&)
folly::File::File	.\File.h	/^  File(const File&) = delete;$/;"	p	class:folly::File	access:private	signature:(const File&)
folly::File::File	.\File.h	/^  explicit File(const char* name, int flags = O_RDONLY, mode_t mode = 0666);$/;"	p	class:folly::File	access:public	signature:(const char* name, int flags = O_RDONLY, mode_t mode = 0666)
folly::File::File	.\File.h	/^  explicit File(int fd, bool ownsFd = false);$/;"	p	class:folly::File	access:public	signature:(int fd, bool ownsFd = false)
folly::File::close	.\File.cpp	/^void File::close() {$/;"	f	class:folly::File	signature:()
folly::File::close	.\File.h	/^  void close();$/;"	p	class:folly::File	access:public	signature:()
folly::File::closeNoThrow	.\File.cpp	/^bool File::closeNoThrow() {$/;"	f	class:folly::File	signature:()
folly::File::closeNoThrow	.\File.h	/^  bool closeNoThrow();$/;"	p	class:folly::File	access:public	signature:()
folly::File::doLock	.\File.cpp	/^void File::doLock(int op) {$/;"	f	class:folly::File	signature:(int op)
folly::File::doLock	.\File.h	/^  void doLock(int op);$/;"	p	class:folly::File	access:private	signature:(int op)
folly::File::doTryLock	.\File.cpp	/^bool File::doTryLock(int op) {$/;"	f	class:folly::File	signature:(int op)
folly::File::doTryLock	.\File.h	/^  bool doTryLock(int op);$/;"	p	class:folly::File	access:private	signature:(int op)
folly::File::dup	.\File.cpp	/^File File::dup() const {$/;"	f	class:folly::File	signature:() const
folly::File::dup	.\File.h	/^  File dup() const;$/;"	p	class:folly::File	access:public	signature:() const
folly::File::fd	.\File.h	/^  int fd() const { return fd_; }$/;"	f	class:folly::File	access:public	signature:() const
folly::File::fd_	.\File.h	/^  int fd_;$/;"	m	class:folly::File	access:private
folly::File::lock	.\File.cpp	/^void File::lock() { doLock(LOCK_EX); }$/;"	f	class:folly::File	signature:()
folly::File::lock	.\File.h	/^  void lock();$/;"	p	class:folly::File	access:public	signature:()
folly::File::lock_shared	.\File.cpp	/^void File::lock_shared() { doLock(LOCK_SH); }$/;"	f	class:folly::File	signature:()
folly::File::lock_shared	.\File.h	/^  void lock_shared();$/;"	p	class:folly::File	access:public	signature:()
folly::File::operator =	.\File.cpp	/^File& File::operator=(File&& other) {$/;"	f	class:folly::File	signature:(File&& other)
folly::File::operator =	.\File.h	/^  File& operator=(File&&);$/;"	p	class:folly::File	access:public	signature:(File&&)
folly::File::operator =	.\File.h	/^  File& operator=(const File&) = delete;$/;"	p	class:folly::File	access:private	signature:(const File&)
folly::File::operator bool	.\File.h	/^  explicit operator bool() const {$/;"	f	class:folly::File	access:public	signature:() const
folly::File::ownsFd_	.\File.h	/^  bool ownsFd_;$/;"	m	class:folly::File	access:private
folly::File::release	.\File.cpp	/^int File::release() {$/;"	f	class:folly::File	signature:()
folly::File::release	.\File.h	/^  int release();$/;"	p	class:folly::File	access:public	signature:()
folly::File::swap	.\File.cpp	/^void File::swap(File& other) {$/;"	f	class:folly::File	signature:(File& other)
folly::File::swap	.\File.h	/^  void swap(File& other);$/;"	p	class:folly::File	access:public	signature:(File& other)
folly::File::temporary	.\File.cpp	/^\/* static *\/ File File::temporary() {$/;"	f	class:folly::File	signature:()
folly::File::temporary	.\File.h	/^  static File temporary();$/;"	p	class:folly::File	access:public	signature:()
folly::File::try_lock	.\File.cpp	/^bool File::try_lock() { return doTryLock(LOCK_EX); }$/;"	f	class:folly::File	signature:()
folly::File::try_lock	.\File.h	/^  bool try_lock();$/;"	p	class:folly::File	access:public	signature:()
folly::File::try_lock_shared	.\File.cpp	/^bool File::try_lock_shared() { return doTryLock(LOCK_SH); }$/;"	f	class:folly::File	signature:()
folly::File::try_lock_shared	.\File.h	/^  bool try_lock_shared();$/;"	p	class:folly::File	access:public	signature:()
folly::File::unlock	.\File.cpp	/^void File::unlock() {$/;"	f	class:folly::File	signature:()
folly::File::unlock	.\File.h	/^  void unlock();$/;"	p	class:folly::File	access:public	signature:()
folly::File::unlock_shared	.\File.cpp	/^void File::unlock_shared() { unlock(); }$/;"	f	class:folly::File	signature:()
folly::File::unlock_shared	.\File.h	/^  void unlock_shared();$/;"	p	class:folly::File	access:public	signature:()
folly::File::~File	.\File.cpp	/^File::~File() {$/;"	f	class:folly::File	signature:()
folly::File::~File	.\File.h	/^  ~File();$/;"	p	class:folly::File	access:public	signature:()
folly::Fingerprint	.\Fingerprint.h	/^class Fingerprint {$/;"	c	namespace:folly
folly::Fingerprint::Fingerprint	.\Fingerprint.h	/^  Fingerprint() {$/;"	f	class:folly::Fingerprint	access:public	signature:()
folly::Fingerprint::fp_	.\Fingerprint.h	/^  uint64_t fp_[1 + (BITS-1)\/64];$/;"	m	class:folly::Fingerprint	access:private
folly::Fingerprint::shlor32	.\Fingerprint.h	/^  uint32_t shlor32(uint32_t v);$/;"	p	class:folly::Fingerprint	access:private	signature:(uint32_t v)
folly::Fingerprint::shlor32	.\Fingerprint.h	/^inline uint32_t Fingerprint<128>::shlor32(uint32_t v) {$/;"	f	class:folly::Fingerprint	signature:(uint32_t v)
folly::Fingerprint::shlor32	.\Fingerprint.h	/^inline uint32_t Fingerprint<64>::shlor32(uint32_t v) {$/;"	f	class:folly::Fingerprint	signature:(uint32_t v)
folly::Fingerprint::shlor32	.\Fingerprint.h	/^inline uint32_t Fingerprint<96>::shlor32(uint32_t v) {$/;"	f	class:folly::Fingerprint	signature:(uint32_t v)
folly::Fingerprint::shlor64	.\Fingerprint.h	/^  uint64_t shlor64(uint64_t v);$/;"	p	class:folly::Fingerprint	access:private	signature:(uint64_t v)
folly::Fingerprint::shlor64	.\Fingerprint.h	/^inline uint64_t Fingerprint<128>::shlor64(uint64_t v) {$/;"	f	class:folly::Fingerprint	signature:(uint64_t v)
folly::Fingerprint::shlor64	.\Fingerprint.h	/^inline uint64_t Fingerprint<64>::shlor64(uint64_t v) {$/;"	f	class:folly::Fingerprint	signature:(uint64_t v)
folly::Fingerprint::shlor64	.\Fingerprint.h	/^inline uint64_t Fingerprint<96>::shlor64(uint64_t v) {$/;"	f	class:folly::Fingerprint	signature:(uint64_t v)
folly::Fingerprint::shlor8	.\Fingerprint.h	/^  uint8_t  shlor8(uint8_t v);$/;"	p	class:folly::Fingerprint	access:private	signature:(uint8_t v)
folly::Fingerprint::shlor8	.\Fingerprint.h	/^inline uint8_t Fingerprint<128>::shlor8(uint8_t v) {$/;"	f	class:folly::Fingerprint	signature:(uint8_t v)
folly::Fingerprint::shlor8	.\Fingerprint.h	/^inline uint8_t Fingerprint<64>::shlor8(uint8_t v) {$/;"	f	class:folly::Fingerprint	signature:(uint8_t v)
folly::Fingerprint::shlor8	.\Fingerprint.h	/^inline uint8_t Fingerprint<96>::shlor8(uint8_t v) {$/;"	f	class:folly::Fingerprint	signature:(uint8_t v)
folly::Fingerprint::size	.\Fingerprint.h	/^  static int size() {$/;"	f	class:folly::Fingerprint	access:public	signature:()
folly::Fingerprint::update	.\Fingerprint.h	/^  Fingerprint& update(StringPiece str) {$/;"	f	class:folly::Fingerprint	access:public	signature:(StringPiece str)
folly::Fingerprint::update32	.\Fingerprint.h	/^  Fingerprint& update32(uint32_t v) {$/;"	f	class:folly::Fingerprint	access:public	signature:(uint32_t v)
folly::Fingerprint::update64	.\Fingerprint.h	/^  Fingerprint& update64(uint64_t v) {$/;"	f	class:folly::Fingerprint	access:public	signature:(uint64_t v)
folly::Fingerprint::update8	.\Fingerprint.h	/^  Fingerprint& update8(uint8_t v) {$/;"	f	class:folly::Fingerprint	access:public	signature:(uint8_t v)
folly::Fingerprint::write	.\Fingerprint.h	/^  void write(uint64_t* out) const {$/;"	f	class:folly::Fingerprint	access:public	signature:(uint64_t* out) const
folly::Fingerprint::xortab	.\Fingerprint.h	/^  void xortab(const uint64_t* tab) {$/;"	f	class:folly::Fingerprint	access:private	signature:(const uint64_t* tab)
folly::FormatArg	.\FormatArg.h	/^struct FormatArg {$/;"	s	namespace:folly
folly::FormatArg::Align	.\FormatArg.h	/^  enum class Align : uint8_t {$/;"	c	struct:folly::FormatArg	inherits:uint8_t	access:public
folly::FormatArg::Align::CENTER	.\FormatArg.h	/^    CENTER,$/;"	m	class:folly::FormatArg::Align	access:private
folly::FormatArg::Align::DEFAULT	.\FormatArg.h	/^    DEFAULT,$/;"	m	class:folly::FormatArg::Align	access:private
folly::FormatArg::Align::LEFT	.\FormatArg.h	/^    LEFT,$/;"	m	class:folly::FormatArg::Align	access:private
folly::FormatArg::Align::PAD_AFTER_SIGN	.\FormatArg.h	/^    PAD_AFTER_SIGN,$/;"	m	class:folly::FormatArg::Align	access:private
folly::FormatArg::Align::RIGHT	.\FormatArg.h	/^    RIGHT,$/;"	m	class:folly::FormatArg::Align	access:private
folly::FormatArg::FormatArg	.\FormatArg.h	/^  explicit FormatArg(StringPiece sp)$/;"	f	struct:folly::FormatArg	access:public	signature:(StringPiece sp)
folly::FormatArg::NextKeyMode	.\FormatArg.h	/^  enum class NextKeyMode {$/;"	c	struct:folly::FormatArg	access:private
folly::FormatArg::NextKeyMode::INT	.\FormatArg.h	/^    INT,$/;"	m	class:folly::FormatArg::NextKeyMode	access:private
folly::FormatArg::NextKeyMode::NONE	.\FormatArg.h	/^    NONE,$/;"	m	class:folly::FormatArg::NextKeyMode	access:private
folly::FormatArg::NextKeyMode::STRING	.\FormatArg.h	/^    STRING,$/;"	m	class:folly::FormatArg::NextKeyMode	access:private
folly::FormatArg::Sign	.\FormatArg.h	/^  enum class Sign : uint8_t {$/;"	c	struct:folly::FormatArg	inherits:uint8_t	access:public
folly::FormatArg::Sign::DEFAULT	.\FormatArg.h	/^    DEFAULT,$/;"	m	class:folly::FormatArg::Sign	access:private
folly::FormatArg::Sign::MINUS	.\FormatArg.h	/^    MINUS,$/;"	m	class:folly::FormatArg::Sign	access:private
folly::FormatArg::Sign::PLUS_OR_MINUS	.\FormatArg.h	/^    PLUS_OR_MINUS,$/;"	m	class:folly::FormatArg::Sign	access:private
folly::FormatArg::Sign::SPACE_OR_MINUS	.\FormatArg.h	/^    SPACE_OR_MINUS,$/;"	m	class:folly::FormatArg::Sign	access:private
folly::FormatArg::Type	.\FormatArg.h	/^  enum class Type {$/;"	c	struct:folly::FormatArg	access:public
folly::FormatArg::Type::FLOAT	.\FormatArg.h	/^    FLOAT,$/;"	m	class:folly::FormatArg::Type	access:private
folly::FormatArg::Type::INTEGER	.\FormatArg.h	/^    INTEGER,$/;"	m	class:folly::FormatArg::Type	access:private
folly::FormatArg::align	.\FormatArg.h	/^  Align align;$/;"	m	struct:folly::FormatArg	access:public
folly::FormatArg::basePrefix	.\FormatArg.h	/^  bool basePrefix;$/;"	m	struct:folly::FormatArg	access:public
folly::FormatArg::doSplitKey	.\FormatArg.h	/^  StringPiece doSplitKey();$/;"	p	struct:folly::FormatArg	access:private	signature:()
folly::FormatArg::doSplitKey	.\FormatArg.h	/^inline StringPiece FormatArg::doSplitKey() {$/;"	f	class:folly::FormatArg	signature:()
folly::FormatArg::enforce	.\FormatArg.h	/^  void enforce(bool v, Args&&... args) const {$/;"	f	struct:folly::FormatArg	access:public	signature:(bool v, Args&&... args) const
folly::FormatArg::error	.\FormatArg.h	/^  FOLLY_NORETURN void error(Args&&... args) const;$/;"	p	struct:folly::FormatArg	access:public	signature:(Args&&.... args) const
folly::FormatArg::error	.\FormatArg.h	/^inline void FormatArg::error(Args&&... args) const {$/;"	f	class:folly::FormatArg	signature:(Args&&.... args) const
folly::FormatArg::errorStr	.\FormatArg.h	/^  std::string errorStr(Args&&... args) const;$/;"	p	struct:folly::FormatArg	access:public	signature:(Args&&.... args) const
folly::FormatArg::errorStr	.\FormatArg.h	/^inline std::string FormatArg::errorStr(Args&&... args) const {$/;"	f	class:folly::FormatArg	signature:(Args&&.... args) const
folly::FormatArg::fill	.\FormatArg.h	/^  char fill;$/;"	m	struct:folly::FormatArg	access:public
folly::FormatArg::fullArgString	.\FormatArg.h	/^  StringPiece fullArgString;$/;"	m	struct:folly::FormatArg	access:public
folly::FormatArg::initSlow	.\Format.cpp	/^void FormatArg::initSlow() {$/;"	f	class:folly::FormatArg	signature:()
folly::FormatArg::initSlow	.\FormatArg.h	/^  void initSlow();$/;"	p	struct:folly::FormatArg	access:private	signature:()
folly::FormatArg::kDefaultFill	.\FormatArg.h	/^  static constexpr char kDefaultFill = '\\0';$/;"	m	struct:folly::FormatArg	access:public
folly::FormatArg::kDefaultPrecision	.\FormatArg.h	/^  static constexpr int kDefaultPrecision = -1;$/;"	m	struct:folly::FormatArg	access:public
folly::FormatArg::kDefaultPresentation	.\FormatArg.h	/^  static constexpr char kDefaultPresentation = '\\0';$/;"	m	struct:folly::FormatArg	access:public
folly::FormatArg::kDefaultWidth	.\FormatArg.h	/^  static constexpr int kDefaultWidth = -1;$/;"	m	struct:folly::FormatArg	access:public
folly::FormatArg::keyEmpty	.\FormatArg.h	/^  bool keyEmpty() const {$/;"	f	struct:folly::FormatArg	access:public	signature:() const
folly::FormatArg::key_	.\FormatArg.h	/^  StringPiece key_;$/;"	m	struct:folly::FormatArg	access:private
folly::FormatArg::nextIntKey_	.\FormatArg.h	/^  int nextIntKey_;$/;"	m	struct:folly::FormatArg	access:private
folly::FormatArg::nextKeyMode_	.\FormatArg.h	/^  NextKeyMode nextKeyMode_;$/;"	m	struct:folly::FormatArg	access:private
folly::FormatArg::nextKey_	.\FormatArg.h	/^  StringPiece nextKey_;$/;"	m	struct:folly::FormatArg	access:private
folly::FormatArg::precision	.\FormatArg.h	/^  int precision;$/;"	m	struct:folly::FormatArg	access:public
folly::FormatArg::presentation	.\FormatArg.h	/^  char presentation;$/;"	m	struct:folly::FormatArg	access:public
folly::FormatArg::setNextIntKey	.\FormatArg.h	/^  void setNextIntKey(int val) {$/;"	f	struct:folly::FormatArg	access:public	signature:(int val)
folly::FormatArg::setNextKey	.\FormatArg.h	/^  void setNextKey(StringPiece val) {$/;"	f	struct:folly::FormatArg	access:public	signature:(StringPiece val)
folly::FormatArg::sign	.\FormatArg.h	/^  Sign sign;$/;"	m	struct:folly::FormatArg	access:public
folly::FormatArg::splitIntKey	.\FormatArg.h	/^  int splitIntKey();$/;"	p	struct:folly::FormatArg	access:public	signature:()
folly::FormatArg::splitIntKey	.\FormatArg.h	/^inline int FormatArg::splitIntKey() {$/;"	f	class:folly::FormatArg	signature:()
folly::FormatArg::splitKey	.\FormatArg.h	/^  StringPiece splitKey();$/;"	p	struct:folly::FormatArg	access:public	signature:()
folly::FormatArg::splitKey	.\FormatArg.h	/^inline StringPiece FormatArg::splitKey() {$/;"	f	class:folly::FormatArg	signature:()
folly::FormatArg::thousandsSeparator	.\FormatArg.h	/^  bool thousandsSeparator;$/;"	m	struct:folly::FormatArg	access:public
folly::FormatArg::trailingDot	.\FormatArg.h	/^  bool trailingDot;$/;"	m	struct:folly::FormatArg	access:public
folly::FormatArg::validate	.\Format.cpp	/^void FormatArg::validate(Type type) const {$/;"	f	class:folly::FormatArg	signature:(Type type) const
folly::FormatArg::validate	.\FormatArg.h	/^  void validate(Type type) const;$/;"	p	struct:folly::FormatArg	access:public	signature:(Type type) const
folly::FormatArg::width	.\FormatArg.h	/^  int width;$/;"	m	struct:folly::FormatArg	access:public
folly::FormatValue	.\Format-inl.h	/^class FormatValue<$/;"	c	namespace:folly
folly::FormatValue	.\Format-inl.h	/^class FormatValue<bool> {$/;"	c	namespace:folly
folly::FormatValue	.\Format-inl.h	/^class FormatValue<double> {$/;"	c	namespace:folly
folly::FormatValue	.\Format-inl.h	/^class FormatValue<float> {$/;"	c	namespace:folly
folly::FormatValue	.\Format-inl.h	/^class FormatValue<std::nullptr_t> {$/;"	c	namespace:folly
folly::FormatValue	.\Format.h	/^template <class T, class Enable=void> class FormatValue;$/;"	x
folly::FormatValue	.\dynamic-inl.h	/^class FormatValue<detail::DefaultValueWrapper<dynamic, V>> {$/;"	c	namespace:folly
folly::FormatValue	.\dynamic-inl.h	/^class FormatValue<dynamic> {$/;"	c	namespace:folly
folly::FormatValue	.\test\FormatTest.cpp	/^template <> class FormatValue<KeyValue> {$/;"	c	namespace:folly	file:
folly::FormatValue::FormatValue	.\Format-inl.h	/^  explicit FormatValue(StringPiece val) : val_(val) { }$/;"	f	class:folly::FormatValue	access:public	signature:(StringPiece val)
folly::FormatValue::FormatValue	.\Format-inl.h	/^  explicit FormatValue(T val) : val_(val) { }$/;"	f	class:folly::FormatValue	access:public	signature:(T val)
folly::FormatValue::FormatValue	.\Format-inl.h	/^  explicit FormatValue(T* val) : val_(val) { }$/;"	f	class:folly::FormatValue	access:public	signature:(T* val)
folly::FormatValue::FormatValue	.\Format-inl.h	/^  explicit FormatValue(bool val) : val_(val) { }$/;"	f	class:folly::FormatValue	access:public	signature:(bool val)
folly::FormatValue::FormatValue	.\Format-inl.h	/^  explicit FormatValue(double val) : val_(val) { }$/;"	f	class:folly::FormatValue	access:public	signature:(double val)
folly::FormatValue::FormatValue	.\Format-inl.h	/^  explicit FormatValue(float val) : val_(val) { }$/;"	f	class:folly::FormatValue	access:public	signature:(float val)
folly::FormatValue::FormatValue	.\Format-inl.h	/^  explicit FormatValue(std::nullptr_t) { }$/;"	f	class:folly::FormatValue	access:public	signature:(std::nullptr_t)
folly::FormatValue::FormatValue	.\dynamic-inl.h	/^  explicit FormatValue($/;"	f	class:folly::FormatValue	access:public	signature:( const detail::DefaultValueWrapper<dynamic, V>& val)
folly::FormatValue::FormatValue	.\dynamic-inl.h	/^  explicit FormatValue(const dynamic& val) : val_(val) { }$/;"	f	class:folly::FormatValue	access:public	signature:(const dynamic& val)
folly::FormatValue::FormatValue	.\test\FormatTest.cpp	/^  explicit FormatValue(const KeyValue& kv) : kv_(kv) { }$/;"	f	class:folly::FormatValue	access:public	signature:(const KeyValue& kv)
folly::FormatValue::doFormat	.\Format-inl.h	/^  void doFormat(FormatArg& arg, FormatCallback& cb) const {$/;"	f	class:folly::FormatValue	access:public	signature:(FormatArg& arg, FormatCallback& cb) const
folly::FormatValue::format	.\Format-inl.h	/^  void format(FormatArg& arg, FormatCallback& cb) const {$/;"	f	class:folly::FormatValue	access:public	signature:(FormatArg& arg, FormatCallback& cb) const
folly::FormatValue::format	.\dynamic-inl.h	/^  void format(FormatArg& arg, FormatCallback& cb) const {$/;"	f	class:folly::FormatValue	access:public	signature:(FormatArg& arg, FormatCallback& cb) const
folly::FormatValue::format	.\test\FormatTest.cpp	/^  void format(FormatArg& arg, FormatCallback& cb) const {$/;"	f	class:folly::FormatValue	access:public	signature:(FormatArg& arg, FormatCallback& cb) const
folly::FormatValue::kv_	.\test\FormatTest.cpp	/^  const KeyValue& kv_;$/;"	m	class:folly::FormatValue	file:	access:private
folly::FormatValue::val_	.\Format-inl.h	/^  StringPiece val_;$/;"	m	class:folly::FormatValue	access:private
folly::FormatValue::val_	.\Format-inl.h	/^  T val_;$/;"	m	class:folly::FormatValue	access:private
folly::FormatValue::val_	.\Format-inl.h	/^  T* val_;$/;"	m	class:folly::FormatValue	access:private
folly::FormatValue::val_	.\Format-inl.h	/^  bool val_;$/;"	m	class:folly::FormatValue	access:private
folly::FormatValue::val_	.\Format-inl.h	/^  double val_;$/;"	m	class:folly::FormatValue	access:private
folly::FormatValue::val_	.\Format-inl.h	/^  float val_;$/;"	m	class:folly::FormatValue	access:private
folly::FormatValue::val_	.\dynamic-inl.h	/^  const detail::DefaultValueWrapper<dynamic, V>& val_;$/;"	m	class:folly::FormatValue	access:private
folly::FormatValue::val_	.\dynamic-inl.h	/^  const dynamic& val_;$/;"	m	class:folly::FormatValue	access:private
folly::Formatter	.\Format.h	/^template <bool containerMode, class... Args> class Formatter;$/;"	x
folly::GroupVarint	.\GroupVarint.h	/^class GroupVarint;$/;"	x
folly::GroupVarint	.\GroupVarint.h	/^class GroupVarint<uint32_t> : public detail::GroupVarintBase<uint32_t> {$/;"	c	namespace:folly	inherits:detail::GroupVarintBase
folly::GroupVarint	.\GroupVarint.h	/^class GroupVarint<uint64_t> : public detail::GroupVarintBase<uint64_t> {$/;"	c	namespace:folly	inherits:detail::GroupVarintBase
folly::GroupVarint	.\detail\GroupVarintDetail.h	/^class GroupVarint;$/;"	x
folly::GroupVarint32	.\GroupVarint.h	/^typedef GroupVarint<uint32_t> GroupVarint32;$/;"	t	namespace:folly
folly::GroupVarint32::kMask	.\GroupVarint.cpp	/^const uint32_t GroupVarint32::kMask[] = {$/;"	m	class:folly::GroupVarint32	file:
folly::GroupVarint32Decoder	.\GroupVarint.h	/^typedef GroupVarintDecoder<uint32_t> GroupVarint32Decoder;$/;"	t	namespace:folly
folly::GroupVarint64	.\GroupVarint.h	/^typedef GroupVarint<uint64_t> GroupVarint64;$/;"	t	namespace:folly
folly::GroupVarint64::kMask	.\GroupVarint.cpp	/^const uint64_t GroupVarint64::kMask[] = {$/;"	m	class:folly::GroupVarint64	file:
folly::GroupVarint64Decoder	.\GroupVarint.h	/^typedef GroupVarintDecoder<uint64_t> GroupVarint64Decoder;$/;"	t	namespace:folly
folly::GroupVarint::b0key	.\GroupVarint.h	/^  static size_t b0key(size_t x) { return x & 3; }$/;"	f	class:folly::GroupVarint	access:private	signature:(size_t x)
folly::GroupVarint::b0key	.\GroupVarint.h	/^  static uint8_t b0key(uint16_t x) { return x & 7; }$/;"	f	class:folly::GroupVarint	access:private	signature:(uint16_t x)
folly::GroupVarint::b1key	.\GroupVarint.h	/^  static size_t b1key(size_t x) { return (x >> 2) & 3; }$/;"	f	class:folly::GroupVarint	access:private	signature:(size_t x)
folly::GroupVarint::b1key	.\GroupVarint.h	/^  static uint8_t b1key(uint16_t x) { return (x >> 3) & 7; }$/;"	f	class:folly::GroupVarint	access:private	signature:(uint16_t x)
folly::GroupVarint::b2key	.\GroupVarint.h	/^  static size_t b2key(size_t x) { return (x >> 4) & 3; }$/;"	f	class:folly::GroupVarint	access:private	signature:(size_t x)
folly::GroupVarint::b2key	.\GroupVarint.h	/^  static uint8_t b2key(uint16_t x) { return (x >> 6) & 7; }$/;"	f	class:folly::GroupVarint	access:private	signature:(uint16_t x)
folly::GroupVarint::b3key	.\GroupVarint.h	/^  static size_t b3key(size_t x) { return (x >> 6) & 3; }$/;"	f	class:folly::GroupVarint	access:private	signature:(size_t x)
folly::GroupVarint::b3key	.\GroupVarint.h	/^  static uint8_t b3key(uint16_t x) { return (x >> 9) & 7; }$/;"	f	class:folly::GroupVarint	access:private	signature:(uint16_t x)
folly::GroupVarint::b4key	.\GroupVarint.h	/^  static uint8_t b4key(uint16_t x) { return (x >> 12) & 7; }$/;"	f	class:folly::GroupVarint	access:private	signature:(uint16_t x)
folly::GroupVarint::decode	.\GroupVarint.h	/^  static const char* decode(const char* p, uint32_t* a, uint32_t* b,$/;"	f	class:folly::GroupVarint	access:public	signature:(const char* p, uint32_t* a, uint32_t* b, uint32_t* c, uint32_t* d)
folly::GroupVarint::decode	.\GroupVarint.h	/^  static const char* decode(const char* p, uint32_t* dest) {$/;"	f	class:folly::GroupVarint	access:public	signature:(const char* p, uint32_t* dest)
folly::GroupVarint::decode	.\GroupVarint.h	/^  static const char* decode(const char* p, uint64_t* a, uint64_t* b,$/;"	f	class:folly::GroupVarint	access:public	signature:(const char* p, uint64_t* a, uint64_t* b, uint64_t* c, uint64_t* d, uint64_t* e)
folly::GroupVarint::decode	.\GroupVarint.h	/^  static const char* decode(const char* p, uint64_t* dest) {$/;"	f	class:folly::GroupVarint	access:public	signature:(const char* p, uint64_t* dest)
folly::GroupVarint::decode_simple	.\GroupVarint.h	/^  static const char* decode_simple(const char* p, uint32_t* a, uint32_t* b,$/;"	f	class:folly::GroupVarint	access:public	signature:(const char* p, uint32_t* a, uint32_t* b, uint32_t* c, uint32_t* d)
folly::GroupVarint::decode_simple	.\GroupVarint.h	/^  static const char* decode_simple(const char* p, uint32_t* dest) {$/;"	f	class:folly::GroupVarint	access:public	signature:(const char* p, uint32_t* dest)
folly::GroupVarint::encode	.\GroupVarint.h	/^  static char* encode(char* p, const uint32_t* src) {$/;"	f	class:folly::GroupVarint	access:public	signature:(char* p, const uint32_t* src)
folly::GroupVarint::encode	.\GroupVarint.h	/^  static char* encode(char* p, const uint64_t* src) {$/;"	f	class:folly::GroupVarint	access:public	signature:(char* p, const uint64_t* src)
folly::GroupVarint::encode	.\GroupVarint.h	/^  static char* encode(char* p, uint32_t a, uint32_t b, uint32_t c, uint32_t d) {$/;"	f	class:folly::GroupVarint	access:public	signature:(char* p, uint32_t a, uint32_t b, uint32_t c, uint32_t d)
folly::GroupVarint::encode	.\GroupVarint.h	/^  static char* encode(char* p, uint64_t a, uint64_t b, uint64_t c,$/;"	f	class:folly::GroupVarint	access:public	signature:(char* p, uint64_t a, uint64_t b, uint64_t c, uint64_t d, uint64_t e)
folly::GroupVarint::encodedSize	.\GroupVarint.h	/^  static size_t encodedSize(const char* p) {$/;"	f	class:folly::GroupVarint	access:public	signature:(const char* p)
folly::GroupVarint::kHeaderBytes	.\GroupVarint.h	/^  enum { kHeaderBytes = 2 };$/;"	e	enum:folly::GroupVarint::__anon59
folly::GroupVarint::kMask	.\GroupVarint.h	/^  static const uint32_t kMask[];$/;"	m	class:folly::GroupVarint	access:private
folly::GroupVarint::kMask	.\GroupVarint.h	/^  static const uint64_t kMask[];$/;"	m	class:folly::GroupVarint	access:private
folly::GroupVarint::key	.\GroupVarint.h	/^  static uint8_t key(uint32_t x) {$/;"	f	class:folly::GroupVarint	access:private	signature:(uint32_t x)
folly::GroupVarint::key	.\GroupVarint.h	/^  static uint8_t key(uint64_t x) {$/;"	f	class:folly::GroupVarint	access:private	signature:(uint64_t x)
folly::GroupVarint::partialCount	.\GroupVarint.h	/^  static size_t partialCount(const char* p, size_t size) {$/;"	f	class:folly::GroupVarint	access:public	signature:(const char* p, size_t size)
folly::GroupVarint::partialSize	.\GroupVarint.h	/^  static size_t partialSize(const type* p, size_t count) {$/;"	f	class:folly::GroupVarint	access:public	signature:(const type* p, size_t count)
folly::GroupVarint::size	.\GroupVarint.h	/^  static size_t size(const uint32_t* p) {$/;"	f	class:folly::GroupVarint	access:public	signature:(const uint32_t* p)
folly::GroupVarint::size	.\GroupVarint.h	/^  static size_t size(const uint64_t* p) {$/;"	f	class:folly::GroupVarint	access:public	signature:(const uint64_t* p)
folly::GroupVarint::size	.\GroupVarint.h	/^  static size_t size(uint32_t a, uint32_t b, uint32_t c, uint32_t d) {$/;"	f	class:folly::GroupVarint	access:public	signature:(uint32_t a, uint32_t b, uint32_t c, uint32_t d)
folly::GroupVarint::size	.\GroupVarint.h	/^  static size_t size(uint64_t a, uint64_t b, uint64_t c, uint64_t d,$/;"	f	class:folly::GroupVarint	access:public	signature:(uint64_t a, uint64_t b, uint64_t c, uint64_t d, uint64_t e)
folly::GroupVarintDecoder	.\GroupVarint.h	/^class GroupVarintDecoder {$/;"	c	namespace:folly
folly::GroupVarintDecoder::Base	.\GroupVarint.h	/^  typedef GroupVarint<T> Base;$/;"	t	class:folly::GroupVarintDecoder	access:public
folly::GroupVarintDecoder::GroupVarintDecoder	.\GroupVarint.h	/^  GroupVarintDecoder() { }$/;"	f	class:folly::GroupVarintDecoder	access:public	signature:()
folly::GroupVarintDecoder::GroupVarintDecoder	.\GroupVarint.h	/^  explicit GroupVarintDecoder(StringPiece data,$/;"	f	class:folly::GroupVarintDecoder	access:public	signature:(StringPiece data, size_t maxCount = (size_t)-1)
folly::GroupVarintDecoder::buf_	.\GroupVarint.h	/^  type buf_[Base::kGroupSize];$/;"	m	class:folly::GroupVarintDecoder	access:private
folly::GroupVarintDecoder::count_	.\GroupVarint.h	/^  size_t count_;$/;"	m	class:folly::GroupVarintDecoder	access:private
folly::GroupVarintDecoder::end_	.\GroupVarint.h	/^  const char* end_;$/;"	m	class:folly::GroupVarintDecoder	access:private
folly::GroupVarintDecoder::limit_	.\GroupVarint.h	/^  const char* limit_;$/;"	m	class:folly::GroupVarintDecoder	access:private
folly::GroupVarintDecoder::next	.\GroupVarint.h	/^  bool next(type* val) {$/;"	f	class:folly::GroupVarintDecoder	access:public	signature:(type* val)
folly::GroupVarintDecoder::p_	.\GroupVarint.h	/^  const char* p_;$/;"	m	class:folly::GroupVarintDecoder	access:private
folly::GroupVarintDecoder::pos_	.\GroupVarint.h	/^  size_t pos_;$/;"	m	class:folly::GroupVarintDecoder	access:private
folly::GroupVarintDecoder::remaining_	.\GroupVarint.h	/^  size_t remaining_;$/;"	m	class:folly::GroupVarintDecoder	access:private
folly::GroupVarintDecoder::reset	.\GroupVarint.h	/^  void reset(StringPiece data, size_t maxCount = (size_t)-1) {$/;"	f	class:folly::GroupVarintDecoder	access:public	signature:(StringPiece data, size_t maxCount = (size_t)-1)
folly::GroupVarintDecoder::rest	.\GroupVarint.h	/^  StringPiece rest() const {$/;"	f	class:folly::GroupVarintDecoder	access:public	signature:() const
folly::GroupVarintDecoder::rrest_	.\GroupVarint.h	/^  const char* rrest_;$/;"	m	class:folly::GroupVarintDecoder	access:private
folly::GroupVarintDecoder::tmp_	.\GroupVarint.h	/^  char tmp_[2 * Base::kMaxSize];$/;"	m	class:folly::GroupVarintDecoder	access:private
folly::GroupVarintDecoder::type	.\GroupVarint.h	/^  typedef T type;$/;"	t	class:folly::GroupVarintDecoder	access:public
folly::GroupVarintEncoder	.\GroupVarint.h	/^class GroupVarintEncoder {$/;"	c	namespace:folly
folly::GroupVarintEncoder::Base	.\GroupVarint.h	/^  typedef GroupVarint<T> Base;$/;"	t	class:folly::GroupVarintEncoder	access:public
folly::GroupVarintEncoder::GroupVarintEncoder	.\GroupVarint.h	/^  explicit GroupVarintEncoder(Output out)$/;"	f	class:folly::GroupVarintEncoder	access:public	signature:(Output out)
folly::GroupVarintEncoder::add	.\GroupVarint.h	/^  void add(type val) {$/;"	f	class:folly::GroupVarintEncoder	access:public	signature:(type val)
folly::GroupVarintEncoder::buf_	.\GroupVarint.h	/^  type buf_[Base::kGroupSize];$/;"	m	class:folly::GroupVarintEncoder	access:private
folly::GroupVarintEncoder::clear	.\GroupVarint.h	/^  void clear() {$/;"	f	class:folly::GroupVarintEncoder	access:public	signature:()
folly::GroupVarintEncoder::count_	.\GroupVarint.h	/^  size_t count_;$/;"	m	class:folly::GroupVarintEncoder	access:private
folly::GroupVarintEncoder::finish	.\GroupVarint.h	/^  void finish() {$/;"	f	class:folly::GroupVarintEncoder	access:public	signature:()
folly::GroupVarintEncoder::out_	.\GroupVarint.h	/^  Output out_;$/;"	m	class:folly::GroupVarintEncoder	access:private
folly::GroupVarintEncoder::output	.\GroupVarint.h	/^  Output& output() {$/;"	f	class:folly::GroupVarintEncoder	access:public	signature:()
folly::GroupVarintEncoder::output	.\GroupVarint.h	/^  const Output& output() const {$/;"	f	class:folly::GroupVarintEncoder	access:public	signature:() const
folly::GroupVarintEncoder::tmp_	.\GroupVarint.h	/^  char tmp_[Base::kMaxSize];$/;"	m	class:folly::GroupVarintEncoder	access:private
folly::GroupVarintEncoder::type	.\GroupVarint.h	/^  typedef T type;$/;"	t	class:folly::GroupVarintEncoder	access:public
folly::GroupVarintEncoder::~GroupVarintEncoder	.\GroupVarint.h	/^  ~GroupVarintEncoder() {$/;"	f	class:folly::GroupVarintEncoder	access:public	signature:()
folly::HHWheelTimer	.\io\async\HHWheelTimer.h	/^class HHWheelTimer : protected folly::AsyncTimeout,$/;"	c	namespace:folly	inherits:folly::AsyncTimeout,folly::DelayedDestruction
folly::HHWheelTimer::Callback	.\io\async\HHWheelTimer.h	/^  class Callback {$/;"	c	class:folly::HHWheelTimer	access:public
folly::HHWheelTimer::Callback::Callback	.\io\async\HHWheelTimer.h	/^    Callback()$/;"	f	class:folly::HHWheelTimer::Callback	access:public	signature:()
folly::HHWheelTimer::Callback::HHWheelTimer	.\io\async\HHWheelTimer.h	/^    friend class HHWheelTimer;$/;"	x
folly::HHWheelTimer::Callback::List	.\io\async\HHWheelTimer.h	/^      boost::intrusive::constant_time_size<false> > List;$/;"	t	class:folly::HHWheelTimer::Callback	access:private
folly::HHWheelTimer::Callback::ListHook	.\io\async\HHWheelTimer.h	/^      boost::intrusive::link_mode<boost::intrusive::auto_unlink> > ListHook;$/;"	t	class:folly::HHWheelTimer::Callback	access:private
folly::HHWheelTimer::Callback::cancelTimeout	.\io\async\HHWheelTimer.h	/^    void cancelTimeout() {$/;"	f	class:folly::HHWheelTimer::Callback	access:public	signature:()
folly::HHWheelTimer::Callback::cancelTimeoutImpl	.\io\async\HHWheelTimer.cpp	/^void HHWheelTimer::Callback::cancelTimeoutImpl() {$/;"	f	class:folly::HHWheelTimer::Callback	signature:()
folly::HHWheelTimer::Callback::cancelTimeoutImpl	.\io\async\HHWheelTimer.h	/^    void cancelTimeoutImpl();$/;"	p	class:folly::HHWheelTimer::Callback	access:private	signature:()
folly::HHWheelTimer::Callback::context_	.\io\async\HHWheelTimer.h	/^    std::shared_ptr<RequestContext> context_;$/;"	m	class:folly::HHWheelTimer::Callback	access:private
folly::HHWheelTimer::Callback::expiration_	.\io\async\HHWheelTimer.h	/^    std::chrono::milliseconds expiration_;$/;"	m	class:folly::HHWheelTimer::Callback	access:private
folly::HHWheelTimer::Callback::getTimeRemaining	.\io\async\HHWheelTimer.h	/^    std::chrono::milliseconds getTimeRemaining($/;"	f	class:folly::HHWheelTimer::Callback	access:private	signature:( std::chrono::milliseconds now) const
folly::HHWheelTimer::Callback::hook_	.\io\async\HHWheelTimer.h	/^    ListHook hook_;$/;"	m	class:folly::HHWheelTimer::Callback	access:private
folly::HHWheelTimer::Callback::isScheduled	.\io\async\HHWheelTimer.h	/^    bool isScheduled() const {$/;"	f	class:folly::HHWheelTimer::Callback	access:public	signature:() const
folly::HHWheelTimer::Callback::noexcept	.\io\async\HHWheelTimer.h	/^    virtual void timeoutExpired() noexcept = 0;$/;"	m	class:folly::HHWheelTimer::Callback	access:public
folly::HHWheelTimer::Callback::setScheduled	.\io\async\HHWheelTimer.cpp	/^void HHWheelTimer::Callback::setScheduled(HHWheelTimer* wheel,$/;"	f	class:folly::HHWheelTimer::Callback	signature:(HHWheelTimer* wheel, std::chrono::milliseconds timeout)
folly::HHWheelTimer::Callback::setScheduled	.\io\async\HHWheelTimer.h	/^    void setScheduled(HHWheelTimer* wheel,$/;"	p	class:folly::HHWheelTimer::Callback	access:private	signature:(HHWheelTimer* wheel, std::chrono::milliseconds)
folly::HHWheelTimer::Callback::wheel_	.\io\async\HHWheelTimer.h	/^    HHWheelTimer* wheel_;$/;"	m	class:folly::HHWheelTimer::Callback	access:private
folly::HHWheelTimer::Callback::~Callback	.\io\async\HHWheelTimer.cpp	/^HHWheelTimer::Callback::~Callback() {$/;"	f	class:folly::HHWheelTimer::Callback	signature:()
folly::HHWheelTimer::Callback::~Callback	.\io\async\HHWheelTimer.h	/^    virtual ~Callback();$/;"	p	class:folly::HHWheelTimer::Callback	access:public	signature:()
folly::HHWheelTimer::CallbackList	.\io\async\HHWheelTimer.h	/^  typedef Callback::List CallbackList;$/;"	t	class:folly::HHWheelTimer	access:private
folly::HHWheelTimer::DEFAULT_CATCHUP_EVERY_N	.\io\async\HHWheelTimer.h	/^  static constexpr uint32_t DEFAULT_CATCHUP_EVERY_N = 100;$/;"	m	class:folly::HHWheelTimer	access:private
folly::HHWheelTimer::DEFAULT_TICK_INTERVAL	.\io\async\HHWheelTimer.cpp	/^int HHWheelTimer::DEFAULT_TICK_INTERVAL = 10;$/;"	m	class:folly::HHWheelTimer	file:
folly::HHWheelTimer::DEFAULT_TICK_INTERVAL	.\io\async\HHWheelTimer.h	/^  static int DEFAULT_TICK_INTERVAL;$/;"	m	class:folly::HHWheelTimer	access:public
folly::HHWheelTimer::HHWheelTimer	.\io\async\HHWheelTimer.cpp	/^HHWheelTimer::HHWheelTimer(folly::EventBase* eventBase,$/;"	f	class:folly::HHWheelTimer	signature:(folly::EventBase* eventBase, std::chrono::milliseconds intervalMS)
folly::HHWheelTimer::HHWheelTimer	.\io\async\HHWheelTimer.h	/^  HHWheelTimer(HHWheelTimer const &) = delete;$/;"	p	class:folly::HHWheelTimer	access:private	signature:(HHWheelTimer const &)
folly::HHWheelTimer::HHWheelTimer	.\io\async\HHWheelTimer.h	/^  explicit HHWheelTimer(folly::EventBase* eventBase,$/;"	p	class:folly::HHWheelTimer	access:public	signature:(folly::EventBase* eventBase, std::chrono::milliseconds intervalMS = std::chrono::milliseconds(DEFAULT_TICK_INTERVAL))
folly::HHWheelTimer::LARGEST_SLOT	.\io\async\HHWheelTimer.h	/^  static constexpr uint32_t LARGEST_SLOT = 0xffffffffUL;$/;"	m	class:folly::HHWheelTimer	access:private
folly::HHWheelTimer::UniquePtr	.\io\async\HHWheelTimer.h	/^  typedef std::unique_ptr<HHWheelTimer, Destructor> UniquePtr;$/;"	t	class:folly::HHWheelTimer	access:public
folly::HHWheelTimer::WHEEL_BITS	.\io\async\HHWheelTimer.h	/^  static constexpr int WHEEL_BITS = 8;$/;"	m	class:folly::HHWheelTimer	access:private
folly::HHWheelTimer::WHEEL_BUCKETS	.\io\async\HHWheelTimer.h	/^  static constexpr int WHEEL_BUCKETS = 4;$/;"	m	class:folly::HHWheelTimer	access:private
folly::HHWheelTimer::WHEEL_MASK	.\io\async\HHWheelTimer.h	/^  static constexpr unsigned int WHEEL_MASK = (WHEEL_SIZE - 1);$/;"	m	class:folly::HHWheelTimer	access:private
folly::HHWheelTimer::WHEEL_SIZE	.\io\async\HHWheelTimer.h	/^  static constexpr unsigned int WHEEL_SIZE = (1 << WHEEL_BITS);$/;"	m	class:folly::HHWheelTimer	access:private
folly::HHWheelTimer::buckets_	.\io\async\HHWheelTimer.h	/^  CallbackList buckets_[WHEEL_BUCKETS][WHEEL_SIZE];$/;"	m	class:folly::HHWheelTimer	access:private
folly::HHWheelTimer::cascadeTimers	.\io\async\HHWheelTimer.cpp	/^bool HHWheelTimer::cascadeTimers(int bucket, int tick) {$/;"	f	class:folly::HHWheelTimer	signature:(int bucket, int tick)
folly::HHWheelTimer::cascadeTimers	.\io\async\HHWheelTimer.h	/^  bool cascadeTimers(int bucket, int tick);$/;"	p	class:folly::HHWheelTimer	access:private	signature:(int bucket, int tick)
folly::HHWheelTimer::catchupEveryN_	.\io\async\HHWheelTimer.h	/^  uint32_t catchupEveryN_;$/;"	m	class:folly::HHWheelTimer	access:private
folly::HHWheelTimer::count	.\io\async\HHWheelTimer.h	/^  uint64_t count() const {$/;"	f	class:folly::HHWheelTimer	access:public	signature:() const
folly::HHWheelTimer::count_	.\io\async\HHWheelTimer.h	/^  uint64_t count_;$/;"	m	class:folly::HHWheelTimer	access:private
folly::HHWheelTimer::destroy	.\io\async\HHWheelTimer.cpp	/^void HHWheelTimer::destroy() {$/;"	f	class:folly::HHWheelTimer	signature:()
folly::HHWheelTimer::destroy	.\io\async\HHWheelTimer.h	/^  virtual void destroy();$/;"	p	class:folly::HHWheelTimer	access:public	signature:()
folly::HHWheelTimer::expirationsSinceCatchup_	.\io\async\HHWheelTimer.h	/^  uint32_t expirationsSinceCatchup_;$/;"	m	class:folly::HHWheelTimer	access:private
folly::HHWheelTimer::getTickInterval	.\io\async\HHWheelTimer.h	/^  std::chrono::milliseconds getTickInterval() const {$/;"	f	class:folly::HHWheelTimer	access:public	signature:() const
folly::HHWheelTimer::interval_	.\io\async\HHWheelTimer.h	/^  std::chrono::milliseconds interval_;$/;"	m	class:folly::HHWheelTimer	access:private
folly::HHWheelTimer::nextTick_	.\io\async\HHWheelTimer.h	/^  int64_t nextTick_;$/;"	m	class:folly::HHWheelTimer	access:private
folly::HHWheelTimer::noexcept	.\io\async\HHWheelTimer.h	/^  virtual void timeoutExpired() noexcept;$/;"	m	class:folly::HHWheelTimer	access:private
folly::HHWheelTimer::now_	.\io\async\HHWheelTimer.h	/^  std::chrono::milliseconds now_;$/;"	m	class:folly::HHWheelTimer	access:private
folly::HHWheelTimer::operator =	.\io\async\HHWheelTimer.h	/^  HHWheelTimer& operator=(HHWheelTimer const &) = delete;$/;"	p	class:folly::HHWheelTimer	access:private	signature:(HHWheelTimer const &)
folly::HHWheelTimer::scheduleTimeout	.\io\async\HHWheelTimer.cpp	/^void HHWheelTimer::scheduleTimeout(Callback* callback,$/;"	f	class:folly::HHWheelTimer	signature:(Callback* callback, std::chrono::milliseconds timeout)
folly::HHWheelTimer::scheduleTimeout	.\io\async\HHWheelTimer.h	/^  void scheduleTimeout(Callback* callback,$/;"	p	class:folly::HHWheelTimer	access:public	signature:(Callback* callback, std::chrono::milliseconds timeout)
folly::HHWheelTimer::scheduleTimeoutImpl	.\io\async\HHWheelTimer.cpp	/^void HHWheelTimer::scheduleTimeoutImpl(Callback* callback,$/;"	f	class:folly::HHWheelTimer	signature:(Callback* callback, std::chrono::milliseconds timeout)
folly::HHWheelTimer::scheduleTimeoutImpl	.\io\async\HHWheelTimer.h	/^  void scheduleTimeoutImpl(Callback* callback,$/;"	p	class:folly::HHWheelTimer	access:public	signature:(Callback* callback, std::chrono::milliseconds timeout)
folly::HHWheelTimer::setCatchupEveryN	.\io\async\HHWheelTimer.h	/^  void setCatchupEveryN(uint32_t everyN) {$/;"	f	class:folly::HHWheelTimer	access:public	signature:(uint32_t everyN)
folly::HHWheelTimer::timeToWheelTicks	.\io\async\HHWheelTimer.h	/^  uint32_t timeToWheelTicks(std::chrono::milliseconds t) {$/;"	f	class:folly::HHWheelTimer	access:private	signature:(std::chrono::milliseconds t)
folly::HHWheelTimer::~HHWheelTimer	.\io\async\HHWheelTimer.cpp	/^HHWheelTimer::~HHWheelTimer() {$/;"	f	class:folly::HHWheelTimer	signature:()
folly::HHWheelTimer::~HHWheelTimer	.\io\async\HHWheelTimer.h	/^  virtual ~HHWheelTimer();$/;"	p	class:folly::HHWheelTimer	access:protected	signature:()
folly::Histogram	.\stats\Histogram.h	/^class Histogram {$/;"	c	namespace:folly
folly::Histogram	.\stats\Instantiations.cpp	/^template class Histogram<int64_t>;$/;"	x	file:
folly::Histogram::AvgFromBucket	.\stats\Histogram.h	/^  struct AvgFromBucket {$/;"	s	class:folly::Histogram	access:private
folly::Histogram::AvgFromBucket::operator ()	.\stats\Histogram.h	/^    ValueType operator()(const Bucket& bucket) const {$/;"	f	struct:folly::Histogram::AvgFromBucket	access:public	signature:(const Bucket& bucket) const
folly::Histogram::Bucket	.\stats\Histogram.h	/^  typedef detail::Bucket<T> Bucket;$/;"	t	class:folly::Histogram	access:public
folly::Histogram::CountFromBucket	.\stats\Histogram.h	/^  struct CountFromBucket {$/;"	s	class:folly::Histogram	access:private
folly::Histogram::CountFromBucket::operator ()	.\stats\Histogram.h	/^    uint64_t operator()(const Bucket& bucket) const {$/;"	f	struct:folly::Histogram::CountFromBucket	access:public	signature:(const Bucket& bucket) const
folly::Histogram::Histogram	.\stats\Histogram.h	/^  Histogram(ValueType bucketSize, ValueType min, ValueType max)$/;"	f	class:folly::Histogram	access:public	signature:(ValueType bucketSize, ValueType min, ValueType max)
folly::Histogram::ValueType	.\stats\Histogram.h	/^  typedef T ValueType;$/;"	t	class:folly::Histogram	access:public
folly::Histogram::addRepeatedValue	.\stats\Histogram.h	/^  void addRepeatedValue(ValueType value, uint64_t nSamples) {$/;"	f	class:folly::Histogram	access:public	signature:(ValueType value, uint64_t nSamples)
folly::Histogram::addValue	.\stats\Histogram.h	/^  void addValue(ValueType value) {$/;"	f	class:folly::Histogram	access:public	signature:(ValueType value)
folly::Histogram::buckets_	.\stats\Histogram.h	/^  detail::HistogramBuckets<ValueType, Bucket> buckets_;$/;"	m	class:folly::Histogram	access:private
folly::Histogram::clear	.\stats\Histogram.h	/^  void clear() {$/;"	f	class:folly::Histogram	access:public	signature:()
folly::Histogram::copy	.\stats\Histogram.h	/^  void copy(const Histogram &hist) {$/;"	f	class:folly::Histogram	access:public	signature:(const Histogram &hist)
folly::Histogram::debugString	.\stats\Histogram-defs.h	/^std::string Histogram<T>::debugString() const {$/;"	f	class:folly::Histogram	signature:() const
folly::Histogram::debugString	.\stats\Histogram.h	/^  std::string debugString() const;$/;"	p	class:folly::Histogram	access:public	signature:() const
folly::Histogram::getBucketByIndex	.\stats\Histogram.h	/^  const Bucket& getBucketByIndex(int idx) const {$/;"	f	class:folly::Histogram	access:public	signature:(int idx) const
folly::Histogram::getBucketMax	.\stats\Histogram.h	/^  ValueType getBucketMax(unsigned int idx) const {$/;"	f	class:folly::Histogram	access:public	signature:(unsigned int idx) const
folly::Histogram::getBucketMin	.\stats\Histogram.h	/^  ValueType getBucketMin(unsigned int idx) const {$/;"	f	class:folly::Histogram	access:public	signature:(unsigned int idx) const
folly::Histogram::getBucketSize	.\stats\Histogram.h	/^  ValueType getBucketSize() const {$/;"	f	class:folly::Histogram	access:public	signature:() const
folly::Histogram::getMax	.\stats\Histogram.h	/^  ValueType getMax() const {$/;"	f	class:folly::Histogram	access:public	signature:() const
folly::Histogram::getMin	.\stats\Histogram.h	/^  ValueType getMin() const {$/;"	f	class:folly::Histogram	access:public	signature:() const
folly::Histogram::getNumBuckets	.\stats\Histogram.h	/^  unsigned int getNumBuckets() const {$/;"	f	class:folly::Histogram	access:public	signature:() const
folly::Histogram::getPercentileBucketIdx	.\stats\Histogram.h	/^  unsigned int getPercentileBucketIdx(double pct,$/;"	f	class:folly::Histogram	access:public	signature:(double pct, double* lowPct = nullptr, double* highPct = nullptr) const
folly::Histogram::getPercentileEstimate	.\stats\Histogram.h	/^  ValueType getPercentileEstimate(double pct) const {$/;"	f	class:folly::Histogram	access:public	signature:(double pct) const
folly::Histogram::merge	.\stats\Histogram.h	/^  void merge(const Histogram &hist) {$/;"	f	class:folly::Histogram	access:public	signature:(const Histogram &hist)
folly::Histogram::removeRepeatedValue	.\stats\Histogram.h	/^  void removeRepeatedValue(ValueType value, uint64_t nSamples) {$/;"	f	class:folly::Histogram	access:public	signature:(ValueType value, uint64_t nSamples)
folly::Histogram::removeValue	.\stats\Histogram.h	/^  void removeValue(ValueType value) {$/;"	f	class:folly::Histogram	access:public	signature:(ValueType value)
folly::Histogram::subtract	.\stats\Histogram.h	/^  void subtract(const Histogram &hist) {$/;"	f	class:folly::Histogram	access:public	signature:(const Histogram &hist)
folly::Histogram::toTSV	.\stats\Histogram-defs.h	/^void Histogram<T>::toTSV(std::ostream& out, bool skipEmptyBuckets) const {$/;"	f	class:folly::Histogram	signature:(std::ostream& out, bool skipEmptyBuckets) const
folly::Histogram::toTSV	.\stats\Histogram.h	/^  void toTSV(std::ostream& out, bool skipEmptyBuckets = true) const;$/;"	p	class:folly::Histogram	access:public	signature:(std::ostream& out, bool skipEmptyBuckets = true) const
folly::HugePageSize	.\experimental\io\HugePages.h	/^struct HugePageSize : private boost::totally_ordered<HugePageSize> {$/;"	s	namespace:folly	inherits:boost::totally_ordered
folly::HugePageSize::HugePageSize	.\experimental\io\HugePages.h	/^  explicit HugePageSize(size_t s) : size(s) { }$/;"	f	struct:folly::HugePageSize	access:public	signature:(size_t s)
folly::HugePageSize::device	.\experimental\io\HugePages.h	/^  dev_t device = 0;$/;"	m	struct:folly::HugePageSize	access:public
folly::HugePageSize::filePath	.\experimental\io\HugePages.h	/^  fs::path filePath(const fs::path& relpath) const {$/;"	f	struct:folly::HugePageSize	access:public	signature:(const fs::path& relpath) const
folly::HugePageSize::mountPoint	.\experimental\io\HugePages.h	/^  fs::path mountPoint;$/;"	m	struct:folly::HugePageSize	access:public
folly::HugePageSize::size	.\experimental\io\HugePages.h	/^  size_t size = 0;$/;"	m	struct:folly::HugePageSize	access:public
folly::HugePageSizeVec	.\experimental\io\HugePages.h	/^typedef std::vector<HugePageSize> HugePageSizeVec;$/;"	t	namespace:folly
folly::IOBuf	.\io\IOBuf.h	/^class IOBuf {$/;"	c	namespace:folly
folly::IOBuf::COPY_BUFFER	.\io\IOBuf.h	/^  enum CopyBufferOp { COPY_BUFFER };$/;"	e	enum:folly::IOBuf::CopyBufferOp
folly::IOBuf::CREATE	.\io\IOBuf.h	/^  enum CreateOp { CREATE };$/;"	e	enum:folly::IOBuf::CreateOp
folly::IOBuf::CopyBufferOp	.\io\IOBuf.h	/^  enum CopyBufferOp { COPY_BUFFER };$/;"	g	class:folly::IOBuf	access:public
folly::IOBuf::CreateOp	.\io\IOBuf.h	/^  enum CreateOp { CREATE };$/;"	g	class:folly::IOBuf	access:public
folly::IOBuf::DeleterBase	.\io\IOBuf.h	/^  struct DeleterBase {$/;"	s	class:folly::IOBuf	access:private
folly::IOBuf::DeleterBase::dispose	.\io\IOBuf.h	/^    virtual void dispose(void* p) = 0;$/;"	p	struct:folly::IOBuf::DeleterBase	access:public	signature:(void* p)
folly::IOBuf::DeleterBase::~DeleterBase	.\io\IOBuf.h	/^    virtual ~DeleterBase() { }$/;"	f	struct:folly::IOBuf::DeleterBase	access:public	signature:()
folly::IOBuf::FreeFunction	.\io\IOBuf.h	/^  typedef void (*FreeFunction)(void* buf, void* userData);$/;"	t	class:folly::IOBuf	access:public
folly::IOBuf::HeapFullStorage	.\io\IOBuf.cpp	/^struct IOBuf::HeapFullStorage {$/;"	s	class:folly::IOBuf	file:
folly::IOBuf::HeapFullStorage	.\io\IOBuf.h	/^  struct HeapFullStorage;$/;"	x
folly::IOBuf::HeapFullStorage::align	.\io\IOBuf.cpp	/^  MaxAlign align;$/;"	m	struct:folly::IOBuf::HeapFullStorage	file:	access:public
folly::IOBuf::HeapFullStorage::hs	.\io\IOBuf.cpp	/^  HeapStorage hs;$/;"	m	struct:folly::IOBuf::HeapFullStorage	file:	access:public
folly::IOBuf::HeapFullStorage::shared	.\io\IOBuf.cpp	/^  SharedInfo shared;$/;"	m	struct:folly::IOBuf::HeapFullStorage	file:	access:public
folly::IOBuf::HeapFullStorage::sizeof	.\io\IOBuf.cpp	/^  static_assert(sizeof(HeapStorage) <= 64,$/;"	p	struct:folly::IOBuf::HeapFullStorage	file:	access:public	signature:(HeapStorage)
folly::IOBuf::HeapPrefix	.\io\IOBuf.cpp	/^struct IOBuf::HeapPrefix {$/;"	s	class:folly::IOBuf	file:
folly::IOBuf::HeapPrefix	.\io\IOBuf.h	/^  struct HeapPrefix;$/;"	x
folly::IOBuf::HeapPrefix::HeapPrefix	.\io\IOBuf.cpp	/^  HeapPrefix(uint16_t flg)$/;"	f	struct:folly::IOBuf::HeapPrefix	access:public	signature:(uint16_t flg)
folly::IOBuf::HeapPrefix::flags	.\io\IOBuf.cpp	/^  std::atomic<uint16_t> flags;$/;"	m	struct:folly::IOBuf::HeapPrefix	file:	access:public
folly::IOBuf::HeapPrefix::magic	.\io\IOBuf.cpp	/^  uint16_t magic;$/;"	m	struct:folly::IOBuf::HeapPrefix	file:	access:public
folly::IOBuf::HeapPrefix::~HeapPrefix	.\io\IOBuf.cpp	/^  ~HeapPrefix() {$/;"	f	struct:folly::IOBuf::HeapPrefix	access:public	signature:()
folly::IOBuf::HeapStorage	.\io\IOBuf.cpp	/^struct IOBuf::HeapStorage {$/;"	s	class:folly::IOBuf	file:
folly::IOBuf::HeapStorage	.\io\IOBuf.h	/^  struct HeapStorage;$/;"	x
folly::IOBuf::HeapStorage::buf	.\io\IOBuf.cpp	/^  folly::IOBuf buf;$/;"	m	struct:folly::IOBuf::HeapStorage	file:	access:public
folly::IOBuf::HeapStorage::prefix	.\io\IOBuf.cpp	/^  HeapPrefix prefix;$/;"	m	struct:folly::IOBuf::HeapStorage	file:	access:public
folly::IOBuf::IOBuf	.\io\IOBuf.cpp	/^IOBuf::IOBuf(CopyBufferOp op, ByteRange br,$/;"	f	class:folly::IOBuf	signature:(CopyBufferOp op, ByteRange br, uint64_t headroom, uint64_t minTailroom)
folly::IOBuf::IOBuf	.\io\IOBuf.cpp	/^IOBuf::IOBuf(CopyBufferOp op, const void* buf, uint64_t size,$/;"	f	class:folly::IOBuf	signature:(CopyBufferOp op, const void* buf, uint64_t size, uint64_t headroom, uint64_t minTailroom)
folly::IOBuf::IOBuf	.\io\IOBuf.cpp	/^IOBuf::IOBuf(CreateOp, uint64_t capacity)$/;"	f	class:folly::IOBuf	signature:(CreateOp, uint64_t capacity)
folly::IOBuf::IOBuf	.\io\IOBuf.cpp	/^IOBuf::IOBuf(InternalConstructor,$/;"	f	class:folly::IOBuf	signature:(InternalConstructor, uintptr_t flagsAndSharedInfo, uint8_t* buf, uint64_t capacity, uint8_t* data, uint64_t length)
folly::IOBuf::IOBuf	.\io\IOBuf.cpp	/^IOBuf::IOBuf(TakeOwnershipOp, void* buf, uint64_t capacity, uint64_t length,$/;"	f	class:folly::IOBuf	signature:(TakeOwnershipOp, void* buf, uint64_t capacity, uint64_t length, FreeFunction freeFn, void* userData, bool freeOnError)
folly::IOBuf::IOBuf	.\io\IOBuf.cpp	/^IOBuf::IOBuf(WrapBufferOp op, ByteRange br)$/;"	f	class:folly::IOBuf	signature:(WrapBufferOp op, ByteRange br)
folly::IOBuf::IOBuf	.\io\IOBuf.cpp	/^IOBuf::IOBuf(WrapBufferOp, const void* buf, uint64_t capacity)$/;"	f	class:folly::IOBuf	signature:(WrapBufferOp, const void* buf, uint64_t capacity)
folly::IOBuf::IOBuf	.\io\IOBuf.h	/^  IOBuf(CopyBufferOp op, ByteRange br,$/;"	p	class:folly::IOBuf	access:public	signature:(CopyBufferOp op, ByteRange br, uint64_t headroom=0, uint64_t minTailroom=0)
folly::IOBuf::IOBuf	.\io\IOBuf.h	/^  IOBuf(CopyBufferOp op, const std::string& buf,$/;"	f	class:folly::IOBuf	access:public	signature:(CopyBufferOp op, const std::string& buf, uint64_t headroom=0, uint64_t minTailroom=0)
folly::IOBuf::IOBuf	.\io\IOBuf.h	/^  IOBuf(CopyBufferOp op, const void* buf, uint64_t size,$/;"	p	class:folly::IOBuf	access:public	signature:(CopyBufferOp op, const void* buf, uint64_t size, uint64_t headroom=0, uint64_t minTailroom=0)
folly::IOBuf::IOBuf	.\io\IOBuf.h	/^  IOBuf(CreateOp, uint64_t capacity);$/;"	p	class:folly::IOBuf	access:public	signature:(CreateOp, uint64_t capacity)
folly::IOBuf::IOBuf	.\io\IOBuf.h	/^  IOBuf(IOBuf const &);$/;"	p	class:folly::IOBuf	access:private	signature:(IOBuf const &)
folly::IOBuf::IOBuf	.\io\IOBuf.h	/^  IOBuf(InternalConstructor, uintptr_t flagsAndSharedInfo,$/;"	p	class:folly::IOBuf	access:private	signature:(InternalConstructor, uintptr_t flagsAndSharedInfo, uint8_t* buf, uint64_t capacity, uint8_t* data, uint64_t length)
folly::IOBuf::IOBuf	.\io\IOBuf.h	/^  IOBuf(TakeOwnershipOp op, void* buf, uint64_t capacity,$/;"	f	class:folly::IOBuf	access:public	signature:(TakeOwnershipOp op, void* buf, uint64_t capacity, FreeFunction freeFn = nullptr, void* userData = nullptr, bool freeOnError = true)
folly::IOBuf::IOBuf	.\io\IOBuf.h	/^  IOBuf(TakeOwnershipOp, void* buf, uint64_t capacity, uint64_t length,$/;"	p	class:folly::IOBuf	access:public	signature:(TakeOwnershipOp, void* buf, uint64_t capacity, uint64_t length, FreeFunction freeFn = nullptr, void* userData = nullptr, bool freeOnError = true)
folly::IOBuf::IOBuf	.\io\IOBuf.h	/^  IOBuf(WrapBufferOp op, ByteRange br);$/;"	p	class:folly::IOBuf	access:public	signature:(WrapBufferOp op, ByteRange br)
folly::IOBuf::IOBuf	.\io\IOBuf.h	/^  IOBuf(WrapBufferOp op, const void* buf, uint64_t capacity);$/;"	p	class:folly::IOBuf	access:public	signature:(WrapBufferOp op, const void* buf, uint64_t capacity)
folly::IOBuf::InternalConstructor	.\io\IOBuf.h	/^  struct InternalConstructor {};  \/\/ avoid conflicts$/;"	s	class:folly::IOBuf	access:private
folly::IOBuf::Iterator	.\io\IOBuf.h	/^  class Iterator;$/;"	x
folly::IOBuf::Iterator	.\io\IOBuf.h	/^class IOBuf::Iterator : public boost::iterator_facade<$/;"	c	class:folly::IOBuf	inherits:boost::iterator_facade
folly::IOBuf::Iterator::Iterator	.\io\IOBuf.h	/^  explicit Iterator(const IOBuf* pos, const IOBuf* end)$/;"	f	class:folly::IOBuf::Iterator	access:public	signature:(const IOBuf* pos, const IOBuf* end)
folly::IOBuf::Iterator::adjustForEnd	.\io\IOBuf.h	/^  void adjustForEnd() {$/;"	f	class:folly::IOBuf::Iterator	access:private	signature:()
folly::IOBuf::Iterator::dereference	.\io\IOBuf.h	/^  const ByteRange& dereference() const {$/;"	f	class:folly::IOBuf::Iterator	access:private	signature:() const
folly::IOBuf::Iterator::end_	.\io\IOBuf.h	/^  const IOBuf* end_;$/;"	m	class:folly::IOBuf::Iterator	access:private
folly::IOBuf::Iterator::equal	.\io\IOBuf.h	/^  bool equal(const Iterator& other) const {$/;"	f	class:folly::IOBuf::Iterator	access:private	signature:(const Iterator& other) const
folly::IOBuf::Iterator::increment	.\io\IOBuf.h	/^  void increment() {$/;"	f	class:folly::IOBuf::Iterator	access:private	signature:()
folly::IOBuf::Iterator::pos_	.\io\IOBuf.h	/^  const IOBuf* pos_;$/;"	m	class:folly::IOBuf::Iterator	access:private
folly::IOBuf::Iterator::setVal	.\io\IOBuf.h	/^  void setVal() {$/;"	f	class:folly::IOBuf::Iterator	access:private	signature:()
folly::IOBuf::Iterator::val_	.\io\IOBuf.h	/^  ByteRange val_;$/;"	m	class:folly::IOBuf::Iterator	access:private
folly::IOBuf::SharedInfo	.\io\IOBuf.h	/^  struct SharedInfo {$/;"	s	class:folly::IOBuf	access:private
folly::IOBuf::SharedInfo::SharedInfo	.\io\IOBuf.cpp	/^IOBuf::SharedInfo::SharedInfo()$/;"	f	class:folly::IOBuf::SharedInfo	signature:()
folly::IOBuf::SharedInfo::SharedInfo	.\io\IOBuf.cpp	/^IOBuf::SharedInfo::SharedInfo(FreeFunction fn, void* arg)$/;"	f	class:folly::IOBuf::SharedInfo	signature:(FreeFunction fn, void* arg)
folly::IOBuf::SharedInfo::SharedInfo	.\io\IOBuf.h	/^    SharedInfo();$/;"	p	struct:folly::IOBuf::SharedInfo	access:public	signature:()
folly::IOBuf::SharedInfo::SharedInfo	.\io\IOBuf.h	/^    SharedInfo(FreeFunction fn, void* arg);$/;"	p	struct:folly::IOBuf::SharedInfo	access:public	signature:(FreeFunction fn, void* arg)
folly::IOBuf::SharedInfo::freeFn	.\io\IOBuf.h	/^    FreeFunction freeFn;$/;"	m	struct:folly::IOBuf::SharedInfo	access:public
folly::IOBuf::SharedInfo::refcount	.\io\IOBuf.h	/^    std::atomic<uint32_t> refcount;$/;"	m	struct:folly::IOBuf::SharedInfo	access:public
folly::IOBuf::SharedInfo::userData	.\io\IOBuf.h	/^    void* userData;$/;"	m	struct:folly::IOBuf::SharedInfo	access:public
folly::IOBuf::TAKE_OWNERSHIP	.\io\IOBuf.h	/^  enum TakeOwnershipOp { TAKE_OWNERSHIP };$/;"	e	enum:folly::IOBuf::TakeOwnershipOp
folly::IOBuf::TakeOwnershipOp	.\io\IOBuf.h	/^  enum TakeOwnershipOp { TAKE_OWNERSHIP };$/;"	g	class:folly::IOBuf	access:public
folly::IOBuf::UniquePtrDeleter	.\io\IOBuf.h	/^  struct UniquePtrDeleter : public DeleterBase {$/;"	s	class:folly::IOBuf	inherits:DeleterBase	access:private
folly::IOBuf::UniquePtrDeleter::Deleter	.\io\IOBuf.h	/^    typedef typename UniquePtr::deleter_type Deleter;$/;"	t	struct:folly::IOBuf::UniquePtrDeleter	access:public
folly::IOBuf::UniquePtrDeleter::Pointer	.\io\IOBuf.h	/^    typedef typename UniquePtr::pointer Pointer;$/;"	t	struct:folly::IOBuf::UniquePtrDeleter	access:public
folly::IOBuf::UniquePtrDeleter::UniquePtrDeleter	.\io\IOBuf.h	/^    explicit UniquePtrDeleter(Deleter deleter) : deleter_(std::move(deleter)){ }$/;"	f	struct:folly::IOBuf::UniquePtrDeleter	access:public	signature:(Deleter deleter)
folly::IOBuf::UniquePtrDeleter::deleter_	.\io\IOBuf.h	/^    Deleter deleter_;$/;"	m	struct:folly::IOBuf::UniquePtrDeleter	access:private
folly::IOBuf::UniquePtrDeleter::dispose	.\io\IOBuf.h	/^    void dispose(void* p) {$/;"	f	struct:folly::IOBuf::UniquePtrDeleter	access:public	signature:(void* p)
folly::IOBuf::WRAP_BUFFER	.\io\IOBuf.h	/^  enum WrapBufferOp { WRAP_BUFFER };$/;"	e	enum:folly::IOBuf::WrapBufferOp
folly::IOBuf::WrapBufferOp	.\io\IOBuf.h	/^  enum WrapBufferOp { WRAP_BUFFER };$/;"	g	class:folly::IOBuf	access:public
folly::IOBuf::advance	.\io\IOBuf.h	/^  void advance(uint64_t amount) {$/;"	f	class:folly::IOBuf	access:public	signature:(uint64_t amount)
folly::IOBuf::allocExtBuffer	.\io\IOBuf.cpp	/^void IOBuf::allocExtBuffer(uint64_t minCapacity,$/;"	f	class:folly::IOBuf	signature:(uint64_t minCapacity, uint8_t** bufReturn, SharedInfo** infoReturn, uint64_t* capacityReturn)
folly::IOBuf::allocExtBuffer	.\io\IOBuf.h	/^  static void allocExtBuffer(uint64_t minCapacity,$/;"	p	class:folly::IOBuf	access:private	signature:(uint64_t minCapacity, uint8_t** bufReturn, SharedInfo** infoReturn, uint64_t* capacityReturn)
folly::IOBuf::append	.\io\IOBuf.h	/^  void append(uint64_t amount) {$/;"	f	class:folly::IOBuf	access:public	signature:(uint64_t amount)
folly::IOBuf::appendChain	.\io\IOBuf.h	/^  void appendChain(std::unique_ptr<IOBuf>&& iobuf) {$/;"	f	class:folly::IOBuf	access:public	signature:(std::unique_ptr<IOBuf>&& iobuf)
folly::IOBuf::begin	.\io\IOBuf.h	/^  Iterator begin() const;$/;"	p	class:folly::IOBuf	access:public	signature:() const
folly::IOBuf::begin	.\io\IOBuf.h	/^inline IOBuf::Iterator IOBuf::begin() const { return cbegin(); }$/;"	f	class:folly::IOBuf	signature:() const
folly::IOBuf::buffer	.\io\IOBuf.h	/^  const uint8_t* buffer() const {$/;"	f	class:folly::IOBuf	access:public	signature:() const
folly::IOBuf::bufferEnd	.\io\IOBuf.h	/^  const uint8_t* bufferEnd() const {$/;"	f	class:folly::IOBuf	access:public	signature:() const
folly::IOBuf::capacity	.\io\IOBuf.h	/^  uint64_t capacity() const {$/;"	f	class:folly::IOBuf	access:public	signature:() const
folly::IOBuf::cbegin	.\io\IOBuf.cpp	/^IOBuf::Iterator IOBuf::cbegin() const {$/;"	f	class:folly::IOBuf	signature:() const
folly::IOBuf::cbegin	.\io\IOBuf.h	/^  Iterator cbegin() const;$/;"	p	class:folly::IOBuf	access:public	signature:() const
folly::IOBuf::cend	.\io\IOBuf.cpp	/^IOBuf::Iterator IOBuf::cend() const {$/;"	f	class:folly::IOBuf	signature:() const
folly::IOBuf::cend	.\io\IOBuf.h	/^  Iterator cend() const;$/;"	p	class:folly::IOBuf	access:public	signature:() const
folly::IOBuf::clear	.\io\IOBuf.h	/^  void clear() {$/;"	f	class:folly::IOBuf	access:public	signature:()
folly::IOBuf::clearFlags	.\io\IOBuf.h	/^  inline void clearFlags(uintptr_t flags) const {$/;"	f	class:folly::IOBuf	access:private	signature:(uintptr_t flags) const
folly::IOBuf::clone	.\io\IOBuf.cpp	/^unique_ptr<IOBuf> IOBuf::clone() const {$/;"	f	class:folly::IOBuf	signature:() const
folly::IOBuf::clone	.\io\IOBuf.h	/^  std::unique_ptr<IOBuf> clone() const;$/;"	p	class:folly::IOBuf	access:public	signature:() const
folly::IOBuf::cloneInto	.\io\IOBuf.cpp	/^void IOBuf::cloneInto(IOBuf& other) const {$/;"	f	class:folly::IOBuf	signature:(IOBuf& other) const
folly::IOBuf::cloneInto	.\io\IOBuf.h	/^  void cloneInto(IOBuf& other) const;$/;"	p	class:folly::IOBuf	access:public	signature:(IOBuf& other) const
folly::IOBuf::cloneOne	.\io\IOBuf.cpp	/^unique_ptr<IOBuf> IOBuf::cloneOne() const {$/;"	f	class:folly::IOBuf	signature:() const
folly::IOBuf::cloneOne	.\io\IOBuf.h	/^  std::unique_ptr<IOBuf> cloneOne() const;$/;"	p	class:folly::IOBuf	access:public	signature:() const
folly::IOBuf::cloneOneInto	.\io\IOBuf.cpp	/^void IOBuf::cloneOneInto(IOBuf& other) const {$/;"	f	class:folly::IOBuf	signature:(IOBuf& other) const
folly::IOBuf::cloneOneInto	.\io\IOBuf.h	/^  void cloneOneInto(IOBuf& other) const;$/;"	p	class:folly::IOBuf	access:public	signature:(IOBuf& other) const
folly::IOBuf::coalesce	.\io\IOBuf.h	/^  ByteRange coalesce() {$/;"	f	class:folly::IOBuf	access:public	signature:()
folly::IOBuf::coalesceAndReallocate	.\io\IOBuf.cpp	/^void IOBuf::coalesceAndReallocate(size_t newHeadroom,$/;"	f	class:folly::IOBuf	signature:(size_t newHeadroom, size_t newLength, IOBuf* end, size_t newTailroom)
folly::IOBuf::coalesceAndReallocate	.\io\IOBuf.h	/^  void coalesceAndReallocate($/;"	p	class:folly::IOBuf	access:private	signature:( size_t newHeadroom, size_t newLength, IOBuf* end, size_t newTailroom)
folly::IOBuf::coalesceAndReallocate	.\io\IOBuf.h	/^  void coalesceAndReallocate(size_t newLength, IOBuf* end) {$/;"	f	class:folly::IOBuf	access:private	signature:(size_t newLength, IOBuf* end)
folly::IOBuf::coalesceSlow	.\io\IOBuf.cpp	/^void IOBuf::coalesceSlow() {$/;"	f	class:folly::IOBuf	signature:()
folly::IOBuf::coalesceSlow	.\io\IOBuf.cpp	/^void IOBuf::coalesceSlow(size_t maxLength) {$/;"	f	class:folly::IOBuf	signature:(size_t maxLength)
folly::IOBuf::coalesceSlow	.\io\IOBuf.h	/^  void coalesceSlow();$/;"	p	class:folly::IOBuf	access:private	signature:()
folly::IOBuf::coalesceSlow	.\io\IOBuf.h	/^  void coalesceSlow(size_t maxLength);$/;"	p	class:folly::IOBuf	access:private	signature:(size_t maxLength)
folly::IOBuf::computeChainDataLength	.\io\IOBuf.cpp	/^uint64_t IOBuf::computeChainDataLength() const {$/;"	f	class:folly::IOBuf	signature:() const
folly::IOBuf::computeChainDataLength	.\io\IOBuf.h	/^  uint64_t computeChainDataLength() const;$/;"	p	class:folly::IOBuf	access:public	signature:() const
folly::IOBuf::const_iterator	.\io\IOBuf.h	/^  typedef Iterator const_iterator;$/;"	t	class:folly::IOBuf	access:public
folly::IOBuf::copyBuffer	.\io\IOBuf.h	/^  static std::unique_ptr<IOBuf> copyBuffer(ByteRange br,$/;"	f	class:folly::IOBuf	access:public	signature:(ByteRange br, uint64_t headroom=0, uint64_t minTailroom=0)
folly::IOBuf::copyBuffer	.\io\IOBuf.h	/^  static std::unique_ptr<IOBuf> copyBuffer(const std::string& buf,$/;"	p	class:folly::IOBuf	access:public	signature:(const std::string& buf, uint64_t headroom=0, uint64_t minTailroom=0)
folly::IOBuf::copyBuffer	.\io\IOBuf.h	/^  static std::unique_ptr<IOBuf> copyBuffer(const void* buf, uint64_t size,$/;"	p	class:folly::IOBuf	access:public	signature:(const void* buf, uint64_t size, uint64_t headroom=0, uint64_t minTailroom=0)
folly::IOBuf::copyBuffer	.\io\IOBuf.h	/^inline std::unique_ptr<IOBuf> IOBuf::copyBuffer($/;"	f	class:folly::IOBuf	signature:( const void* data, uint64_t size, uint64_t headroom, uint64_t minTailroom)
folly::IOBuf::copyBuffer	.\io\IOBuf.h	/^inline std::unique_ptr<IOBuf> IOBuf::copyBuffer(const std::string& buf,$/;"	f	class:folly::IOBuf	signature:(const std::string& buf, uint64_t headroom, uint64_t minTailroom)
folly::IOBuf::countChainElements	.\io\IOBuf.cpp	/^size_t IOBuf::countChainElements() const {$/;"	f	class:folly::IOBuf	signature:() const
folly::IOBuf::countChainElements	.\io\IOBuf.h	/^  size_t countChainElements() const;$/;"	p	class:folly::IOBuf	access:public	signature:() const
folly::IOBuf::create	.\io\IOBuf.cpp	/^unique_ptr<IOBuf> IOBuf::create(uint64_t capacity) {$/;"	f	class:folly::IOBuf	signature:(uint64_t capacity)
folly::IOBuf::create	.\io\IOBuf.h	/^  static std::unique_ptr<IOBuf> create(uint64_t capacity);$/;"	p	class:folly::IOBuf	access:public	signature:(uint64_t capacity)
folly::IOBuf::createChain	.\io\IOBuf.cpp	/^unique_ptr<IOBuf> IOBuf::createChain($/;"	f	class:folly::IOBuf	signature:( size_t totalCapacity, uint64_t maxBufCapacity)
folly::IOBuf::createChain	.\io\IOBuf.h	/^  static std::unique_ptr<IOBuf> createChain($/;"	p	class:folly::IOBuf	access:public	signature:( size_t totalCapacity, uint64_t maxBufCapacity)
folly::IOBuf::createCombined	.\io\IOBuf.cpp	/^unique_ptr<IOBuf> IOBuf::createCombined(uint64_t capacity) {$/;"	f	class:folly::IOBuf	signature:(uint64_t capacity)
folly::IOBuf::createCombined	.\io\IOBuf.h	/^  static std::unique_ptr<IOBuf> createCombined(uint64_t capacity);$/;"	p	class:folly::IOBuf	access:public	signature:(uint64_t capacity)
folly::IOBuf::createSeparate	.\io\IOBuf.cpp	/^unique_ptr<IOBuf> IOBuf::createSeparate(uint64_t capacity) {$/;"	f	class:folly::IOBuf	signature:(uint64_t capacity)
folly::IOBuf::createSeparate	.\io\IOBuf.h	/^  static std::unique_ptr<IOBuf> createSeparate(uint64_t capacity);$/;"	p	class:folly::IOBuf	access:public	signature:(uint64_t capacity)
folly::IOBuf::data	.\io\IOBuf.h	/^  const uint8_t* data() const {$/;"	f	class:folly::IOBuf	access:public	signature:() const
folly::IOBuf::decrementRefcount	.\io\IOBuf.cpp	/^void IOBuf::decrementRefcount() {$/;"	f	class:folly::IOBuf	signature:()
folly::IOBuf::decrementRefcount	.\io\IOBuf.h	/^  void decrementRefcount();$/;"	p	class:folly::IOBuf	access:private	signature:()
folly::IOBuf::destroy	.\io\IOBuf.h	/^  static void destroy(std::unique_ptr<IOBuf>&& data) {$/;"	f	class:folly::IOBuf	access:public	signature:(std::unique_ptr<IOBuf>&& data)
folly::IOBuf::empty	.\io\IOBuf.cpp	/^bool IOBuf::empty() const {$/;"	f	class:folly::IOBuf	signature:() const
folly::IOBuf::empty	.\io\IOBuf.h	/^  bool empty() const;$/;"	p	class:folly::IOBuf	access:public	signature:() const
folly::IOBuf::end	.\io\IOBuf.h	/^  Iterator end() const;$/;"	p	class:folly::IOBuf	access:public	signature:() const
folly::IOBuf::end	.\io\IOBuf.h	/^inline IOBuf::Iterator IOBuf::end() const { return cend(); }$/;"	f	class:folly::IOBuf	signature:() const
folly::IOBuf::flags	.\io\IOBuf.h	/^  inline uintptr_t flags() const {$/;"	f	class:folly::IOBuf	access:private	signature:() const
folly::IOBuf::freeExtBuffer	.\io\IOBuf.cpp	/^void IOBuf::freeExtBuffer() {$/;"	f	class:folly::IOBuf	signature:()
folly::IOBuf::freeExtBuffer	.\io\IOBuf.h	/^  void freeExtBuffer();$/;"	p	class:folly::IOBuf	access:private	signature:()
folly::IOBuf::freeInternalBuf	.\io\IOBuf.cpp	/^void IOBuf::freeInternalBuf(void* buf, void* userData) {$/;"	f	class:folly::IOBuf	signature:(void* buf, void* userData)
folly::IOBuf::freeInternalBuf	.\io\IOBuf.h	/^  static void freeInternalBuf(void* buf, void* userData);$/;"	p	class:folly::IOBuf	access:private	signature:(void* buf, void* userData)
folly::IOBuf::freeUniquePtrBuffer	.\io\IOBuf.h	/^  static void freeUniquePtrBuffer(void* ptr, void* userData) {$/;"	f	class:folly::IOBuf	access:private	signature:(void* ptr, void* userData)
folly::IOBuf::gather	.\io\IOBuf.h	/^  void gather(uint64_t maxLength) {$/;"	f	class:folly::IOBuf	access:public	signature:(uint64_t maxLength)
folly::IOBuf::getIov	.\io\IOBuf.cpp	/^folly::fbvector<struct iovec> IOBuf::getIov() const {$/;"	f	class:folly::IOBuf	signature:() const
folly::IOBuf::getIov	.\io\IOBuf.h	/^  folly::fbvector<struct iovec> getIov() const;$/;"	p	class:folly::IOBuf	access:public	signature:() const
folly::IOBuf::goodExtBufferSize	.\io\IOBuf.cpp	/^size_t IOBuf::goodExtBufferSize(uint64_t minCapacity) {$/;"	f	class:folly::IOBuf	signature:(uint64_t minCapacity)
folly::IOBuf::goodExtBufferSize	.\io\IOBuf.h	/^  static size_t goodExtBufferSize(uint64_t minCapacity);$/;"	p	class:folly::IOBuf	access:private	signature:(uint64_t minCapacity)
folly::IOBuf::headroom	.\io\IOBuf.h	/^  uint64_t headroom() const {$/;"	f	class:folly::IOBuf	access:public	signature:() const
folly::IOBuf::initExtBuffer	.\io\IOBuf.cpp	/^void IOBuf::initExtBuffer(uint8_t* buf, size_t mallocSize,$/;"	f	class:folly::IOBuf	signature:(uint8_t* buf, size_t mallocSize, SharedInfo** infoReturn, uint64_t* capacityReturn)
folly::IOBuf::initExtBuffer	.\io\IOBuf.h	/^  static void initExtBuffer(uint8_t* buf, size_t mallocSize,$/;"	p	class:folly::IOBuf	access:private	signature:(uint8_t* buf, size_t mallocSize, SharedInfo** infoReturn, uint64_t* capacityReturn)
folly::IOBuf::isChained	.\io\IOBuf.h	/^  bool isChained() const {$/;"	f	class:folly::IOBuf	access:public	signature:() const
folly::IOBuf::isShared	.\io\IOBuf.h	/^  bool isShared() const {$/;"	f	class:folly::IOBuf	access:public	signature:() const
folly::IOBuf::isSharedOne	.\io\IOBuf.h	/^  bool isSharedOne() const {$/;"	f	class:folly::IOBuf	access:public	signature:() const
folly::IOBuf::iterator	.\io\IOBuf.h	/^  typedef Iterator iterator;$/;"	t	class:folly::IOBuf	access:public
folly::IOBuf::length	.\io\IOBuf.h	/^  uint64_t length() const {$/;"	f	class:folly::IOBuf	access:public	signature:() const
folly::IOBuf::maybeCopyBuffer	.\io\IOBuf.h	/^  static std::unique_ptr<IOBuf> maybeCopyBuffer(const std::string& buf,$/;"	p	class:folly::IOBuf	access:public	signature:(const std::string& buf, uint64_t headroom=0, uint64_t minTailroom=0)
folly::IOBuf::maybeCopyBuffer	.\io\IOBuf.h	/^inline std::unique_ptr<IOBuf> IOBuf::maybeCopyBuffer(const std::string& buf,$/;"	f	class:folly::IOBuf	signature:(const std::string& buf, uint64_t headroom, uint64_t minTailroom)
folly::IOBuf::moveToFbString	.\io\IOBuf.cpp	/^fbstring IOBuf::moveToFbString() {$/;"	f	class:folly::IOBuf	signature:()
folly::IOBuf::moveToFbString	.\io\IOBuf.h	/^  fbstring moveToFbString();$/;"	p	class:folly::IOBuf	access:public	signature:()
folly::IOBuf::next	.\io\IOBuf.h	/^  IOBuf* next() {$/;"	f	class:folly::IOBuf	access:public	signature:()
folly::IOBuf::next	.\io\IOBuf.h	/^  const IOBuf* next() const {$/;"	f	class:folly::IOBuf	access:public	signature:() const
folly::IOBuf::noexcept	.\io\IOBuf.h	/^  IOBuf& operator=(IOBuf&& other) noexcept;$/;"	m	class:folly::IOBuf	access:public
folly::IOBuf::noexcept	.\io\IOBuf.h	/^  IOBuf() noexcept;$/;"	m	class:folly::IOBuf	access:public
folly::IOBuf::noexcept	.\io\IOBuf.h	/^  IOBuf(IOBuf&& other) noexcept;$/;"	m	class:folly::IOBuf	access:public
folly::IOBuf::operator =	.\io\IOBuf.h	/^  IOBuf& operator=(IOBuf const &);$/;"	p	class:folly::IOBuf	access:private	signature:(IOBuf const &)
folly::IOBuf::operator delete	.\io\IOBuf.cpp	/^void IOBuf::operator delete(void* ptr) {$/;"	f	class:folly::IOBuf	signature:(void* ptr)
folly::IOBuf::operator delete	.\io\IOBuf.h	/^  void operator delete(void* ptr);$/;"	p	class:folly::IOBuf	access:public	signature:(void* ptr)
folly::IOBuf::operator new	.\io\IOBuf.cpp	/^void* IOBuf::operator new(size_t size) {$/;"	f	class:folly::IOBuf	signature:(size_t size)
folly::IOBuf::operator new	.\io\IOBuf.cpp	/^void* IOBuf::operator new(size_t size, void* ptr) {$/;"	f	class:folly::IOBuf	signature:(size_t size, void* ptr)
folly::IOBuf::operator new	.\io\IOBuf.h	/^  void* operator new(size_t size);$/;"	p	class:folly::IOBuf	access:public	signature:(size_t size)
folly::IOBuf::operator new	.\io\IOBuf.h	/^  void* operator new(size_t size, void* ptr);$/;"	p	class:folly::IOBuf	access:public	signature:(size_t size, void* ptr)
folly::IOBuf::packFlagsAndSharedInfo	.\io\IOBuf.h	/^  static inline uintptr_t packFlagsAndSharedInfo(uintptr_t flags,$/;"	f	class:folly::IOBuf	access:private	signature:(uintptr_t flags, SharedInfo* info)
folly::IOBuf::pop	.\io\IOBuf.h	/^  std::unique_ptr<IOBuf> pop() {$/;"	f	class:folly::IOBuf	access:public	signature:()
folly::IOBuf::prepend	.\io\IOBuf.h	/^  void prepend(uint64_t amount) {$/;"	f	class:folly::IOBuf	access:public	signature:(uint64_t amount)
folly::IOBuf::prependChain	.\io\IOBuf.cpp	/^void IOBuf::prependChain(unique_ptr<IOBuf>&& iobuf) {$/;"	f	class:folly::IOBuf	signature:(unique_ptr<IOBuf>&& iobuf)
folly::IOBuf::prependChain	.\io\IOBuf.h	/^  void prependChain(std::unique_ptr<IOBuf>&& iobuf);$/;"	p	class:folly::IOBuf	access:public	signature:(std::unique_ptr<IOBuf>&& iobuf)
folly::IOBuf::prev	.\io\IOBuf.h	/^  IOBuf* prev() {$/;"	f	class:folly::IOBuf	access:public	signature:()
folly::IOBuf::prev	.\io\IOBuf.h	/^  const IOBuf* prev() const {$/;"	f	class:folly::IOBuf	access:public	signature:() const
folly::IOBuf::releaseStorage	.\io\IOBuf.cpp	/^void IOBuf::releaseStorage(HeapStorage* storage, uint16_t freeFlags) {$/;"	f	class:folly::IOBuf	signature:(HeapStorage* storage, uint16_t freeFlags)
folly::IOBuf::releaseStorage	.\io\IOBuf.h	/^  static void releaseStorage(HeapStorage* storage, uint16_t freeFlags);$/;"	p	class:folly::IOBuf	access:private	signature:(HeapStorage* storage, uint16_t freeFlags)
folly::IOBuf::reserve	.\io\IOBuf.h	/^  void reserve(uint64_t minHeadroom, uint64_t minTailroom) {$/;"	f	class:folly::IOBuf	access:public	signature:(uint64_t minHeadroom, uint64_t minTailroom)
folly::IOBuf::reserveSlow	.\io\IOBuf.cpp	/^void IOBuf::reserveSlow(uint64_t minHeadroom, uint64_t minTailroom) {$/;"	f	class:folly::IOBuf	signature:(uint64_t minHeadroom, uint64_t minTailroom)
folly::IOBuf::reserveSlow	.\io\IOBuf.h	/^  void reserveSlow(uint64_t minHeadroom, uint64_t minTailroom);$/;"	p	class:folly::IOBuf	access:private	signature:(uint64_t minHeadroom, uint64_t minTailroom)
folly::IOBuf::retreat	.\io\IOBuf.h	/^  void retreat(uint64_t amount) {$/;"	f	class:folly::IOBuf	access:public	signature:(uint64_t amount)
folly::IOBuf::separateChain	.\io\IOBuf.h	/^  std::unique_ptr<IOBuf> separateChain(IOBuf* head, IOBuf* tail) {$/;"	f	class:folly::IOBuf	access:public	signature:(IOBuf* head, IOBuf* tail)
folly::IOBuf::setFlags	.\io\IOBuf.h	/^  inline void setFlags(uintptr_t flags) const {$/;"	f	class:folly::IOBuf	access:private	signature:(uintptr_t flags) const
folly::IOBuf::setFlagsAndSharedInfo	.\io\IOBuf.h	/^  inline void setFlagsAndSharedInfo(uintptr_t flags, SharedInfo* info) {$/;"	f	class:folly::IOBuf	access:private	signature:(uintptr_t flags, SharedInfo* info)
folly::IOBuf::setSharedInfo	.\io\IOBuf.h	/^  inline void setSharedInfo(SharedInfo* info) {$/;"	f	class:folly::IOBuf	access:private	signature:(SharedInfo* info)
folly::IOBuf::sharedInfo	.\io\IOBuf.h	/^  inline SharedInfo* sharedInfo() const {$/;"	f	class:folly::IOBuf	access:private	signature:() const
folly::IOBuf::tail	.\io\IOBuf.h	/^  const uint8_t* tail() const {$/;"	f	class:folly::IOBuf	access:public	signature:() const
folly::IOBuf::tailroom	.\io\IOBuf.h	/^  uint64_t tailroom() const {$/;"	f	class:folly::IOBuf	access:public	signature:() const
folly::IOBuf::takeOwnership	.\io\IOBuf.cpp	/^unique_ptr<IOBuf> IOBuf::takeOwnership(void* buf, uint64_t capacity,$/;"	f	class:folly::IOBuf	signature:(void* buf, uint64_t capacity, uint64_t length, FreeFunction freeFn, void* userData, bool freeOnError)
folly::IOBuf::takeOwnership	.\io\IOBuf.h	/^  static std::unique_ptr<IOBuf> takeOwnership(void* buf, uint64_t capacity,$/;"	f	class:folly::IOBuf	access:public	signature:(void* buf, uint64_t capacity, FreeFunction freeFn = nullptr, void* userData = nullptr, bool freeOnError = true)
folly::IOBuf::takeOwnership	.\io\IOBuf.h	/^  static std::unique_ptr<IOBuf> takeOwnership(void* buf, uint64_t capacity,$/;"	p	class:folly::IOBuf	access:public	signature:(void* buf, uint64_t capacity, uint64_t length, FreeFunction freeFn = nullptr, void* userData = nullptr, bool freeOnError = true)
folly::IOBuf::takeOwnership	.\io\IOBuf.h	/^  takeOwnership(UniquePtr&& buf, size_t count=1);$/;"	p	class:folly::IOBuf	access:public	signature:(UniquePtr&& buf, size_t count=1)
folly::IOBuf::takeOwnership	.\io\IOBuf.h	/^IOBuf::takeOwnership(UniquePtr&& buf, size_t count) {$/;"	f	class:folly::IOBuf	signature:(UniquePtr&& buf, size_t count)
folly::IOBuf::trimEnd	.\io\IOBuf.h	/^  void trimEnd(uint64_t amount) {$/;"	f	class:folly::IOBuf	access:public	signature:(uint64_t amount)
folly::IOBuf::trimStart	.\io\IOBuf.h	/^  void trimStart(uint64_t amount) {$/;"	f	class:folly::IOBuf	access:public	signature:(uint64_t amount)
folly::IOBuf::unlink	.\io\IOBuf.h	/^  std::unique_ptr<IOBuf> unlink() {$/;"	f	class:folly::IOBuf	access:public	signature:()
folly::IOBuf::unshare	.\io\IOBuf.h	/^  void unshare() {$/;"	f	class:folly::IOBuf	access:public	signature:()
folly::IOBuf::unshareChained	.\io\IOBuf.cpp	/^void IOBuf::unshareChained() {$/;"	f	class:folly::IOBuf	signature:()
folly::IOBuf::unshareChained	.\io\IOBuf.h	/^  void unshareChained();$/;"	p	class:folly::IOBuf	access:private	signature:()
folly::IOBuf::unshareOne	.\io\IOBuf.h	/^  void unshareOne() {$/;"	f	class:folly::IOBuf	access:public	signature:()
folly::IOBuf::unshareOneSlow	.\io\IOBuf.cpp	/^void IOBuf::unshareOneSlow() {$/;"	f	class:folly::IOBuf	signature:()
folly::IOBuf::unshareOneSlow	.\io\IOBuf.h	/^  void unshareOneSlow();$/;"	p	class:folly::IOBuf	access:private	signature:()
folly::IOBuf::value_type	.\io\IOBuf.h	/^  typedef ByteRange value_type;$/;"	t	class:folly::IOBuf	access:public
folly::IOBuf::wrapBuffer	.\io\IOBuf.cpp	/^unique_ptr<IOBuf> IOBuf::wrapBuffer(const void* buf, uint64_t capacity) {$/;"	f	class:folly::IOBuf	signature:(const void* buf, uint64_t capacity)
folly::IOBuf::wrapBuffer	.\io\IOBuf.h	/^  static std::unique_ptr<IOBuf> wrapBuffer(ByteRange br) {$/;"	f	class:folly::IOBuf	access:public	signature:(ByteRange br)
folly::IOBuf::wrapBuffer	.\io\IOBuf.h	/^  static std::unique_ptr<IOBuf> wrapBuffer(const void* buf, uint64_t capacity);$/;"	p	class:folly::IOBuf	access:public	signature:(const void* buf, uint64_t capacity)
folly::IOBuf::writableBuffer	.\io\IOBuf.h	/^  uint8_t* writableBuffer() {$/;"	f	class:folly::IOBuf	access:public	signature:()
folly::IOBuf::writableData	.\io\IOBuf.h	/^  uint8_t* writableData() {$/;"	f	class:folly::IOBuf	access:public	signature:()
folly::IOBuf::writableTail	.\io\IOBuf.h	/^  uint8_t* writableTail() {$/;"	f	class:folly::IOBuf	access:public	signature:()
folly::IOBuf::~IOBuf	.\io\IOBuf.cpp	/^IOBuf::~IOBuf() {$/;"	f	class:folly::IOBuf	signature:()
folly::IOBuf::~IOBuf	.\io\IOBuf.h	/^  ~IOBuf();$/;"	p	class:folly::IOBuf	access:public	signature:()
folly::IOBufEqual	.\io\IOBuf.h	/^struct IOBufEqual {$/;"	s	namespace:folly
folly::IOBufEqual::operator ()	.\io\IOBuf.cpp	/^bool IOBufEqual::operator()(const IOBuf& a, const IOBuf& b) const {$/;"	f	class:folly::IOBufEqual	signature:(const IOBuf& a, const IOBuf& b) const
folly::IOBufEqual::operator ()	.\io\IOBuf.h	/^  bool operator()(const IOBuf& a, const IOBuf& b) const;$/;"	p	struct:folly::IOBufEqual	access:public	signature:(const IOBuf& a, const IOBuf& b) const
folly::IOBufEqual::operator ()	.\io\IOBuf.h	/^  bool operator()(const std::unique_ptr<IOBuf>& a,$/;"	f	struct:folly::IOBufEqual	access:public	signature:(const std::unique_ptr<IOBuf>& a, const std::unique_ptr<IOBuf>& b) const
folly::IOBufHash	.\io\IOBuf.h	/^struct IOBufHash {$/;"	s	namespace:folly
folly::IOBufHash::operator ()	.\io\IOBuf.cpp	/^size_t IOBufHash::operator()(const IOBuf& buf) const {$/;"	f	class:folly::IOBufHash	signature:(const IOBuf& buf) const
folly::IOBufHash::operator ()	.\io\IOBuf.h	/^  size_t operator()(const IOBuf& buf) const;$/;"	p	struct:folly::IOBufHash	access:public	signature:(const IOBuf& buf) const
folly::IOBufHash::operator ()	.\io\IOBuf.h	/^  size_t operator()(const std::unique_ptr<IOBuf>& buf) const {$/;"	f	struct:folly::IOBufHash	access:public	signature:(const std::unique_ptr<IOBuf>& buf) const
folly::IOBufQueue	.\io\IOBufQueue.h	/^class IOBufQueue {$/;"	c	namespace:folly
folly::IOBufQueue::IOBufQueue	.\io\IOBufQueue.cpp	/^IOBufQueue::IOBufQueue(IOBufQueue&& other)$/;"	f	class:folly::IOBufQueue	signature:(IOBufQueue&& other)
folly::IOBufQueue::IOBufQueue	.\io\IOBufQueue.cpp	/^IOBufQueue::IOBufQueue(const Options& options)$/;"	f	class:folly::IOBufQueue	signature:(const Options& options)
folly::IOBufQueue::IOBufQueue	.\io\IOBufQueue.h	/^  IOBufQueue(IOBufQueue&&);$/;"	p	class:folly::IOBufQueue	access:public	signature:(IOBufQueue&&)
folly::IOBufQueue::IOBufQueue	.\io\IOBufQueue.h	/^  IOBufQueue(const IOBufQueue&) = delete;$/;"	p	class:folly::IOBufQueue	access:private	signature:(const IOBufQueue&)
folly::IOBufQueue::IOBufQueue	.\io\IOBufQueue.h	/^  explicit IOBufQueue(const Options& options = Options());$/;"	p	class:folly::IOBufQueue	access:public	signature:(const Options& options = Options())
folly::IOBufQueue::Options	.\io\IOBufQueue.h	/^  struct Options {$/;"	s	class:folly::IOBufQueue	access:public
folly::IOBufQueue::Options::Options	.\io\IOBufQueue.h	/^    Options() : cacheChainLength(false) { }$/;"	f	struct:folly::IOBufQueue::Options	access:public	signature:()
folly::IOBufQueue::Options::cacheChainLength	.\io\IOBufQueue.h	/^    bool cacheChainLength;$/;"	m	struct:folly::IOBufQueue::Options	access:public
folly::IOBufQueue::allocate	.\io\IOBufQueue.h	/^  void* allocate(uint64_t n) {$/;"	f	class:folly::IOBufQueue	access:public	signature:(uint64_t n)
folly::IOBufQueue::append	.\io\IOBufQueue.cpp	/^IOBufQueue::append(IOBufQueue& other, bool pack) {$/;"	f	class:folly::IOBufQueue	signature:(IOBufQueue& other, bool pack)
folly::IOBufQueue::append	.\io\IOBufQueue.cpp	/^IOBufQueue::append(const void* buf, size_t len) {$/;"	f	class:folly::IOBufQueue	signature:(const void* buf, size_t len)
folly::IOBufQueue::append	.\io\IOBufQueue.cpp	/^IOBufQueue::append(unique_ptr<IOBuf>&& buf, bool pack) {$/;"	f	class:folly::IOBufQueue	signature:(unique_ptr<IOBuf>&& buf, bool pack)
folly::IOBufQueue::append	.\io\IOBufQueue.h	/^  void append(IOBufQueue& other, bool pack=false);$/;"	p	class:folly::IOBufQueue	access:public	signature:(IOBufQueue& other, bool pack=false)
folly::IOBufQueue::append	.\io\IOBufQueue.h	/^  void append(IOBufQueue&& other, bool pack=false) {$/;"	f	class:folly::IOBufQueue	access:public	signature:(IOBufQueue&& other, bool pack=false)
folly::IOBufQueue::append	.\io\IOBufQueue.h	/^  void append(StringPiece sp) {$/;"	f	class:folly::IOBufQueue	access:public	signature:(StringPiece sp)
folly::IOBufQueue::append	.\io\IOBufQueue.h	/^  void append(const void* buf, size_t len);$/;"	p	class:folly::IOBufQueue	access:public	signature:(const void* buf, size_t len)
folly::IOBufQueue::append	.\io\IOBufQueue.h	/^  void append(std::unique_ptr<folly::IOBuf>&& buf,$/;"	p	class:folly::IOBufQueue	access:public	signature:(std::unique_ptr<folly::IOBuf>&& buf, bool pack=false)
folly::IOBufQueue::cacheChainLength	.\io\IOBufQueue.h	/^  static Options cacheChainLength() {$/;"	f	class:folly::IOBufQueue	access:public	signature:()
folly::IOBufQueue::chainLength	.\io\IOBufQueue.h	/^  size_t chainLength() const {$/;"	f	class:folly::IOBufQueue	access:public	signature:() const
folly::IOBufQueue::chainLength_	.\io\IOBufQueue.h	/^  size_t chainLength_;$/;"	m	class:folly::IOBufQueue	access:private
folly::IOBufQueue::clear	.\io\IOBufQueue.cpp	/^void IOBufQueue::clear() {$/;"	f	class:folly::IOBufQueue	signature:()
folly::IOBufQueue::clear	.\io\IOBufQueue.h	/^  void clear();$/;"	p	class:folly::IOBufQueue	access:public	signature:()
folly::IOBufQueue::empty	.\io\IOBufQueue.h	/^  bool empty() const {$/;"	f	class:folly::IOBufQueue	access:public	signature:() const
folly::IOBufQueue::front	.\io\IOBufQueue.h	/^  const folly::IOBuf* front() const {$/;"	f	class:folly::IOBufQueue	access:public	signature:() const
folly::IOBufQueue::head_	.\io\IOBufQueue.h	/^  std::unique_ptr<folly::IOBuf> head_;$/;"	m	class:folly::IOBufQueue	access:private
folly::IOBufQueue::headroom	.\io\IOBufQueue.cpp	/^IOBufQueue::headroom() {$/;"	f	class:folly::IOBufQueue	signature:()
folly::IOBufQueue::headroom	.\io\IOBufQueue.h	/^  std::pair<void*, uint64_t> headroom();$/;"	p	class:folly::IOBufQueue	access:public	signature:()
folly::IOBufQueue::kChainLengthNotCached	.\io\IOBufQueue.h	/^  static const size_t kChainLengthNotCached = (size_t)-1;$/;"	m	class:folly::IOBufQueue	access:private
folly::IOBufQueue::markPrepended	.\io\IOBufQueue.cpp	/^IOBufQueue::markPrepended(uint64_t n) {$/;"	f	class:folly::IOBufQueue	signature:(uint64_t n)
folly::IOBufQueue::markPrepended	.\io\IOBufQueue.h	/^  void markPrepended(uint64_t n);$/;"	p	class:folly::IOBufQueue	access:public	signature:(uint64_t n)
folly::IOBufQueue::move	.\io\IOBufQueue.h	/^  std::unique_ptr<folly::IOBuf> move() {$/;"	f	class:folly::IOBufQueue	access:public	signature:()
folly::IOBufQueue::operator =	.\io\IOBufQueue.cpp	/^IOBufQueue& IOBufQueue::operator=(IOBufQueue&& other) {$/;"	f	class:folly::IOBufQueue	signature:(IOBufQueue&& other)
folly::IOBufQueue::operator =	.\io\IOBufQueue.h	/^  IOBufQueue& operator=(IOBufQueue&&);$/;"	p	class:folly::IOBufQueue	access:public	signature:(IOBufQueue&&)
folly::IOBufQueue::operator =	.\io\IOBufQueue.h	/^  IOBufQueue& operator=(const IOBufQueue&) = delete;$/;"	p	class:folly::IOBufQueue	access:private	signature:(const IOBufQueue&)
folly::IOBufQueue::options	.\io\IOBufQueue.h	/^  const Options& options() const {$/;"	f	class:folly::IOBufQueue	access:public	signature:() const
folly::IOBufQueue::options_	.\io\IOBufQueue.h	/^  Options options_;$/;"	m	class:folly::IOBufQueue	access:private
folly::IOBufQueue::pop_front	.\io\IOBufQueue.cpp	/^std::unique_ptr<folly::IOBuf> IOBufQueue::pop_front() {$/;"	f	class:folly::IOBufQueue	signature:()
folly::IOBufQueue::pop_front	.\io\IOBufQueue.h	/^  std::unique_ptr<folly::IOBuf> pop_front();$/;"	p	class:folly::IOBufQueue	access:public	signature:()
folly::IOBufQueue::postallocate	.\io\IOBufQueue.h	/^  void postallocate(uint64_t n) {$/;"	f	class:folly::IOBufQueue	access:public	signature:(uint64_t n)
folly::IOBufQueue::preallocate	.\io\IOBufQueue.h	/^  std::pair<void*,uint64_t> preallocate($/;"	f	class:folly::IOBufQueue	access:public	signature:( uint64_t min, uint64_t newAllocationSize, uint64_t max = std::numeric_limits<uint64_t>::max())
folly::IOBufQueue::preallocateSlow	.\io\IOBufQueue.cpp	/^IOBufQueue::preallocateSlow(uint64_t min, uint64_t newAllocationSize,$/;"	f	class:folly::IOBufQueue	signature:(uint64_t min, uint64_t newAllocationSize, uint64_t max)
folly::IOBufQueue::preallocateSlow	.\io\IOBufQueue.h	/^  std::pair<void*,uint64_t> preallocateSlow($/;"	p	class:folly::IOBufQueue	access:private	signature:( uint64_t min, uint64_t newAllocationSize, uint64_t max)
folly::IOBufQueue::prepend	.\io\IOBufQueue.cpp	/^IOBufQueue::prepend(const void* buf, uint64_t n) {$/;"	f	class:folly::IOBufQueue	signature:(const void* buf, uint64_t n)
folly::IOBufQueue::prepend	.\io\IOBufQueue.h	/^  void prepend(const void* buf, uint64_t n);$/;"	p	class:folly::IOBufQueue	access:public	signature:(const void* buf, uint64_t n)
folly::IOBufQueue::split	.\io\IOBufQueue.cpp	/^IOBufQueue::split(size_t n) {$/;"	f	class:folly::IOBufQueue	signature:(size_t n)
folly::IOBufQueue::split	.\io\IOBufQueue.h	/^  std::unique_ptr<folly::IOBuf> split(size_t n);$/;"	p	class:folly::IOBufQueue	access:public	signature:(size_t n)
folly::IOBufQueue::tailBuf	.\io\IOBufQueue.h	/^  IOBuf* tailBuf() const {$/;"	f	class:folly::IOBufQueue	access:private	signature:() const
folly::IOBufQueue::tailroom	.\io\IOBufQueue.h	/^  size_t tailroom() const {$/;"	f	class:folly::IOBufQueue	access:public	signature:() const
folly::IOBufQueue::trimEnd	.\io\IOBufQueue.cpp	/^void IOBufQueue::trimEnd(size_t amount) {$/;"	f	class:folly::IOBufQueue	signature:(size_t amount)
folly::IOBufQueue::trimEnd	.\io\IOBufQueue.h	/^  void trimEnd(size_t amount);$/;"	p	class:folly::IOBufQueue	access:public	signature:(size_t amount)
folly::IOBufQueue::trimStart	.\io\IOBufQueue.cpp	/^void IOBufQueue::trimStart(size_t amount) {$/;"	f	class:folly::IOBufQueue	signature:(size_t amount)
folly::IOBufQueue::trimStart	.\io\IOBufQueue.h	/^  void trimStart(size_t amount);$/;"	p	class:folly::IOBufQueue	access:public	signature:(size_t amount)
folly::IOBufQueue::wrapBuffer	.\io\IOBufQueue.cpp	/^IOBufQueue::wrapBuffer(const void* buf, size_t len, uint64_t blockSize) {$/;"	f	class:folly::IOBufQueue	signature:(const void* buf, size_t len, uint64_t blockSize)
folly::IOBufQueue::wrapBuffer	.\io\IOBufQueue.h	/^  void wrapBuffer(const void* buf, size_t len,$/;"	p	class:folly::IOBufQueue	access:public	signature:(const void* buf, size_t len, uint64_t blockSize=(1U << 31))
folly::IOBufQueue::writableTail	.\io\IOBufQueue.h	/^  void* writableTail() const {$/;"	f	class:folly::IOBufQueue	access:public	signature:() const
folly::IPAddress	.\IPAddress.h	/^class IPAddress : boost::totally_ordered<IPAddress> {$/;"	c	namespace:folly	inherits:boost::totally_ordered
folly::IPAddress	.\IPAddress.h	/^class IPAddress;$/;"	x
folly::IPAddress	.\IPAddressV4.h	/^class IPAddress;$/;"	x
folly::IPAddress	.\IPAddressV6.h	/^class IPAddress;$/;"	x
folly::IPAddress	.\test\IPAddressTest.h	/^class IPAddress;$/;"	x
folly::IPAddress::IPAddress	.\IPAddress.cpp	/^IPAddress::IPAddress()$/;"	f	class:folly::IPAddress	signature:()
folly::IPAddress::IPAddress	.\IPAddress.cpp	/^IPAddress::IPAddress(StringPiece addr)$/;"	f	class:folly::IPAddress	signature:(StringPiece addr)
folly::IPAddress::IPAddress	.\IPAddress.cpp	/^IPAddress::IPAddress(const IPAddressV4 ipV4Addr)$/;"	f	class:folly::IPAddress	signature:(const IPAddressV4 ipV4Addr)
folly::IPAddress::IPAddress	.\IPAddress.cpp	/^IPAddress::IPAddress(const IPAddressV6& ipV6Addr)$/;"	f	class:folly::IPAddress	signature:(const IPAddressV6& ipV6Addr)
folly::IPAddress::IPAddress	.\IPAddress.cpp	/^IPAddress::IPAddress(const in6_addr& ipV6Addr)$/;"	f	class:folly::IPAddress	signature:(const in6_addr& ipV6Addr)
folly::IPAddress::IPAddress	.\IPAddress.cpp	/^IPAddress::IPAddress(const in_addr ipV4Addr)$/;"	f	class:folly::IPAddress	signature:(const in_addr ipV4Addr)
folly::IPAddress::IPAddress	.\IPAddress.cpp	/^IPAddress::IPAddress(const sockaddr* addr)$/;"	f	class:folly::IPAddress	signature:(const sockaddr* addr)
folly::IPAddress::IPAddress	.\IPAddress.h	/^  IPAddress();$/;"	p	class:folly::IPAddress	access:public	signature:()
folly::IPAddress::IPAddress	.\IPAddress.h	/^  \/* implicit *\/ IPAddress(const IPAddressV4 ipV4Addr);$/;"	p	class:folly::IPAddress	access:public	signature:(const IPAddressV4 ipV4Addr)
folly::IPAddress::IPAddress	.\IPAddress.h	/^  \/* implicit *\/ IPAddress(const IPAddressV6& ipV6Addr);$/;"	p	class:folly::IPAddress	access:public	signature:(const IPAddressV6& ipV6Addr)
folly::IPAddress::IPAddress	.\IPAddress.h	/^  \/* implicit *\/ IPAddress(const in6_addr& addr);$/;"	p	class:folly::IPAddress	access:public	signature:(const in6_addr& addr)
folly::IPAddress::IPAddress	.\IPAddress.h	/^  \/* implicit *\/ IPAddress(const in_addr addr);$/;"	p	class:folly::IPAddress	access:public	signature:(const in_addr addr)
folly::IPAddress::IPAddress	.\IPAddress.h	/^  explicit IPAddress(StringPiece ip);$/;"	p	class:folly::IPAddress	access:public	signature:(StringPiece ip)
folly::IPAddress::IPAddress	.\IPAddress.h	/^  explicit IPAddress(const sockaddr* addr);$/;"	p	class:folly::IPAddress	access:public	signature:(const sockaddr* addr)
folly::IPAddress::IPAddressV46	.\IPAddress.h	/^  typedef union IPAddressV46 {$/;"	u	class:folly::IPAddress	access:private
folly::IPAddress::IPAddressV46	.\IPAddress.h	/^  } IPAddressV46;$/;"	t	class:folly::IPAddress	typeref:union:folly::IPAddress::IPAddressV46	access:private
folly::IPAddress::IPAddressV46::IPAddressV46	.\IPAddress.h	/^    IPAddressV46() {$/;"	f	union:folly::IPAddress::IPAddressV46	access:public	signature:()
folly::IPAddress::IPAddressV46::IPAddressV46	.\IPAddress.h	/^    explicit IPAddressV46(const IPAddressV4& addr): ipV4Addr(addr) {}$/;"	f	union:folly::IPAddress::IPAddressV46	access:public	signature:(const IPAddressV4& addr)
folly::IPAddress::IPAddressV46::IPAddressV46	.\IPAddress.h	/^    explicit IPAddressV46(const IPAddressV6& addr): ipV6Addr(addr) {}$/;"	f	union:folly::IPAddress::IPAddressV46	access:public	signature:(const IPAddressV6& addr)
folly::IPAddress::IPAddressV46::ipV4Addr	.\IPAddress.h	/^    IPAddressV4 ipV4Addr;$/;"	m	union:folly::IPAddress::IPAddressV46	access:public
folly::IPAddress::IPAddressV46::ipV6Addr	.\IPAddress.h	/^    IPAddressV6 ipV6Addr;$/;"	m	union:folly::IPAddress::IPAddressV46	access:public
folly::IPAddress::addr_	.\IPAddress.h	/^  IPAddressV46 addr_;$/;"	m	class:folly::IPAddress	access:private
folly::IPAddress::asV4	.\IPAddress.h	/^  const IPAddressV4& asV4() const {$/;"	f	class:folly::IPAddress	access:public	signature:() const
folly::IPAddress::asV6	.\IPAddress.h	/^  const IPAddressV6& asV6() const {$/;"	f	class:folly::IPAddress	access:public	signature:() const
folly::IPAddress::bitCount	.\IPAddress.h	/^  size_t bitCount() const {$/;"	f	class:folly::IPAddress	access:public	signature:() const
folly::IPAddress::byteCount	.\IPAddress.h	/^  size_t byteCount() const {$/;"	f	class:folly::IPAddress	access:public	signature:() const
folly::IPAddress::bytes	.\IPAddress.h	/^  const unsigned char* bytes() const {$/;"	f	class:folly::IPAddress	access:public	signature:() const
folly::IPAddress::createIPv4	.\IPAddress.cpp	/^IPAddressV4 IPAddress::createIPv4(const IPAddress& addr) {$/;"	f	class:folly::IPAddress	signature:(const IPAddress& addr)
folly::IPAddress::createIPv4	.\IPAddress.h	/^  static IPAddressV4 createIPv4(const IPAddress& addr);$/;"	p	class:folly::IPAddress	access:public	signature:(const IPAddress& addr)
folly::IPAddress::createIPv6	.\IPAddress.cpp	/^IPAddressV6 IPAddress::createIPv6(const IPAddress& addr) {$/;"	f	class:folly::IPAddress	signature:(const IPAddress& addr)
folly::IPAddress::createIPv6	.\IPAddress.h	/^  static IPAddressV6 createIPv6(const IPAddress& addr);$/;"	p	class:folly::IPAddress	access:public	signature:(const IPAddress& addr)
folly::IPAddress::createNetwork	.\IPAddress.cpp	/^CIDRNetwork IPAddress::createNetwork(StringPiece ipSlashCidr,$/;"	f	class:folly::IPAddress	signature:(StringPiece ipSlashCidr, int defaultCidr, bool applyMask )
folly::IPAddress::createNetwork	.\IPAddress.h	/^  static CIDRNetwork createNetwork($/;"	p	class:folly::IPAddress	access:public	signature:( StringPiece ipSlashCidr, int defaultCidr = -1, bool mask = true)
folly::IPAddress::empty	.\IPAddress.h	/^  bool empty() const { return (family_ == AF_UNSPEC); }$/;"	f	class:folly::IPAddress	access:public	signature:() const
folly::IPAddress::family	.\IPAddress.h	/^  sa_family_t family() const { return family_; }$/;"	f	class:folly::IPAddress	access:public	signature:() const
folly::IPAddress::family_	.\IPAddress.h	/^  sa_family_t family_;$/;"	m	class:folly::IPAddress	access:private
folly::IPAddress::fromBinary	.\IPAddress.cpp	/^IPAddress IPAddress::fromBinary(ByteRange bytes) {$/;"	f	class:folly::IPAddress	signature:(ByteRange bytes)
folly::IPAddress::fromBinary	.\IPAddress.h	/^  static IPAddress fromBinary(ByteRange bytes);$/;"	p	class:folly::IPAddress	access:public	signature:(ByteRange bytes)
folly::IPAddress::fromLong	.\IPAddress.cpp	/^IPAddress IPAddress::fromLong(uint32_t src) {$/;"	f	class:folly::IPAddress	signature:(uint32_t src)
folly::IPAddress::fromLong	.\IPAddress.h	/^  static IPAddress fromLong(uint32_t src);$/;"	p	class:folly::IPAddress	access:public	signature:(uint32_t src)
folly::IPAddress::fromLongHBO	.\IPAddress.cpp	/^IPAddress IPAddress::fromLongHBO(uint32_t src) {$/;"	f	class:folly::IPAddress	signature:(uint32_t src)
folly::IPAddress::fromLongHBO	.\IPAddress.h	/^  static IPAddress fromLongHBO(uint32_t src);$/;"	p	class:folly::IPAddress	access:public	signature:(uint32_t src)
folly::IPAddress::getNthLSBit	.\IPAddress.h	/^  bool getNthLSBit(size_t bitIndex) const {$/;"	f	class:folly::IPAddress	access:public	signature:(size_t bitIndex) const
folly::IPAddress::getNthLSByte	.\IPAddress.h	/^  uint8_t getNthLSByte(size_t byteIndex) const {$/;"	f	class:folly::IPAddress	access:public	signature:(size_t byteIndex) const
folly::IPAddress::getNthMSBit	.\IPAddress.h	/^  bool getNthMSBit(size_t bitIndex) const {$/;"	f	class:folly::IPAddress	access:public	signature:(size_t bitIndex) const
folly::IPAddress::getNthMSByte	.\IPAddress.cpp	/^uint8_t IPAddress::getNthMSByte(size_t byteIndex) const {$/;"	f	class:folly::IPAddress	signature:(size_t byteIndex) const
folly::IPAddress::getNthMSByte	.\IPAddress.h	/^  uint8_t getNthMSByte(size_t byteIndex) const;$/;"	p	class:folly::IPAddress	access:public	signature:(size_t byteIndex) const
folly::IPAddress::hash	.\IPAddress.h	/^  std::size_t hash() const {$/;"	f	class:folly::IPAddress	access:public	signature:() const
folly::IPAddress::inSubnet	.\IPAddress.cpp	/^bool IPAddress::inSubnet(StringPiece cidrNetwork) const {$/;"	f	class:folly::IPAddress	signature:(StringPiece cidrNetwork) const
folly::IPAddress::inSubnet	.\IPAddress.cpp	/^bool IPAddress::inSubnet(const IPAddress& subnet, uint8_t cidr) const {$/;"	f	class:folly::IPAddress	signature:(const IPAddress& subnet, uint8_t cidr) const
folly::IPAddress::inSubnet	.\IPAddress.h	/^  bool inSubnet(StringPiece ipSlashCidr) const;$/;"	p	class:folly::IPAddress	access:public	signature:(StringPiece ipSlashCidr) const
folly::IPAddress::inSubnet	.\IPAddress.h	/^  bool inSubnet(const IPAddress& subnet, uint8_t cidr) const;$/;"	p	class:folly::IPAddress	access:public	signature:(const IPAddress& subnet, uint8_t cidr) const
folly::IPAddress::inSubnetWithMask	.\IPAddress.cpp	/^bool IPAddress::inSubnetWithMask(const IPAddress& subnet,$/;"	f	class:folly::IPAddress	signature:(const IPAddress& subnet, ByteRange mask) const
folly::IPAddress::inSubnetWithMask	.\IPAddress.h	/^  bool inSubnetWithMask(const IPAddress& subnet, ByteRange mask) const;$/;"	p	class:folly::IPAddress	access:public	signature:(const IPAddress& subnet, ByteRange mask) const
folly::IPAddress::isIPv4Mapped	.\IPAddress.h	/^  bool isIPv4Mapped() const {$/;"	f	class:folly::IPAddress	access:public	signature:() const
folly::IPAddress::isLinkLocalBroadcast	.\IPAddress.h	/^  bool isLinkLocalBroadcast() const {$/;"	f	class:folly::IPAddress	access:public	signature:() const
folly::IPAddress::isLoopback	.\IPAddress.h	/^  bool isLoopback() const {$/;"	f	class:folly::IPAddress	access:public	signature:() const
folly::IPAddress::isMulticast	.\IPAddress.h	/^  bool isMulticast() const {$/;"	f	class:folly::IPAddress	access:public	signature:() const
folly::IPAddress::isNonroutable	.\IPAddress.h	/^  bool isNonroutable() const {$/;"	f	class:folly::IPAddress	access:public	signature:() const
folly::IPAddress::isPrivate	.\IPAddress.h	/^  bool isPrivate() const {$/;"	f	class:folly::IPAddress	access:public	signature:() const
folly::IPAddress::isV4	.\IPAddress.h	/^  bool isV4() const { return (family_ == AF_INET); }$/;"	f	class:folly::IPAddress	access:public	signature:() const
folly::IPAddress::isV6	.\IPAddress.h	/^  bool isV6() const { return (family_ == AF_INET6); }$/;"	f	class:folly::IPAddress	access:public	signature:() const
folly::IPAddress::isZero	.\IPAddress.h	/^  bool isZero() const {$/;"	f	class:folly::IPAddress	access:public	signature:() const
folly::IPAddress::longestCommonPrefix	.\IPAddress.cpp	/^IPAddress::longestCommonPrefix(const CIDRNetwork& one, const CIDRNetwork& two) {$/;"	f	class:folly::IPAddress	signature:(const CIDRNetwork& one, const CIDRNetwork& two)
folly::IPAddress::longestCommonPrefix	.\IPAddress.h	/^  static CIDRNetwork longestCommonPrefix(const CIDRNetwork& one,$/;"	p	class:folly::IPAddress	access:public	signature:(const CIDRNetwork& one, const CIDRNetwork& two)
folly::IPAddress::mask	.\IPAddress.h	/^  IPAddress mask(uint8_t numBits) const {$/;"	f	class:folly::IPAddress	access:public	signature:(uint8_t numBits) const
folly::IPAddress::networkToString	.\IPAddress.h	/^  static std::string networkToString(const CIDRNetwork& network) {$/;"	f	class:folly::IPAddress	access:public	signature:(const CIDRNetwork& network)
folly::IPAddress::operator =	.\IPAddress.cpp	/^IPAddress& IPAddress::operator=(const IPAddressV4& ipv4_addr) {$/;"	f	class:folly::IPAddress	signature:(const IPAddressV4& ipv4_addr)
folly::IPAddress::operator =	.\IPAddress.cpp	/^IPAddress& IPAddress::operator=(const IPAddressV6& ipv6_addr) {$/;"	f	class:folly::IPAddress	signature:(const IPAddressV6& ipv6_addr)
folly::IPAddress::operator =	.\IPAddress.h	/^  IPAddress& operator=(const IPAddressV4& ipV4Addr);$/;"	p	class:folly::IPAddress	access:public	signature:(const IPAddressV4& ipV4Addr)
folly::IPAddress::operator =	.\IPAddress.h	/^  IPAddress& operator=(const IPAddressV6& ipV6Addr);$/;"	p	class:folly::IPAddress	access:public	signature:(const IPAddressV6& ipV6Addr)
folly::IPAddress::operator bool	.\IPAddress.h	/^  explicit operator bool() const { return !empty(); }$/;"	f	class:folly::IPAddress	access:public	signature:() const
folly::IPAddress::str	.\IPAddress.h	/^  std::string str() const {$/;"	f	class:folly::IPAddress	access:public	signature:() const
folly::IPAddress::toFullyQualified	.\IPAddress.h	/^  std::string toFullyQualified() const {$/;"	f	class:folly::IPAddress	access:public	signature:() const
folly::IPAddress::toJson	.\IPAddress.h	/^  std::string toJson() const {$/;"	f	class:folly::IPAddress	access:public	signature:() const
folly::IPAddress::toSockaddrStorage	.\IPAddress.h	/^  int toSockaddrStorage(sockaddr_storage *dest, uint16_t port = 0) const {$/;"	f	class:folly::IPAddress	access:public	signature:(sockaddr_storage *dest, uint16_t port = 0) const
folly::IPAddress::version	.\IPAddress.h	/^  uint8_t version() const {$/;"	f	class:folly::IPAddress	access:public	signature:() const
folly::IPAddressBitAccessorTest	.\test\IPAddressTest.h	/^struct IPAddressBitAccessorTest:$/;"	s	namespace:folly	inherits:::testing::TestWithParam
folly::IPAddressByteAccessorTest	.\test\IPAddressTest.h	/^struct IPAddressByteAccessorTest:$/;"	s	namespace:folly	inherits:::testing::TestWithParam
folly::IPAddressCtorBinaryTest	.\test\IPAddressTest.h	/^struct IPAddressCtorBinaryTest : public ::testing::TestWithParam<ByteVector> {};$/;"	s	namespace:folly	inherits:::testing::TestWithParam
folly::IPAddressCtorTest	.\test\IPAddressTest.h	/^struct IPAddressCtorTest : public ::testing::TestWithParam<std::string> {};$/;"	s	namespace:folly	inherits:::testing::TestWithParam
folly::IPAddressFlagTest	.\test\IPAddressTest.h	/^struct IPAddressFlagTest : public ::testing::TestWithParam<AddressFlags> {};$/;"	s	namespace:folly	inherits:::testing::TestWithParam
folly::IPAddressFormatException	.\IPAddressException.h	/^class IPAddressFormatException : public std::exception {$/;"	c	namespace:folly	inherits:std::exception
folly::IPAddressFormatException::IPAddressFormatException	.\IPAddressException.h	/^  explicit IPAddressFormatException(Args&&... args)$/;"	f	class:folly::IPAddressFormatException	access:public	signature:(Args&&.... args)
folly::IPAddressFormatException::IPAddressFormatException	.\IPAddressException.h	/^  explicit IPAddressFormatException(const std::string& msg)$/;"	f	class:folly::IPAddressFormatException	access:public	signature:(const std::string& msg)
folly::IPAddressFormatException::exception_	.\IPAddressException.h	/^    const IPAddressFormatException& exception_) = default;$/;"	m	class:folly::IPAddressFormatException	access:public
folly::IPAddressFormatException::msg_	.\IPAddressException.h	/^  const std::string msg_;$/;"	m	class:folly::IPAddressFormatException	access:private
folly::IPAddressMappedTest	.\test\IPAddressTest.h	/^struct IPAddressMappedTest :$/;"	s	namespace:folly	inherits:::testing::TestWithParam
folly::IPAddressMaskBoundaryTest	.\test\IPAddressTest.h	/^struct IPAddressMaskBoundaryTest :$/;"	s	namespace:folly	inherits:::testing::TestWithParam
folly::IPAddressMaskTest	.\test\IPAddressTest.h	/^struct IPAddressMaskTest : public ::testing::TestWithParam<MaskData> {};$/;"	s	namespace:folly	inherits:::testing::TestWithParam
folly::IPAddressSerializeTest	.\test\IPAddressTest.h	/^struct IPAddressSerializeTest :$/;"	s	namespace:folly	inherits:::testing::TestWithParam
folly::IPAddressTest	.\test\IPAddressTest.h	/^struct IPAddressTest : public ::testing::TestWithParam<AddressData> {$/;"	s	namespace:folly	inherits:::testing::TestWithParam
folly::IPAddressTest::ExpectIsValid	.\test\IPAddressTest.h	/^  void ExpectIsValid(const IPAddress& addr) {$/;"	f	struct:folly::IPAddressTest	access:public	signature:(const IPAddress& addr)
folly::IPAddressV4	.\IPAddressV4.h	/^class IPAddressV4 : boost::totally_ordered<IPAddressV4> {$/;"	c	namespace:folly	inherits:boost::totally_ordered
folly::IPAddressV4	.\IPAddressV4.h	/^class IPAddressV4;$/;"	x
folly::IPAddressV4	.\IPAddressV6.h	/^class IPAddressV4;$/;"	x
folly::IPAddressV4::AddressStorage	.\IPAddressV4.h	/^  union AddressStorage {$/;"	u	class:folly::IPAddressV4	access:private
folly::IPAddressV4::AddressStorage::AddressStorage	.\IPAddressV4.h	/^    AddressStorage() {$/;"	f	union:folly::IPAddressV4::AddressStorage	access:public	signature:()
folly::IPAddressV4::AddressStorage::AddressStorage	.\IPAddressV4.h	/^    explicit AddressStorage(const ByteArray4 bytes): bytes_(bytes) {}$/;"	f	union:folly::IPAddressV4::AddressStorage	access:public	signature:(const ByteArray4 bytes)
folly::IPAddressV4::AddressStorage::AddressStorage	.\IPAddressV4.h	/^    explicit AddressStorage(const in_addr addr): inAddr_(addr) {}$/;"	f	union:folly::IPAddressV4::AddressStorage	access:public	signature:(const in_addr addr)
folly::IPAddressV4::AddressStorage::bytes_	.\IPAddressV4.h	/^    ByteArray4 bytes_;$/;"	m	union:folly::IPAddressV4::AddressStorage	access:public
folly::IPAddressV4::AddressStorage::inAddr_	.\IPAddressV4.h	/^    in_addr inAddr_;$/;"	m	union:folly::IPAddressV4::AddressStorage	access:public
folly::IPAddressV4::IPAddressV4	.\IPAddressV4.cpp	/^IPAddressV4::IPAddressV4() {$/;"	f	class:folly::IPAddressV4	signature:()
folly::IPAddressV4::IPAddressV4	.\IPAddressV4.cpp	/^IPAddressV4::IPAddressV4(StringPiece addr)$/;"	f	class:folly::IPAddressV4	signature:(StringPiece addr)
folly::IPAddressV4::IPAddressV4	.\IPAddressV4.cpp	/^IPAddressV4::IPAddressV4(const ByteArray4& src)$/;"	f	class:folly::IPAddressV4	signature:(const ByteArray4& src)
folly::IPAddressV4::IPAddressV4	.\IPAddressV4.cpp	/^IPAddressV4::IPAddressV4(const in_addr src)$/;"	f	class:folly::IPAddressV4	signature:(const in_addr src)
folly::IPAddressV4::IPAddressV4	.\IPAddressV4.h	/^  IPAddressV4();$/;"	p	class:folly::IPAddressV4	access:public	signature:()
folly::IPAddressV4::IPAddressV4	.\IPAddressV4.h	/^  explicit IPAddressV4(StringPiece ip);$/;"	p	class:folly::IPAddressV4	access:public	signature:(StringPiece ip)
folly::IPAddressV4::IPAddressV4	.\IPAddressV4.h	/^  explicit IPAddressV4(const ByteArray4& src);$/;"	p	class:folly::IPAddressV4	access:public	signature:(const ByteArray4& src)
folly::IPAddressV4::IPAddressV4	.\IPAddressV4.h	/^  explicit IPAddressV4(const in_addr src);$/;"	p	class:folly::IPAddressV4	access:public	signature:(const in_addr src)
folly::IPAddressV4::addr_	.\IPAddressV4.h	/^  } addr_;$/;"	m	class:folly::IPAddressV4	typeref:union:folly::IPAddressV4::AddressStorage	access:private
folly::IPAddressV4::bitCount	.\IPAddressV4.h	/^  static size_t bitCount() { return 32; }$/;"	f	class:folly::IPAddressV4	access:public	signature:()
folly::IPAddressV4::byteCount	.\IPAddressV4.h	/^  static size_t byteCount() { return 4; }$/;"	f	class:folly::IPAddressV4	access:public	signature:()
folly::IPAddressV4::bytes	.\IPAddressV4.h	/^  const unsigned char* bytes() const { return addr_.bytes_.data(); }$/;"	f	class:folly::IPAddressV4	access:public	signature:() const
folly::IPAddressV4::createIPv6	.\IPAddressV4.cpp	/^IPAddressV6 IPAddressV4::createIPv6() const {$/;"	f	class:folly::IPAddressV4	signature:() const
folly::IPAddressV4::createIPv6	.\IPAddressV4.h	/^  IPAddressV6 createIPv6() const;$/;"	p	class:folly::IPAddressV4	access:public	signature:() const
folly::IPAddressV4::fetchMask	.\IPAddressV4.cpp	/^const ByteArray4 IPAddressV4::fetchMask(size_t numBits) {$/;"	f	class:folly::IPAddressV4	signature:(size_t numBits)
folly::IPAddressV4::fetchMask	.\IPAddressV4.h	/^  static const ByteArray4 fetchMask(size_t numBits);$/;"	p	class:folly::IPAddressV4	access:public	signature:(size_t numBits)
folly::IPAddressV4::fromBinary	.\IPAddressV4.h	/^  static IPAddressV4 fromBinary(ByteRange bytes) {$/;"	f	class:folly::IPAddressV4	access:public	signature:(ByteRange bytes)
folly::IPAddressV4::fromLong	.\IPAddressV4.cpp	/^IPAddressV4 IPAddressV4::fromLong(uint32_t src) {$/;"	f	class:folly::IPAddressV4	signature:(uint32_t src)
folly::IPAddressV4::fromLong	.\IPAddressV4.h	/^  static IPAddressV4 fromLong(uint32_t src);$/;"	p	class:folly::IPAddressV4	access:public	signature:(uint32_t src)
folly::IPAddressV4::fromLongHBO	.\IPAddressV4.cpp	/^IPAddressV4 IPAddressV4::fromLongHBO(uint32_t src) {$/;"	f	class:folly::IPAddressV4	signature:(uint32_t src)
folly::IPAddressV4::fromLongHBO	.\IPAddressV4.h	/^  static IPAddressV4 fromLongHBO(uint32_t src);$/;"	p	class:folly::IPAddressV4	access:public	signature:(uint32_t src)
folly::IPAddressV4::getNthLSBit	.\IPAddressV4.h	/^  bool getNthLSBit(size_t bitIndex) const {$/;"	f	class:folly::IPAddressV4	access:public	signature:(size_t bitIndex) const
folly::IPAddressV4::getNthLSByte	.\IPAddressV4.h	/^  uint8_t getNthLSByte(size_t byteIndex) const {$/;"	f	class:folly::IPAddressV4	access:public	signature:(size_t byteIndex) const
folly::IPAddressV4::getNthMSBit	.\IPAddressV4.h	/^  bool getNthMSBit(size_t bitIndex) const {$/;"	f	class:folly::IPAddressV4	access:public	signature:(size_t bitIndex) const
folly::IPAddressV4::getNthMSByte	.\IPAddressV4.cpp	/^uint8_t IPAddressV4::getNthMSByte(size_t byteIndex) const {$/;"	f	class:folly::IPAddressV4	signature:(size_t byteIndex) const
folly::IPAddressV4::getNthMSByte	.\IPAddressV4.h	/^  uint8_t getNthMSByte(size_t byteIndex) const;$/;"	p	class:folly::IPAddressV4	access:public	signature:(size_t byteIndex) const
folly::IPAddressV4::hash	.\IPAddressV4.h	/^  size_t hash() const {$/;"	f	class:folly::IPAddressV4	access:public	signature:() const
folly::IPAddressV4::inSubnet	.\IPAddressV4.cpp	/^bool IPAddressV4::inSubnet(StringPiece cidrNetwork) const {$/;"	f	class:folly::IPAddressV4	signature:(StringPiece cidrNetwork) const
folly::IPAddressV4::inSubnet	.\IPAddressV4.h	/^  bool inSubnet(StringPiece cidrNetwork) const;$/;"	p	class:folly::IPAddressV4	access:public	signature:(StringPiece cidrNetwork) const
folly::IPAddressV4::inSubnet	.\IPAddressV4.h	/^  bool inSubnet(const IPAddressV4& subnet, uint8_t cidr) const {$/;"	f	class:folly::IPAddressV4	access:public	signature:(const IPAddressV4& subnet, uint8_t cidr) const
folly::IPAddressV4::inSubnetWithMask	.\IPAddressV4.cpp	/^bool IPAddressV4::inSubnetWithMask(const IPAddressV4& subnet,$/;"	f	class:folly::IPAddressV4	signature:(const IPAddressV4& subnet, const ByteArray4 cidrMask) const
folly::IPAddressV4::inSubnetWithMask	.\IPAddressV4.h	/^  bool inSubnetWithMask(const IPAddressV4& subnet, const ByteArray4 mask) const;$/;"	p	class:folly::IPAddressV4	access:public	signature:(const IPAddressV4& subnet, const ByteArray4 mask) const
folly::IPAddressV4::isLinkLocalBroadcast	.\IPAddressV4.h	/^  bool isLinkLocalBroadcast() const {$/;"	f	class:folly::IPAddressV4	access:public	signature:() const
folly::IPAddressV4::isLoopback	.\IPAddressV4.cpp	/^bool IPAddressV4::isLoopback() const {$/;"	f	class:folly::IPAddressV4	signature:() const
folly::IPAddressV4::isLoopback	.\IPAddressV4.h	/^  bool isLoopback() const;$/;"	p	class:folly::IPAddressV4	access:public	signature:() const
folly::IPAddressV4::isMulticast	.\IPAddressV4.cpp	/^bool IPAddressV4::isMulticast() const {$/;"	f	class:folly::IPAddressV4	signature:() const
folly::IPAddressV4::isMulticast	.\IPAddressV4.h	/^  bool isMulticast() const;$/;"	p	class:folly::IPAddressV4	access:public	signature:() const
folly::IPAddressV4::isNonroutable	.\IPAddressV4.cpp	/^bool IPAddressV4::isNonroutable() const {$/;"	f	class:folly::IPAddressV4	signature:() const
folly::IPAddressV4::isNonroutable	.\IPAddressV4.h	/^  bool isNonroutable() const;$/;"	p	class:folly::IPAddressV4	access:public	signature:() const
folly::IPAddressV4::isPrivate	.\IPAddressV4.cpp	/^bool IPAddressV4::isPrivate() const {$/;"	f	class:folly::IPAddressV4	signature:() const
folly::IPAddressV4::isPrivate	.\IPAddressV4.h	/^  bool isPrivate() const;$/;"	p	class:folly::IPAddressV4	access:public	signature:() const
folly::IPAddressV4::isZero	.\IPAddressV4.h	/^  bool isZero() const {$/;"	f	class:folly::IPAddressV4	access:public	signature:() const
folly::IPAddressV4::longestCommonPrefix	.\IPAddressV4.h	/^  static CIDRNetworkV4 longestCommonPrefix($/;"	f	class:folly::IPAddressV4	access:public	signature:( const CIDRNetworkV4& one, const CIDRNetworkV4& two)
folly::IPAddressV4::mask	.\IPAddressV4.cpp	/^IPAddressV4 IPAddressV4::mask(size_t numBits) const {$/;"	f	class:folly::IPAddressV4	signature:(size_t numBits) const
folly::IPAddressV4::mask	.\IPAddressV4.h	/^  IPAddressV4 mask(size_t numBits) const;$/;"	p	class:folly::IPAddressV4	access:public	signature:(size_t numBits) const
folly::IPAddressV4::masks_	.\IPAddressV4.cpp	/^const std::array<ByteArray4, 33> IPAddressV4::masks_ = {{$/;"	m	class:folly::IPAddressV4	file:
folly::IPAddressV4::masks_	.\IPAddressV4.h	/^  static const std::array<ByteArray4, 33> masks_;$/;"	m	class:folly::IPAddressV4	access:private
folly::IPAddressV4::setFromBinary	.\IPAddressV4.cpp	/^void IPAddressV4::setFromBinary(ByteRange bytes) {$/;"	f	class:folly::IPAddressV4	signature:(ByteRange bytes)
folly::IPAddressV4::setFromBinary	.\IPAddressV4.h	/^  void setFromBinary(ByteRange bytes);$/;"	p	class:folly::IPAddressV4	access:private	signature:(ByteRange bytes)
folly::IPAddressV4::str	.\IPAddressV4.cpp	/^string IPAddressV4::str() const {$/;"	f	class:folly::IPAddressV4	signature:() const
folly::IPAddressV4::str	.\IPAddressV4.h	/^  std::string str() const;$/;"	p	class:folly::IPAddressV4	access:public	signature:() const
folly::IPAddressV4::toAddr	.\IPAddressV4.h	/^  in_addr toAddr() const { return addr_.inAddr_; }$/;"	f	class:folly::IPAddressV4	access:public	signature:() const
folly::IPAddressV4::toByteArray	.\IPAddressV4.h	/^  ByteArray4 toByteArray() const {$/;"	f	class:folly::IPAddressV4	access:public	signature:() const
folly::IPAddressV4::toFullyQualified	.\IPAddressV4.h	/^  std::string toFullyQualified() const { return str(); }$/;"	f	class:folly::IPAddressV4	access:public	signature:() const
folly::IPAddressV4::toJson	.\IPAddressV4.cpp	/^string IPAddressV4::toJson() const {$/;"	f	class:folly::IPAddressV4	signature:() const
folly::IPAddressV4::toJson	.\IPAddressV4.h	/^  std::string toJson() const;$/;"	p	class:folly::IPAddressV4	access:public	signature:() const
folly::IPAddressV4::toLong	.\IPAddressV4.cpp	/^uint32_t IPAddressV4::toLong(StringPiece ip) {$/;"	f	class:folly::IPAddressV4	signature:(StringPiece ip)
folly::IPAddressV4::toLong	.\IPAddressV4.h	/^  static uint32_t toLong(StringPiece ip);$/;"	p	class:folly::IPAddressV4	access:public	signature:(StringPiece ip)
folly::IPAddressV4::toLong	.\IPAddressV4.h	/^  uint32_t toLong() const {$/;"	f	class:folly::IPAddressV4	access:public	signature:() const
folly::IPAddressV4::toLongHBO	.\IPAddressV4.cpp	/^uint32_t IPAddressV4::toLongHBO(StringPiece ip) {$/;"	f	class:folly::IPAddressV4	signature:(StringPiece ip)
folly::IPAddressV4::toLongHBO	.\IPAddressV4.h	/^  static uint32_t toLongHBO(StringPiece ip);$/;"	p	class:folly::IPAddressV4	access:public	signature:(StringPiece ip)
folly::IPAddressV4::toLongHBO	.\IPAddressV4.h	/^  uint32_t toLongHBO() const {$/;"	f	class:folly::IPAddressV4	access:public	signature:() const
folly::IPAddressV4::toSockAddr	.\IPAddressV4.h	/^  sockaddr_in toSockAddr() const {$/;"	f	class:folly::IPAddressV4	access:public	signature:() const
folly::IPAddressV4::version	.\IPAddressV4.h	/^  size_t version() const { return 4; }$/;"	f	class:folly::IPAddressV4	access:public	signature:() const
folly::IPAddressV6	.\IPAddressV4.h	/^class IPAddressV6;$/;"	x
folly::IPAddressV6	.\IPAddressV6.h	/^class IPAddressV6 : boost::totally_ordered<IPAddressV6> {$/;"	c	namespace:folly	inherits:boost::totally_ordered
folly::IPAddressV6	.\IPAddressV6.h	/^class IPAddressV6;$/;"	x
folly::IPAddressV6	.\MacAddress.h	/^class IPAddressV6;$/;"	x
folly::IPAddressV6::AddressStorage	.\IPAddressV6.h	/^  union AddressStorage {$/;"	u	class:folly::IPAddressV6	access:private
folly::IPAddressV6::AddressStorage::AddressStorage	.\IPAddressV6.cpp	/^IPAddressV6::AddressStorage::AddressStorage(MacAddress mac) {$/;"	f	class:folly::IPAddressV6::AddressStorage	signature:(MacAddress mac)
folly::IPAddressV6::AddressStorage::AddressStorage	.\IPAddressV6.h	/^    AddressStorage() {$/;"	f	union:folly::IPAddressV6::AddressStorage	access:public	signature:()
folly::IPAddressV6::AddressStorage::AddressStorage	.\IPAddressV6.h	/^    explicit AddressStorage(MacAddress mac);$/;"	p	union:folly::IPAddressV6::AddressStorage	access:public	signature:(MacAddress mac)
folly::IPAddressV6::AddressStorage::AddressStorage	.\IPAddressV6.h	/^    explicit AddressStorage(const ByteArray16& bytes): bytes_(bytes) {}$/;"	f	union:folly::IPAddressV6::AddressStorage	access:public	signature:(const ByteArray16& bytes)
folly::IPAddressV6::AddressStorage::AddressStorage	.\IPAddressV6.h	/^    explicit AddressStorage(const in6_addr& addr): in6Addr_(addr) {}$/;"	f	union:folly::IPAddressV6::AddressStorage	access:public	signature:(const in6_addr& addr)
folly::IPAddressV6::AddressStorage::bytes_	.\IPAddressV6.h	/^    ByteArray16 bytes_;$/;"	m	union:folly::IPAddressV6::AddressStorage	access:public
folly::IPAddressV6::AddressStorage::in6Addr_	.\IPAddressV6.h	/^    in6_addr in6Addr_;$/;"	m	union:folly::IPAddressV6::AddressStorage	access:public
folly::IPAddressV6::IPAddressV6	.\IPAddressV6.cpp	/^IPAddressV6::IPAddressV6() {$/;"	f	class:folly::IPAddressV6	signature:()
folly::IPAddressV6::IPAddressV6	.\IPAddressV6.cpp	/^IPAddressV6::IPAddressV6(LinkLocalTag, MacAddress mac)$/;"	f	class:folly::IPAddressV6	signature:(LinkLocalTag, MacAddress mac)
folly::IPAddressV6::IPAddressV6	.\IPAddressV6.cpp	/^IPAddressV6::IPAddressV6(StringPiece addr) {$/;"	f	class:folly::IPAddressV6	signature:(StringPiece addr)
folly::IPAddressV6::IPAddressV6	.\IPAddressV6.cpp	/^IPAddressV6::IPAddressV6(const ByteArray16& src)$/;"	f	class:folly::IPAddressV6	signature:(const ByteArray16& src)
folly::IPAddressV6::IPAddressV6	.\IPAddressV6.cpp	/^IPAddressV6::IPAddressV6(const in6_addr& src)$/;"	f	class:folly::IPAddressV6	signature:(const in6_addr& src)
folly::IPAddressV6::IPAddressV6	.\IPAddressV6.cpp	/^IPAddressV6::IPAddressV6(const sockaddr_in6& src)$/;"	f	class:folly::IPAddressV6	signature:(const sockaddr_in6& src)
folly::IPAddressV6::IPAddressV6	.\IPAddressV6.h	/^  IPAddressV6();$/;"	p	class:folly::IPAddressV6	access:public	signature:()
folly::IPAddressV6::IPAddressV6	.\IPAddressV6.h	/^  IPAddressV6(LinkLocalTag tag, MacAddress mac);$/;"	p	class:folly::IPAddressV6	access:public	signature:(LinkLocalTag tag, MacAddress mac)
folly::IPAddressV6::IPAddressV6	.\IPAddressV6.h	/^  explicit IPAddressV6(StringPiece ip);$/;"	p	class:folly::IPAddressV6	access:public	signature:(StringPiece ip)
folly::IPAddressV6::IPAddressV6	.\IPAddressV6.h	/^  explicit IPAddressV6(const ByteArray16& src);$/;"	p	class:folly::IPAddressV6	access:public	signature:(const ByteArray16& src)
folly::IPAddressV6::IPAddressV6	.\IPAddressV6.h	/^  explicit IPAddressV6(const in6_addr& src);$/;"	p	class:folly::IPAddressV6	access:public	signature:(const in6_addr& src)
folly::IPAddressV6::IPAddressV6	.\IPAddressV6.h	/^  explicit IPAddressV6(const sockaddr_in6& src);$/;"	p	class:folly::IPAddressV6	access:public	signature:(const sockaddr_in6& src)
folly::IPAddressV6::LINK_LOCAL	.\IPAddressV6.h	/^    LINK_LOCAL,$/;"	e	enum:folly::IPAddressV6::LinkLocalTag
folly::IPAddressV6::LinkLocalTag	.\IPAddressV6.h	/^  enum LinkLocalTag {$/;"	g	class:folly::IPAddressV6	access:public
folly::IPAddressV6::NORMAL	.\IPAddressV6.h	/^    TEREDO, T6TO4, NORMAL,$/;"	e	enum:folly::IPAddressV6::Type
folly::IPAddressV6::PREFIX_6TO4	.\IPAddressV6.cpp	/^const uint32_t IPAddressV6::PREFIX_6TO4 = 0x2002;$/;"	m	class:folly::IPAddressV6	file:
folly::IPAddressV6::PREFIX_6TO4	.\IPAddressV6.h	/^  static const uint32_t PREFIX_6TO4;$/;"	m	class:folly::IPAddressV6	access:public
folly::IPAddressV6::PREFIX_TEREDO	.\IPAddressV6.cpp	/^const uint32_t IPAddressV6::PREFIX_TEREDO = 0x20010000;$/;"	m	class:folly::IPAddressV6	file:
folly::IPAddressV6::PREFIX_TEREDO	.\IPAddressV6.h	/^  static const uint32_t PREFIX_TEREDO;$/;"	m	class:folly::IPAddressV6	access:public
folly::IPAddressV6::T6TO4	.\IPAddressV6.h	/^    TEREDO, T6TO4, NORMAL,$/;"	e	enum:folly::IPAddressV6::Type
folly::IPAddressV6::TEREDO	.\IPAddressV6.h	/^    TEREDO, T6TO4, NORMAL,$/;"	e	enum:folly::IPAddressV6::Type
folly::IPAddressV6::Type	.\IPAddressV6.h	/^  enum Type {$/;"	g	class:folly::IPAddressV6	access:public
folly::IPAddressV6::TypeError	.\IPAddressV6.h	/^  typedef std::runtime_error TypeError;$/;"	t	class:folly::IPAddressV6	access:public
folly::IPAddressV6::addr_	.\IPAddressV6.h	/^  } addr_;$/;"	m	class:folly::IPAddressV6	typeref:union:folly::IPAddressV6::AddressStorage	access:private
folly::IPAddressV6::bitCount	.\IPAddressV6.h	/^  static size_t bitCount() { return 128; }$/;"	f	class:folly::IPAddressV6	access:public	signature:()
folly::IPAddressV6::byteCount	.\IPAddressV6.h	/^  static constexpr size_t byteCount() { return 16; }$/;"	f	class:folly::IPAddressV6	access:public	signature:()
folly::IPAddressV6::bytes	.\IPAddressV6.h	/^  const unsigned char* bytes() const { return addr_.in6Addr_.s6_addr; }$/;"	f	class:folly::IPAddressV6	access:public	signature:() const
folly::IPAddressV6::createIPv4	.\IPAddressV6.cpp	/^IPAddressV4 IPAddressV6::createIPv4() const {$/;"	f	class:folly::IPAddressV6	signature:() const
folly::IPAddressV6::createIPv4	.\IPAddressV6.h	/^  IPAddressV4 createIPv4() const;$/;"	p	class:folly::IPAddressV6	access:public	signature:() const
folly::IPAddressV6::fetchMask	.\IPAddressV6.cpp	/^const ByteArray16 IPAddressV6::fetchMask(size_t numBits) {$/;"	f	class:folly::IPAddressV6	signature:(size_t numBits)
folly::IPAddressV6::fetchMask	.\IPAddressV6.h	/^  static const ByteArray16 fetchMask(size_t numBits);$/;"	p	class:folly::IPAddressV6	access:public	signature:(size_t numBits)
folly::IPAddressV6::fromBinary	.\IPAddressV6.h	/^  static IPAddressV6 fromBinary(ByteRange bytes) {$/;"	f	class:folly::IPAddressV6	access:public	signature:(ByteRange bytes)
folly::IPAddressV6::getIPv4For6To4	.\IPAddressV6.cpp	/^IPAddressV4 IPAddressV6::getIPv4For6To4() const {$/;"	f	class:folly::IPAddressV6	signature:() const
folly::IPAddressV6::getIPv4For6To4	.\IPAddressV6.h	/^  IPAddressV4 getIPv4For6To4() const;$/;"	p	class:folly::IPAddressV6	access:public	signature:() const
folly::IPAddressV6::getMulticastFlags	.\IPAddressV6.cpp	/^uint8_t IPAddressV6::getMulticastFlags() const {$/;"	f	class:folly::IPAddressV6	signature:() const
folly::IPAddressV6::getMulticastFlags	.\IPAddressV6.h	/^  uint8_t getMulticastFlags() const;$/;"	p	class:folly::IPAddressV6	access:public	signature:() const
folly::IPAddressV6::getMulticastScope	.\IPAddressV6.cpp	/^uint8_t IPAddressV6::getMulticastScope() const {$/;"	f	class:folly::IPAddressV6	signature:() const
folly::IPAddressV6::getMulticastScope	.\IPAddressV6.h	/^  uint8_t getMulticastScope() const;$/;"	p	class:folly::IPAddressV6	access:public	signature:() const
folly::IPAddressV6::getNthLSBit	.\IPAddressV6.h	/^  bool getNthLSBit(size_t bitIndex) const {$/;"	f	class:folly::IPAddressV6	access:public	signature:(size_t bitIndex) const
folly::IPAddressV6::getNthLSByte	.\IPAddressV6.h	/^  uint8_t getNthLSByte(size_t byteIndex) const {$/;"	f	class:folly::IPAddressV6	access:public	signature:(size_t byteIndex) const
folly::IPAddressV6::getNthMSBit	.\IPAddressV6.h	/^  bool getNthMSBit(size_t bitIndex) const {$/;"	f	class:folly::IPAddressV6	access:public	signature:(size_t bitIndex) const
folly::IPAddressV6::getNthMSByte	.\IPAddressV6.cpp	/^uint8_t IPAddressV6::getNthMSByte(size_t byteIndex) const {$/;"	f	class:folly::IPAddressV6	signature:(size_t byteIndex) const
folly::IPAddressV6::getNthMSByte	.\IPAddressV6.h	/^  uint8_t getNthMSByte(size_t byteIndex) const;$/;"	p	class:folly::IPAddressV6	access:public	signature:(size_t byteIndex) const
folly::IPAddressV6::getScopeId	.\IPAddressV6.h	/^  uint16_t getScopeId() const { return scope_; }$/;"	f	class:folly::IPAddressV6	access:public	signature:() const
folly::IPAddressV6::getSolicitedNodeAddress	.\IPAddressV6.cpp	/^IPAddressV6 IPAddressV6::getSolicitedNodeAddress() const {$/;"	f	class:folly::IPAddressV6	signature:() const
folly::IPAddressV6::getSolicitedNodeAddress	.\IPAddressV6.h	/^  IPAddressV6 getSolicitedNodeAddress() const;$/;"	p	class:folly::IPAddressV6	access:public	signature:() const
folly::IPAddressV6::hash	.\IPAddressV6.cpp	/^size_t IPAddressV6::hash() const {$/;"	f	class:folly::IPAddressV6	signature:() const
folly::IPAddressV6::hash	.\IPAddressV6.h	/^  size_t hash() const;$/;"	p	class:folly::IPAddressV6	access:public	signature:() const
folly::IPAddressV6::inBinarySubnet	.\IPAddressV6.cpp	/^bool IPAddressV6::inBinarySubnet(const std::array<uint8_t, 2> addr,$/;"	f	class:folly::IPAddressV6	signature:(const std::array<uint8_t, 2> addr, size_t numBits) const
folly::IPAddressV6::inBinarySubnet	.\IPAddressV6.h	/^  bool inBinarySubnet(const std::array<uint8_t, 2> addr,$/;"	p	class:folly::IPAddressV6	access:protected	signature:(const std::array<uint8_t, 2> addr, size_t numBits) const
folly::IPAddressV6::inSubnet	.\IPAddressV6.cpp	/^bool IPAddressV6::inSubnet(StringPiece cidrNetwork) const {$/;"	f	class:folly::IPAddressV6	signature:(StringPiece cidrNetwork) const
folly::IPAddressV6::inSubnet	.\IPAddressV6.h	/^  bool inSubnet(StringPiece cidrNetwork) const;$/;"	p	class:folly::IPAddressV6	access:public	signature:(StringPiece cidrNetwork) const
folly::IPAddressV6::inSubnet	.\IPAddressV6.h	/^  bool inSubnet(const IPAddressV6& subnet, uint8_t cidr) const {$/;"	f	class:folly::IPAddressV6	access:public	signature:(const IPAddressV6& subnet, uint8_t cidr) const
folly::IPAddressV6::inSubnetWithMask	.\IPAddressV6.cpp	/^bool IPAddressV6::inSubnetWithMask(const IPAddressV6& subnet,$/;"	f	class:folly::IPAddressV6	signature:(const IPAddressV6& subnet, const ByteArray16& cidrMask) const
folly::IPAddressV6::inSubnetWithMask	.\IPAddressV6.h	/^  bool inSubnetWithMask(const IPAddressV6& subnet,$/;"	p	class:folly::IPAddressV6	access:public	signature:(const IPAddressV6& subnet, const ByteArray16& mask) const
folly::IPAddressV6::is6To4	.\IPAddressV6.h	/^  bool is6To4() const {$/;"	f	class:folly::IPAddressV6	access:public	signature:() const
folly::IPAddressV6::isIPv4Mapped	.\IPAddressV6.cpp	/^bool IPAddressV6::isIPv4Mapped() const {$/;"	f	class:folly::IPAddressV6	signature:() const
folly::IPAddressV6::isIPv4Mapped	.\IPAddressV6.h	/^  bool isIPv4Mapped() const;$/;"	p	class:folly::IPAddressV6	access:public	signature:() const
folly::IPAddressV6::isLinkLocal	.\IPAddressV6.cpp	/^bool IPAddressV6::isLinkLocal() const {$/;"	f	class:folly::IPAddressV6	signature:() const
folly::IPAddressV6::isLinkLocal	.\IPAddressV6.h	/^  bool isLinkLocal() const;$/;"	p	class:folly::IPAddressV6	access:public	signature:() const
folly::IPAddressV6::isLinkLocalBroadcast	.\IPAddressV6.cpp	/^bool IPAddressV6::isLinkLocalBroadcast() const {$/;"	f	class:folly::IPAddressV6	signature:() const
folly::IPAddressV6::isLinkLocalBroadcast	.\IPAddressV6.h	/^  bool isLinkLocalBroadcast() const;$/;"	p	class:folly::IPAddressV6	access:public	signature:() const
folly::IPAddressV6::isLoopback	.\IPAddressV6.cpp	/^bool IPAddressV6::isLoopback() const {$/;"	f	class:folly::IPAddressV6	signature:() const
folly::IPAddressV6::isLoopback	.\IPAddressV6.h	/^  bool isLoopback() const;$/;"	p	class:folly::IPAddressV6	access:public	signature:() const
folly::IPAddressV6::isMulticast	.\IPAddressV6.cpp	/^bool IPAddressV6::isMulticast() const {$/;"	f	class:folly::IPAddressV6	signature:() const
folly::IPAddressV6::isMulticast	.\IPAddressV6.h	/^  bool isMulticast() const;$/;"	p	class:folly::IPAddressV6	access:public	signature:() const
folly::IPAddressV6::isNonroutable	.\IPAddressV6.h	/^  bool isNonroutable() const {$/;"	f	class:folly::IPAddressV6	access:public	signature:() const
folly::IPAddressV6::isPrivate	.\IPAddressV6.cpp	/^bool IPAddressV6::isPrivate() const {$/;"	f	class:folly::IPAddressV6	signature:() const
folly::IPAddressV6::isPrivate	.\IPAddressV6.h	/^  bool isPrivate() const;$/;"	p	class:folly::IPAddressV6	access:public	signature:() const
folly::IPAddressV6::isRoutable	.\IPAddressV6.cpp	/^bool IPAddressV6::isRoutable() const {$/;"	f	class:folly::IPAddressV6	signature:() const
folly::IPAddressV6::isRoutable	.\IPAddressV6.h	/^  bool isRoutable() const;$/;"	p	class:folly::IPAddressV6	access:public	signature:() const
folly::IPAddressV6::isTeredo	.\IPAddressV6.h	/^  bool isTeredo() const {$/;"	f	class:folly::IPAddressV6	access:public	signature:() const
folly::IPAddressV6::isZero	.\IPAddressV6.h	/^  bool isZero() const {$/;"	f	class:folly::IPAddressV6	access:public	signature:() const
folly::IPAddressV6::longestCommonPrefix	.\IPAddressV6.h	/^  static CIDRNetworkV6 longestCommonPrefix(const CIDRNetworkV6& one,$/;"	f	class:folly::IPAddressV6	access:public	signature:(const CIDRNetworkV6& one, const CIDRNetworkV6& two)
folly::IPAddressV6::mask	.\IPAddressV6.cpp	/^IPAddressV6 IPAddressV6::mask(size_t numBits) const {$/;"	f	class:folly::IPAddressV6	signature:(size_t numBits) const
folly::IPAddressV6::mask	.\IPAddressV6.h	/^  IPAddressV6 mask(size_t numBits) const;$/;"	p	class:folly::IPAddressV6	access:public	signature:(size_t numBits) const
folly::IPAddressV6::masks_	.\IPAddressV6.cpp	/^const std::array<ByteArray16, 129> IPAddressV6::masks_ = {{$/;"	m	class:folly::IPAddressV6	file:
folly::IPAddressV6::masks_	.\IPAddressV6.h	/^  static const std::array<ByteArray16, 129> masks_;$/;"	m	class:folly::IPAddressV6	access:private
folly::IPAddressV6::setFromBinary	.\IPAddressV6.cpp	/^void IPAddressV6::setFromBinary(ByteRange bytes) {$/;"	f	class:folly::IPAddressV6	signature:(ByteRange bytes)
folly::IPAddressV6::setFromBinary	.\IPAddressV6.h	/^  void setFromBinary(ByteRange bytes);$/;"	p	class:folly::IPAddressV6	access:private	signature:(ByteRange bytes)
folly::IPAddressV6::setScopeId	.\IPAddressV6.h	/^  void setScopeId(uint16_t scope) {$/;"	f	class:folly::IPAddressV6	access:public	signature:(uint16_t scope)
folly::IPAddressV6::str	.\IPAddressV6.cpp	/^string IPAddressV6::str() const {$/;"	f	class:folly::IPAddressV6	signature:() const
folly::IPAddressV6::str	.\IPAddressV6.h	/^  std::string str() const;$/;"	p	class:folly::IPAddressV6	access:public	signature:() const
folly::IPAddressV6::toAddr	.\IPAddressV6.h	/^  in6_addr toAddr() const { return addr_.in6Addr_; }$/;"	f	class:folly::IPAddressV6	access:public	signature:() const
folly::IPAddressV6::toByteArray	.\IPAddressV6.h	/^  ByteArray16 toByteArray() const {$/;"	f	class:folly::IPAddressV6	access:public	signature:() const
folly::IPAddressV6::toFullyQualified	.\IPAddressV6.cpp	/^string IPAddressV6::toFullyQualified() const {$/;"	f	class:folly::IPAddressV6	signature:() const
folly::IPAddressV6::toFullyQualified	.\IPAddressV6.h	/^  std::string toFullyQualified() const;$/;"	p	class:folly::IPAddressV6	access:public	signature:() const
folly::IPAddressV6::toJson	.\IPAddressV6.cpp	/^string IPAddressV6::toJson() const {$/;"	f	class:folly::IPAddressV6	signature:() const
folly::IPAddressV6::toJson	.\IPAddressV6.h	/^  std::string toJson() const;$/;"	p	class:folly::IPAddressV6	access:public	signature:() const
folly::IPAddressV6::toSockAddr	.\IPAddressV6.h	/^  sockaddr_in6 toSockAddr() const {$/;"	f	class:folly::IPAddressV6	access:public	signature:() const
folly::IPAddressV6::type	.\IPAddressV6.cpp	/^IPAddressV6::Type IPAddressV6::type() const {$/;"	f	class:folly::IPAddressV6	signature:() const
folly::IPAddressV6::type	.\IPAddressV6.h	/^  Type type() const;$/;"	p	class:folly::IPAddressV6	access:public	signature:() const
folly::IPAddressV6::version	.\IPAddressV6.h	/^  size_t version() const { return 6; }$/;"	f	class:folly::IPAddressV6	access:public	signature:() const
folly::IndexedMemPool	.\IndexedMemPool.h	/^struct IndexedMemPool : boost::noncopyable {$/;"	s	namespace:folly	inherits:boost::noncopyable
folly::IndexedMemPool::IndexedMemPool	.\IndexedMemPool.h	/^  explicit IndexedMemPool(uint32_t capacity)$/;"	f	struct:folly::IndexedMemPool	access:public	signature:(uint32_t capacity)
folly::IndexedMemPool::LocalListLimit	.\IndexedMemPool.h	/^    LocalListLimit = LocalListLimit_$/;"	e	enum:folly::IndexedMemPool::__anon61
folly::IndexedMemPool::NumLocalLists	.\IndexedMemPool.h	/^    NumLocalLists = NumLocalLists_,$/;"	e	enum:folly::IndexedMemPool::__anon61
folly::IndexedMemPool::Slot	.\IndexedMemPool.h	/^  struct Slot {$/;"	s	struct:folly::IndexedMemPool	access:private
folly::IndexedMemPool::Slot::Slot	.\IndexedMemPool.h	/^    Slot() : localNext{}, globalNext{} {}$/;"	f	struct:folly::IndexedMemPool::Slot	access:public	signature:()
folly::IndexedMemPool::Slot::elem	.\IndexedMemPool.h	/^    T elem;$/;"	m	struct:folly::IndexedMemPool::Slot	access:public
folly::IndexedMemPool::Slot::globalNext	.\IndexedMemPool.h	/^    uint32_t globalNext;$/;"	m	struct:folly::IndexedMemPool::Slot	access:public
folly::IndexedMemPool::Slot::localNext	.\IndexedMemPool.h	/^    uint32_t localNext;$/;"	m	struct:folly::IndexedMemPool::Slot	access:public
folly::IndexedMemPool::TaggedPtr	.\IndexedMemPool.h	/^  struct TaggedPtr {$/;"	s	struct:folly::IndexedMemPool	access:private
folly::IndexedMemPool::TaggedPtr::SizeMask	.\IndexedMemPool.h	/^        SizeMask = (1U << SizeBits) - 1,$/;"	m	struct:folly::IndexedMemPool::TaggedPtr	typeref:enum:folly::IndexedMemPool::TaggedPtr::	access:public
folly::IndexedMemPool::TaggedPtr::TagIncr	.\IndexedMemPool.h	/^        TagIncr = 1U << SizeBits,$/;"	m	struct:folly::IndexedMemPool::TaggedPtr	typeref:enum:folly::IndexedMemPool::TaggedPtr::	access:public
folly::IndexedMemPool::TaggedPtr::idx	.\IndexedMemPool.h	/^    uint32_t idx;$/;"	m	struct:folly::IndexedMemPool::TaggedPtr	access:public
folly::IndexedMemPool::TaggedPtr::tagAndSize	.\IndexedMemPool.h	/^    uint32_t tagAndSize;$/;"	m	struct:folly::IndexedMemPool::TaggedPtr	access:public
folly::IndexedMemPool::UniquePtr	.\IndexedMemPool.h	/^      UniquePtr;$/;"	t	struct:folly::IndexedMemPool	access:public
folly::IndexedMemPool::allocElem	.\IndexedMemPool.h	/^  UniquePtr allocElem() {$/;"	f	struct:folly::IndexedMemPool	access:public	signature:()
folly::IndexedMemPool::allocIndex	.\IndexedMemPool.h	/^  uint32_t allocIndex() {$/;"	f	struct:folly::IndexedMemPool	access:public	signature:()
folly::IndexedMemPool::capacity	.\IndexedMemPool.h	/^  size_t capacity() {$/;"	f	struct:folly::IndexedMemPool	access:public	signature:()
folly::IndexedMemPool::capacityForMaxIndex	.\IndexedMemPool.h	/^  static constexpr uint32_t capacityForMaxIndex(uint32_t maxIndex) {$/;"	f	struct:folly::IndexedMemPool	access:public	signature:(uint32_t maxIndex)
folly::IndexedMemPool::isAllocated	.\IndexedMemPool.h	/^  bool isAllocated(uint32_t idx) const {$/;"	f	struct:folly::IndexedMemPool	access:public	signature:(uint32_t idx) const
folly::IndexedMemPool::locateElem	.\IndexedMemPool.h	/^  uint32_t locateElem(const T* elem) const {$/;"	f	struct:folly::IndexedMemPool	access:public	signature:(const T* elem) const
folly::IndexedMemPool::maxIndexForCapacity	.\IndexedMemPool.h	/^  static constexpr uint32_t maxIndexForCapacity(uint32_t capacity) {$/;"	f	struct:folly::IndexedMemPool	access:public	signature:(uint32_t capacity)
folly::IndexedMemPool::operator []	.\IndexedMemPool.h	/^  T& operator[](uint32_t idx) {$/;"	f	struct:folly::IndexedMemPool	access:public	signature:(uint32_t idx)
folly::IndexedMemPool::operator []	.\IndexedMemPool.h	/^  const T& operator[](uint32_t idx) const {$/;"	f	struct:folly::IndexedMemPool	access:public	signature:(uint32_t idx) const
folly::IndexedMemPool::recycleIndex	.\IndexedMemPool.h	/^  void recycleIndex(uint32_t idx) {$/;"	f	struct:folly::IndexedMemPool	access:public	signature:(uint32_t idx)
folly::IndexedMemPool::size	.\IndexedMemPool.h	/^    uint32_t size() const {$/;"	f	struct:folly::IndexedMemPool	access:private	signature:() const
folly::IndexedMemPool::static_assert	.\IndexedMemPool.h	/^  static_assert(LocalListLimit_ <= 255, "LocalListLimit must fit in 8 bits");$/;"	p	struct:folly::IndexedMemPool	access:public	signature:(LocalListLimit_ <= 255, )
folly::IndexedMemPool::value_type	.\IndexedMemPool.h	/^  typedef T value_type;$/;"	t	struct:folly::IndexedMemPool	access:public
folly::IndexedMemPool::withEmpty	.\IndexedMemPool.h	/^    TaggedPtr withEmpty() const {$/;"	f	struct:folly::IndexedMemPool	access:private	signature:() const
folly::IndexedMemPool::withIdx	.\IndexedMemPool.h	/^    TaggedPtr withIdx(uint32_t repl) const {$/;"	f	struct:folly::IndexedMemPool	access:private	signature:(uint32_t repl) const
folly::IndexedMemPool::withSize	.\IndexedMemPool.h	/^    TaggedPtr withSize(uint32_t repl) const {$/;"	f	struct:folly::IndexedMemPool	access:private	signature:(uint32_t repl) const
folly::IndexedMemPool::withSizeDecr	.\IndexedMemPool.h	/^    TaggedPtr withSizeDecr() const {$/;"	f	struct:folly::IndexedMemPool	access:private	signature:() const
folly::IndexedMemPool::withSizeIncr	.\IndexedMemPool.h	/^    TaggedPtr withSizeIncr() const {$/;"	f	struct:folly::IndexedMemPool	access:private	signature:() const
folly::IndexedMemPool::~IndexedMemPool	.\IndexedMemPool.h	/^  ~IndexedMemPool() {$/;"	f	struct:folly::IndexedMemPool	access:public	signature:()
folly::IntrusiveList	.\IntrusiveList.h	/^class IntrusiveList : public boost::intrusive::list<$/;"	c	namespace:folly	inherits:boost::intrusive::list
folly::IntrusiveListHook	.\IntrusiveList.h	/^        IntrusiveListHook;$/;"	t	namespace:folly
folly::InvalidAddressFamilyException	.\IPAddressException.h	/^class InvalidAddressFamilyException : public IPAddressFormatException {$/;"	c	namespace:folly	inherits:IPAddressFormatException
folly::InvalidAddressFamilyException::InvalidAddressFamilyException	.\IPAddressException.h	/^  explicit InvalidAddressFamilyException(Args&&... args)$/;"	f	class:folly::InvalidAddressFamilyException	access:public	signature:(Args&&.... args)
folly::InvalidAddressFamilyException::InvalidAddressFamilyException	.\IPAddressException.h	/^  explicit InvalidAddressFamilyException(const std::string& msg)$/;"	f	class:folly::InvalidAddressFamilyException	access:public	signature:(const std::string& msg)
folly::InvalidAddressFamilyException::InvalidAddressFamilyException	.\IPAddressException.h	/^  explicit InvalidAddressFamilyException(sa_family_t family)$/;"	f	class:folly::InvalidAddressFamilyException	access:public	signature:(sa_family_t family)
folly::InvalidAddressFamilyException::ex	.\IPAddressException.h	/^    const InvalidAddressFamilyException& ex) = default;$/;"	m	class:folly::InvalidAddressFamilyException	access:public
folly::IsArenaAllocator	.\Arena.h	/^struct IsArenaAllocator<Arena<Alloc>> : std::true_type { };$/;"	s	namespace:folly	inherits:std::true_type
folly::IsArenaAllocator	.\Arena.h	/^struct IsArenaAllocator<SysArena> : std::true_type { };$/;"	s	namespace:folly	inherits:std::true_type
folly::IsArenaAllocator	.\Memory.h	/^template <class T> struct IsArenaAllocator : std::false_type { };$/;"	s	namespace:folly	inherits:std::false_type
folly::IsArenaAllocator	.\ThreadCachedArena.h	/^struct IsArenaAllocator<ThreadCachedArena> : std::true_type { };$/;"	s	namespace:folly	inherits:std::true_type
folly::IsOneOf	.\Traits.h	/^struct IsOneOf {$/;"	s	namespace:folly
folly::IsOneOf	.\Traits.h	/^struct IsOneOf<T, T1, Ts...> {$/;"	s	namespace:folly
folly::IsOneOf::value	.\Traits.h	/^  enum { value = false };$/;"	e	enum:folly::IsOneOf::__anon151
folly::IsOneOf::value	.\Traits.h	/^  enum { value = std::is_same<T, T1>::value || IsOneOf<T, Ts...>::value };$/;"	e	enum:folly::IsOneOf::__anon152
folly::IsRelocatable	.\Traits.h	/^struct IsRelocatable<  std::pair<T, U> >$/;"	s	namespace:folly	inherits:::boost::mpl::and_
folly::IsRelocatable	.\Traits.h	/^template <class T> struct IsRelocatable$/;"	s	namespace:folly	inherits:std::integral_constant
folly::IsRelocatable	.\test\TraitsTest.cpp	/^  template <> struct IsRelocatable<T1> : std::true_type {};$/;"	s	namespace:folly	file:	inherits:std::true_type
folly::IsRelocatable	.\test\stl_tests\StlVectorTest.cpp	/^struct IsRelocatable<Data<f, pad>>$/;"	s	namespace:folly	file:	inherits:std::integral_constant
folly::IsSomeString	.\Conv.h	/^template <class T> struct IsSomeString {$/;"	s	namespace:folly
folly::IsSomeString::value	.\Conv.h	/^  enum { value = std::is_same<T, std::string>::value$/;"	e	enum:folly::IsSomeString::__anon8
folly::IsTriviallyCopyable	.\Traits.h	/^template <class T> struct IsTriviallyCopyable$/;"	s	namespace:folly	inherits:std::integral_constant
folly::IsTriviallyCopyable	.\detail\MemoryIdler.h	/^struct IsTriviallyCopyable<std::chrono::steady_clock::duration>$/;"	s	namespace:folly	inherits:std::true_type
folly::IsZeroInitializable	.\Traits.h	/^template <class T> struct IsZeroInitializable$/;"	s	namespace:folly	inherits:std::integral_constant
folly::LifoSem	.\LifoSem.h	/^typedef LifoSemImpl<> LifoSem;$/;"	t	namespace:folly
folly::LifoSemImpl	.\LifoSem.h	/^struct LifoSemImpl : public detail::LifoSemBase<BatonType, Atom> {$/;"	s	namespace:folly	inherits:detail::LifoSemBase
folly::LifoSemImpl	.\LifoSem.h	/^struct LifoSemImpl;$/;"	x
folly::LifoSemImpl::LifoSemImpl	.\LifoSem.h	/^  explicit LifoSemImpl(uint32_t v = 0)$/;"	f	struct:folly::LifoSemImpl	access:public	signature:(uint32_t v = 0)
folly::LocalList	.\IndexedMemPool.h	/^  struct FOLLY_ALIGN_TO_AVOID_FALSE_SHARING LocalList {$/;"	s	namespace:folly
folly::LocalList::LocalList	.\IndexedMemPool.h	/^    LocalList() : head(TaggedPtr{}) {}$/;"	f	struct:folly::LocalList	access:public	signature:()
folly::LocalList::head	.\IndexedMemPool.h	/^    AtomicStruct<TaggedPtr,Atom> head;$/;"	m	struct:folly::LocalList	access:public
folly::MPMCPipeline	.\MPMCPipeline.h	/^template <class In, class... Stages> class MPMCPipeline {$/;"	c	namespace:folly
folly::MPMCPipeline	.\detail\MPMCPipelineDetail.h	/^template <class T, class... Stages> class MPMCPipeline;$/;"	x
folly::MPMCPipeline::MPMCPipeline	.\MPMCPipeline.h	/^  MPMCPipeline() { }$/;"	f	class:folly::MPMCPipeline	access:public	signature:()
folly::MPMCPipeline::MPMCPipeline	.\MPMCPipeline.h	/^  explicit MPMCPipeline(Sizes... sizes) : stages_(sizes...) { }$/;"	f	class:folly::MPMCPipeline	access:public	signature:(Sizes.... sizes)
folly::MPMCPipeline::StageInfos	.\MPMCPipeline.h	/^  typedef std::tuple<detail::PipelineStageInfo<Stages>...> StageInfos;$/;"	t	class:folly::MPMCPipeline	access:private
folly::MPMCPipeline::StageTuple	.\MPMCPipeline.h	/^    StageTuple;$/;"	t	class:folly::MPMCPipeline	access:private
folly::MPMCPipeline::Ticket	.\MPMCPipeline.h	/^  class Ticket {$/;"	c	class:folly::MPMCPipeline	access:public
folly::MPMCPipeline::Ticket::MPMCPipeline	.\MPMCPipeline.h	/^    friend class MPMCPipeline;$/;"	x
folly::MPMCPipeline::Ticket::owner_	.\MPMCPipeline.h	/^        owner_(other.owner_),$/;"	p	class:folly::MPMCPipeline::Ticket	access:public	signature:(other.owner_)
folly::MPMCPipeline::Ticket::owner_	.\MPMCPipeline.h	/^        owner_(owner),$/;"	p	class:folly::MPMCPipeline::Ticket	access:private	signature:(owner)
folly::MPMCPipeline::Ticket::owner_	.\MPMCPipeline.h	/^      : owner_(nullptr),$/;"	p	class:folly::MPMCPipeline::Ticket	access:public	signature:(nullptr)
folly::MPMCPipeline::Ticket::owner_	.\MPMCPipeline.h	/^    MPMCPipeline* owner_;$/;"	m	class:folly::MPMCPipeline::Ticket	access:private
folly::MPMCPipeline::Ticket::remainingUses_	.\MPMCPipeline.h	/^        remainingUses_(amplification),$/;"	p	class:folly::MPMCPipeline::Ticket	access:private	signature:(amplification)
folly::MPMCPipeline::Ticket::remainingUses_	.\MPMCPipeline.h	/^        remainingUses_(other.remainingUses_),$/;"	p	class:folly::MPMCPipeline::Ticket	access:public	signature:(other.remainingUses_)
folly::MPMCPipeline::Ticket::remainingUses_	.\MPMCPipeline.h	/^    size_t remainingUses_;$/;"	m	class:folly::MPMCPipeline::Ticket	access:private
folly::MPMCPipeline::Ticket::use	.\MPMCPipeline.h	/^    uint64_t use(MPMCPipeline* owner) {$/;"	f	class:folly::MPMCPipeline::Ticket	access:private	signature:(MPMCPipeline* owner)
folly::MPMCPipeline::Ticket::value_	.\MPMCPipeline.h	/^        value_(other.value_) {$/;"	f	class:folly::MPMCPipeline::Ticket	access:public	signature:(other.value_)
folly::MPMCPipeline::Ticket::value_	.\MPMCPipeline.h	/^        value_(value * amplification) {$/;"	f	class:folly::MPMCPipeline::Ticket	access:private	signature:(value * amplification)
folly::MPMCPipeline::Ticket::value_	.\MPMCPipeline.h	/^    uint64_t value_;$/;"	m	class:folly::MPMCPipeline::Ticket	access:private
folly::MPMCPipeline::blockingRead	.\MPMCPipeline.h	/^  void blockingRead($/;"	f	class:folly::MPMCPipeline	access:public	signature:( typename std::tuple_element< sizeof...(Stages), StageTuple>::type::value_type& elem)
folly::MPMCPipeline::blockingReadStage	.\MPMCPipeline.h	/^  Ticket<Stage> blockingReadStage($/;"	f	class:folly::MPMCPipeline	access:public	signature:( typename std::tuple_element<Stage, StageTuple>::type::value_type& elem)
folly::MPMCPipeline::blockingWrite	.\MPMCPipeline.h	/^  void blockingWrite(Args&&... args) {$/;"	f	class:folly::MPMCPipeline	access:public	signature:(Args&&.... args)
folly::MPMCPipeline::blockingWriteStage	.\MPMCPipeline.h	/^  void blockingWriteStage(Ticket<Stage>& ticket, Args&&... args) {$/;"	f	class:folly::MPMCPipeline	access:public	signature:(Ticket<Stage>& ticket, Args&&... args)
folly::MPMCPipeline::kAmplification	.\MPMCPipeline.h	/^  static constexpr size_t kAmplification =$/;"	m	class:folly::MPMCPipeline	access:private
folly::MPMCPipeline::read	.\MPMCPipeline.h	/^  bool read($/;"	f	class:folly::MPMCPipeline	access:public	signature:( typename std::tuple_element< sizeof...(Stages), StageTuple>::type::value_type& elem)
folly::MPMCPipeline::readStage	.\MPMCPipeline.h	/^  bool readStage($/;"	f	class:folly::MPMCPipeline	access:public	signature:( Ticket<Stage>& ticket, typename std::tuple_element<Stage, StageTuple>::type::value_type& elem)
folly::MPMCPipeline::stages_	.\MPMCPipeline.h	/^  StageTuple stages_;$/;"	m	class:folly::MPMCPipeline	access:private
folly::MPMCPipeline::write	.\MPMCPipeline.h	/^  bool write(Args&&... args) {$/;"	f	class:folly::MPMCPipeline	access:public	signature:(Args&&.... args)
folly::MPMCPipelineStage	.\MPMCPipeline.h	/^template <class T, size_t Amp> class MPMCPipelineStage;$/;"	x
folly::MPMCPipelineStage	.\detail\MPMCPipelineDetail.h	/^template <class T, size_t Amp> class MPMCPipelineStage {$/;"	c	namespace:folly
folly::MPMCPipelineStage::kAmplification	.\detail\MPMCPipelineDetail.h	/^  static constexpr size_t kAmplification = Amp;$/;"	m	class:folly::MPMCPipelineStage	access:public
folly::MPMCPipelineStage::value_type	.\detail\MPMCPipelineDetail.h	/^  typedef T value_type;$/;"	t	class:folly::MPMCPipelineStage	access:public
folly::MPMCQueue	.\MPMCQueue.h	/^class MPMCQueue : boost::noncopyable {$/;"	c	namespace:folly	inherits:boost::noncopyable
folly::MPMCQueue::MPMCQueue	.\MPMCQueue.h	/^  explicit MPMCQueue(size_t queueCapacity)$/;"	f	class:folly::MPMCQueue	access:public	signature:(size_t queueCapacity)
folly::MPMCQueue::capacity_	.\MPMCQueue.h	/^    : capacity_(rhs.capacity_)$/;"	p	class:folly::MPMCQueue	access:public	signature:(rhs.capacity_)
folly::MPMCQueue::capacity_	.\MPMCQueue.h	/^  size_t FOLLY_ALIGN_TO_AVOID_FALSE_SHARING capacity_;$/;"	m	class:folly::MPMCQueue	access:private
folly::MPMCQueue::kAdaptationFreq	.\MPMCQueue.h	/^    kAdaptationFreq = 128,$/;"	e	enum:folly::MPMCQueue::__anon80
folly::MPMCQueue::kSlotPadding	.\MPMCQueue.h	/^    kSlotPadding = (detail::CacheLocality::kFalseSharingRange - 1)$/;"	e	enum:folly::MPMCQueue::__anon80
folly::MPMCQueue::operator =	.\MPMCQueue.h	/^  MPMCQueue<T,Atom> const& operator= (MPMCQueue<T,Atom>&& rhs) {$/;"	f	class:folly::MPMCQueue	access:public	signature:(MPMCQueue<T,Atom>&& rhs)
folly::MPMCQueue::padding_	.\MPMCQueue.h	/^  char padding_[detail::CacheLocality::kFalseSharingRange - sizeof(Atom<int>)];$/;"	m	class:folly::MPMCQueue	access:private
folly::MPMCQueue::popSpinCutoff_	.\MPMCQueue.h	/^    , popSpinCutoff_(rhs.popSpinCutoff_.load(std::memory_order_relaxed))$/;"	f	class:folly::MPMCQueue	access:public	signature:(rhs.popSpinCutoff_.load(std::memory_order_relaxed))
folly::MPMCQueue::popSpinCutoff_	.\MPMCQueue.h	/^  Atom<int> FOLLY_ALIGN_TO_AVOID_FALSE_SHARING popSpinCutoff_;$/;"	m	class:folly::MPMCQueue	access:private
folly::MPMCQueue::popTicket_	.\MPMCQueue.h	/^    , popTicket_(rhs.popTicket_.load(std::memory_order_relaxed))$/;"	p	class:folly::MPMCQueue	access:public	signature:(rhs.popTicket_.load(std::memory_order_relaxed))
folly::MPMCQueue::popTicket_	.\MPMCQueue.h	/^  Atom<uint64_t> FOLLY_ALIGN_TO_AVOID_FALSE_SHARING popTicket_;$/;"	m	class:folly::MPMCQueue	access:private
folly::MPMCQueue::pushSpinCutoff_	.\MPMCQueue.h	/^    , pushSpinCutoff_(rhs.pushSpinCutoff_.load(std::memory_order_relaxed))$/;"	p	class:folly::MPMCQueue	access:public	signature:(rhs.pushSpinCutoff_.load(std::memory_order_relaxed))
folly::MPMCQueue::pushSpinCutoff_	.\MPMCQueue.h	/^  Atom<int> FOLLY_ALIGN_TO_AVOID_FALSE_SHARING pushSpinCutoff_;$/;"	m	class:folly::MPMCQueue	access:private
folly::MPMCQueue::pushTicket_	.\MPMCQueue.h	/^    , pushTicket_(rhs.pushTicket_.load(std::memory_order_relaxed))$/;"	p	class:folly::MPMCQueue	access:public	signature:(rhs.pushTicket_.load(std::memory_order_relaxed))
folly::MPMCQueue::pushTicket_	.\MPMCQueue.h	/^  Atom<uint64_t> FOLLY_ALIGN_TO_AVOID_FALSE_SHARING pushTicket_;$/;"	m	class:folly::MPMCQueue	access:private
folly::MPMCQueue::slots_	.\MPMCQueue.h	/^    , slots_(nullptr)$/;"	p	class:folly::MPMCQueue	access:public	signature:(nullptr)
folly::MPMCQueue::slots_	.\MPMCQueue.h	/^    , slots_(rhs.slots_)$/;"	p	class:folly::MPMCQueue	access:public	signature:(rhs.slots_)
folly::MPMCQueue::slots_	.\MPMCQueue.h	/^  detail::SingleElementQueue<T,Atom>* slots_;$/;"	m	class:folly::MPMCQueue	access:private
folly::MPMCQueue::stride_	.\MPMCQueue.h	/^    , stride_(rhs.stride_)$/;"	p	class:folly::MPMCQueue	access:public	signature:(rhs.stride_)
folly::MPMCQueue::stride_	.\MPMCQueue.h	/^  int stride_;$/;"	m	class:folly::MPMCQueue	access:private
folly::MPMCQueue::value_type	.\MPMCQueue.h	/^  typedef T value_type;$/;"	t	class:folly::MPMCQueue	access:public
folly::MPMCQueue::~MPMCQueue	.\MPMCQueue.h	/^  ~MPMCQueue() {$/;"	f	class:folly::MPMCQueue	access:public	signature:()
folly::MSLGuard	.\SmallLocks.h	/^typedef std::lock_guard<MicroSpinLock> MSLGuard;$/;"	t	namespace:folly
folly::MacAddress	.\IPAddressV6.h	/^class MacAddress;$/;"	x
folly::MacAddress	.\MacAddress.h	/^class MacAddress : private boost::totally_ordered<MacAddress> {$/;"	c	namespace:folly	inherits:boost::totally_ordered
folly::MacAddress::BROADCAST	.\MacAddress.h	/^  static const MacAddress BROADCAST;$/;"	m	class:folly::MacAddress	access:public
folly::MacAddress::MacAddress	.\MacAddress.cpp	/^MacAddress::MacAddress(StringPiece str) {$/;"	f	class:folly::MacAddress	signature:(StringPiece str)
folly::MacAddress::MacAddress	.\MacAddress.h	/^  MacAddress() {$/;"	f	class:folly::MacAddress	access:public	signature:()
folly::MacAddress::MacAddress	.\MacAddress.h	/^  explicit MacAddress(StringPiece str);$/;"	p	class:folly::MacAddress	access:public	signature:(StringPiece str)
folly::MacAddress::MacAddress	.\MacAddress.h	/^  explicit MacAddress(uint64_t valueNBO) {$/;"	f	class:folly::MacAddress	access:private	signature:(uint64_t valueNBO)
folly::MacAddress::SIZE	.\MacAddress.h	/^  static constexpr size_t SIZE = 6;$/;"	m	class:folly::MacAddress	access:public
folly::MacAddress::ZERO	.\MacAddress.cpp	/^const MacAddress MacAddress::ZERO;$/;"	m	class:folly::MacAddress	file:
folly::MacAddress::ZERO	.\MacAddress.h	/^  static const MacAddress ZERO;$/;"	m	class:folly::MacAddress	access:public
folly::MacAddress::bytes	.\MacAddress.h	/^  const uint8_t* bytes() const {$/;"	f	class:folly::MacAddress	access:public	signature:() const
folly::MacAddress::bytes_	.\MacAddress.h	/^  unsigned char bytes_[8];$/;"	m	class:folly::MacAddress	access:private
folly::MacAddress::createMulticast	.\MacAddress.cpp	/^MacAddress MacAddress::createMulticast(IPAddressV6 v6addr) {$/;"	f	class:folly::MacAddress	signature:(IPAddressV6 v6addr)
folly::MacAddress::createMulticast	.\MacAddress.h	/^  static MacAddress createMulticast(IPAddressV6 addr);$/;"	p	class:folly::MacAddress	access:public	signature:(IPAddressV6 addr)
folly::MacAddress::fromBinary	.\MacAddress.h	/^  static MacAddress fromBinary(ByteRange value) {$/;"	f	class:folly::MacAddress	access:public	signature:(ByteRange value)
folly::MacAddress::fromHBO	.\MacAddress.h	/^  static MacAddress fromHBO(uint64_t value) {$/;"	f	class:folly::MacAddress	access:public	signature:(uint64_t value)
folly::MacAddress::fromNBO	.\MacAddress.h	/^  static MacAddress fromNBO(uint64_t value) {$/;"	f	class:folly::MacAddress	access:public	signature:(uint64_t value)
folly::MacAddress::getByte	.\MacAddress.h	/^  inline uint64_t getByte(size_t index) const {$/;"	f	class:folly::MacAddress	access:private	signature:(size_t index) const
folly::MacAddress::isBroadcast	.\MacAddress.h	/^  bool isBroadcast() const {$/;"	f	class:folly::MacAddress	access:public	signature:() const
folly::MacAddress::isLocallyAdministered	.\MacAddress.h	/^  bool isLocallyAdministered() const {$/;"	f	class:folly::MacAddress	access:public	signature:() const
folly::MacAddress::isMulticast	.\MacAddress.h	/^  bool isMulticast() const {$/;"	f	class:folly::MacAddress	access:public	signature:() const
folly::MacAddress::isUnicast	.\MacAddress.h	/^  bool isUnicast() const {$/;"	f	class:folly::MacAddress	access:public	signature:() const
folly::MacAddress::operator <	.\MacAddress.h	/^  bool operator<(const MacAddress& other) const {$/;"	f	class:folly::MacAddress	access:public	signature:(const MacAddress& other) const
folly::MacAddress::operator ==	.\MacAddress.h	/^  bool operator==(const MacAddress& other) const {$/;"	f	class:folly::MacAddress	access:public	signature:(const MacAddress& other) const
folly::MacAddress::packedBytes	.\MacAddress.h	/^  uint64_t packedBytes() const {$/;"	f	class:folly::MacAddress	access:private	signature:() const
folly::MacAddress::parse	.\MacAddress.cpp	/^void MacAddress::parse(StringPiece str) {$/;"	f	class:folly::MacAddress	signature:(StringPiece str)
folly::MacAddress::parse	.\MacAddress.h	/^  void parse(StringPiece str);$/;"	p	class:folly::MacAddress	access:public	signature:(StringPiece str)
folly::MacAddress::setFromBinary	.\MacAddress.cpp	/^void MacAddress::setFromBinary(ByteRange value) {$/;"	f	class:folly::MacAddress	signature:(ByteRange value)
folly::MacAddress::setFromBinary	.\MacAddress.h	/^  void setFromBinary(ByteRange value);$/;"	p	class:folly::MacAddress	access:public	signature:(ByteRange value)
folly::MacAddress::toString	.\MacAddress.cpp	/^string MacAddress::toString() const {$/;"	f	class:folly::MacAddress	signature:() const
folly::MacAddress::toString	.\MacAddress.h	/^  std::string toString() const;$/;"	p	class:folly::MacAddress	access:public	signature:() const
folly::MacAddress::u64HBO	.\MacAddress.h	/^  uint64_t u64HBO() const {$/;"	f	class:folly::MacAddress	access:public	signature:() const
folly::MacAddress::u64NBO	.\MacAddress.h	/^  uint64_t u64NBO() const {$/;"	f	class:folly::MacAddress	access:public	signature:() const
folly::MaskBoundaryData	.\test\IPAddressTest.h	/^struct MaskBoundaryData : MaskData {$/;"	s	namespace:folly	inherits:MaskData
folly::MaskBoundaryData::MaskBoundaryData	.\test\IPAddressTest.h	/^  MaskBoundaryData(const std::string& addr, uint8_t mask,$/;"	f	struct:folly::MaskBoundaryData	access:public	signature:(const std::string& addr, uint8_t mask, const std::string& subnet, bool inSubnet)
folly::MaskBoundaryData::inSubnet	.\test\IPAddressTest.h	/^  bool inSubnet;$/;"	m	struct:folly::MaskBoundaryData	access:public
folly::MaskData	.\test\IPAddressTest.h	/^struct MaskData {$/;"	s	namespace:folly
folly::MaskData::MaskData	.\test\IPAddressTest.h	/^  MaskData(const std::string& addr, uint8_t mask,$/;"	f	struct:folly::MaskData	access:public	signature:(const std::string& addr, uint8_t mask, const std::string& subnet)
folly::MaskData::address	.\test\IPAddressTest.h	/^  std::string address;$/;"	m	struct:folly::MaskData	access:public
folly::MaskData::mask	.\test\IPAddressTest.h	/^  uint8_t mask;$/;"	m	struct:folly::MaskData	access:public
folly::MaskData::subnet	.\test\IPAddressTest.h	/^  std::string subnet;$/;"	m	struct:folly::MaskData	access:public
folly::MemoryMapping	.\MemoryMapping.h	/^class MemoryMapping : boost::noncopyable {$/;"	c	namespace:folly	inherits:boost::noncopyable
folly::MemoryMapping::AnonymousType	.\MemoryMapping.h	/^  enum AnonymousType {$/;"	g	class:folly::MemoryMapping	access:public
folly::MemoryMapping::InitFlags	.\MemoryMapping.h	/^  enum InitFlags {$/;"	g	class:folly::MemoryMapping	access:private
folly::MemoryMapping::LockMode	.\MemoryMapping.h	/^  enum class LockMode {$/;"	c	class:folly::MemoryMapping	access:public
folly::MemoryMapping::LockMode::TRY_LOCK	.\MemoryMapping.h	/^    TRY_LOCK,$/;"	m	class:folly::MemoryMapping::LockMode	access:private
folly::MemoryMapping::MemoryMapping	.\MemoryMapping.cpp	/^MemoryMapping::MemoryMapping(AnonymousType, off_t length, Options options)$/;"	f	class:folly::MemoryMapping	signature:(AnonymousType, off_t length, Options options)
folly::MemoryMapping::MemoryMapping	.\MemoryMapping.cpp	/^MemoryMapping::MemoryMapping(File file, off_t offset, off_t length,$/;"	f	class:folly::MemoryMapping	signature:(File file, off_t offset, off_t length, Options options)
folly::MemoryMapping::MemoryMapping	.\MemoryMapping.cpp	/^MemoryMapping::MemoryMapping(MemoryMapping&& other) {$/;"	f	class:folly::MemoryMapping	signature:(MemoryMapping&& other)
folly::MemoryMapping::MemoryMapping	.\MemoryMapping.cpp	/^MemoryMapping::MemoryMapping(const char* name, off_t offset, off_t length,$/;"	f	class:folly::MemoryMapping	signature:(const char* name, off_t offset, off_t length, Options options)
folly::MemoryMapping::MemoryMapping	.\MemoryMapping.cpp	/^MemoryMapping::MemoryMapping(int fd, off_t offset, off_t length,$/;"	f	class:folly::MemoryMapping	signature:(int fd, off_t offset, off_t length, Options options)
folly::MemoryMapping::MemoryMapping	.\MemoryMapping.h	/^  MemoryMapping();$/;"	p	class:folly::MemoryMapping	access:private	signature:()
folly::MemoryMapping::MemoryMapping	.\MemoryMapping.h	/^  MemoryMapping(AnonymousType, off_t length, Options options=Options());$/;"	p	class:folly::MemoryMapping	access:public	signature:(AnonymousType, off_t length, Options options=Options())
folly::MemoryMapping::MemoryMapping	.\MemoryMapping.h	/^  MemoryMapping(MemoryMapping&&);$/;"	p	class:folly::MemoryMapping	access:public	signature:(MemoryMapping&&)
folly::MemoryMapping::MemoryMapping	.\MemoryMapping.h	/^  explicit MemoryMapping(File file,$/;"	p	class:folly::MemoryMapping	access:public	signature:(File file, off_t offset=0, off_t length=-1, Options options=Options())
folly::MemoryMapping::MemoryMapping	.\MemoryMapping.h	/^  explicit MemoryMapping(const char* name,$/;"	p	class:folly::MemoryMapping	access:public	signature:(const char* name, off_t offset=0, off_t length=-1, Options options=Options())
folly::MemoryMapping::MemoryMapping	.\MemoryMapping.h	/^  explicit MemoryMapping(int fd,$/;"	p	class:folly::MemoryMapping	access:public	signature:(int fd, off_t offset=0, off_t length=-1, Options options=Options())
folly::MemoryMapping::Options	.\MemoryMapping.h	/^  struct Options {$/;"	s	class:folly::MemoryMapping	access:public
folly::MemoryMapping::Options::Options	.\MemoryMapping.h	/^    Options() { }$/;"	f	struct:folly::MemoryMapping::Options	access:public	signature:()
folly::MemoryMapping::Options::address	.\MemoryMapping.h	/^    void* address = nullptr;$/;"	m	struct:folly::MemoryMapping::Options	access:public
folly::MemoryMapping::Options::grow	.\MemoryMapping.h	/^    bool grow = false;$/;"	m	struct:folly::MemoryMapping::Options	access:public
folly::MemoryMapping::Options::pageSize	.\MemoryMapping.h	/^    off_t pageSize = 0;$/;"	m	struct:folly::MemoryMapping::Options	access:public
folly::MemoryMapping::Options::prefault	.\MemoryMapping.h	/^    bool prefault = false;$/;"	m	struct:folly::MemoryMapping::Options	access:public
folly::MemoryMapping::Options::readable	.\MemoryMapping.h	/^    bool readable = true;$/;"	m	struct:folly::MemoryMapping::Options	access:public
folly::MemoryMapping::Options::setGrow	.\MemoryMapping.h	/^    Options& setGrow(bool v) { grow = v; return *this; }$/;"	f	struct:folly::MemoryMapping::Options	access:public	signature:(bool v)
folly::MemoryMapping::Options::setPageSize	.\MemoryMapping.h	/^    Options& setPageSize(off_t v) { pageSize = v; return *this; }$/;"	f	struct:folly::MemoryMapping::Options	access:public	signature:(off_t v)
folly::MemoryMapping::Options::setPrefault	.\MemoryMapping.h	/^    Options& setPrefault(bool v) { prefault = v; return *this; }$/;"	f	struct:folly::MemoryMapping::Options	access:public	signature:(bool v)
folly::MemoryMapping::Options::setReadable	.\MemoryMapping.h	/^    Options& setReadable(bool v) { readable = v; return *this; }$/;"	f	struct:folly::MemoryMapping::Options	access:public	signature:(bool v)
folly::MemoryMapping::Options::setShared	.\MemoryMapping.h	/^    Options& setShared(bool v) { shared = v; return *this; }$/;"	f	struct:folly::MemoryMapping::Options	access:public	signature:(bool v)
folly::MemoryMapping::Options::setWritable	.\MemoryMapping.h	/^    Options& setWritable(bool v) { writable = v; return *this; }$/;"	f	struct:folly::MemoryMapping::Options	access:public	signature:(bool v)
folly::MemoryMapping::Options::shared	.\MemoryMapping.h	/^    bool shared = true;$/;"	m	struct:folly::MemoryMapping::Options	access:public
folly::MemoryMapping::Options::writable	.\MemoryMapping.h	/^    bool writable = false;$/;"	m	struct:folly::MemoryMapping::Options	access:public
folly::MemoryMapping::advise	.\MemoryMapping.cpp	/^void MemoryMapping::advise(int advice) const {$/;"	f	class:folly::MemoryMapping	signature:(int advice) const
folly::MemoryMapping::advise	.\MemoryMapping.h	/^  void advise(int advice) const;$/;"	p	class:folly::MemoryMapping	access:public	signature:(int advice) const
folly::MemoryMapping::asRange	.\MemoryMapping.h	/^  Range<const T*> asRange() const {$/;"	f	class:folly::MemoryMapping	access:public	signature:() const
folly::MemoryMapping::asWritableRange	.\MemoryMapping.h	/^  Range<T*> asWritableRange() const {$/;"	f	class:folly::MemoryMapping	access:public	signature:() const
folly::MemoryMapping::data	.\MemoryMapping.h	/^  StringPiece data() const {$/;"	f	class:folly::MemoryMapping	access:public	signature:() const
folly::MemoryMapping::data_	.\MemoryMapping.h	/^  MutableByteRange data_;$/;"	m	class:folly::MemoryMapping	access:private
folly::MemoryMapping::fd	.\MemoryMapping.h	/^  int fd() const { return file_.fd(); }$/;"	f	class:folly::MemoryMapping	access:public	signature:() const
folly::MemoryMapping::file_	.\MemoryMapping.h	/^  File file_;$/;"	m	class:folly::MemoryMapping	access:private
folly::MemoryMapping::hintLinearScan	.\MemoryMapping.cpp	/^void MemoryMapping::hintLinearScan() {$/;"	f	class:folly::MemoryMapping	signature:()
folly::MemoryMapping::hintLinearScan	.\MemoryMapping.h	/^  void hintLinearScan();$/;"	p	class:folly::MemoryMapping	access:public	signature:()
folly::MemoryMapping::init	.\MemoryMapping.cpp	/^void MemoryMapping::init(off_t offset, off_t length) {$/;"	f	class:folly::MemoryMapping	signature:(off_t offset, off_t length)
folly::MemoryMapping::init	.\MemoryMapping.h	/^  void init(off_t offset, off_t length);$/;"	p	class:folly::MemoryMapping	access:private	signature:(off_t offset, off_t length)
folly::MemoryMapping::kAnon	.\MemoryMapping.h	/^    kAnon = 1 << 1,$/;"	e	enum:folly::MemoryMapping::InitFlags
folly::MemoryMapping::kAnonymous	.\MemoryMapping.h	/^    kAnonymous$/;"	e	enum:folly::MemoryMapping::AnonymousType
folly::MemoryMapping::kGrow	.\MemoryMapping.h	/^    kGrow = 1 << 0,$/;"	e	enum:folly::MemoryMapping::InitFlags
folly::MemoryMapping::locked_	.\MemoryMapping.h	/^  bool locked_ = false;$/;"	m	class:folly::MemoryMapping	access:private
folly::MemoryMapping::mapLength_	.\MemoryMapping.h	/^  off_t mapLength_ = 0;$/;"	m	class:folly::MemoryMapping	access:private
folly::MemoryMapping::mapStart_	.\MemoryMapping.h	/^  void* mapStart_ = nullptr;$/;"	m	class:folly::MemoryMapping	access:private
folly::MemoryMapping::mlock	.\MemoryMapping.cpp	/^bool MemoryMapping::mlock(LockMode lock) {$/;"	f	class:folly::MemoryMapping	signature:(LockMode lock)
folly::MemoryMapping::mlock	.\MemoryMapping.h	/^  bool mlock(LockMode lock);$/;"	p	class:folly::MemoryMapping	access:public	signature:(LockMode lock)
folly::MemoryMapping::mlocked	.\MemoryMapping.h	/^  bool mlocked() const {$/;"	f	class:folly::MemoryMapping	access:public	signature:() const
folly::MemoryMapping::munlock	.\MemoryMapping.cpp	/^void MemoryMapping::munlock(bool dontneed) {$/;"	f	class:folly::MemoryMapping	signature:(bool dontneed)
folly::MemoryMapping::munlock	.\MemoryMapping.h	/^  void munlock(bool dontneed = false);$/;"	p	class:folly::MemoryMapping	access:public	signature:(bool dontneed = false)
folly::MemoryMapping::operator =	.\MemoryMapping.cpp	/^MemoryMapping& MemoryMapping::operator=(MemoryMapping other) {$/;"	f	class:folly::MemoryMapping	signature:(MemoryMapping other)
folly::MemoryMapping::operator =	.\MemoryMapping.h	/^  MemoryMapping& operator=(MemoryMapping);$/;"	p	class:folly::MemoryMapping	access:public	signature:(MemoryMapping)
folly::MemoryMapping::options_	.\MemoryMapping.h	/^  Options options_;$/;"	m	class:folly::MemoryMapping	access:private
folly::MemoryMapping::range	.\MemoryMapping.h	/^  ByteRange range() const {$/;"	f	class:folly::MemoryMapping	access:public	signature:() const
folly::MemoryMapping::swap	.\MemoryMapping.cpp	/^void MemoryMapping::swap(MemoryMapping& other) {$/;"	f	class:folly::MemoryMapping	signature:(MemoryMapping& other)
folly::MemoryMapping::swap	.\MemoryMapping.h	/^  void swap(MemoryMapping& other);$/;"	p	class:folly::MemoryMapping	access:public	signature:(MemoryMapping& other)
folly::MemoryMapping::writable	.\MemoryMapping.h	/^  static Options writable() {$/;"	f	class:folly::MemoryMapping	access:public	signature:()
folly::MemoryMapping::writableRange	.\MemoryMapping.h	/^  MutableByteRange writableRange() const {$/;"	f	class:folly::MemoryMapping	access:public	signature:() const
folly::MemoryMapping::~MemoryMapping	.\MemoryMapping.cpp	/^MemoryMapping::~MemoryMapping() {$/;"	f	class:folly::MemoryMapping	signature:()
folly::MemoryMapping::~MemoryMapping	.\MemoryMapping.h	/^  ~MemoryMapping();$/;"	p	class:folly::MemoryMapping	access:public	signature:()
folly::MicroSpinLock	.\SmallLocks.h	/^struct MicroSpinLock {$/;"	s	namespace:folly
folly::MicroSpinLock::FREE	.\SmallLocks.h	/^  enum { FREE = 0, LOCKED = 1 };$/;"	e	enum:folly::MicroSpinLock::__anon87
folly::MicroSpinLock::LOCKED	.\SmallLocks.h	/^  enum { FREE = 0, LOCKED = 1 };$/;"	e	enum:folly::MicroSpinLock::__anon87
folly::MicroSpinLock::cas	.\SmallLocks.h	/^  bool cas(uint8_t compare, uint8_t newVal) {$/;"	f	struct:folly::MicroSpinLock	access:public	signature:(uint8_t compare, uint8_t newVal)
folly::MicroSpinLock::init	.\SmallLocks.h	/^  void init() {$/;"	f	struct:folly::MicroSpinLock	access:public	signature:()
folly::MicroSpinLock::lock	.\SmallLocks.h	/^  void lock() {$/;"	f	struct:folly::MicroSpinLock	access:public	signature:()
folly::MicroSpinLock::lock_	.\SmallLocks.h	/^  uint8_t lock_;$/;"	m	struct:folly::MicroSpinLock	access:public
folly::MicroSpinLock::try_lock	.\SmallLocks.h	/^  bool try_lock() {$/;"	f	struct:folly::MicroSpinLock	access:public	signature:()
folly::MicroSpinLock::unlock	.\SmallLocks.h	/^  void unlock() {$/;"	f	struct:folly::MicroSpinLock	access:public	signature:()
folly::MoveTester	.\test\OptionalTest.cpp	/^class MoveTester {$/;"	c	namespace:folly	file:
folly::MoveTester::MoveTester	.\test\OptionalTest.cpp	/^  MoveTester(const MoveTester&) = default;$/;"	p	class:folly::MoveTester	file:	access:public	signature:(const MoveTester&)
folly::MoveTester::MoveTester	.\test\OptionalTest.cpp	/^  \/* implicit *\/ MoveTester(const char* s) : s_(s) {}$/;"	f	class:folly::MoveTester	access:public	signature:(const char* s)
folly::MoveTester::operator =	.\test\OptionalTest.cpp	/^  MoveTester& operator=(MoveTester&&) = default;$/;"	p	class:folly::MoveTester	file:	access:public	signature:(MoveTester&&)
folly::MoveTester::operator =	.\test\OptionalTest.cpp	/^  MoveTester& operator=(const MoveTester&) = default;$/;"	p	class:folly::MoveTester	file:	access:public	signature:(const MoveTester&)
folly::MoveTester::operator ==	.\test\OptionalTest.cpp	/^  friend bool operator==(const MoveTester& o1, const MoveTester& o2);$/;"	p	class:folly::MoveTester	file:	access:friend	signature:(const MoveTester& o1, const MoveTester& o2)
folly::MoveTester::s_	.\test\OptionalTest.cpp	/^  std::string s_;$/;"	m	class:folly::MoveTester	file:	access:private
folly::MoveWrapper	.\MoveWrapper.h	/^class MoveWrapper {$/;"	c	namespace:folly
folly::MoveWrapper::MoveWrapper	.\MoveWrapper.h	/^  MoveWrapper() = default;$/;"	p	class:folly::MoveWrapper	access:public	signature:()
folly::MoveWrapper::MoveWrapper	.\MoveWrapper.h	/^  MoveWrapper(MoveWrapper&& other) : value(std::move(other.value)) {}$/;"	f	class:folly::MoveWrapper	access:public	signature:(MoveWrapper&& other)
folly::MoveWrapper::MoveWrapper	.\MoveWrapper.h	/^  MoveWrapper(T&& t) : value(std::move(t)) {}$/;"	f	class:folly::MoveWrapper	access:public	signature:(T&& t)
folly::MoveWrapper::MoveWrapper	.\MoveWrapper.h	/^  MoveWrapper(const MoveWrapper& other) : value(std::move(other.value)) {}$/;"	f	class:folly::MoveWrapper	access:public	signature:(const MoveWrapper& other)
folly::MoveWrapper::operator *	.\MoveWrapper.h	/^        T& operator*()       { return value; }$/;"	f	class:folly::MoveWrapper	access:public	signature:()
folly::MoveWrapper::operator *	.\MoveWrapper.h	/^  const T& operator*() const { return value; }$/;"	f	class:folly::MoveWrapper	access:public	signature:() const
folly::MoveWrapper::operator ->	.\MoveWrapper.h	/^        T* operator->()       { return &value; }$/;"	f	class:folly::MoveWrapper	access:public	signature:()
folly::MoveWrapper::operator ->	.\MoveWrapper.h	/^  const T* operator->() const { return &value; }$/;"	f	class:folly::MoveWrapper	access:public	signature:() const
folly::MoveWrapper::operator =	.\MoveWrapper.h	/^  MoveWrapper& operator=(MoveWrapper const&) = delete;$/;"	p	class:folly::MoveWrapper	access:public	signature:(MoveWrapper const&)
folly::MoveWrapper::operator =	.\MoveWrapper.h	/^  MoveWrapper& operator=(MoveWrapper&&) = delete;$/;"	p	class:folly::MoveWrapper	access:public	signature:(MoveWrapper&&)
folly::MoveWrapper::value	.\MoveWrapper.h	/^  mutable T value;$/;"	m	class:folly::MoveWrapper	access:private
folly::MultiLevelTimeSeries	.\stats\Instantiations.cpp	/^template class MultiLevelTimeSeries<int64_t>;$/;"	x	file:
folly::MultiLevelTimeSeries	.\stats\MultiLevelTimeSeries.h	/^class MultiLevelTimeSeries {$/;"	c	namespace:folly
folly::MultiLevelTimeSeries::Level	.\stats\MultiLevelTimeSeries.h	/^  typedef folly::BucketedTimeSeries<ValueType, TimeType> Level;$/;"	t	class:folly::MultiLevelTimeSeries	access:public
folly::MultiLevelTimeSeries::MultiLevelTimeSeries	.\stats\MultiLevelTimeSeries-defs.h	/^MultiLevelTimeSeries<VT, TT>::MultiLevelTimeSeries($/;"	f	class:folly::MultiLevelTimeSeries	signature:( size_t nBuckets, size_t nLevels, const TimeType levelDurations[])
folly::MultiLevelTimeSeries::MultiLevelTimeSeries	.\stats\MultiLevelTimeSeries.h	/^  MultiLevelTimeSeries(size_t numBuckets,$/;"	p	class:folly::MultiLevelTimeSeries	access:public	signature:(size_t numBuckets, size_t numLevels, const TimeType levelDurations[])
folly::MultiLevelTimeSeries::TimeType	.\stats\MultiLevelTimeSeries.h	/^  typedef TT TimeType;$/;"	t	class:folly::MultiLevelTimeSeries	access:public
folly::MultiLevelTimeSeries::ValueType	.\stats\MultiLevelTimeSeries.h	/^  typedef VT ValueType;$/;"	t	class:folly::MultiLevelTimeSeries	access:public
folly::MultiLevelTimeSeries::addValue	.\stats\MultiLevelTimeSeries-defs.h	/^void MultiLevelTimeSeries<VT, TT>::addValue(TimeType now,$/;"	f	class:folly::MultiLevelTimeSeries	signature:(TimeType now, const ValueType& val)
folly::MultiLevelTimeSeries::addValue	.\stats\MultiLevelTimeSeries-defs.h	/^void MultiLevelTimeSeries<VT, TT>::addValue(TimeType now,$/;"	f	class:folly::MultiLevelTimeSeries	signature:(TimeType now, const ValueType& val, int64_t times)
folly::MultiLevelTimeSeries::addValue	.\stats\MultiLevelTimeSeries.h	/^  void addValue(TimeType now, const ValueType& val);$/;"	p	class:folly::MultiLevelTimeSeries	access:public	signature:(TimeType now, const ValueType& val)
folly::MultiLevelTimeSeries::addValue	.\stats\MultiLevelTimeSeries.h	/^  void addValue(TimeType now, const ValueType& val, int64_t times);$/;"	p	class:folly::MultiLevelTimeSeries	access:public	signature:(TimeType now, const ValueType& val, int64_t times)
folly::MultiLevelTimeSeries::addValueAggregated	.\stats\MultiLevelTimeSeries-defs.h	/^void MultiLevelTimeSeries<VT, TT>::addValueAggregated(TimeType now,$/;"	f	class:folly::MultiLevelTimeSeries	signature:(TimeType now, const ValueType& total, int64_t nsamples)
folly::MultiLevelTimeSeries::addValueAggregated	.\stats\MultiLevelTimeSeries.h	/^  void addValueAggregated(TimeType now, const ValueType& sum, int64_t nsamples);$/;"	p	class:folly::MultiLevelTimeSeries	access:public	signature:(TimeType now, const ValueType& sum, int64_t nsamples)
folly::MultiLevelTimeSeries::avg	.\stats\MultiLevelTimeSeries.h	/^  ReturnType avg(TimeType start, TimeType end) const {$/;"	f	class:folly::MultiLevelTimeSeries	access:public	signature:(TimeType start, TimeType end) const
folly::MultiLevelTimeSeries::avg	.\stats\MultiLevelTimeSeries.h	/^  ReturnType avg(int level) const {$/;"	f	class:folly::MultiLevelTimeSeries	access:public	signature:(int level) const
folly::MultiLevelTimeSeries::cachedCount_	.\stats\MultiLevelTimeSeries.h	/^  int cachedCount_;$/;"	m	class:folly::MultiLevelTimeSeries	access:private
folly::MultiLevelTimeSeries::cachedSum_	.\stats\MultiLevelTimeSeries.h	/^  ValueType cachedSum_;$/;"	m	class:folly::MultiLevelTimeSeries	access:private
folly::MultiLevelTimeSeries::cachedTime_	.\stats\MultiLevelTimeSeries.h	/^  TimeType cachedTime_;$/;"	m	class:folly::MultiLevelTimeSeries	access:private
folly::MultiLevelTimeSeries::clear	.\stats\MultiLevelTimeSeries-defs.h	/^void MultiLevelTimeSeries<VT, TT>::clear() {$/;"	f	class:folly::MultiLevelTimeSeries	signature:()
folly::MultiLevelTimeSeries::clear	.\stats\MultiLevelTimeSeries.h	/^  void clear();$/;"	p	class:folly::MultiLevelTimeSeries	access:public	signature:()
folly::MultiLevelTimeSeries::count	.\stats\MultiLevelTimeSeries.h	/^  int64_t count(TimeType start, TimeType end) const {$/;"	f	class:folly::MultiLevelTimeSeries	access:public	signature:(TimeType start, TimeType end) const
folly::MultiLevelTimeSeries::count	.\stats\MultiLevelTimeSeries.h	/^  int64_t count(int level) const {$/;"	f	class:folly::MultiLevelTimeSeries	access:public	signature:(int level) const
folly::MultiLevelTimeSeries::countRate	.\stats\MultiLevelTimeSeries.h	/^  ReturnType countRate(int level) const {$/;"	f	class:folly::MultiLevelTimeSeries	access:public	signature:(int level) const
folly::MultiLevelTimeSeries::flush	.\stats\MultiLevelTimeSeries-defs.h	/^void MultiLevelTimeSeries<VT, TT>::flush() {$/;"	f	class:folly::MultiLevelTimeSeries	signature:()
folly::MultiLevelTimeSeries::flush	.\stats\MultiLevelTimeSeries.h	/^  void flush();$/;"	p	class:folly::MultiLevelTimeSeries	access:public	signature:()
folly::MultiLevelTimeSeries::getLevel	.\stats\MultiLevelTimeSeries.h	/^  const Level& getLevel(TimeType start) const {$/;"	f	class:folly::MultiLevelTimeSeries	access:public	signature:(TimeType start) const
folly::MultiLevelTimeSeries::getLevel	.\stats\MultiLevelTimeSeries.h	/^  const Level& getLevel(int level) const {$/;"	f	class:folly::MultiLevelTimeSeries	access:public	signature:(int level) const
folly::MultiLevelTimeSeries::levels_	.\stats\MultiLevelTimeSeries.h	/^  std::vector<Level> levels_;$/;"	m	class:folly::MultiLevelTimeSeries	access:private
folly::MultiLevelTimeSeries::numBuckets	.\stats\MultiLevelTimeSeries.h	/^  size_t numBuckets() const {$/;"	f	class:folly::MultiLevelTimeSeries	access:public	signature:() const
folly::MultiLevelTimeSeries::numLevels	.\stats\MultiLevelTimeSeries.h	/^  size_t numLevels() const { return levels_.size(); }$/;"	f	class:folly::MultiLevelTimeSeries	access:public	signature:() const
folly::MultiLevelTimeSeries::rate	.\stats\MultiLevelTimeSeries.h	/^  ReturnType rate(TimeType start, TimeType end) const {$/;"	f	class:folly::MultiLevelTimeSeries	access:public	signature:(TimeType start, TimeType end) const
folly::MultiLevelTimeSeries::rate	.\stats\MultiLevelTimeSeries.h	/^  ValueType rate(int level) const {$/;"	f	class:folly::MultiLevelTimeSeries	access:public	signature:(int level) const
folly::MultiLevelTimeSeries::sum	.\stats\MultiLevelTimeSeries.h	/^  ValueType sum(TimeType start, TimeType end) const {$/;"	f	class:folly::MultiLevelTimeSeries	access:public	signature:(TimeType start, TimeType end) const
folly::MultiLevelTimeSeries::sum	.\stats\MultiLevelTimeSeries.h	/^  ValueType sum(int level) const {$/;"	f	class:folly::MultiLevelTimeSeries	access:public	signature:(int level) const
folly::MultiLevelTimeSeries::update	.\stats\MultiLevelTimeSeries-defs.h	/^void MultiLevelTimeSeries<VT, TT>::update(TimeType now) {$/;"	f	class:folly::MultiLevelTimeSeries	signature:(TimeType now)
folly::MultiLevelTimeSeries::update	.\stats\MultiLevelTimeSeries.h	/^  void update(TimeType now);$/;"	p	class:folly::MultiLevelTimeSeries	access:public	signature:(TimeType now)
folly::MutableByteRange	.\Range.h	/^typedef Range<unsigned char*> MutableByteRange;$/;"	t	namespace:folly
folly::MutableStringPiece	.\Range.h	/^typedef Range<char*> MutableStringPiece;$/;"	t	namespace:folly
folly::NoDefault	.\test\OptionalTest.cpp	/^struct NoDefault {$/;"	s	namespace:folly	file:
folly::NoDefault::NoDefault	.\test\OptionalTest.cpp	/^  NoDefault(int, int) {}$/;"	f	struct:folly::NoDefault	access:public	signature:(int, int)
folly::NoDefault::a	.\test\OptionalTest.cpp	/^  char a, b, c;$/;"	m	struct:folly::NoDefault	file:	access:public
folly::NoDefault::b	.\test\OptionalTest.cpp	/^  char a, b, c;$/;"	m	struct:folly::NoDefault	file:	access:public
folly::NoDefault::c	.\test\OptionalTest.cpp	/^  char a, b, c;$/;"	m	struct:folly::NoDefault	file:	access:public
folly::NotificationQueue	.\io\async\EventBase.h	/^class NotificationQueue;$/;"	x
folly::NotificationQueue	.\io\async\NotificationQueue.h	/^class NotificationQueue {$/;"	c	namespace:folly
folly::NotificationQueue::Consumer	.\io\async\NotificationQueue.h	/^  class Consumer : private EventHandler {$/;"	c	class:folly::NotificationQueue	inherits:EventHandler	access:public
folly::NotificationQueue::Consumer::Consumer	.\io\async\NotificationQueue.h	/^    Consumer()$/;"	f	class:folly::NotificationQueue::Consumer	access:public	signature:()
folly::NotificationQueue::Consumer::base_	.\io\async\NotificationQueue.h	/^    EventBase* base_;$/;"	m	class:folly::NotificationQueue::Consumer	access:private
folly::NotificationQueue::Consumer::destroyedFlagPtr_	.\io\async\NotificationQueue.h	/^    bool* destroyedFlagPtr_;$/;"	m	class:folly::NotificationQueue::Consumer	access:private
folly::NotificationQueue::Consumer::getCurrentQueue	.\io\async\NotificationQueue.h	/^    NotificationQueue* getCurrentQueue() const {$/;"	f	class:folly::NotificationQueue::Consumer	access:public	signature:() const
folly::NotificationQueue::Consumer::getEventBase	.\io\async\NotificationQueue.h	/^    EventBase* getEventBase() {$/;"	f	class:folly::NotificationQueue::Consumer	access:public	signature:()
folly::NotificationQueue::Consumer::getMaxReadAtOnce	.\io\async\NotificationQueue.h	/^    uint32_t getMaxReadAtOnce() const {$/;"	f	class:folly::NotificationQueue::Consumer	access:public	signature:() const
folly::NotificationQueue::Consumer::init	.\io\async\NotificationQueue.h	/^    void init(EventBase* eventBase, NotificationQueue* queue);$/;"	p	class:folly::NotificationQueue::Consumer	access:private	signature:(EventBase* eventBase, NotificationQueue* queue)
folly::NotificationQueue::Consumer::init	.\io\async\NotificationQueue.h	/^void NotificationQueue<MessageT>::Consumer::init($/;"	f	class:folly::NotificationQueue::Consumer	signature:( EventBase* eventBase, NotificationQueue* queue)
folly::NotificationQueue::Consumer::maxReadAtOnce_	.\io\async\NotificationQueue.h	/^    uint32_t maxReadAtOnce_;$/;"	m	class:folly::NotificationQueue::Consumer	access:private
folly::NotificationQueue::Consumer::messageAvailable	.\io\async\NotificationQueue.h	/^    virtual void messageAvailable(MessageT&& message) = 0;$/;"	p	class:folly::NotificationQueue::Consumer	access:public	signature:(MessageT&& message)
folly::NotificationQueue::Consumer::noexcept	.\io\async\NotificationQueue.h	/^    virtual void handlerReady(uint16_t events) noexcept;$/;"	m	class:folly::NotificationQueue::Consumer	access:public
folly::NotificationQueue::Consumer::queue_	.\io\async\NotificationQueue.h	/^    NotificationQueue* queue_;$/;"	m	class:folly::NotificationQueue::Consumer	access:private
folly::NotificationQueue::Consumer::setActive	.\io\async\NotificationQueue.h	/^    void setActive(bool active, bool shouldLock = false) {$/;"	f	class:folly::NotificationQueue::Consumer	access:private	signature:(bool active, bool shouldLock = false)
folly::NotificationQueue::Consumer::setMaxReadAtOnce	.\io\async\NotificationQueue.h	/^    void setMaxReadAtOnce(uint32_t maxAtOnce) {$/;"	f	class:folly::NotificationQueue::Consumer	access:public	signature:(uint32_t maxAtOnce)
folly::NotificationQueue::Consumer::startConsuming	.\io\async\NotificationQueue.h	/^    void startConsuming(EventBase* eventBase, NotificationQueue* queue) {$/;"	f	class:folly::NotificationQueue::Consumer	access:public	signature:(EventBase* eventBase, NotificationQueue* queue)
folly::NotificationQueue::Consumer::startConsumingInternal	.\io\async\NotificationQueue.h	/^    void startConsumingInternal($/;"	f	class:folly::NotificationQueue::Consumer	access:public	signature:( EventBase* eventBase, NotificationQueue* queue)
folly::NotificationQueue::Consumer::stopConsuming	.\io\async\NotificationQueue.h	/^    void stopConsuming();$/;"	p	class:folly::NotificationQueue::Consumer	access:public	signature:()
folly::NotificationQueue::Consumer::stopConsuming	.\io\async\NotificationQueue.h	/^void NotificationQueue<MessageT>::Consumer::stopConsuming() {$/;"	f	class:folly::NotificationQueue::Consumer	signature:()
folly::NotificationQueue::Consumer::~Consumer	.\io\async\NotificationQueue.h	/^    virtual ~Consumer();$/;"	p	class:folly::NotificationQueue::Consumer	access:public	signature:()
folly::NotificationQueue::Consumer::~Consumer	.\io\async\NotificationQueue.h	/^NotificationQueue<MessageT>::Consumer::~Consumer() {$/;"	f	class:folly::NotificationQueue::Consumer	signature:()
folly::NotificationQueue::FdType	.\io\async\NotificationQueue.h	/^  enum class FdType {$/;"	c	class:folly::NotificationQueue	access:public
folly::NotificationQueue::FdType::EVENTFD	.\io\async\NotificationQueue.h	/^    EVENTFD,$/;"	m	class:folly::NotificationQueue::FdType	access:private
folly::NotificationQueue::NotificationQueue	.\io\async\NotificationQueue.h	/^  NotificationQueue(NotificationQueue const &) = delete;$/;"	p	class:folly::NotificationQueue	access:private	signature:(NotificationQueue const &)
folly::NotificationQueue::NotificationQueue	.\io\async\NotificationQueue.h	/^  explicit NotificationQueue(uint32_t maxSize = 0,$/;"	f	class:folly::NotificationQueue	access:public	signature:(uint32_t maxSize = 0, FdType fdType = FdType::EVENTFD)
folly::NotificationQueue::advisoryMaxQueueSize_	.\io\async\NotificationQueue.h	/^      advisoryMaxQueueSize_(maxSize),$/;"	p	class:folly::NotificationQueue	access:public	signature:(maxSize)
folly::NotificationQueue::advisoryMaxQueueSize_	.\io\async\NotificationQueue.h	/^  uint32_t advisoryMaxQueueSize_;$/;"	m	class:folly::NotificationQueue	access:private
folly::NotificationQueue::checkPid	.\io\async\NotificationQueue.h	/^  void checkPid() const {$/;"	f	class:folly::NotificationQueue	access:public	signature:() const
folly::NotificationQueue::checkQueueSize	.\io\async\NotificationQueue.h	/^  inline bool checkQueueSize(size_t maxSize, bool throws=true) const {$/;"	f	class:folly::NotificationQueue	access:private	signature:(size_t maxSize, bool throws=true) const
folly::NotificationQueue::eventfd_	.\io\async\NotificationQueue.h	/^  int eventfd_;$/;"	m	class:folly::NotificationQueue	access:private
folly::NotificationQueue::operator =	.\io\async\NotificationQueue.h	/^  NotificationQueue& operator=(NotificationQueue const &) = delete;$/;"	p	class:folly::NotificationQueue	access:private	signature:(NotificationQueue const &)
folly::NotificationQueue::pid_	.\io\async\NotificationQueue.h	/^  pid_t pid_;$/;"	m	class:folly::NotificationQueue	access:private
folly::NotificationQueue::pipeFds_	.\io\async\NotificationQueue.h	/^  int pipeFds_[2]; \/\/ to fallback to on older\/non-linux systems$/;"	m	class:folly::NotificationQueue	access:private
folly::NotificationQueue::putMessage	.\io\async\NotificationQueue.h	/^  void putMessage(MessageT&& message) {$/;"	f	class:folly::NotificationQueue	access:public	signature:(MessageT&& message)
folly::NotificationQueue::putMessage	.\io\async\NotificationQueue.h	/^  void putMessage(const MessageT& message) {$/;"	f	class:folly::NotificationQueue	access:public	signature:(const MessageT& message)
folly::NotificationQueue::putMessageImpl	.\io\async\NotificationQueue.h	/^  bool putMessageImpl($/;"	f	class:folly::NotificationQueue	access:private	signature:( const MessageT& message, size_t maxSize, bool throws=true)
folly::NotificationQueue::putMessageImpl	.\io\async\NotificationQueue.h	/^  bool putMessageImpl(MessageT&& message, size_t maxSize, bool throws=true) {$/;"	f	class:folly::NotificationQueue	access:private	signature:(MessageT&& message, size_t maxSize, bool throws=true)
folly::NotificationQueue::putMessages	.\io\async\NotificationQueue.h	/^  void putMessages(InputIteratorT first, InputIteratorT last) {$/;"	f	class:folly::NotificationQueue	access:public	signature:(InputIteratorT first, InputIteratorT last)
folly::NotificationQueue::putMessagesImpl	.\io\async\NotificationQueue.h	/^  void putMessagesImpl(InputIteratorT first, InputIteratorT last,$/;"	f	class:folly::NotificationQueue	access:private	signature:(InputIteratorT first, InputIteratorT last, std::input_iterator_tag)
folly::NotificationQueue::queue_	.\io\async\NotificationQueue.h	/^      queue_() {$/;"	f	class:folly::NotificationQueue	access:public	signature:()
folly::NotificationQueue::queue_	.\io\async\NotificationQueue.h	/^  std::deque<std::pair<MessageT, std::shared_ptr<RequestContext>>> queue_;$/;"	m	class:folly::NotificationQueue	access:private
folly::NotificationQueue::setMaxQueueSize	.\io\async\NotificationQueue.h	/^  void setMaxQueueSize(uint32_t max) {$/;"	f	class:folly::NotificationQueue	access:public	signature:(uint32_t max)
folly::NotificationQueue::signalEvent	.\io\async\NotificationQueue.h	/^  inline void signalEvent(size_t numAdded = 1) const {$/;"	f	class:folly::NotificationQueue	access:private	signature:(size_t numAdded = 1) const
folly::NotificationQueue::size	.\io\async\NotificationQueue.h	/^  int size() {$/;"	f	class:folly::NotificationQueue	access:public	signature:()
folly::NotificationQueue::spinlock_	.\io\async\NotificationQueue.h	/^  mutable folly::MicroSpinLock spinlock_;$/;"	m	class:folly::NotificationQueue	access:private
folly::NotificationQueue::tryConsume	.\io\async\NotificationQueue.h	/^  bool tryConsume(MessageT& result) {$/;"	f	class:folly::NotificationQueue	access:public	signature:(MessageT& result)
folly::NotificationQueue::tryConsumeEvent	.\io\async\NotificationQueue.h	/^  bool tryConsumeEvent() {$/;"	f	class:folly::NotificationQueue	access:private	signature:()
folly::NotificationQueue::tryPutMessage	.\io\async\NotificationQueue.h	/^  void tryPutMessage(MessageT&& message) {$/;"	f	class:folly::NotificationQueue	access:public	signature:(MessageT&& message)
folly::NotificationQueue::tryPutMessage	.\io\async\NotificationQueue.h	/^  void tryPutMessage(const MessageT& message) {$/;"	f	class:folly::NotificationQueue	access:public	signature:(const MessageT& message)
folly::NotificationQueue::tryPutMessageNoThrow	.\io\async\NotificationQueue.h	/^  bool tryPutMessageNoThrow(MessageT&& message) {$/;"	f	class:folly::NotificationQueue	access:public	signature:(MessageT&& message)
folly::NotificationQueue::tryPutMessageNoThrow	.\io\async\NotificationQueue.h	/^  bool tryPutMessageNoThrow(const MessageT& message) {$/;"	f	class:folly::NotificationQueue	access:public	signature:(const MessageT& message)
folly::NotificationQueue::~NotificationQueue	.\io\async\NotificationQueue.h	/^  ~NotificationQueue() {$/;"	f	class:folly::NotificationQueue	access:public	signature:()
folly::Optional	.\Optional.h	/^class Optional {$/;"	c	namespace:folly
folly::Optional::Optional	.\Optional.h	/^  Optional()$/;"	f	class:folly::Optional	access:public	signature:()
folly::Optional::__anon81::value_	.\Optional.h	/^  union { Value value_; };$/;"	m	union:folly::Optional::__anon81	access:public
folly::Optional::assign	.\Optional.h	/^  void assign(Optional&& src) {$/;"	f	class:folly::Optional	access:public	signature:(Optional&& src)
folly::Optional::assign	.\Optional.h	/^  void assign(Value&& newValue) {$/;"	f	class:folly::Optional	access:public	signature:(Value&& newValue)
folly::Optional::assign	.\Optional.h	/^  void assign(const None&) {$/;"	f	class:folly::Optional	access:public	signature:(const None&)
folly::Optional::assign	.\Optional.h	/^  void assign(const Optional& src) {$/;"	f	class:folly::Optional	access:public	signature:(const Optional& src)
folly::Optional::assign	.\Optional.h	/^  void assign(const Value& newValue) {$/;"	f	class:folly::Optional	access:public	signature:(const Value& newValue)
folly::Optional::clear	.\Optional.h	/^  void clear() {$/;"	f	class:folly::Optional	access:public	signature:()
folly::Optional::construct	.\Optional.h	/^  void construct(Args&&... args) {$/;"	f	class:folly::Optional	access:private	signature:(Args&&.... args)
folly::Optional::emplace	.\Optional.h	/^  void emplace(Args&&... args) {$/;"	f	class:folly::Optional	access:public	signature:(Args&&.... args)
folly::Optional::hasValue	.\Optional.h	/^  bool hasValue() const { return hasValue_; }$/;"	f	class:folly::Optional	access:public	signature:() const
folly::Optional::hasValue_	.\Optional.h	/^    : hasValue_(false) {$/;"	f	class:folly::Optional	access:public	signature:(false)
folly::Optional::hasValue_	.\Optional.h	/^  bool hasValue_;$/;"	m	class:folly::Optional	access:private
folly::Optional::noexcept	.\Optional.h	/^    noexcept (std::is_nothrow_copy_assignable<Value>::value) {$/;"	f	class:folly::Optional	access:public	signature:(std::is_nothrow_copy_assignable<Value>::value)
folly::Optional::noexcept	.\Optional.h	/^    noexcept (std::is_nothrow_move_assignable<Value>::value) {$/;"	f	class:folly::Optional	access:public	signature:(std::is_nothrow_move_assignable<Value>::value)
folly::Optional::noexcept	.\Optional.h	/^    noexcept(std::is_nothrow_copy_constructible<Value>::value) {$/;"	f	class:folly::Optional	access:public	signature:(std::is_nothrow_copy_constructible<Value>::value)
folly::Optional::noexcept	.\Optional.h	/^    noexcept(std::is_nothrow_move_constructible<Value>::value) {$/;"	f	class:folly::Optional	access:public	signature:(std::is_nothrow_move_constructible<Value>::value)
folly::Optional::operator *	.\Optional.h	/^        Value& operator*()       { return value(); }$/;"	f	class:folly::Optional	access:public	signature:()
folly::Optional::operator *	.\Optional.h	/^  const Value& operator*() const { return value(); }$/;"	f	class:folly::Optional	access:public	signature:() const
folly::Optional::operator ->	.\Optional.h	/^        Value* operator->()       { return &value(); }$/;"	f	class:folly::Optional	access:public	signature:()
folly::Optional::operator ->	.\Optional.h	/^  const Value* operator->() const { return &value(); }$/;"	f	class:folly::Optional	access:public	signature:() const
folly::Optional::operator =	.\Optional.h	/^  Optional& operator=(Arg&& arg) {$/;"	f	class:folly::Optional	access:public	signature:(Arg&& arg)
folly::Optional::operator bool	.\Optional.h	/^  explicit operator bool() const {$/;"	f	class:folly::Optional	access:public	signature:() const
folly::Optional::value	.\Optional.h	/^  Value& value() {$/;"	f	class:folly::Optional	access:public	signature:()
folly::Optional::value	.\Optional.h	/^  const Value& value() const {$/;"	f	class:folly::Optional	access:public	signature:() const
folly::Optional::value_or	.\Optional.h	/^  Value value_or(U&& dflt) && {$/;"	f	class:folly::Optional	access:public	signature:(U&& dflt)
folly::Optional::value_or	.\Optional.h	/^  Value value_or(U&& dflt) const& {$/;"	f	class:folly::Optional	access:public	signature:(U&& dflt) const
folly::PackedSyncPtr	.\PackedSyncPtr.h	/^class PackedSyncPtr {$/;"	c	namespace:folly
folly::PackedSyncPtr::data_	.\PackedSyncPtr.h	/^  PicoSpinLock<uintptr_t> data_;$/;"	m	class:folly::PackedSyncPtr	access:public
folly::PackedSyncPtr::extra	.\PackedSyncPtr.h	/^  uint16_t extra() const {$/;"	f	class:folly::PackedSyncPtr	access:public	signature:() const
folly::PackedSyncPtr::get	.\PackedSyncPtr.h	/^  T* get() const {$/;"	f	class:folly::PackedSyncPtr	access:public	signature:() const
folly::PackedSyncPtr::init	.\PackedSyncPtr.h	/^  void init(T* initialPtr = 0, uint16_t initialExtra = 0) {$/;"	f	class:folly::PackedSyncPtr	access:public	signature:(T* initialPtr = 0, uint16_t initialExtra = 0)
folly::PackedSyncPtr::lock	.\PackedSyncPtr.h	/^  void lock() const { data_.lock(); }$/;"	f	class:folly::PackedSyncPtr	access:public	signature:() const
folly::PackedSyncPtr::operator *	.\PackedSyncPtr.h	/^  reference operator*() const { return *get(); }$/;"	f	class:folly::PackedSyncPtr	access:public	signature:() const
folly::PackedSyncPtr::operator ->	.\PackedSyncPtr.h	/^  T* operator->() const { return get(); }$/;"	f	class:folly::PackedSyncPtr	access:public	signature:() const
folly::PackedSyncPtr::operator []	.\PackedSyncPtr.h	/^  reference operator[](std::ptrdiff_t i) const { return get()[i]; }$/;"	f	class:folly::PackedSyncPtr	access:public	signature:(std::ptrdiff_t i) const
folly::PackedSyncPtr::reference	.\PackedSyncPtr.h	/^  typedef typename std::add_lvalue_reference<T>::type reference;$/;"	t	class:folly::PackedSyncPtr	access:private
folly::PackedSyncPtr::set	.\PackedSyncPtr.h	/^  void set(T* t) {$/;"	f	class:folly::PackedSyncPtr	access:public	signature:(T* t)
folly::PackedSyncPtr::setExtra	.\PackedSyncPtr.h	/^  void setExtra(uint16_t extra) {$/;"	f	class:folly::PackedSyncPtr	access:public	signature:(uint16_t extra)
folly::PackedSyncPtr::try_lock	.\PackedSyncPtr.h	/^  bool try_lock() const { return data_.try_lock(); }$/;"	f	class:folly::PackedSyncPtr	access:public	signature:() const
folly::PackedSyncPtr::unlock	.\PackedSyncPtr.h	/^  void unlock() const { data_.unlock(); }$/;"	f	class:folly::PackedSyncPtr	access:public	signature:() const
folly::PicoSpinLock	.\SmallLocks.h	/^struct PicoSpinLock {$/;"	s	namespace:folly
folly::PicoSpinLock::UIntType	.\SmallLocks.h	/^  typedef typename std::make_unsigned<IntType>::type UIntType;$/;"	t	struct:folly::PicoSpinLock	access:public
folly::PicoSpinLock::getData	.\SmallLocks.h	/^  IntType getData() const {$/;"	f	struct:folly::PicoSpinLock	access:public	signature:() const
folly::PicoSpinLock::init	.\SmallLocks.h	/^  void init(IntType initialValue = 0) {$/;"	f	struct:folly::PicoSpinLock	access:public	signature:(IntType initialValue = 0)
folly::PicoSpinLock::kLockBitMask_	.\SmallLocks.h	/^  static const UIntType kLockBitMask_ = UIntType(1) << Bit;$/;"	m	struct:folly::PicoSpinLock	access:public
folly::PicoSpinLock::lock	.\SmallLocks.h	/^  void lock() const {$/;"	f	struct:folly::PicoSpinLock	access:public	signature:() const
folly::PicoSpinLock::lock_	.\SmallLocks.h	/^  UIntType lock_;$/;"	m	struct:folly::PicoSpinLock	access:public
folly::PicoSpinLock::setData	.\SmallLocks.h	/^  void setData(IntType w) {$/;"	f	struct:folly::PicoSpinLock	access:public	signature:(IntType w)
folly::PicoSpinLock::sizeof	.\SmallLocks.h	/^                  sizeof(IntType) == 8,$/;"	m	struct:folly::PicoSpinLock	access:public
folly::PicoSpinLock::static_assert	.\SmallLocks.h	/^  static_assert(std::is_integral<IntType>::value,$/;"	p	struct:folly::PicoSpinLock	access:public	signature:(std::is_integral<IntType>::value, )
folly::PicoSpinLock::try_lock	.\SmallLocks.h	/^  bool try_lock() const {$/;"	f	struct:folly::PicoSpinLock	access:public	signature:() const
folly::PicoSpinLock::unlock	.\SmallLocks.h	/^  void unlock() const {$/;"	f	struct:folly::PicoSpinLock	access:public	signature:() const
folly::ProcessReturnCode	.\Subprocess.h	/^class ProcessReturnCode {$/;"	c	namespace:folly
folly::ProcessReturnCode::EXITED	.\Subprocess.h	/^    EXITED,$/;"	e	enum:folly::ProcessReturnCode::State
folly::ProcessReturnCode::KILLED	.\Subprocess.h	/^    KILLED$/;"	e	enum:folly::ProcessReturnCode::State
folly::ProcessReturnCode::NOT_STARTED	.\Subprocess.h	/^    NOT_STARTED,$/;"	e	enum:folly::ProcessReturnCode::State
folly::ProcessReturnCode::ProcessReturnCode	.\Subprocess.h	/^  explicit ProcessReturnCode(int rv) : rawStatus_(rv) { }$/;"	f	class:folly::ProcessReturnCode	access:private	signature:(int rv)
folly::ProcessReturnCode::RUNNING	.\Subprocess.h	/^    RUNNING,$/;"	e	enum:folly::ProcessReturnCode::State
folly::ProcessReturnCode::RV_NOT_STARTED	.\Subprocess.h	/^  static constexpr int RV_NOT_STARTED = -2;$/;"	m	class:folly::ProcessReturnCode	access:private
folly::ProcessReturnCode::RV_RUNNING	.\Subprocess.h	/^  static constexpr int RV_RUNNING = -1;$/;"	m	class:folly::ProcessReturnCode	access:private
folly::ProcessReturnCode::State	.\Subprocess.h	/^  enum State {$/;"	g	class:folly::ProcessReturnCode	access:public
folly::ProcessReturnCode::Subprocess	.\Subprocess.h	/^  friend class Subprocess;$/;"	x
folly::ProcessReturnCode::coreDumped	.\Subprocess.cpp	/^bool ProcessReturnCode::coreDumped() const {$/;"	f	class:folly::ProcessReturnCode	signature:() const
folly::ProcessReturnCode::coreDumped	.\Subprocess.h	/^  bool coreDumped() const;$/;"	p	class:folly::ProcessReturnCode	access:public	signature:() const
folly::ProcessReturnCode::enforce	.\Subprocess.cpp	/^void ProcessReturnCode::enforce(State expected) const {$/;"	f	class:folly::ProcessReturnCode	signature:(State expected) const
folly::ProcessReturnCode::enforce	.\Subprocess.h	/^  void enforce(State state) const;$/;"	p	class:folly::ProcessReturnCode	access:public	signature:(State state) const
folly::ProcessReturnCode::exitStatus	.\Subprocess.cpp	/^int ProcessReturnCode::exitStatus() const {$/;"	f	class:folly::ProcessReturnCode	signature:() const
folly::ProcessReturnCode::exitStatus	.\Subprocess.h	/^  int exitStatus() const;$/;"	p	class:folly::ProcessReturnCode	access:public	signature:() const
folly::ProcessReturnCode::exited	.\Subprocess.h	/^  bool exited() const { return state() == EXITED; }$/;"	f	class:folly::ProcessReturnCode	access:public	signature:() const
folly::ProcessReturnCode::killSignal	.\Subprocess.cpp	/^int ProcessReturnCode::killSignal() const {$/;"	f	class:folly::ProcessReturnCode	signature:() const
folly::ProcessReturnCode::killSignal	.\Subprocess.h	/^  int killSignal() const;$/;"	p	class:folly::ProcessReturnCode	access:public	signature:() const
folly::ProcessReturnCode::killed	.\Subprocess.h	/^  bool killed() const { return state() == KILLED; }$/;"	f	class:folly::ProcessReturnCode	access:public	signature:() const
folly::ProcessReturnCode::notStarted	.\Subprocess.h	/^  bool notStarted() const { return state() == NOT_STARTED; }$/;"	f	class:folly::ProcessReturnCode	access:public	signature:() const
folly::ProcessReturnCode::rawStatus_	.\Subprocess.h	/^  int rawStatus_;$/;"	m	class:folly::ProcessReturnCode	access:private
folly::ProcessReturnCode::running	.\Subprocess.h	/^  bool running() const { return state() == RUNNING; }$/;"	f	class:folly::ProcessReturnCode	access:public	signature:() const
folly::ProcessReturnCode::state	.\Subprocess.cpp	/^ProcessReturnCode::State ProcessReturnCode::state() const {$/;"	f	class:folly::ProcessReturnCode	signature:() const
folly::ProcessReturnCode::state	.\Subprocess.h	/^  State state() const;$/;"	p	class:folly::ProcessReturnCode	access:public	signature:() const
folly::ProcessReturnCode::str	.\Subprocess.cpp	/^std::string ProcessReturnCode::str() const {$/;"	f	class:folly::ProcessReturnCode	signature:() const
folly::ProcessReturnCode::str	.\Subprocess.h	/^  std::string str() const;$/;"	p	class:folly::ProcessReturnCode	access:public	signature:() const
folly::ProducerConsumerQueue	.\ProducerConsumerQueue.h	/^struct ProducerConsumerQueue : private boost::noncopyable {$/;"	s	namespace:folly	inherits:boost::noncopyable
folly::ProducerConsumerQueue::ProducerConsumerQueue	.\ProducerConsumerQueue.h	/^  explicit ProducerConsumerQueue(uint32_t size)$/;"	f	struct:folly::ProducerConsumerQueue	access:public	signature:(uint32_t size)
folly::ProducerConsumerQueue::frontPtr	.\ProducerConsumerQueue.h	/^  T* frontPtr() {$/;"	f	struct:folly::ProducerConsumerQueue	access:public	signature:()
folly::ProducerConsumerQueue::isEmpty	.\ProducerConsumerQueue.h	/^  bool isEmpty() const {$/;"	f	struct:folly::ProducerConsumerQueue	access:public	signature:() const
folly::ProducerConsumerQueue::isFull	.\ProducerConsumerQueue.h	/^  bool isFull() const {$/;"	f	struct:folly::ProducerConsumerQueue	access:public	signature:() const
folly::ProducerConsumerQueue::popFront	.\ProducerConsumerQueue.h	/^  void popFront() {$/;"	f	struct:folly::ProducerConsumerQueue	access:public	signature:()
folly::ProducerConsumerQueue::read	.\ProducerConsumerQueue.h	/^  bool read(T& record) {$/;"	f	struct:folly::ProducerConsumerQueue	access:public	signature:(T& record)
folly::ProducerConsumerQueue::readIndex_	.\ProducerConsumerQueue.h	/^  std::atomic<int> readIndex_;$/;"	m	struct:folly::ProducerConsumerQueue	access:private
folly::ProducerConsumerQueue::records_	.\ProducerConsumerQueue.h	/^  T* const records_;$/;"	m	struct:folly::ProducerConsumerQueue	access:private
folly::ProducerConsumerQueue::sizeGuess	.\ProducerConsumerQueue.h	/^  size_t sizeGuess() const {$/;"	f	struct:folly::ProducerConsumerQueue	access:public	signature:() const
folly::ProducerConsumerQueue::size_	.\ProducerConsumerQueue.h	/^  const uint32_t size_;$/;"	m	struct:folly::ProducerConsumerQueue	access:private
folly::ProducerConsumerQueue::value_type	.\ProducerConsumerQueue.h	/^  typedef T value_type;$/;"	t	struct:folly::ProducerConsumerQueue	access:public
folly::ProducerConsumerQueue::write	.\ProducerConsumerQueue.h	/^  bool write(Args&&... recordArgs) {$/;"	f	struct:folly::ProducerConsumerQueue	access:public	signature:(Args&&.... recordArgs)
folly::ProducerConsumerQueue::writeIndex_	.\ProducerConsumerQueue.h	/^  std::atomic<int> writeIndex_;$/;"	m	struct:folly::ProducerConsumerQueue	access:private
folly::ProducerConsumerQueue::~ProducerConsumerQueue	.\ProducerConsumerQueue.h	/^  ~ProducerConsumerQueue() {$/;"	f	struct:folly::ProducerConsumerQueue	access:public	signature:()
folly::RWSpinLock	.\RWSpinLock.h	/^class RWSpinLock : boost::noncopyable {$/;"	c	namespace:folly	inherits:boost::noncopyable
folly::RWSpinLock::RWSpinLock	.\RWSpinLock.h	/^  RWSpinLock() : bits_(0) {}$/;"	f	class:folly::RWSpinLock	access:public	signature:()
folly::RWSpinLock::ReadHolder	.\RWSpinLock.h	/^  class ReadHolder {$/;"	c	class:folly::RWSpinLock	access:public
folly::RWSpinLock::ReadHolder	.\RWSpinLock.h	/^  class ReadHolder;$/;"	x
folly::RWSpinLock::ReadHolder::ReadHolder	.\RWSpinLock.h	/^    ReadHolder(ReadHolder&& other) : lock_(other.lock_) {$/;"	f	class:folly::RWSpinLock::ReadHolder	access:public	signature:(ReadHolder&& other)
folly::RWSpinLock::ReadHolder::ReadHolder	.\RWSpinLock.h	/^    explicit ReadHolder(RWSpinLock& lock) : lock_(&lock) {$/;"	f	class:folly::RWSpinLock::ReadHolder	access:public	signature:(RWSpinLock& lock)
folly::RWSpinLock::ReadHolder::ReadHolder	.\RWSpinLock.h	/^    explicit ReadHolder(RWSpinLock* lock = nullptr) : lock_(lock) {$/;"	f	class:folly::RWSpinLock::ReadHolder	access:public	signature:(RWSpinLock* lock = nullptr)
folly::RWSpinLock::ReadHolder::ReadHolder	.\RWSpinLock.h	/^    explicit ReadHolder(UpgradedHolder&& upgraded) : lock_(upgraded.lock_) {$/;"	f	class:folly::RWSpinLock::ReadHolder	access:public	signature:(UpgradedHolder&& upgraded)
folly::RWSpinLock::ReadHolder::ReadHolder	.\RWSpinLock.h	/^    explicit ReadHolder(WriteHolder&& writer) : lock_(writer.lock_) {$/;"	f	class:folly::RWSpinLock::ReadHolder	access:public	signature:(WriteHolder&& writer)
folly::RWSpinLock::ReadHolder::UpgradedHolder	.\RWSpinLock.h	/^    friend class UpgradedHolder;$/;"	x
folly::RWSpinLock::ReadHolder::WriteHolder	.\RWSpinLock.h	/^    friend class WriteHolder;$/;"	x
folly::RWSpinLock::ReadHolder::lock_	.\RWSpinLock.h	/^    RWSpinLock* lock_;$/;"	m	class:folly::RWSpinLock::ReadHolder	access:private
folly::RWSpinLock::ReadHolder::operator =	.\RWSpinLock.h	/^    ReadHolder& operator=(ReadHolder&& other) {$/;"	f	class:folly::RWSpinLock::ReadHolder	access:public	signature:(ReadHolder&& other)
folly::RWSpinLock::ReadHolder::other	.\RWSpinLock.h	/^    ReadHolder& operator=(const ReadHolder& other) = delete;$/;"	m	class:folly::RWSpinLock::ReadHolder	access:public
folly::RWSpinLock::ReadHolder::other	.\RWSpinLock.h	/^    ReadHolder(const ReadHolder& other) = delete;$/;"	m	class:folly::RWSpinLock::ReadHolder	access:public
folly::RWSpinLock::ReadHolder::reset	.\RWSpinLock.h	/^    void reset(RWSpinLock* lock = nullptr) {$/;"	f	class:folly::RWSpinLock::ReadHolder	access:public	signature:(RWSpinLock* lock = nullptr)
folly::RWSpinLock::ReadHolder::swap	.\RWSpinLock.h	/^    void swap(ReadHolder* other) {$/;"	f	class:folly::RWSpinLock::ReadHolder	access:public	signature:(ReadHolder* other)
folly::RWSpinLock::ReadHolder::~ReadHolder	.\RWSpinLock.h	/^    ~ReadHolder() { if (lock_) lock_->unlock_shared(); }$/;"	f	class:folly::RWSpinLock::ReadHolder	access:public	signature:()
folly::RWSpinLock::UpgradedHolder	.\RWSpinLock.h	/^  class UpgradedHolder {$/;"	c	class:folly::RWSpinLock	access:public
folly::RWSpinLock::UpgradedHolder	.\RWSpinLock.h	/^  class UpgradedHolder;$/;"	x
folly::RWSpinLock::UpgradedHolder::ReadHolder	.\RWSpinLock.h	/^    friend class ReadHolder;$/;"	x
folly::RWSpinLock::UpgradedHolder::UpgradedHolder	.\RWSpinLock.h	/^    UpgradedHolder(UpgradedHolder&& other) : lock_(other.lock_) {$/;"	f	class:folly::RWSpinLock::UpgradedHolder	access:public	signature:(UpgradedHolder&& other)
folly::RWSpinLock::UpgradedHolder::UpgradedHolder	.\RWSpinLock.h	/^    explicit UpgradedHolder(RWSpinLock& lock) : lock_(&lock) {$/;"	f	class:folly::RWSpinLock::UpgradedHolder	access:public	signature:(RWSpinLock& lock)
folly::RWSpinLock::UpgradedHolder::UpgradedHolder	.\RWSpinLock.h	/^    explicit UpgradedHolder(RWSpinLock* lock = nullptr) : lock_(lock) {$/;"	f	class:folly::RWSpinLock::UpgradedHolder	access:public	signature:(RWSpinLock* lock = nullptr)
folly::RWSpinLock::UpgradedHolder::UpgradedHolder	.\RWSpinLock.h	/^    explicit UpgradedHolder(WriteHolder&& writer) {$/;"	f	class:folly::RWSpinLock::UpgradedHolder	access:public	signature:(WriteHolder&& writer)
folly::RWSpinLock::UpgradedHolder::WriteHolder	.\RWSpinLock.h	/^    friend class WriteHolder;$/;"	x
folly::RWSpinLock::UpgradedHolder::lock_	.\RWSpinLock.h	/^    RWSpinLock* lock_;$/;"	m	class:folly::RWSpinLock::UpgradedHolder	access:private
folly::RWSpinLock::UpgradedHolder::operator =	.\RWSpinLock.h	/^    UpgradedHolder& operator =(UpgradedHolder&& other) {$/;"	f	class:folly::RWSpinLock::UpgradedHolder	access:public	signature:(UpgradedHolder&& other)
folly::RWSpinLock::UpgradedHolder::other	.\RWSpinLock.h	/^    UpgradedHolder& operator =(const UpgradedHolder& other) = delete;$/;"	m	class:folly::RWSpinLock::UpgradedHolder	access:public
folly::RWSpinLock::UpgradedHolder::other	.\RWSpinLock.h	/^    UpgradedHolder(const UpgradedHolder& other) = delete;$/;"	m	class:folly::RWSpinLock::UpgradedHolder	access:public
folly::RWSpinLock::UpgradedHolder::reset	.\RWSpinLock.h	/^    void reset(RWSpinLock* lock = nullptr) {$/;"	f	class:folly::RWSpinLock::UpgradedHolder	access:public	signature:(RWSpinLock* lock = nullptr)
folly::RWSpinLock::UpgradedHolder::swap	.\RWSpinLock.h	/^    void swap(UpgradedHolder* other) {$/;"	f	class:folly::RWSpinLock::UpgradedHolder	access:public	signature:(UpgradedHolder* other)
folly::RWSpinLock::UpgradedHolder::~UpgradedHolder	.\RWSpinLock.h	/^    ~UpgradedHolder() { if (lock_) lock_->unlock_upgrade(); }$/;"	f	class:folly::RWSpinLock::UpgradedHolder	access:public	signature:()
folly::RWSpinLock::WriteHolder	.\RWSpinLock.h	/^  class WriteHolder {$/;"	c	class:folly::RWSpinLock	access:public
folly::RWSpinLock::WriteHolder	.\RWSpinLock.h	/^  class WriteHolder;$/;"	x
folly::RWSpinLock::WriteHolder::ReadHolder	.\RWSpinLock.h	/^    friend class ReadHolder;$/;"	x
folly::RWSpinLock::WriteHolder::UpgradedHolder	.\RWSpinLock.h	/^    friend class UpgradedHolder;$/;"	x
folly::RWSpinLock::WriteHolder::WriteHolder	.\RWSpinLock.h	/^    WriteHolder(WriteHolder&& other) : lock_(other.lock_) {$/;"	f	class:folly::RWSpinLock::WriteHolder	access:public	signature:(WriteHolder&& other)
folly::RWSpinLock::WriteHolder::WriteHolder	.\RWSpinLock.h	/^    explicit WriteHolder(RWSpinLock& lock) : lock_(&lock) {$/;"	f	class:folly::RWSpinLock::WriteHolder	access:public	signature:(RWSpinLock& lock)
folly::RWSpinLock::WriteHolder::WriteHolder	.\RWSpinLock.h	/^    explicit WriteHolder(RWSpinLock* lock = nullptr) : lock_(lock) {$/;"	f	class:folly::RWSpinLock::WriteHolder	access:public	signature:(RWSpinLock* lock = nullptr)
folly::RWSpinLock::WriteHolder::WriteHolder	.\RWSpinLock.h	/^    explicit WriteHolder(UpgradedHolder&& upgraded) {$/;"	f	class:folly::RWSpinLock::WriteHolder	access:public	signature:(UpgradedHolder&& upgraded)
folly::RWSpinLock::WriteHolder::lock_	.\RWSpinLock.h	/^    RWSpinLock* lock_;$/;"	m	class:folly::RWSpinLock::WriteHolder	access:private
folly::RWSpinLock::WriteHolder::operator =	.\RWSpinLock.h	/^    WriteHolder& operator =(WriteHolder&& other) {$/;"	f	class:folly::RWSpinLock::WriteHolder	access:public	signature:(WriteHolder&& other)
folly::RWSpinLock::WriteHolder::other	.\RWSpinLock.h	/^    WriteHolder& operator =(const WriteHolder& other) = delete;$/;"	m	class:folly::RWSpinLock::WriteHolder	access:public
folly::RWSpinLock::WriteHolder::other	.\RWSpinLock.h	/^    WriteHolder(const WriteHolder& other) = delete;$/;"	m	class:folly::RWSpinLock::WriteHolder	access:public
folly::RWSpinLock::WriteHolder::reset	.\RWSpinLock.h	/^    void reset(RWSpinLock* lock = nullptr) {$/;"	f	class:folly::RWSpinLock::WriteHolder	access:public	signature:(RWSpinLock* lock = nullptr)
folly::RWSpinLock::WriteHolder::swap	.\RWSpinLock.h	/^    void swap(WriteHolder* other) {$/;"	f	class:folly::RWSpinLock::WriteHolder	access:public	signature:(WriteHolder* other)
folly::RWSpinLock::WriteHolder::~WriteHolder	.\RWSpinLock.h	/^    ~WriteHolder () { if (lock_) lock_->unlock(); }$/;"	f	class:folly::RWSpinLock::WriteHolder	access:public	signature:()
folly::RWSpinLock::acquireRead	.\RWSpinLock.h	/^  friend void acquireRead(RWSpinLock& l) { return l.lock_shared(); }$/;"	f	class:folly::RWSpinLock	access:friend	signature:(RWSpinLock& l)
folly::RWSpinLock::acquireReadWrite	.\RWSpinLock.h	/^  friend void acquireReadWrite(RWSpinLock& l) { return l.lock(); }$/;"	f	class:folly::RWSpinLock	access:friend	signature:(RWSpinLock& l)
folly::RWSpinLock::bits	.\RWSpinLock.h	/^  int32_t bits() const { return bits_.load(std::memory_order_acquire); }$/;"	f	class:folly::RWSpinLock	access:public	signature:() const
folly::RWSpinLock::bits_	.\RWSpinLock.h	/^  std::atomic<int32_t> bits_;$/;"	m	class:folly::RWSpinLock	access:private
folly::RWSpinLock::lock	.\RWSpinLock.h	/^  void lock() {$/;"	f	class:folly::RWSpinLock	access:public	signature:()
folly::RWSpinLock::lock_shared	.\RWSpinLock.h	/^  void lock_shared() {$/;"	f	class:folly::RWSpinLock	access:public	signature:()
folly::RWSpinLock::lock_upgrade	.\RWSpinLock.h	/^  void lock_upgrade() {$/;"	f	class:folly::RWSpinLock	access:public	signature:()
folly::RWSpinLock::releaseRead	.\RWSpinLock.h	/^  friend void releaseRead(RWSpinLock& l) { return l.unlock_shared(); }$/;"	f	class:folly::RWSpinLock	access:friend	signature:(RWSpinLock& l)
folly::RWSpinLock::releaseReadWrite	.\RWSpinLock.h	/^  friend void releaseReadWrite(RWSpinLock& l) { return l.unlock(); }$/;"	f	class:folly::RWSpinLock	access:friend	signature:(RWSpinLock& l)
folly::RWSpinLock::try_lock	.\RWSpinLock.h	/^  bool try_lock() {$/;"	f	class:folly::RWSpinLock	access:public	signature:()
folly::RWSpinLock::try_lock_shared	.\RWSpinLock.h	/^  bool try_lock_shared() {$/;"	f	class:folly::RWSpinLock	access:public	signature:()
folly::RWSpinLock::try_lock_upgrade	.\RWSpinLock.h	/^  bool try_lock_upgrade() {$/;"	f	class:folly::RWSpinLock	access:public	signature:()
folly::RWSpinLock::try_unlock_upgrade_and_lock	.\RWSpinLock.h	/^  bool try_unlock_upgrade_and_lock() {$/;"	f	class:folly::RWSpinLock	access:public	signature:()
folly::RWSpinLock::unlock	.\RWSpinLock.h	/^  void unlock() {$/;"	f	class:folly::RWSpinLock	access:public	signature:()
folly::RWSpinLock::unlock_and_lock_shared	.\RWSpinLock.h	/^  void unlock_and_lock_shared() {$/;"	f	class:folly::RWSpinLock	access:public	signature:()
folly::RWSpinLock::unlock_and_lock_upgrade	.\RWSpinLock.h	/^  void unlock_and_lock_upgrade() {$/;"	f	class:folly::RWSpinLock	access:public	signature:()
folly::RWSpinLock::unlock_shared	.\RWSpinLock.h	/^  void unlock_shared() {$/;"	f	class:folly::RWSpinLock	access:public	signature:()
folly::RWSpinLock::unlock_upgrade	.\RWSpinLock.h	/^  void unlock_upgrade() {$/;"	f	class:folly::RWSpinLock	access:public	signature:()
folly::RWSpinLock::unlock_upgrade_and_lock	.\RWSpinLock.h	/^  void unlock_upgrade_and_lock() {$/;"	f	class:folly::RWSpinLock	access:public	signature:()
folly::RWSpinLock::unlock_upgrade_and_lock_shared	.\RWSpinLock.h	/^  void unlock_upgrade_and_lock_shared() {$/;"	f	class:folly::RWSpinLock	access:public	signature:()
folly::RWTicketSpinLock32	.\RWSpinLock.h	/^typedef RWTicketSpinLockT<32> RWTicketSpinLock32;$/;"	t	namespace:folly
folly::RWTicketSpinLock64	.\RWSpinLock.h	/^typedef RWTicketSpinLockT<64> RWTicketSpinLock64;$/;"	t	namespace:folly
folly::RWTicketSpinLockT	.\RWSpinLock.h	/^class RWTicketSpinLockT : boost::noncopyable {$/;"	c	namespace:folly	inherits:boost::noncopyable
folly::RWTicketSpinLockT::FullInt	.\RWSpinLock.h	/^  typedef typename detail::RWTicketIntTrait<kBitWidth>::FullInt FullInt;$/;"	t	class:folly::RWTicketSpinLockT	access:private
folly::RWTicketSpinLockT::HalfInt	.\RWSpinLock.h	/^  typedef typename detail::RWTicketIntTrait<kBitWidth>::HalfInt HalfInt;$/;"	t	class:folly::RWTicketSpinLockT	access:private
folly::RWTicketSpinLockT::IntTraitType	.\RWSpinLock.h	/^  typedef detail::RWTicketIntTrait<kBitWidth> IntTraitType;$/;"	t	class:folly::RWTicketSpinLockT	access:private
folly::RWTicketSpinLockT::QuarterInt	.\RWSpinLock.h	/^    QuarterInt;$/;"	t	class:folly::RWTicketSpinLockT	access:private
folly::RWTicketSpinLockT::RWSpinLock	.\RWSpinLock.h	/^  typedef RWTicketSpinLockT<kBitWidth, kFavorWriter> RWSpinLock;$/;"	t	class:folly::RWTicketSpinLockT	access:public
folly::RWTicketSpinLockT::RWTicket	.\RWSpinLock.h	/^  union RWTicket {$/;"	u	class:folly::RWTicketSpinLockT	access:private
folly::RWTicketSpinLockT::RWTicket::__anon85::read	.\RWSpinLock.h	/^      QuarterInt read;$/;"	m	struct:folly::RWTicketSpinLockT::RWTicket::__anon85	access:public
folly::RWTicketSpinLockT::RWTicket::__anon85::users	.\RWSpinLock.h	/^      QuarterInt users;$/;"	m	struct:folly::RWTicketSpinLockT::RWTicket::__anon85	access:public
folly::RWTicketSpinLockT::RWTicket::__anon85::write	.\RWSpinLock.h	/^      QuarterInt write;$/;"	m	struct:folly::RWTicketSpinLockT::RWTicket::__anon85	access:public
folly::RWTicketSpinLockT::RWTicket::readWrite	.\RWSpinLock.h	/^    HalfInt readWrite;$/;"	m	union:folly::RWTicketSpinLockT::RWTicket	access:public
folly::RWTicketSpinLockT::RWTicket::whole	.\RWSpinLock.h	/^    FullInt whole;$/;"	m	union:folly::RWTicketSpinLockT::RWTicket	access:public
folly::RWTicketSpinLockT::RWTicketSpinLockT	.\RWSpinLock.h	/^  RWTicketSpinLockT() {$/;"	f	class:folly::RWTicketSpinLockT	access:public	signature:()
folly::RWTicketSpinLockT::ReadHolder	.\RWSpinLock.h	/^  class ReadHolder : boost::noncopyable {$/;"	c	class:folly::RWTicketSpinLockT	inherits:boost::noncopyable	access:public
folly::RWTicketSpinLockT::ReadHolder::ReadHolder	.\RWSpinLock.h	/^    explicit ReadHolder(RWSpinLock &lock) : lock_ (&lock) {$/;"	f	class:folly::RWTicketSpinLockT::ReadHolder	access:public	signature:(RWSpinLock &lock)
folly::RWTicketSpinLockT::ReadHolder::ReadHolder	.\RWSpinLock.h	/^    explicit ReadHolder(RWSpinLock *lock = nullptr) :$/;"	f	class:folly::RWTicketSpinLockT::ReadHolder	access:public	signature:(RWSpinLock *lock = nullptr)
folly::RWTicketSpinLockT::ReadHolder::ReadHolder	.\RWSpinLock.h	/^    explicit ReadHolder(WriteHolder *writer) : lock_(nullptr) {$/;"	f	class:folly::RWTicketSpinLockT::ReadHolder	access:public	signature:(WriteHolder *writer)
folly::RWTicketSpinLockT::ReadHolder::lock_	.\RWSpinLock.h	/^    RWSpinLock *lock_;$/;"	m	class:folly::RWTicketSpinLockT::ReadHolder	access:private
folly::RWTicketSpinLockT::ReadHolder::reset	.\RWSpinLock.h	/^    void reset(RWSpinLock *lock = nullptr) {$/;"	f	class:folly::RWTicketSpinLockT::ReadHolder	access:public	signature:(RWSpinLock *lock = nullptr)
folly::RWTicketSpinLockT::ReadHolder::swap	.\RWSpinLock.h	/^    void swap(ReadHolder *other) {$/;"	f	class:folly::RWTicketSpinLockT::ReadHolder	access:public	signature:(ReadHolder *other)
folly::RWTicketSpinLockT::ReadHolder::~ReadHolder	.\RWSpinLock.h	/^    ~ReadHolder() {$/;"	f	class:folly::RWTicketSpinLockT::ReadHolder	access:public	signature:()
folly::RWTicketSpinLockT::WriteHolder	.\RWSpinLock.h	/^  class WriteHolder : boost::noncopyable {$/;"	c	class:folly::RWTicketSpinLockT	inherits:boost::noncopyable	access:public
folly::RWTicketSpinLockT::WriteHolder	.\RWSpinLock.h	/^  class WriteHolder;$/;"	x
folly::RWTicketSpinLockT::WriteHolder::ReadHolder	.\RWSpinLock.h	/^    friend class ReadHolder;$/;"	x
folly::RWTicketSpinLockT::WriteHolder::WriteHolder	.\RWSpinLock.h	/^    explicit WriteHolder(RWSpinLock &lock) : lock_ (&lock) {$/;"	f	class:folly::RWTicketSpinLockT::WriteHolder	access:public	signature:(RWSpinLock &lock)
folly::RWTicketSpinLockT::WriteHolder::WriteHolder	.\RWSpinLock.h	/^    explicit WriteHolder(RWSpinLock *lock = nullptr) : lock_(lock) {$/;"	f	class:folly::RWTicketSpinLockT::WriteHolder	access:public	signature:(RWSpinLock *lock = nullptr)
folly::RWTicketSpinLockT::WriteHolder::lock_	.\RWSpinLock.h	/^    RWSpinLock *lock_;$/;"	m	class:folly::RWTicketSpinLockT::WriteHolder	access:private
folly::RWTicketSpinLockT::WriteHolder::reset	.\RWSpinLock.h	/^    void reset(RWSpinLock *lock = nullptr) {$/;"	f	class:folly::RWTicketSpinLockT::WriteHolder	access:public	signature:(RWSpinLock *lock = nullptr)
folly::RWTicketSpinLockT::WriteHolder::swap	.\RWSpinLock.h	/^    void swap(WriteHolder *other) {$/;"	f	class:folly::RWTicketSpinLockT::WriteHolder	access:public	signature:(WriteHolder *other)
folly::RWTicketSpinLockT::WriteHolder::~WriteHolder	.\RWSpinLock.h	/^    ~WriteHolder() {$/;"	f	class:folly::RWTicketSpinLockT::WriteHolder	access:public	signature:()
folly::RWTicketSpinLockT::acquireRead	.\RWSpinLock.h	/^  friend void acquireRead(RWTicketSpinLockT& mutex) {$/;"	f	class:folly::RWTicketSpinLockT	access:friend	signature:(RWTicketSpinLockT& mutex)
folly::RWTicketSpinLockT::acquireReadWrite	.\RWSpinLock.h	/^  friend bool acquireReadWrite(RWTicketSpinLockT& mutex,$/;"	f	class:folly::RWTicketSpinLockT	access:friend	signature:(RWTicketSpinLockT& mutex, unsigned int milliseconds)
folly::RWTicketSpinLockT::acquireReadWrite	.\RWSpinLock.h	/^  friend void acquireReadWrite(RWTicketSpinLockT& mutex) {$/;"	f	class:folly::RWTicketSpinLockT	access:friend	signature:(RWTicketSpinLockT& mutex)
folly::RWTicketSpinLockT::load_acquire	.\RWSpinLock.h	/^  template<class T> static T load_acquire(T* addr) {$/;"	f	class:folly::RWTicketSpinLockT	access:private	signature:(T* addr)
folly::RWTicketSpinLockT::lock	.\RWSpinLock.h	/^  void lock() {$/;"	f	class:folly::RWTicketSpinLockT	access:public	signature:()
folly::RWTicketSpinLockT::lock_shared	.\RWSpinLock.h	/^  void lock_shared() {$/;"	f	class:folly::RWTicketSpinLockT	access:public	signature:()
folly::RWTicketSpinLockT::releaseRead	.\RWSpinLock.h	/^  friend void releaseRead(RWTicketSpinLockT& mutex) {$/;"	f	class:folly::RWTicketSpinLockT	access:friend	signature:(RWTicketSpinLockT& mutex)
folly::RWTicketSpinLockT::releaseReadWrite	.\RWSpinLock.h	/^  friend void releaseReadWrite(RWTicketSpinLockT& mutex) {$/;"	f	class:folly::RWTicketSpinLockT	access:friend	signature:(RWTicketSpinLockT& mutex)
folly::RWTicketSpinLockT::store_release	.\RWSpinLock.h	/^  static void store_release(T* addr, T v) {$/;"	f	class:folly::RWTicketSpinLockT	access:private	signature:(T* addr, T v)
folly::RWTicketSpinLockT::ticket	.\RWSpinLock.h	/^  } ticket;$/;"	m	class:folly::RWTicketSpinLockT	typeref:union:folly::RWTicketSpinLockT::RWTicket	access:private
folly::RWTicketSpinLockT::try_lock	.\RWSpinLock.h	/^  bool try_lock() {$/;"	f	class:folly::RWTicketSpinLockT	access:public	signature:()
folly::RWTicketSpinLockT::try_lock_shared	.\RWSpinLock.h	/^  bool try_lock_shared() {$/;"	f	class:folly::RWTicketSpinLockT	access:public	signature:()
folly::RWTicketSpinLockT::unlock	.\RWSpinLock.h	/^  void unlock() {$/;"	f	class:folly::RWTicketSpinLockT	access:public	signature:()
folly::RWTicketSpinLockT::unlock_and_lock_shared	.\RWSpinLock.h	/^  void unlock_and_lock_shared() {$/;"	f	class:folly::RWTicketSpinLockT	access:public	signature:()
folly::RWTicketSpinLockT::unlock_shared	.\RWSpinLock.h	/^  void unlock_shared() {$/;"	f	class:folly::RWTicketSpinLockT	access:public	signature:()
folly::RWTicketSpinLockT::writeLockAggressive	.\RWSpinLock.h	/^  void writeLockAggressive() {$/;"	f	class:folly::RWTicketSpinLockT	access:public	signature:()
folly::RWTicketSpinLockT::writeLockNice	.\RWSpinLock.h	/^  void writeLockNice() {$/;"	f	class:folly::RWTicketSpinLockT	access:public	signature:()
folly::Random	.\Random.h	/^class Random {$/;"	c	namespace:folly
folly::Random::DefaultGenerator	.\Random.h	/^  typedef __gnu_cxx::sfmt19937 DefaultGenerator;$/;"	t	class:folly::Random	access:public
folly::Random::create	.\Random.h	/^  static ValidRNG<RNG> create();$/;"	p	class:folly::Random	access:public	signature:()
folly::Random::oneIn	.\Random.h	/^  static bool oneIn(uint32_t n, ValidRNG<RNG> rng = RNG()) {$/;"	f	class:folly::Random	access:public	signature:(uint32_t n, ValidRNG<RNG> rng = RNG())
folly::Random::rand32	.\Random.h	/^  static uint32_t rand32(ValidRNG<RNG> rng = RNG()) {$/;"	f	class:folly::Random	access:public	signature:(ValidRNG<RNG> rng = RNG())
folly::Random::rand32	.\Random.h	/^  static uint32_t rand32(uint32_t max, ValidRNG<RNG> rng = RNG()) {$/;"	f	class:folly::Random	access:public	signature:(uint32_t max, ValidRNG<RNG> rng = RNG())
folly::Random::rand32	.\Random.h	/^  static uint32_t rand32(uint32_t min,$/;"	f	class:folly::Random	access:public	signature:(uint32_t min, uint32_t max, ValidRNG<RNG> rng = RNG())
folly::Random::rand64	.\Random.h	/^  static uint64_t rand64(ValidRNG<RNG> rng = RNG()) {$/;"	f	class:folly::Random	access:public	signature:(ValidRNG<RNG> rng = RNG())
folly::Random::rand64	.\Random.h	/^  static uint64_t rand64(uint64_t max, ValidRNG<RNG> rng = RNG()) {$/;"	f	class:folly::Random	access:public	signature:(uint64_t max, ValidRNG<RNG> rng = RNG())
folly::Random::rand64	.\Random.h	/^  static uint64_t rand64(uint64_t min,$/;"	f	class:folly::Random	access:public	signature:(uint64_t min, uint64_t max, ValidRNG<RNG> rng = RNG())
folly::Random::randDouble	.\Random.h	/^  static double randDouble(double min, double max, ValidRNG<RNG> rng = RNG()) {$/;"	f	class:folly::Random	access:public	signature:(double min, double max, ValidRNG<RNG> rng = RNG())
folly::Random::randDouble01	.\Random.h	/^  static double randDouble01(ValidRNG<RNG> rng = RNG()) {$/;"	f	class:folly::Random	access:public	signature:(ValidRNG<RNG> rng = RNG())
folly::Random::secureRandom	.\Random.cpp	/^void Random::secureRandom(void* data, size_t size) {$/;"	f	class:folly::Random	signature:(void* data, size_t size)
folly::Random::secureRandom	.\Random.h	/^  secureRandom() {$/;"	f	class:folly::Random	access:public	signature:()
folly::Random::secureRandom	.\Random.h	/^  static void secureRandom(void* data, size_t len);$/;"	p	class:folly::Random	access:public	signature:(void* data, size_t len)
folly::Random::seed	.\Random-inl.h	/^void Random::seed(ValidRNG<RNG>& rng) {$/;"	f	class:folly::Random	signature:(ValidRNG<RNG>& rng)
folly::Random::seed	.\Random.h	/^  static void seed(ValidRNG<RNG>& rng);$/;"	p	class:folly::Random	access:public	signature:(ValidRNG<RNG>& rng)
folly::Range	.\Range.h	/^class Range : private boost::totally_ordered<Range<Iter> > {$/;"	c	namespace:folly	inherits:boost::totally_ordered
folly::Range	.\Range.h	/^template <class T> class Range;$/;"	x
folly::Range::Range	.\Range.h	/^  Range(const Range<Iter>& str,$/;"	f	class:folly::Range	access:public	signature:(const Range<Iter>& str, size_t startFrom, size_t size)
folly::Range::Range	.\Range.h	/^  Range(const fbstring& str, fbstring::size_type startFrom) {$/;"	f	class:folly::Range	access:public	signature:(const fbstring& str, fbstring::size_type startFrom)
folly::Range::Range	.\Range.h	/^  Range(const fbstring& str, fbstring::size_type startFrom,$/;"	f	class:folly::Range	access:public	signature:(const fbstring& str, fbstring::size_type startFrom, fbstring::size_type size)
folly::Range::Range	.\Range.h	/^  Range(const std::string& str, std::string::size_type startFrom) {$/;"	f	class:folly::Range	access:public	signature:(const std::string& str, std::string::size_type startFrom)
folly::Range::Range	.\Range.h	/^  Range(const std::string& str,$/;"	f	class:folly::Range	access:public	signature:(const std::string& str, std::string::size_type startFrom, std::string::size_type size)
folly::Range::Range	.\Range.h	/^  \/* implicit *\/ Range(Iter str)$/;"	f	class:folly::Range	access:public	signature:(Iter str)
folly::Range::Range	.\Range.h	/^  \/* implicit *\/ Range(const Range<OtherIter>& other)$/;"	f	class:folly::Range	access:public	signature:(const Range<OtherIter>& other)
folly::Range::Range	.\Range.h	/^  \/* implicit *\/ Range(const fbstring& str)$/;"	f	class:folly::Range	access:public	signature:(const fbstring& str)
folly::Range::Range	.\Range.h	/^  \/* implicit *\/ Range(const std::string& str)$/;"	f	class:folly::Range	access:public	signature:(const std::string& str)
folly::Range::Range	.\Range.h	/^  constexpr Range() : b_(), e_() {$/;"	f	class:folly::Range	access:public	signature:()
folly::Range::Range	.\Range.h	/^  constexpr Range(Iter start, Iter end) : b_(start), e_(end) {$/;"	f	class:folly::Range	access:public	signature:(Iter start, Iter end)
folly::Range::Range	.\Range.h	/^  constexpr Range(Iter start, size_t size)$/;"	f	class:folly::Range	access:public	signature:(Iter start, size_t size)
folly::Range::Range	.\Range.h	/^  constexpr \/* implicit *\/ Range(Iter str)$/;"	f	class:folly::Range	access:public	signature:(Iter str)
folly::Range::Range	.\Range.h	/^  constexpr \/* implicit *\/ Range(const Range<OtherIter>& other)$/;"	f	class:folly::Range	access:public	signature:(const Range<OtherIter>& other)
folly::Range::Range	.\Range.h	/^  constexpr explicit Range(const Range<OtherIter>& other)$/;"	f	class:folly::Range	access:public	signature:(const Range<OtherIter>& other)
folly::Range::Range	.\Range.h	/^  explicit Range(const Range<OtherIter>& other)$/;"	f	class:folly::Range	access:public	signature:(const Range<OtherIter>& other)
folly::Range::advance	.\Range.h	/^  void advance(size_type n) {$/;"	f	class:folly::Range	access:public	signature:(size_type n)
folly::Range::assign	.\Range.h	/^  void assign(Iter start, Iter end) {$/;"	f	class:folly::Range	access:public	signature:(Iter start, Iter end)
folly::Range::at	.\Range.h	/^  const value_type& at(size_t i) const {$/;"	f	class:folly::Range	access:public	signature:(size_t i) const
folly::Range::at	.\Range.h	/^  value_type& at(size_t i) {$/;"	f	class:folly::Range	access:public	signature:(size_t i)
folly::Range::b_	.\Range.h	/^  Iter b_, e_;$/;"	m	class:folly::Range	access:private
folly::Range::back	.\Range.h	/^  const value_type& back() const {$/;"	f	class:folly::Range	access:public	signature:() const
folly::Range::back	.\Range.h	/^  value_type& back() {$/;"	f	class:folly::Range	access:public	signature:()
folly::Range::begin	.\Range.h	/^  Iter begin() const { return b_; }$/;"	f	class:folly::Range	access:public	signature:() const
folly::Range::castToConst	.\Range.h	/^  const_range_type castToConst() const {$/;"	f	class:folly::Range	access:public	signature:() const
folly::Range::cbegin	.\Range.h	/^  Iter cbegin() const { return b_; }$/;"	f	class:folly::Range	access:public	signature:() const
folly::Range::cend	.\Range.h	/^  Iter cend() const { return e_; }$/;"	f	class:folly::Range	access:public	signature:() const
folly::Range::clear	.\Range.h	/^  void clear() {$/;"	f	class:folly::Range	access:public	signature:()
folly::Range::compare	.\Range.h	/^  int compare(const const_range_type& o) const {$/;"	f	class:folly::Range	access:public	signature:(const const_range_type& o) const
folly::Range::const_iterator	.\Range.h	/^  typedef Iter const_iterator;$/;"	t	class:folly::Range	access:public
folly::Range::const_range_type	.\Range.h	/^    Range<Iter>>::type const_range_type;$/;"	t	class:folly::Range	access:public
folly::Range::contains	.\Range.h	/^  bool contains(const const_range_type& other) const {$/;"	f	class:folly::Range	access:public	signature:(const const_range_type& other) const
folly::Range::contains	.\Range.h	/^  bool contains(const value_type& other) const {$/;"	f	class:folly::Range	access:public	signature:(const value_type& other) const
folly::Range::data	.\Range.h	/^  Iter data() const { return b_; }$/;"	f	class:folly::Range	access:public	signature:() const
folly::Range::e_	.\Range.h	/^  Iter b_, e_;$/;"	m	class:folly::Range	access:private
folly::Range::empty	.\Range.h	/^  bool empty() const { return b_ == e_; }$/;"	f	class:folly::Range	access:public	signature:() const
folly::Range::end	.\Range.h	/^  Iter end() const { return e_; }$/;"	f	class:folly::Range	access:public	signature:() const
folly::Range::endsWith	.\Range.h	/^  bool endsWith(const const_range_type& other) const {$/;"	f	class:folly::Range	access:public	signature:(const const_range_type& other) const
folly::Range::endsWith	.\Range.h	/^  bool endsWith(value_type c) const {$/;"	f	class:folly::Range	access:public	signature:(value_type c) const
folly::Range::fbstr	.\Range.h	/^  fbstring fbstr() const { return fbstring(b_, size()); }$/;"	f	class:folly::Range	access:public	signature:() const
folly::Range::find	.\Range.h	/^  size_type find(Iter s, size_t pos, size_t n) const {$/;"	f	class:folly::Range	access:public	signature:(Iter s, size_t pos, size_t n) const
folly::Range::find	.\Range.h	/^  size_type find(const Iter s) const {$/;"	f	class:folly::Range	access:public	signature:(const Iter s) const
folly::Range::find	.\Range.h	/^  size_type find(const Iter s, size_t pos) const {$/;"	f	class:folly::Range	access:public	signature:(const Iter s, size_t pos) const
folly::Range::find	.\Range.h	/^  size_type find(const_range_type str) const {$/;"	f	class:folly::Range	access:public	signature:(const_range_type str) const
folly::Range::find	.\Range.h	/^  size_type find(const_range_type str, size_t pos) const {$/;"	f	class:folly::Range	access:public	signature:(const_range_type str, size_t pos) const
folly::Range::find	.\Range.h	/^  size_type find(value_type c) const {$/;"	f	class:folly::Range	access:public	signature:(value_type c) const
folly::Range::find	.\Range.h	/^  size_type find(value_type c, size_t pos) const {$/;"	f	class:folly::Range	access:public	signature:(value_type c, size_t pos) const
folly::Range::find_first_of	.\Range.h	/^  size_type find_first_of(Iter needles) const {$/;"	f	class:folly::Range	access:public	signature:(Iter needles) const
folly::Range::find_first_of	.\Range.h	/^  size_type find_first_of(Iter needles, size_t pos) const {$/;"	f	class:folly::Range	access:public	signature:(Iter needles, size_t pos) const
folly::Range::find_first_of	.\Range.h	/^  size_type find_first_of(Iter needles, size_t pos, size_t n) const {$/;"	f	class:folly::Range	access:public	signature:(Iter needles, size_t pos, size_t n) const
folly::Range::find_first_of	.\Range.h	/^  size_type find_first_of(const_range_type needles) const {$/;"	f	class:folly::Range	access:public	signature:(const_range_type needles) const
folly::Range::find_first_of	.\Range.h	/^  size_type find_first_of(const_range_type needles, size_t pos) const {$/;"	f	class:folly::Range	access:public	signature:(const_range_type needles, size_t pos) const
folly::Range::find_first_of	.\Range.h	/^  size_type find_first_of(value_type c) const {$/;"	f	class:folly::Range	access:public	signature:(value_type c) const
folly::Range::find_first_of	.\Range.h	/^  size_type find_first_of(value_type c, size_t pos) const {$/;"	f	class:folly::Range	access:public	signature:(value_type c, size_t pos) const
folly::Range::front	.\Range.h	/^  const value_type& front() const {$/;"	f	class:folly::Range	access:public	signature:() const
folly::Range::front	.\Range.h	/^  value_type& front() {$/;"	f	class:folly::Range	access:public	signature:()
folly::Range::hash	.\Range.h	/^  uint32_t hash() const {$/;"	f	class:folly::Range	access:public	signature:() const
folly::Range::iterator	.\Range.h	/^  typedef Iter iterator;$/;"	t	class:folly::Range	access:public
folly::Range::npos	.\Range.h	/^  static const size_type npos;$/;"	m	class:folly::Range	access:public
folly::Range::npos	.\Range.h	/^const typename Range<Iter>::size_type Range<Iter>::npos = std::string::npos;$/;"	m	class:folly::Range
folly::Range::operator []	.\Range.h	/^  const value_type& operator[](size_t i) const {$/;"	f	class:folly::Range	access:public	signature:(size_t i) const
folly::Range::operator []	.\Range.h	/^  value_type& operator[](size_t i) {$/;"	f	class:folly::Range	access:public	signature:(size_t i)
folly::Range::pop_back	.\Range.h	/^  void pop_back() {$/;"	f	class:folly::Range	access:public	signature:()
folly::Range::pop_front	.\Range.h	/^  void pop_front() {$/;"	f	class:folly::Range	access:public	signature:()
folly::Range::reference	.\Range.h	/^  typedef typename std::iterator_traits<Iter>::reference reference;$/;"	t	class:folly::Range	access:public
folly::Range::removePrefix	.\Range.h	/^  bool removePrefix(const const_range_type& prefix) {$/;"	f	class:folly::Range	access:public	signature:(const const_range_type& prefix)
folly::Range::removePrefix	.\Range.h	/^  bool removePrefix(value_type prefix) {$/;"	f	class:folly::Range	access:public	signature:(value_type prefix)
folly::Range::removeSuffix	.\Range.h	/^  bool removeSuffix(const const_range_type& suffix) {$/;"	f	class:folly::Range	access:public	signature:(const const_range_type& suffix)
folly::Range::removeSuffix	.\Range.h	/^  bool removeSuffix(value_type suffix) {$/;"	f	class:folly::Range	access:public	signature:(value_type suffix)
folly::Range::replaceAll	.\Range.h	/^  size_t replaceAll(const_range_type source, const_range_type dest) {$/;"	f	class:folly::Range	access:public	signature:(const_range_type source, const_range_type dest)
folly::Range::replaceAt	.\Range.h	/^  bool replaceAt(size_t pos, const_range_type replacement) {$/;"	f	class:folly::Range	access:public	signature:(size_t pos, const_range_type replacement)
folly::Range::reset	.\Range.h	/^  void reset(Iter start, size_type size) {$/;"	f	class:folly::Range	access:public	signature:(Iter start, size_type size)
folly::Range::reset	.\Range.h	/^  void reset(const std::string& str) {$/;"	f	class:folly::Range	access:public	signature:(const std::string& str)
folly::Range::rfind	.\Range.h	/^  size_type rfind(value_type c) const {$/;"	f	class:folly::Range	access:public	signature:(value_type c) const
folly::Range::size	.\Range.h	/^  size_type size() const {$/;"	f	class:folly::Range	access:public	signature:() const
folly::Range::size_type	.\Range.h	/^  typedef std::size_t size_type;$/;"	t	class:folly::Range	access:public
folly::Range::split_step	.\Range.h	/^  Range split_step(Range delimiter) {$/;"	f	class:folly::Range	access:public	signature:(Range delimiter)
folly::Range::split_step	.\Range.h	/^  Range split_step(value_type delimiter) {$/;"	f	class:folly::Range	access:public	signature:(value_type delimiter)
folly::Range::start	.\Range.h	/^  Iter start() const { return b_; }$/;"	f	class:folly::Range	access:public	signature:() const
folly::Range::startsWith	.\Range.h	/^  bool startsWith(const const_range_type& other) const {$/;"	f	class:folly::Range	access:public	signature:(const const_range_type& other) const
folly::Range::startsWith	.\Range.h	/^  bool startsWith(value_type c) const {$/;"	f	class:folly::Range	access:public	signature:(value_type c) const
folly::Range::std::forward	.\Range.h	/^    -> decltype(process(std::declval<Range>(), std::forward<Args>(args)...))$/;"	f	class:folly::Range::std	access:public	signature:(args)
folly::Range::str	.\Range.h	/^  std::string str() const { return std::string(b_, size()); }$/;"	f	class:folly::Range	access:public	signature:() const
folly::Range::subpiece	.\Range.h	/^  Range subpiece(size_type first,$/;"	f	class:folly::Range	access:public	signature:(size_type first, size_type length = std::string::npos) const
folly::Range::subtract	.\Range.h	/^  void subtract(size_type n) {$/;"	f	class:folly::Range	access:public	signature:(size_type n)
folly::Range::swap	.\Range.h	/^  void swap(Range& rhs) {$/;"	f	class:folly::Range	access:public	signature:(Range& rhs)
folly::Range::toFbstring	.\Range.h	/^  fbstring toFbstring() const { return fbstr(); }$/;"	f	class:folly::Range	access:public	signature:() const
folly::Range::toString	.\Range.h	/^  std::string toString() const { return str(); }$/;"	f	class:folly::Range	access:public	signature:() const
folly::Range::traits_type	.\Range.h	/^    traits_type;$/;"	t	class:folly::Range	access:public
folly::Range::value_type	.\Range.h	/^  value_type;$/;"	t	class:folly::Range	access:public
folly::Range::walk_size	.\Range.h	/^  size_type walk_size() const {$/;"	f	class:folly::Range	access:public	signature:() const
folly::RecordIOReader	.\io\RecordIO.h	/^class RecordIOReader {$/;"	c	namespace:folly
folly::RecordIOReader::Iterator	.\io\RecordIO-inl.h	/^class RecordIOReader::Iterator : public boost::iterator_facade<$/;"	c	class:folly::RecordIOReader	inherits:boost::iterator_facade
folly::RecordIOReader::Iterator	.\io\RecordIO.h	/^  class Iterator;$/;"	x
folly::RecordIOReader::Iterator::Iterator	.\io\RecordIO-inl.h	/^  Iterator(ByteRange range, uint32_t fileId, off_t pos);$/;"	p	class:folly::RecordIOReader::Iterator	access:private	signature:(ByteRange range, uint32_t fileId, off_t pos)
folly::RecordIOReader::Iterator::Iterator	.\io\RecordIO.cpp	/^RecordIOReader::Iterator::Iterator(ByteRange range, uint32_t fileId, off_t pos)$/;"	f	class:folly::RecordIOReader::Iterator	signature:(ByteRange range, uint32_t fileId, off_t pos)
folly::RecordIOReader::Iterator::RecordIOReader	.\io\RecordIO-inl.h	/^  friend class RecordIOReader;$/;"	x
folly::RecordIOReader::Iterator::advanceToValid	.\io\RecordIO-inl.h	/^  void advanceToValid();$/;"	p	class:folly::RecordIOReader::Iterator	access:private	signature:()
folly::RecordIOReader::Iterator::advanceToValid	.\io\RecordIO.cpp	/^void RecordIOReader::Iterator::advanceToValid() {$/;"	f	class:folly::RecordIOReader::Iterator	signature:()
folly::RecordIOReader::Iterator::dereference	.\io\RecordIO-inl.h	/^  reference dereference() const { return recordAndPos_; }$/;"	f	class:folly::RecordIOReader::Iterator	access:private	signature:() const
folly::RecordIOReader::Iterator::equal	.\io\RecordIO-inl.h	/^  bool equal(const Iterator& other) const { return range_ == other.range_; }$/;"	f	class:folly::RecordIOReader::Iterator	access:private	signature:(const Iterator& other) const
folly::RecordIOReader::Iterator::fileId_	.\io\RecordIO-inl.h	/^  uint32_t fileId_;$/;"	m	class:folly::RecordIOReader::Iterator	access:private
folly::RecordIOReader::Iterator::increment	.\io\RecordIO-inl.h	/^  void increment() {$/;"	f	class:folly::RecordIOReader::Iterator	access:private	signature:()
folly::RecordIOReader::Iterator::range_	.\io\RecordIO-inl.h	/^  ByteRange range_;$/;"	m	class:folly::RecordIOReader::Iterator	access:private
folly::RecordIOReader::Iterator::recordAndPos_	.\io\RecordIO-inl.h	/^  std::pair<ByteRange, off_t> recordAndPos_;$/;"	m	class:folly::RecordIOReader::Iterator	access:private
folly::RecordIOReader::RecordIOReader	.\io\RecordIO.cpp	/^RecordIOReader::RecordIOReader(File file, uint32_t fileId)$/;"	f	class:folly::RecordIOReader	signature:(File file, uint32_t fileId)
folly::RecordIOReader::RecordIOReader	.\io\RecordIO.h	/^  explicit RecordIOReader(File file, uint32_t fileId = 0);$/;"	p	class:folly::RecordIOReader	access:public	signature:(File file, uint32_t fileId = 0)
folly::RecordIOReader::begin	.\io\RecordIO.h	/^  Iterator begin() const;$/;"	p	class:folly::RecordIOReader	access:public	signature:() const
folly::RecordIOReader::cbegin	.\io\RecordIO.h	/^  Iterator cbegin() const;$/;"	p	class:folly::RecordIOReader	access:public	signature:() const
folly::RecordIOReader::cend	.\io\RecordIO.h	/^  Iterator cend() const;$/;"	p	class:folly::RecordIOReader	access:public	signature:() const
folly::RecordIOReader::const_iterator	.\io\RecordIO.h	/^  typedef Iterator const_iterator;$/;"	t	class:folly::RecordIOReader	access:public
folly::RecordIOReader::const_reference	.\io\RecordIO.h	/^  typedef const value_type& const_reference;$/;"	t	class:folly::RecordIOReader	access:public
folly::RecordIOReader::end	.\io\RecordIO.h	/^  Iterator end() const;$/;"	p	class:folly::RecordIOReader	access:public	signature:() const
folly::RecordIOReader::fileId_	.\io\RecordIO.h	/^  uint32_t fileId_;$/;"	m	class:folly::RecordIOReader	access:private
folly::RecordIOReader::iterator	.\io\RecordIO.h	/^  typedef Iterator iterator;$/;"	t	class:folly::RecordIOReader	access:public
folly::RecordIOReader::map_	.\io\RecordIO.h	/^  MemoryMapping map_;$/;"	m	class:folly::RecordIOReader	access:private
folly::RecordIOReader::reference	.\io\RecordIO.h	/^  typedef value_type& reference;$/;"	t	class:folly::RecordIOReader	access:public
folly::RecordIOReader::seek	.\io\RecordIO.h	/^  Iterator seek(off_t pos) const;$/;"	p	class:folly::RecordIOReader	access:public	signature:(off_t pos) const
folly::RecordIOReader::value_type	.\io\RecordIO.h	/^  typedef std::pair<ByteRange, off_t> value_type;$/;"	t	class:folly::RecordIOReader	access:public
folly::RecordIOWriter	.\io\RecordIO.h	/^class RecordIOWriter {$/;"	c	namespace:folly
folly::RecordIOWriter::RecordIOWriter	.\io\RecordIO.cpp	/^RecordIOWriter::RecordIOWriter(File file, uint32_t fileId)$/;"	f	class:folly::RecordIOWriter	signature:(File file, uint32_t fileId)
folly::RecordIOWriter::RecordIOWriter	.\io\RecordIO.h	/^  explicit RecordIOWriter(File file, uint32_t fileId = 1);$/;"	p	class:folly::RecordIOWriter	access:public	signature:(File file, uint32_t fileId = 1)
folly::RecordIOWriter::fileId_	.\io\RecordIO.h	/^  uint32_t fileId_;$/;"	m	class:folly::RecordIOWriter	access:private
folly::RecordIOWriter::filePos	.\io\RecordIO.h	/^  off_t filePos() const { return filePos_; }$/;"	f	class:folly::RecordIOWriter	access:public	signature:() const
folly::RecordIOWriter::filePos_	.\io\RecordIO.h	/^  std::atomic<off_t> filePos_;$/;"	m	class:folly::RecordIOWriter	access:private
folly::RecordIOWriter::file_	.\io\RecordIO.h	/^  File file_;$/;"	m	class:folly::RecordIOWriter	access:private
folly::RecordIOWriter::write	.\io\RecordIO.cpp	/^void RecordIOWriter::write(std::unique_ptr<IOBuf> buf) {$/;"	f	class:folly::RecordIOWriter	signature:(std::unique_ptr<IOBuf> buf)
folly::RecordIOWriter::write	.\io\RecordIO.h	/^  void write(std::unique_ptr<IOBuf> buf);$/;"	p	class:folly::RecordIOWriter	access:public	signature:(std::unique_ptr<IOBuf> buf)
folly::RecordIOWriter::writeLock_	.\io\RecordIO.h	/^  std::unique_lock<File> writeLock_;$/;"	m	class:folly::RecordIOWriter	access:private
folly::RequestContext	.\io\async\AsyncTimeout.h	/^class RequestContext;$/;"	x
folly::RequestContext	.\io\async\Request.h	/^class RequestContext {$/;"	c	namespace:folly
folly::RequestContext	.\io\async\Request.h	/^class RequestContext;$/;"	x
folly::RequestContext::clearContextData	.\io\async\Request.h	/^  void clearContextData(const std::string& val) {$/;"	f	class:folly::RequestContext	access:public	signature:(const std::string& val)
folly::RequestContext::create	.\io\async\Request.h	/^  static bool create() {$/;"	f	class:folly::RequestContext	access:public	signature:()
folly::RequestContext::data_	.\io\async\Request.h	/^  std::map<std::string, std::unique_ptr<RequestData>> data_;$/;"	m	class:folly::RequestContext	access:private
folly::RequestContext::get	.\io\async\Request.h	/^  static RequestContext* get() {$/;"	f	class:folly::RequestContext	access:public	signature:()
folly::RequestContext::getContextData	.\io\async\Request.h	/^  RequestData* getContextData(const std::string& val) {$/;"	f	class:folly::RequestContext	access:public	signature:(const std::string& val)
folly::RequestContext::getStaticContext	.\io\async\Request.h	/^  getStaticContext() {$/;"	f	class:folly::RequestContext	access:public	signature:()
folly::RequestContext::hasContextData	.\io\async\Request.h	/^  bool hasContextData(const std::string& val) {$/;"	f	class:folly::RequestContext	access:public	signature:(const std::string& val)
folly::RequestContext::lock	.\io\async\Request.h	/^  folly::RWSpinLock lock;$/;"	m	class:folly::RequestContext	access:private
folly::RequestContext::saveContext	.\io\async\Request.h	/^  static std::shared_ptr<RequestContext> saveContext() {$/;"	f	class:folly::RequestContext	access:public	signature:()
folly::RequestContext::setContext	.\io\async\Request.h	/^  setContext(std::shared_ptr<RequestContext> ctx) {$/;"	f	class:folly::RequestContext	access:public	signature:(std::shared_ptr<RequestContext> ctx)
folly::RequestContext::setContextData	.\io\async\Request.h	/^  void setContextData($/;"	f	class:folly::RequestContext	access:public	signature:( const std::string& val, std::unique_ptr<RequestData> data)
folly::RequestContextGuard	.\io\async\Request.h	/^class RequestContextGuard {$/;"	c	namespace:folly
folly::RequestContextGuard::RequestContextGuard	.\io\async\Request.h	/^  explicit RequestContextGuard(std::shared_ptr<RequestContext> ctx) {$/;"	f	class:folly::RequestContextGuard	access:public	signature:(std::shared_ptr<RequestContext> ctx)
folly::RequestContextGuard::oldctx_	.\io\async\Request.h	/^  std::shared_ptr<RequestContext> oldctx_;$/;"	m	class:folly::RequestContextGuard	access:private
folly::RequestContextGuard::~RequestContextGuard	.\io\async\Request.h	/^  ~RequestContextGuard() {$/;"	f	class:folly::RequestContextGuard	access:public	signature:()
folly::RequestData	.\io\async\Request.h	/^class RequestData {$/;"	c	namespace:folly
folly::RequestData::~RequestData	.\io\async\Request.h	/^  virtual ~RequestData() {}$/;"	f	class:folly::RequestData	access:public	signature:()
folly::SafeIntrusiveListHook	.\IntrusiveList.h	/^        SafeIntrusiveListHook;$/;"	t	namespace:folly
folly::ScaleInfo	.\Benchmark.cpp	/^struct ScaleInfo {$/;"	s	namespace:folly	file:
folly::ScaleInfo::boundary	.\Benchmark.cpp	/^  double boundary;$/;"	m	struct:folly::ScaleInfo	file:	access:public
folly::ScaleInfo::suffix	.\Benchmark.cpp	/^  const char* suffix;$/;"	m	struct:folly::ScaleInfo	file:	access:public
folly::ScopeGuard	.\ScopeGuard.h	/^typedef ScopeGuardImplBase&& ScopeGuard;$/;"	t	namespace:folly
folly::ScopeGuardImpl	.\ScopeGuard.h	/^class ScopeGuardImpl : public ScopeGuardImplBase {$/;"	c	namespace:folly	inherits:ScopeGuardImplBase
folly::ScopeGuardImpl::ScopeGuardImpl	.\ScopeGuard.h	/^  ScopeGuardImpl(ScopeGuardImpl&& other)$/;"	f	class:folly::ScopeGuardImpl	access:public	signature:(ScopeGuardImpl&& other)
folly::ScopeGuardImpl::ScopeGuardImpl	.\ScopeGuard.h	/^  explicit ScopeGuardImpl(FunctionType&& fn)$/;"	f	class:folly::ScopeGuardImpl	access:public	signature:(FunctionType&& fn)
folly::ScopeGuardImpl::ScopeGuardImpl	.\ScopeGuard.h	/^  explicit ScopeGuardImpl(const FunctionType& fn)$/;"	f	class:folly::ScopeGuardImpl	access:public	signature:(const FunctionType& fn)
folly::ScopeGuardImpl::function_	.\ScopeGuard.h	/^  FunctionType function_;$/;"	m	class:folly::ScopeGuardImpl	access:private
folly::ScopeGuardImpl::size_t	.\ScopeGuard.h	/^  void* operator new(size_t) = delete;$/;"	m	class:folly::ScopeGuardImpl	access:private
folly::ScopeGuardImplBase	.\ScopeGuard.h	/^class ScopeGuardImplBase {$/;"	c	namespace:folly
folly::ScopeGuardImplBase::ScopeGuardImplBase	.\ScopeGuard.h	/^  ScopeGuardImplBase()$/;"	f	class:folly::ScopeGuardImplBase	access:protected	signature:()
folly::ScopeGuardImplBase::ScopeGuardImplBase	.\ScopeGuard.h	/^  ScopeGuardImplBase(ScopeGuardImplBase&& other)$/;"	f	class:folly::ScopeGuardImplBase	access:protected	signature:(ScopeGuardImplBase&& other)
folly::ScopeGuardImplBase::dismissed_	.\ScopeGuard.h	/^  bool dismissed_;$/;"	m	class:folly::ScopeGuardImplBase	access:protected
folly::SerializeData	.\test\IPAddressTest.h	/^struct SerializeData {$/;"	s	namespace:folly
folly::SerializeData::SerializeData	.\test\IPAddressTest.h	/^  SerializeData(const std::string& addr, const ByteVector& bytes)$/;"	f	struct:folly::SerializeData	access:public	signature:(const std::string& addr, const ByteVector& bytes)
folly::SerializeData::address	.\test\IPAddressTest.h	/^  std::string address;$/;"	m	struct:folly::SerializeData	access:public
folly::SerializeData::bytes	.\test\IPAddressTest.h	/^  ByteVector bytes;$/;"	m	struct:folly::SerializeData	access:public
folly::ShutdownSemError	.\LifoSem.h	/^struct ShutdownSemError : public std::runtime_error {$/;"	s	namespace:folly	inherits:std::runtime_error
folly::ShutdownSemError::ShutdownSemError	.\LifoSem.cpp	/^ShutdownSemError::ShutdownSemError(const std::string& msg)$/;"	f	class:folly::ShutdownSemError	signature:(const std::string& msg)
folly::ShutdownSemError::ShutdownSemError	.\LifoSem.h	/^  explicit ShutdownSemError(const std::string& msg);$/;"	p	struct:folly::ShutdownSemError	access:public	signature:(const std::string& msg)
folly::ShutdownSemError::noexcept	.\LifoSem.h	/^  virtual ~ShutdownSemError() noexcept;$/;"	m	struct:folly::ShutdownSemError	access:public
folly::SingleElementQueue	.\MPMCQueue.h	/^struct SingleElementQueue {$/;"	s	namespace:folly
folly::SingleElementQueue::contents_	.\MPMCQueue.h	/^  typename std::aligned_storage<sizeof(T),alignof(T)>::type contents_;$/;"	m	struct:folly::SingleElementQueue	access:private
folly::SingleElementQueue::sequencer_	.\MPMCQueue.h	/^  TurnSequencer<Atom> sequencer_;$/;"	m	struct:folly::SingleElementQueue	access:private
folly::Singleton	.\experimental\Singleton.h	/^class Singleton {$/;"	c	namespace:folly
folly::Singleton::CreateFunc	.\experimental\Singleton.h	/^  typedef std::function<T*(void)> CreateFunc;$/;"	t	class:folly::Singleton	access:public
folly::Singleton::Singleton	.\experimental\Singleton.h	/^  explicit Singleton(Singleton::CreateFunc c = nullptr,$/;"	f	class:folly::Singleton	access:public	signature:(Singleton::CreateFunc c = nullptr, Singleton::TeardownFunc t = nullptr, SingletonVault* vault = nullptr )
folly::Singleton::Singleton	.\experimental\Singleton.h	/^  explicit Singleton(const char* name,$/;"	f	class:folly::Singleton	access:public	signature:(const char* name, Singleton::CreateFunc c = nullptr, Singleton::TeardownFunc t = nullptr, SingletonVault* vault = nullptr )
folly::Singleton::Singleton	.\experimental\Singleton.h	/^  explicit Singleton(detail::TypeDescriptor type,$/;"	f	class:folly::Singleton	access:private	signature:(detail::TypeDescriptor type, Singleton::CreateFunc c = nullptr, Singleton::TeardownFunc t = nullptr, SingletonVault* vault = nullptr )
folly::Singleton::TeardownFunc	.\experimental\Singleton.h	/^  typedef std::function<void(T*)> TeardownFunc;$/;"	t	class:folly::Singleton	access:public
folly::Singleton::get	.\experimental\Singleton.h	/^  static T* get(SingletonVault* vault = nullptr \/* for testing *\/) {$/;"	f	class:folly::Singleton	access:public	signature:(SingletonVault* vault = nullptr )
folly::Singleton::get	.\experimental\Singleton.h	/^  static T* get(const char* name,$/;"	f	class:folly::Singleton	access:public	signature:(const char* name, SingletonVault* vault = nullptr )
folly::Singleton::get_ptr	.\experimental\Singleton.h	/^  static T* get_ptr(detail::TypeDescriptor type_descriptor = {typeid(T), ""},$/;"	f	class:folly::Singleton	access:private	signature:(detail::TypeDescriptor type_descriptor = {typeid(T), }, SingletonVault* vault = nullptr )
folly::Singleton::get_shared	.\experimental\Singleton.h	/^  static std::shared_ptr<T> get_shared($/;"	f	class:folly::Singleton	access:private	signature:( detail::TypeDescriptor type_descriptor = {typeid(T), }, SingletonVault* vault = nullptr )
folly::Singleton::get_weak	.\experimental\Singleton.h	/^  static std::weak_ptr<T> get_weak($/;"	f	class:folly::Singleton	access:public	signature:( SingletonVault* vault = nullptr )
folly::Singleton::get_weak	.\experimental\Singleton.h	/^  static std::weak_ptr<T> get_weak($/;"	f	class:folly::Singleton	access:public	signature:( const char* name, SingletonVault* vault = nullptr )
folly::Singleton::get_weak	.\experimental\Singleton.h	/^  std::weak_ptr<T> get_weak(const char* name) {$/;"	f	class:folly::Singleton	access:public	signature:(const char* name)
folly::Singleton::operator *	.\experimental\Singleton.h	/^  T& operator*() { return *ptr(); }$/;"	f	class:folly::Singleton	access:public	signature:()
folly::Singleton::operator ->	.\experimental\Singleton.h	/^  T* operator->() { return ptr(); }$/;"	f	class:folly::Singleton	access:public	signature:()
folly::Singleton::ptr	.\experimental\Singleton.h	/^  T* ptr() { return get_ptr(type_descriptor_, vault_); }$/;"	f	class:folly::Singleton	access:public	signature:()
folly::Singleton::type_descriptor_	.\experimental\Singleton.h	/^  detail::TypeDescriptor type_descriptor_;$/;"	m	class:folly::Singleton	access:private
folly::Singleton::vault_	.\experimental\Singleton.h	/^  SingletonVault* vault_;$/;"	m	class:folly::Singleton	access:private
folly::SingletonVault	.\experimental\Singleton.h	/^class SingletonVault {$/;"	c	namespace:folly
folly::SingletonVault::CreateFunc	.\experimental\Singleton.h	/^  typedef std::function<void*(void)> CreateFunc;$/;"	t	class:folly::SingletonVault	access:public
folly::SingletonVault::SingletonEntry	.\experimental\Singleton.h	/^  struct SingletonEntry {$/;"	s	class:folly::SingletonVault	access:private
folly::SingletonVault::SingletonEntry::SingletonEntry	.\experimental\Singleton.h	/^    SingletonEntry() = default;$/;"	p	struct:folly::SingletonVault::SingletonEntry	access:public	signature:()
folly::SingletonVault::SingletonEntry::SingletonEntry	.\experimental\Singleton.h	/^    SingletonEntry(SingletonEntry&&) = delete;$/;"	p	struct:folly::SingletonVault::SingletonEntry	access:public	signature:(SingletonEntry&&)
folly::SingletonVault::SingletonEntry::SingletonEntry	.\experimental\Singleton.h	/^    SingletonEntry(const SingletonEntry&) = delete;$/;"	p	struct:folly::SingletonVault::SingletonEntry	access:public	signature:(const SingletonEntry&)
folly::SingletonVault::SingletonEntry::create	.\experimental\Singleton.h	/^    CreateFunc create = nullptr;$/;"	m	struct:folly::SingletonVault::SingletonEntry	access:public
folly::SingletonVault::SingletonEntry::creating_thread	.\experimental\Singleton.h	/^    std::thread::id creating_thread;$/;"	m	struct:folly::SingletonVault::SingletonEntry	access:public
folly::SingletonVault::SingletonEntry::instance	.\experimental\Singleton.h	/^    std::shared_ptr<void> instance;$/;"	m	struct:folly::SingletonVault::SingletonEntry	access:public
folly::SingletonVault::SingletonEntry::instance_ptr	.\experimental\Singleton.h	/^    void* instance_ptr = nullptr;$/;"	m	struct:folly::SingletonVault::SingletonEntry	access:public
folly::SingletonVault::SingletonEntry::mutex	.\experimental\Singleton.h	/^    std::mutex mutex;$/;"	m	struct:folly::SingletonVault::SingletonEntry	access:public
folly::SingletonVault::SingletonEntry::operator =	.\experimental\Singleton.h	/^    SingletonEntry& operator=(SingletonEntry&&) = delete;$/;"	p	struct:folly::SingletonVault::SingletonEntry	access:public	signature:(SingletonEntry&&)
folly::SingletonVault::SingletonEntry::operator =	.\experimental\Singleton.h	/^    SingletonEntry& operator=(const SingletonEntry&) = delete;$/;"	p	struct:folly::SingletonVault::SingletonEntry	access:public	signature:(const SingletonEntry&)
folly::SingletonVault::SingletonEntry::state	.\experimental\Singleton.h	/^    SingletonEntryState state = SingletonEntryState::Dead;$/;"	m	struct:folly::SingletonVault::SingletonEntry	access:public
folly::SingletonVault::SingletonEntry::state_condvar	.\experimental\Singleton.h	/^    std::condition_variable state_condvar;$/;"	m	struct:folly::SingletonVault::SingletonEntry	access:public
folly::SingletonVault::SingletonEntry::teardown	.\experimental\Singleton.h	/^    TeardownFunc teardown = nullptr;$/;"	m	struct:folly::SingletonVault::SingletonEntry	access:public
folly::SingletonVault::SingletonEntryPtr	.\experimental\Singleton.h	/^  typedef std::unique_ptr<SingletonEntry> SingletonEntryPtr;$/;"	t	class:folly::SingletonVault	access:private
folly::SingletonVault::SingletonEntryState	.\experimental\Singleton.h	/^  enum class SingletonEntryState {$/;"	c	class:folly::SingletonVault	access:private
folly::SingletonVault::SingletonEntryState::BeingBorn	.\experimental\Singleton.h	/^    BeingBorn,$/;"	m	class:folly::SingletonVault::SingletonEntryState	access:private
folly::SingletonVault::SingletonEntryState::Dead	.\experimental\Singleton.h	/^    Dead,$/;"	m	class:folly::SingletonVault::SingletonEntryState	access:private
folly::SingletonVault::SingletonEntryState::Living	.\experimental\Singleton.h	/^    Living,$/;"	m	class:folly::SingletonVault::SingletonEntryState	access:private
folly::SingletonVault::SingletonVault	.\experimental\Singleton.h	/^  explicit SingletonVault(Type type = Type::Relaxed) : type_(type) {}$/;"	f	class:folly::SingletonVault	access:public	signature:(Type type = Type::Relaxed)
folly::SingletonVault::SingletonVaultState	.\experimental\Singleton.h	/^  enum class SingletonVaultState {$/;"	c	class:folly::SingletonVault	access:private
folly::SingletonVault::SingletonVaultState::Registering	.\experimental\Singleton.h	/^    Registering,$/;"	m	class:folly::SingletonVault::SingletonVaultState	access:private
folly::SingletonVault::SingletonVaultState::Running	.\experimental\Singleton.h	/^    Running,$/;"	m	class:folly::SingletonVault::SingletonVaultState	access:private
folly::SingletonVault::TeardownFunc	.\experimental\Singleton.h	/^  typedef std::function<void(void*)> TeardownFunc;$/;"	t	class:folly::SingletonVault	access:public
folly::SingletonVault::Type	.\experimental\Singleton.h	/^  enum class Type { Strict, Relaxed };$/;"	c	class:folly::SingletonVault	access:public
folly::SingletonVault::Type::Strict	.\experimental\Singleton.h	/^  enum class Type { Strict, Relaxed };$/;"	m	class:folly::SingletonVault::Type	access:private
folly::SingletonVault::creation_order_	.\experimental\Singleton.h	/^  std::vector<detail::TypeDescriptor> creation_order_;$/;"	m	class:folly::SingletonVault	access:private
folly::SingletonVault::destroyInstances	.\experimental\Singleton.cpp	/^void SingletonVault::destroyInstances() {$/;"	f	class:folly::SingletonVault	signature:()
folly::SingletonVault::destroyInstances	.\experimental\Singleton.h	/^  void destroyInstances();$/;"	p	class:folly::SingletonVault	access:public	signature:()
folly::SingletonVault::get_entry	.\experimental\Singleton.h	/^  SingletonEntry* get_entry(detail::TypeDescriptor type,$/;"	f	class:folly::SingletonVault	access:private	signature:(detail::TypeDescriptor type, std::unique_lock<std::mutex>* lock)
folly::SingletonVault::get_ptr	.\experimental\Singleton.h	/^  void* get_ptr(detail::TypeDescriptor type) {$/;"	f	class:folly::SingletonVault	access:public	signature:(detail::TypeDescriptor type)
folly::SingletonVault::get_shared	.\experimental\Singleton.h	/^  std::shared_ptr<void> get_shared(detail::TypeDescriptor type) {$/;"	f	class:folly::SingletonVault	access:public	signature:(detail::TypeDescriptor type)
folly::SingletonVault::livingSingletonCount	.\experimental\Singleton.h	/^  size_t livingSingletonCount() const {$/;"	f	class:folly::SingletonVault	access:public	signature:() const
folly::SingletonVault::mutex_	.\experimental\Singleton.h	/^  mutable std::mutex mutex_;$/;"	m	class:folly::SingletonVault	access:private
folly::SingletonVault::registerSingleton	.\experimental\Singleton.h	/^  void registerSingleton(detail::TypeDescriptor type,$/;"	f	class:folly::SingletonVault	access:public	signature:(detail::TypeDescriptor type, CreateFunc create, TeardownFunc teardown)
folly::SingletonVault::registeredSingletonCount	.\experimental\Singleton.h	/^  size_t registeredSingletonCount() const {$/;"	f	class:folly::SingletonVault	access:public	signature:() const
folly::SingletonVault::registrationComplete	.\experimental\Singleton.h	/^  void registrationComplete() {$/;"	f	class:folly::SingletonVault	access:public	signature:()
folly::SingletonVault::singleton	.\experimental\Singleton.cpp	/^SingletonVault* SingletonVault::singleton() {$/;"	f	class:folly::SingletonVault	signature:()
folly::SingletonVault::singleton	.\experimental\Singleton.h	/^  static SingletonVault* singleton();$/;"	p	class:folly::SingletonVault	access:public	signature:()
folly::SingletonVault::singletons_	.\experimental\Singleton.h	/^                     detail::TypeDescriptorHasher> singletons_;$/;"	m	class:folly::SingletonVault	access:private
folly::SingletonVault::stateCheck	.\experimental\Singleton.h	/^  void stateCheck(SingletonVaultState expected,$/;"	f	class:folly::SingletonVault	access:private	signature:(SingletonVaultState expected, const char* msg=)
folly::SingletonVault::state_	.\experimental\Singleton.h	/^  SingletonVaultState state_ = SingletonVaultState::Registering;$/;"	m	class:folly::SingletonVault	access:private
folly::SingletonVault::type_	.\experimental\Singleton.h	/^  Type type_ = Type::Relaxed;$/;"	m	class:folly::SingletonVault	access:private
folly::SingletonVault::~SingletonVault	.\experimental\Singleton.cpp	/^SingletonVault::~SingletonVault() { destroyInstances(); }$/;"	f	class:folly::SingletonVault	signature:()
folly::SingletonVault::~SingletonVault	.\experimental\Singleton.h	/^  ~SingletonVault();$/;"	p	class:folly::SingletonVault	access:public	signature:()
folly::SocketAddress	.\SocketAddress.h	/^class SocketAddress {$/;"	c	namespace:folly
folly::SocketAddress::ExternalUnixAddr	.\SocketAddress.h	/^  struct ExternalUnixAddr {$/;"	s	class:folly::SocketAddress	access:private
folly::SocketAddress::ExternalUnixAddr::addr	.\SocketAddress.h	/^    struct sockaddr_un *addr;$/;"	m	struct:folly::SocketAddress::ExternalUnixAddr	typeref:struct:folly::SocketAddress::ExternalUnixAddr::sockaddr_un	access:public
folly::SocketAddress::ExternalUnixAddr::copy	.\SocketAddress.h	/^    void copy(const ExternalUnixAddr &other) {$/;"	f	struct:folly::SocketAddress::ExternalUnixAddr	access:public	signature:(const ExternalUnixAddr &other)
folly::SocketAddress::ExternalUnixAddr::free	.\SocketAddress.h	/^    void free() {$/;"	f	struct:folly::SocketAddress::ExternalUnixAddr	access:public	signature:()
folly::SocketAddress::ExternalUnixAddr::init	.\SocketAddress.h	/^    void init() {$/;"	f	struct:folly::SocketAddress::ExternalUnixAddr	access:public	signature:()
folly::SocketAddress::ExternalUnixAddr::init	.\SocketAddress.h	/^    void init(const ExternalUnixAddr &other) {$/;"	f	struct:folly::SocketAddress::ExternalUnixAddr	access:public	signature:(const ExternalUnixAddr &other)
folly::SocketAddress::ExternalUnixAddr::len	.\SocketAddress.h	/^    socklen_t len;$/;"	m	struct:folly::SocketAddress::ExternalUnixAddr	access:public
folly::SocketAddress::ExternalUnixAddr::pathLength	.\SocketAddress.h	/^    socklen_t pathLength() const {$/;"	f	struct:folly::SocketAddress::ExternalUnixAddr	access:public	signature:() const
folly::SocketAddress::SocketAddress	.\SocketAddress.h	/^  SocketAddress() {$/;"	f	class:folly::SocketAddress	access:public	signature:()
folly::SocketAddress::SocketAddress	.\SocketAddress.h	/^  SocketAddress(SocketAddress&& addr) {$/;"	f	class:folly::SocketAddress	access:public	signature:(SocketAddress&& addr)
folly::SocketAddress::SocketAddress	.\SocketAddress.h	/^  SocketAddress(const SocketAddress& addr) {$/;"	f	class:folly::SocketAddress	access:public	signature:(const SocketAddress& addr)
folly::SocketAddress::SocketAddress	.\SocketAddress.h	/^  SocketAddress(const char* host, uint16_t port,$/;"	f	class:folly::SocketAddress	access:public	signature:(const char* host, uint16_t port, bool allowNameLookup = false)
folly::SocketAddress::SocketAddress	.\SocketAddress.h	/^  SocketAddress(const std::string& host, uint16_t port,$/;"	f	class:folly::SocketAddress	access:public	signature:(const std::string& host, uint16_t port, bool allowNameLookup = false)
folly::SocketAddress::__anon91::un	.\SocketAddress.h	/^    ExternalUnixAddr un;$/;"	m	union:folly::SocketAddress::__anon91	access:public
folly::SocketAddress::convertToIPv4	.\SocketAddress.cpp	/^void SocketAddress::convertToIPv4() {$/;"	f	class:folly::SocketAddress	signature:()
folly::SocketAddress::convertToIPv4	.\SocketAddress.h	/^  void convertToIPv4();$/;"	p	class:folly::SocketAddress	access:public	signature:()
folly::SocketAddress::describe	.\SocketAddress.cpp	/^std::string SocketAddress::describe() const {$/;"	f	class:folly::SocketAddress	signature:() const
folly::SocketAddress::describe	.\SocketAddress.h	/^  std::string describe() const;$/;"	p	class:folly::SocketAddress	access:public	signature:() const
folly::SocketAddress::empty	.\SocketAddress.h	/^  bool empty() const {$/;"	f	class:folly::SocketAddress	access:public	signature:() const
folly::SocketAddress::getActualSize	.\SocketAddress.cpp	/^socklen_t SocketAddress::getActualSize() const {$/;"	f	class:folly::SocketAddress	signature:() const
folly::SocketAddress::getActualSize	.\SocketAddress.h	/^  socklen_t getActualSize() const;$/;"	p	class:folly::SocketAddress	access:public	signature:() const
folly::SocketAddress::getAddrInfo	.\SocketAddress.cpp	/^struct addrinfo* SocketAddress::getAddrInfo(const char* host,$/;"	f	class:folly::SocketAddress	signature:(const char* host, const char* port, int flags)
folly::SocketAddress::getAddrInfo	.\SocketAddress.cpp	/^struct addrinfo* SocketAddress::getAddrInfo(const char* host,$/;"	f	class:folly::SocketAddress	signature:(const char* host, uint16_t port, int flags)
folly::SocketAddress::getAddrInfo	.\SocketAddress.h	/^  struct addrinfo* getAddrInfo(const char* host, const char* port, int flags);$/;"	p	class:folly::SocketAddress	access:private	signature:(const char* host, const char* port, int flags)
folly::SocketAddress::getAddrInfo	.\SocketAddress.h	/^  struct addrinfo* getAddrInfo(const char* host, uint16_t port, int flags);$/;"	p	class:folly::SocketAddress	access:private	signature:(const char* host, uint16_t port, int flags)
folly::SocketAddress::getAddress	.\SocketAddress.h	/^  socklen_t getAddress(sockaddr_storage* addr) const {$/;"	f	class:folly::SocketAddress	access:public	signature:(sockaddr_storage* addr) const
folly::SocketAddress::getAddressStr	.\SocketAddress.cpp	/^std::string SocketAddress::getAddressStr() const {$/;"	f	class:folly::SocketAddress	signature:() const
folly::SocketAddress::getAddressStr	.\SocketAddress.cpp	/^void SocketAddress::getAddressStr(char* buf, size_t buflen) const {$/;"	f	class:folly::SocketAddress	signature:(char* buf, size_t buflen) const
folly::SocketAddress::getAddressStr	.\SocketAddress.h	/^  std::string getAddressStr() const;$/;"	p	class:folly::SocketAddress	access:public	signature:() const
folly::SocketAddress::getAddressStr	.\SocketAddress.h	/^  void getAddressStr(char* buf, size_t buflen) const;$/;"	p	class:folly::SocketAddress	access:public	signature:(char* buf, size_t buflen) const
folly::SocketAddress::getFamily	.\SocketAddress.h	/^  sa_family_t getFamily() const {$/;"	f	class:folly::SocketAddress	access:public	signature:() const
folly::SocketAddress::getFullyQualified	.\SocketAddress.cpp	/^std::string SocketAddress::getFullyQualified() const {$/;"	f	class:folly::SocketAddress	signature:() const
folly::SocketAddress::getFullyQualified	.\SocketAddress.h	/^  std::string getFullyQualified() const;$/;"	p	class:folly::SocketAddress	access:public	signature:() const
folly::SocketAddress::getHostStr	.\SocketAddress.cpp	/^std::string SocketAddress::getHostStr() const {$/;"	f	class:folly::SocketAddress	signature:() const
folly::SocketAddress::getHostStr	.\SocketAddress.h	/^  std::string getHostStr() const;$/;"	p	class:folly::SocketAddress	access:public	signature:() const
folly::SocketAddress::getIPAddress	.\SocketAddress.cpp	/^const folly::IPAddress& SocketAddress::getIPAddress() const {$/;"	f	class:folly::SocketAddress	signature:() const
folly::SocketAddress::getIPAddress	.\SocketAddress.h	/^  const folly::IPAddress& getIPAddress() const;$/;"	p	class:folly::SocketAddress	access:public	signature:() const
folly::SocketAddress::getIpString	.\SocketAddress.cpp	/^std::string SocketAddress::getIpString(int flags) const {$/;"	f	class:folly::SocketAddress	signature:(int flags) const
folly::SocketAddress::getIpString	.\SocketAddress.cpp	/^void SocketAddress::getIpString(char *buf, size_t buflen, int flags) const {$/;"	f	class:folly::SocketAddress	signature:(char *buf, size_t buflen, int flags) const
folly::SocketAddress::getIpString	.\SocketAddress.h	/^  std::string getIpString(int flags) const;$/;"	p	class:folly::SocketAddress	access:private	signature:(int flags) const
folly::SocketAddress::getIpString	.\SocketAddress.h	/^  void getIpString(char *buf, size_t buflen, int flags) const;$/;"	p	class:folly::SocketAddress	access:private	signature:(char *buf, size_t buflen, int flags) const
folly::SocketAddress::getPath	.\SocketAddress.cpp	/^std::string SocketAddress::getPath() const {$/;"	f	class:folly::SocketAddress	signature:() const
folly::SocketAddress::getPath	.\SocketAddress.h	/^  std::string getPath() const;$/;"	p	class:folly::SocketAddress	access:public	signature:() const
folly::SocketAddress::getPort	.\SocketAddress.cpp	/^uint16_t SocketAddress::getPort() const {$/;"	f	class:folly::SocketAddress	signature:() const
folly::SocketAddress::getPort	.\SocketAddress.h	/^  uint16_t getPort() const;$/;"	p	class:folly::SocketAddress	access:public	signature:() const
folly::SocketAddress::hash	.\SocketAddress.cpp	/^size_t SocketAddress::hash() const {$/;"	f	class:folly::SocketAddress	signature:() const
folly::SocketAddress::hash	.\SocketAddress.h	/^  size_t hash() const;$/;"	p	class:folly::SocketAddress	access:public	signature:() const
folly::SocketAddress::isIPv4Mapped	.\SocketAddress.h	/^  bool isIPv4Mapped() const {$/;"	f	class:folly::SocketAddress	access:public	signature:() const
folly::SocketAddress::isInitialized	.\SocketAddress.h	/^  bool isInitialized() const {$/;"	f	class:folly::SocketAddress	access:public	signature:() const
folly::SocketAddress::isLoopbackAddress	.\SocketAddress.cpp	/^bool SocketAddress::isLoopbackAddress() const {$/;"	f	class:folly::SocketAddress	signature:() const
folly::SocketAddress::isLoopbackAddress	.\SocketAddress.h	/^  bool isLoopbackAddress() const;$/;"	p	class:folly::SocketAddress	access:public	signature:() const
folly::SocketAddress::isPrivateAddress	.\SocketAddress.cpp	/^bool SocketAddress::isPrivateAddress() const {$/;"	f	class:folly::SocketAddress	signature:() const
folly::SocketAddress::isPrivateAddress	.\SocketAddress.h	/^  bool isPrivateAddress() const;$/;"	p	class:folly::SocketAddress	access:public	signature:() const
folly::SocketAddress::mapToIPv6	.\SocketAddress.cpp	/^bool SocketAddress::mapToIPv6() {$/;"	f	class:folly::SocketAddress	signature:()
folly::SocketAddress::mapToIPv6	.\SocketAddress.h	/^  bool mapToIPv6();$/;"	p	class:folly::SocketAddress	access:public	signature:()
folly::SocketAddress::operator !=	.\SocketAddress.h	/^  bool operator!=(const SocketAddress& other) const {$/;"	f	class:folly::SocketAddress	access:public	signature:(const SocketAddress& other) const
folly::SocketAddress::operator <	.\SocketAddress.cpp	/^bool SocketAddress::operator<(const SocketAddress& other) const {$/;"	f	class:folly::SocketAddress	signature:(const SocketAddress& other) const
folly::SocketAddress::operator <	.\SocketAddress.h	/^  bool operator<(const SocketAddress& other) const;$/;"	p	class:folly::SocketAddress	access:public	signature:(const SocketAddress& other) const
folly::SocketAddress::operator =	.\SocketAddress.h	/^  SocketAddress& operator=(SocketAddress&& addr) {$/;"	f	class:folly::SocketAddress	access:public	signature:(SocketAddress&& addr)
folly::SocketAddress::operator =	.\SocketAddress.h	/^  SocketAddress& operator=(const SocketAddress& addr) {$/;"	f	class:folly::SocketAddress	access:public	signature:(const SocketAddress& addr)
folly::SocketAddress::operator ==	.\SocketAddress.cpp	/^bool SocketAddress::operator==(const SocketAddress& other) const {$/;"	f	class:folly::SocketAddress	signature:(const SocketAddress& other) const
folly::SocketAddress::operator ==	.\SocketAddress.h	/^  bool operator==(const SocketAddress& other) const;$/;"	p	class:folly::SocketAddress	access:public	signature:(const SocketAddress& other) const
folly::SocketAddress::port_	.\SocketAddress.h	/^  uint16_t port_;$/;"	m	class:folly::SocketAddress	access:private
folly::SocketAddress::prefixMatch	.\SocketAddress.cpp	/^bool SocketAddress::prefixMatch(const SocketAddress& other,$/;"	f	class:folly::SocketAddress	signature:(const SocketAddress& other, unsigned prefixLength) const
folly::SocketAddress::prefixMatch	.\SocketAddress.h	/^  bool prefixMatch(const SocketAddress& other, unsigned prefixLength) const;$/;"	p	class:folly::SocketAddress	access:public	signature:(const SocketAddress& other, unsigned prefixLength) const
folly::SocketAddress::prepFamilyChange	.\SocketAddress.h	/^  void prepFamilyChange(sa_family_t newFamily) {$/;"	f	class:folly::SocketAddress	access:private	signature:(sa_family_t newFamily)
folly::SocketAddress::reset	.\SocketAddress.h	/^  void reset() {$/;"	f	class:folly::SocketAddress	access:public	signature:()
folly::SocketAddress::setFromAddrInfo	.\SocketAddress.cpp	/^void SocketAddress::setFromAddrInfo(const struct addrinfo* info) {$/;"	f	class:folly::SocketAddress	signature:(const struct addrinfo* info)
folly::SocketAddress::setFromAddrInfo	.\SocketAddress.h	/^  void setFromAddrInfo(const struct addrinfo* results);$/;"	p	class:folly::SocketAddress	access:private	signature:(const struct addrinfo* results)
folly::SocketAddress::setFromHostPort	.\SocketAddress.cpp	/^void SocketAddress::setFromHostPort(const char* host, uint16_t port) {$/;"	f	class:folly::SocketAddress	signature:(const char* host, uint16_t port)
folly::SocketAddress::setFromHostPort	.\SocketAddress.cpp	/^void SocketAddress::setFromHostPort(const char* hostAndPort) {$/;"	f	class:folly::SocketAddress	signature:(const char* hostAndPort)
folly::SocketAddress::setFromHostPort	.\SocketAddress.h	/^  void setFromHostPort(const char* host, uint16_t port);$/;"	p	class:folly::SocketAddress	access:public	signature:(const char* host, uint16_t port)
folly::SocketAddress::setFromHostPort	.\SocketAddress.h	/^  void setFromHostPort(const char* hostAndPort);$/;"	p	class:folly::SocketAddress	access:public	signature:(const char* hostAndPort)
folly::SocketAddress::setFromHostPort	.\SocketAddress.h	/^  void setFromHostPort(const std::string& host, uint16_t port) {$/;"	f	class:folly::SocketAddress	access:public	signature:(const std::string& host, uint16_t port)
folly::SocketAddress::setFromHostPort	.\SocketAddress.h	/^  void setFromHostPort(const std::string& hostAndPort) {$/;"	f	class:folly::SocketAddress	access:public	signature:(const std::string& hostAndPort)
folly::SocketAddress::setFromIpPort	.\SocketAddress.cpp	/^void SocketAddress::setFromIpPort(const char* addressAndPort) {$/;"	f	class:folly::SocketAddress	signature:(const char* addressAndPort)
folly::SocketAddress::setFromIpPort	.\SocketAddress.cpp	/^void SocketAddress::setFromIpPort(const char* ip, uint16_t port) {$/;"	f	class:folly::SocketAddress	signature:(const char* ip, uint16_t port)
folly::SocketAddress::setFromIpPort	.\SocketAddress.h	/^  void setFromIpPort(const char* addressAndPort);$/;"	p	class:folly::SocketAddress	access:public	signature:(const char* addressAndPort)
folly::SocketAddress::setFromIpPort	.\SocketAddress.h	/^  void setFromIpPort(const char* ip, uint16_t port);$/;"	p	class:folly::SocketAddress	access:public	signature:(const char* ip, uint16_t port)
folly::SocketAddress::setFromIpPort	.\SocketAddress.h	/^  void setFromIpPort(const std::string& addressAndPort) {$/;"	f	class:folly::SocketAddress	access:public	signature:(const std::string& addressAndPort)
folly::SocketAddress::setFromIpPort	.\SocketAddress.h	/^  void setFromIpPort(const std::string& ip, uint16_t port) {$/;"	f	class:folly::SocketAddress	access:public	signature:(const std::string& ip, uint16_t port)
folly::SocketAddress::setFromLocalAddr	.\SocketAddress.cpp	/^void SocketAddress::setFromLocalAddr(const struct addrinfo* info) {$/;"	f	class:folly::SocketAddress	signature:(const struct addrinfo* info)
folly::SocketAddress::setFromLocalAddr	.\SocketAddress.h	/^  void setFromLocalAddr(const struct addrinfo* results);$/;"	p	class:folly::SocketAddress	access:private	signature:(const struct addrinfo* results)
folly::SocketAddress::setFromLocalAddress	.\SocketAddress.cpp	/^void SocketAddress::setFromLocalAddress(int socket) {$/;"	f	class:folly::SocketAddress	signature:(int socket)
folly::SocketAddress::setFromLocalAddress	.\SocketAddress.h	/^  void setFromLocalAddress(int socket);$/;"	p	class:folly::SocketAddress	access:public	signature:(int socket)
folly::SocketAddress::setFromLocalIpPort	.\SocketAddress.cpp	/^void SocketAddress::setFromLocalIpPort(const char* addressAndPort) {$/;"	f	class:folly::SocketAddress	signature:(const char* addressAndPort)
folly::SocketAddress::setFromLocalIpPort	.\SocketAddress.h	/^  void setFromLocalIpPort(const char* addressAndPort);$/;"	p	class:folly::SocketAddress	access:public	signature:(const char* addressAndPort)
folly::SocketAddress::setFromLocalIpPort	.\SocketAddress.h	/^  void setFromLocalIpPort(const std::string& addressAndPort) {$/;"	f	class:folly::SocketAddress	access:public	signature:(const std::string& addressAndPort)
folly::SocketAddress::setFromLocalPort	.\SocketAddress.cpp	/^void SocketAddress::setFromLocalPort(const char* port) {$/;"	f	class:folly::SocketAddress	signature:(const char* port)
folly::SocketAddress::setFromLocalPort	.\SocketAddress.cpp	/^void SocketAddress::setFromLocalPort(uint16_t port) {$/;"	f	class:folly::SocketAddress	signature:(uint16_t port)
folly::SocketAddress::setFromLocalPort	.\SocketAddress.h	/^  void setFromLocalPort(const char* port);$/;"	p	class:folly::SocketAddress	access:public	signature:(const char* port)
folly::SocketAddress::setFromLocalPort	.\SocketAddress.h	/^  void setFromLocalPort(const std::string& port) {$/;"	f	class:folly::SocketAddress	access:public	signature:(const std::string& port)
folly::SocketAddress::setFromLocalPort	.\SocketAddress.h	/^  void setFromLocalPort(uint16_t port);$/;"	p	class:folly::SocketAddress	access:public	signature:(uint16_t port)
folly::SocketAddress::setFromPath	.\SocketAddress.cpp	/^void SocketAddress::setFromPath(const char* path, size_t len) {$/;"	f	class:folly::SocketAddress	signature:(const char* path, size_t len)
folly::SocketAddress::setFromPath	.\SocketAddress.h	/^  void setFromPath(const char* path) {$/;"	f	class:folly::SocketAddress	access:public	signature:(const char* path)
folly::SocketAddress::setFromPath	.\SocketAddress.h	/^  void setFromPath(const char* path, size_t length);$/;"	p	class:folly::SocketAddress	access:public	signature:(const char* path, size_t length)
folly::SocketAddress::setFromPath	.\SocketAddress.h	/^  void setFromPath(const std::string& path) {$/;"	f	class:folly::SocketAddress	access:public	signature:(const std::string& path)
folly::SocketAddress::setFromPeerAddress	.\SocketAddress.cpp	/^void SocketAddress::setFromPeerAddress(int socket) {$/;"	f	class:folly::SocketAddress	signature:(int socket)
folly::SocketAddress::setFromPeerAddress	.\SocketAddress.h	/^  void setFromPeerAddress(int socket);$/;"	p	class:folly::SocketAddress	access:public	signature:(int socket)
folly::SocketAddress::setFromSockaddr	.\SocketAddress.cpp	/^void SocketAddress::setFromSockaddr(const struct sockaddr* address) {$/;"	f	class:folly::SocketAddress	signature:(const struct sockaddr* address)
folly::SocketAddress::setFromSockaddr	.\SocketAddress.cpp	/^void SocketAddress::setFromSockaddr(const struct sockaddr* address,$/;"	f	class:folly::SocketAddress	signature:(const struct sockaddr* address, socklen_t addrlen)
folly::SocketAddress::setFromSockaddr	.\SocketAddress.cpp	/^void SocketAddress::setFromSockaddr(const struct sockaddr_in* address) {$/;"	f	class:folly::SocketAddress	signature:(const struct sockaddr_in* address)
folly::SocketAddress::setFromSockaddr	.\SocketAddress.cpp	/^void SocketAddress::setFromSockaddr(const struct sockaddr_in6* address) {$/;"	f	class:folly::SocketAddress	signature:(const struct sockaddr_in6* address)
folly::SocketAddress::setFromSockaddr	.\SocketAddress.cpp	/^void SocketAddress::setFromSockaddr(const struct sockaddr_un* address,$/;"	f	class:folly::SocketAddress	signature:(const struct sockaddr_un* address, socklen_t addrlen)
folly::SocketAddress::setFromSockaddr	.\SocketAddress.h	/^  void setFromSockaddr(const struct sockaddr* address);$/;"	p	class:folly::SocketAddress	access:public	signature:(const struct sockaddr* address)
folly::SocketAddress::setFromSockaddr	.\SocketAddress.h	/^  void setFromSockaddr(const struct sockaddr* address,$/;"	p	class:folly::SocketAddress	access:public	signature:(const struct sockaddr* address, socklen_t addrlen)
folly::SocketAddress::setFromSockaddr	.\SocketAddress.h	/^  void setFromSockaddr(const struct sockaddr_in* address);$/;"	p	class:folly::SocketAddress	access:public	signature:(const struct sockaddr_in* address)
folly::SocketAddress::setFromSockaddr	.\SocketAddress.h	/^  void setFromSockaddr(const struct sockaddr_in6* address);$/;"	p	class:folly::SocketAddress	access:public	signature:(const struct sockaddr_in6* address)
folly::SocketAddress::setFromSockaddr	.\SocketAddress.h	/^  void setFromSockaddr(const struct sockaddr_un* address,$/;"	p	class:folly::SocketAddress	access:public	signature:(const struct sockaddr_un* address, socklen_t addrlen)
folly::SocketAddress::setFromSocket	.\SocketAddress.cpp	/^void SocketAddress::setFromSocket(int socket,$/;"	f	class:folly::SocketAddress	signature:(int socket, int (*fn)(int, sockaddr*, socklen_t*))
folly::SocketAddress::setFromSocket	.\SocketAddress.h	/^  void setFromSocket(int socket, int (*fn)(int, struct sockaddr*, socklen_t*));$/;"	p	class:folly::SocketAddress	access:private	signature:(int socket, int (*fn)(int, struct sockaddr*, socklen_t*))
folly::SocketAddress::setPort	.\SocketAddress.cpp	/^void SocketAddress::setPort(uint16_t port) {$/;"	f	class:folly::SocketAddress	signature:(uint16_t port)
folly::SocketAddress::setPort	.\SocketAddress.h	/^  void setPort(uint16_t port);$/;"	p	class:folly::SocketAddress	access:public	signature:(uint16_t port)
folly::SocketAddress::storage_	.\SocketAddress.h	/^  } storage_;$/;"	m	class:folly::SocketAddress	typeref:union:folly::SocketAddress::__anon91	access:private
folly::SocketAddress::tryConvertToIPv4	.\SocketAddress.cpp	/^bool SocketAddress::tryConvertToIPv4() {$/;"	f	class:folly::SocketAddress	signature:()
folly::SocketAddress::tryConvertToIPv4	.\SocketAddress.h	/^  bool tryConvertToIPv4();$/;"	p	class:folly::SocketAddress	access:public	signature:()
folly::SocketAddress::updateUnixAddressLength	.\SocketAddress.cpp	/^void SocketAddress::updateUnixAddressLength(socklen_t addrlen) {$/;"	f	class:folly::SocketAddress	signature:(socklen_t addrlen)
folly::SocketAddress::updateUnixAddressLength	.\SocketAddress.h	/^  void updateUnixAddressLength(socklen_t addrlen);$/;"	p	class:folly::SocketAddress	access:private	signature:(socklen_t addrlen)
folly::SocketAddress::~SocketAddress	.\SocketAddress.h	/^  ~SocketAddress() {$/;"	f	class:folly::SocketAddress	access:public	signature:()
folly::SpinLockArray	.\SmallLocks.h	/^struct SpinLockArray {$/;"	s	namespace:folly
folly::SpinLockArray::FOLLY_CACHE_LINE_SIZE	.\SmallLocks.h	/^  static_assert(sizeof(PaddedSpinLock) == FOLLY_CACHE_LINE_SIZE,$/;"	m	struct:folly::SpinLockArray	access:private
folly::SpinLockArray::PaddedSpinLock	.\SmallLocks.h	/^  struct PaddedSpinLock {$/;"	s	struct:folly::SpinLockArray	access:private
folly::SpinLockArray::PaddedSpinLock::PaddedSpinLock	.\SmallLocks.h	/^    PaddedSpinLock() : lock() { }$/;"	f	struct:folly::SpinLockArray::PaddedSpinLock	access:public	signature:()
folly::SpinLockArray::PaddedSpinLock::lock	.\SmallLocks.h	/^    T lock;$/;"	m	struct:folly::SpinLockArray::PaddedSpinLock	access:public
folly::SpinLockArray::PaddedSpinLock::padding	.\SmallLocks.h	/^    char padding[FOLLY_CACHE_LINE_SIZE - sizeof(T)];$/;"	m	struct:folly::SpinLockArray::PaddedSpinLock	access:public
folly::SpinLockArray::data_	.\SmallLocks.h	/^  std::array<PaddedSpinLock, N> data_;$/;"	m	struct:folly::SpinLockArray	access:private
folly::SpinLockArray::operator []	.\SmallLocks.h	/^  T& operator[](size_t i) {$/;"	f	struct:folly::SpinLockArray	access:public	signature:(size_t i)
folly::SpinLockArray::operator []	.\SmallLocks.h	/^  const T& operator[](size_t i) const {$/;"	f	struct:folly::SpinLockArray	access:public	signature:(size_t i) const
folly::SpinLockArray::padding_	.\SmallLocks.h	/^  char padding_[FOLLY_CACHE_LINE_SIZE];$/;"	m	struct:folly::SpinLockArray	access:private
folly::SpinLockArray::size	.\SmallLocks.h	/^  constexpr size_t size() const { return N; }$/;"	f	struct:folly::SpinLockArray	access:public	signature:() const
folly::SpinLockArray::sizeof	.\SmallLocks.h	/^                sizeof(T) <= alignof(MaxAlign),$/;"	p	struct:folly::SpinLockArray	access:private	signature:(T)
folly::StlAllocator	.\Memory.h	/^class StlAllocator {$/;"	c	namespace:folly
folly::StlAllocator	.\Memory.h	/^template <class Alloc, class T> class StlAllocator;$/;"	x
folly::StlAllocator	.\Memory.h	/^template <class Alloc> class StlAllocator<Alloc, void> {$/;"	c	namespace:folly
folly::StlAllocator::StlAllocator	.\Memory.h	/^  StlAllocator() : alloc_(nullptr) { }$/;"	f	class:folly::StlAllocator	access:public	signature:()
folly::StlAllocator::StlAllocator	.\Memory.h	/^  explicit StlAllocator(Alloc* a) : alloc_(a) { }$/;"	f	class:folly::StlAllocator	access:public	signature:(Alloc* a)
folly::StlAllocator::StlAllocator	.\Memory.h	/^  template <class U> StlAllocator(const StlAllocator<Alloc, U>& other)$/;"	f	class:folly::StlAllocator	access:public	signature:(const StlAllocator<Alloc, U>& other)
folly::StlAllocator::address	.\Memory.h	/^  T* address(T& x) const {$/;"	f	class:folly::StlAllocator	access:public	signature:(T& x) const
folly::StlAllocator::address	.\Memory.h	/^  const T* address(const T& x) const {$/;"	f	class:folly::StlAllocator	access:public	signature:(const T& x) const
folly::StlAllocator::alloc	.\Memory.h	/^  Alloc* alloc() const {$/;"	f	class:folly::StlAllocator	access:public	signature:() const
folly::StlAllocator::alloc_	.\Memory.h	/^  Alloc* alloc_;$/;"	m	class:folly::StlAllocator	access:private
folly::StlAllocator::allocate	.\Memory.h	/^  T* allocate(size_t n, const void* hint = nullptr) {$/;"	f	class:folly::StlAllocator	access:public	signature:(size_t n, const void* hint = nullptr)
folly::StlAllocator::const_pointer	.\Memory.h	/^  typedef const T* const_pointer;$/;"	t	class:folly::StlAllocator	access:public
folly::StlAllocator::const_pointer	.\Memory.h	/^  typedef const void* const_pointer;$/;"	t	class:folly::StlAllocator	access:public
folly::StlAllocator::const_reference	.\Memory.h	/^  typedef const T& const_reference;$/;"	t	class:folly::StlAllocator	access:public
folly::StlAllocator::construct	.\Memory.h	/^  void construct(T* p, Args&&... args) {$/;"	f	class:folly::StlAllocator	access:public	signature:(T* p, Args&&... args)
folly::StlAllocator::deallocate	.\Memory.h	/^  void deallocate(T* p, size_t n) {$/;"	f	class:folly::StlAllocator	access:public	signature:(T* p, size_t n)
folly::StlAllocator::destroy	.\Memory.h	/^  void destroy(T* p) {$/;"	f	class:folly::StlAllocator	access:public	signature:(T* p)
folly::StlAllocator::difference_type	.\Memory.h	/^  typedef ptrdiff_t difference_type;$/;"	t	class:folly::StlAllocator	access:public
folly::StlAllocator::max_size	.\Memory.h	/^  size_t max_size() const {$/;"	f	class:folly::StlAllocator	access:public	signature:() const
folly::StlAllocator::operator !=	.\Memory.h	/^  bool operator!=(const StlAllocator<Alloc, T>& other) const {$/;"	f	class:folly::StlAllocator	access:public	signature:(const StlAllocator<Alloc, T>& other) const
folly::StlAllocator::operator !=	.\Memory.h	/^  bool operator!=(const StlAllocator<Alloc, void>& other) const {$/;"	f	class:folly::StlAllocator	access:public	signature:(const StlAllocator<Alloc, void>& other) const
folly::StlAllocator::operator ==	.\Memory.h	/^  bool operator==(const StlAllocator<Alloc, T>& other) const {$/;"	f	class:folly::StlAllocator	access:public	signature:(const StlAllocator<Alloc, T>& other) const
folly::StlAllocator::operator ==	.\Memory.h	/^  bool operator==(const StlAllocator<Alloc, void>& other) const {$/;"	f	class:folly::StlAllocator	access:public	signature:(const StlAllocator<Alloc, void>& other) const
folly::StlAllocator::pointer	.\Memory.h	/^  typedef T* pointer;$/;"	t	class:folly::StlAllocator	access:public
folly::StlAllocator::pointer	.\Memory.h	/^  typedef void* pointer;$/;"	t	class:folly::StlAllocator	access:public
folly::StlAllocator::rebind	.\Memory.h	/^  template <class U> struct rebind {$/;"	s	class:folly::StlAllocator	access:public
folly::StlAllocator::rebind::other	.\Memory.h	/^    typedef StlAllocator<Alloc, U> other;$/;"	t	struct:folly::StlAllocator::rebind	access:public
folly::StlAllocator::reference	.\Memory.h	/^  typedef T& reference;$/;"	t	class:folly::StlAllocator	access:public
folly::StlAllocator::size_type	.\Memory.h	/^  typedef size_t size_type;$/;"	t	class:folly::StlAllocator	access:public
folly::StlAllocator::value_type	.\Memory.h	/^  typedef T value_type;$/;"	t	class:folly::StlAllocator	access:public
folly::StlAllocator::value_type	.\Memory.h	/^  typedef void value_type;$/;"	t	class:folly::StlAllocator	access:public
folly::StringPiece	.\Range.h	/^typedef Range<const char*> StringPiece;$/;"	t	namespace:folly
folly::StringPieceHash	.\Range.h	/^struct StringPieceHash {$/;"	s	namespace:folly
folly::StringPieceHash::operator ()	.\Range.h	/^  std::size_t operator()(const StringPiece& str) const {$/;"	f	struct:folly::StringPieceHash	access:public	signature:(const StringPiece& str) const
folly::Subprocess	.\Subprocess.h	/^class Subprocess : private boost::noncopyable {$/;"	c	namespace:folly	inherits:boost::noncopyable
folly::Subprocess	.\Subprocess.h	/^class Subprocess;$/;"	x
folly::Subprocess::CLOSE	.\Subprocess.h	/^  static const int CLOSE = -1;$/;"	m	class:folly::Subprocess	access:public
folly::Subprocess::FdCallback	.\Subprocess.h	/^  typedef std::function<bool(int, int)> FdCallback;$/;"	t	class:folly::Subprocess	access:public
folly::Subprocess::Options	.\Subprocess.h	/^  class Options : private boost::orable<Options> {$/;"	c	class:folly::Subprocess	inherits:boost::orable	access:public
folly::Subprocess::Options::FdMap	.\Subprocess.h	/^    typedef boost::container::flat_map<int, int> FdMap;$/;"	t	class:folly::Subprocess::Options	access:private
folly::Subprocess::Options::Options	.\Subprocess.h	/^    Options()$/;"	f	class:folly::Subprocess::Options	access:public	signature:()
folly::Subprocess::Options::Subprocess	.\Subprocess.h	/^    friend class Subprocess;$/;"	x
folly::Subprocess::Options::chdir	.\Subprocess.h	/^    Options& chdir(const std::string& dir) { childDir_ = dir; return *this; }$/;"	f	class:folly::Subprocess::Options	access:public	signature:(const std::string& dir)
folly::Subprocess::Options::childDir_	.\Subprocess.h	/^    std::string childDir_;  \/\/ "" keeps the parent's working directory$/;"	m	class:folly::Subprocess::Options	access:private
folly::Subprocess::Options::closeOtherFds	.\Subprocess.h	/^    Options& closeOtherFds() { closeOtherFds_ = true; return *this; }$/;"	f	class:folly::Subprocess::Options	access:public	signature:()
folly::Subprocess::Options::closeOtherFds_	.\Subprocess.h	/^    bool closeOtherFds_;$/;"	m	class:folly::Subprocess::Options	access:private
folly::Subprocess::Options::fd	.\Subprocess.cpp	/^Subprocess::Options& Subprocess::Options::fd(int fd, int action) {$/;"	f	class:folly::Subprocess::Options	signature:(int fd, int action)
folly::Subprocess::Options::fd	.\Subprocess.h	/^    Options& fd(int fd, int action);$/;"	p	class:folly::Subprocess::Options	access:public	signature:(int fd, int action)
folly::Subprocess::Options::fdActions_	.\Subprocess.h	/^    FdMap fdActions_;$/;"	m	class:folly::Subprocess::Options	access:private
folly::Subprocess::Options::operator |=	.\Subprocess.h	/^    Options& operator|=(const Options& other);$/;"	p	class:folly::Subprocess::Options	access:public	signature:(const Options& other)
folly::Subprocess::Options::operator |=	.\Subprocess.h	/^inline Subprocess::Options& Subprocess::Options::operator|=($/;"	f	class:folly::Subprocess::Options	signature:( const Subprocess::Options& other)
folly::Subprocess::Options::parentDeathSignal	.\Subprocess.h	/^    Options& parentDeathSignal(int sig) {$/;"	f	class:folly::Subprocess::Options	access:public	signature:(int sig)
folly::Subprocess::Options::pipeStderr	.\Subprocess.h	/^    Options& pipeStderr() { return fd(STDERR_FILENO, PIPE_OUT); }$/;"	f	class:folly::Subprocess::Options	access:public	signature:()
folly::Subprocess::Options::pipeStdin	.\Subprocess.h	/^    Options& pipeStdin() { return fd(STDIN_FILENO, PIPE_IN); }$/;"	f	class:folly::Subprocess::Options	access:public	signature:()
folly::Subprocess::Options::pipeStdout	.\Subprocess.h	/^    Options& pipeStdout() { return fd(STDOUT_FILENO, PIPE_OUT); }$/;"	f	class:folly::Subprocess::Options	access:public	signature:()
folly::Subprocess::Options::stderr	.\Subprocess.h	/^    Options& stderr(int action) { return fd(STDERR_FILENO, action); }$/;"	f	class:folly::Subprocess::Options	access:public	signature:(int action)
folly::Subprocess::Options::stdin	.\Subprocess.h	/^    Options& stdin(int action) { return fd(STDIN_FILENO, action); }$/;"	f	class:folly::Subprocess::Options	access:public	signature:(int action)
folly::Subprocess::Options::stdout	.\Subprocess.h	/^    Options& stdout(int action) { return fd(STDOUT_FILENO, action); }$/;"	f	class:folly::Subprocess::Options	access:public	signature:(int action)
folly::Subprocess::Options::usePath	.\Subprocess.h	/^    Options& usePath() { usePath_ = true; return *this; }$/;"	f	class:folly::Subprocess::Options	access:public	signature:()
folly::Subprocess::Options::usePath_	.\Subprocess.h	/^    bool usePath_;$/;"	m	class:folly::Subprocess::Options	access:private
folly::Subprocess::PIPE	.\Subprocess.h	/^  static const int PIPE = -2;$/;"	m	class:folly::Subprocess	access:public
folly::Subprocess::PIPE_IN	.\Subprocess.h	/^  static const int PIPE_IN = -3;$/;"	m	class:folly::Subprocess	access:public
folly::Subprocess::PIPE_OUT	.\Subprocess.h	/^  static const int PIPE_OUT = -4;$/;"	m	class:folly::Subprocess	access:public
folly::Subprocess::PipeInfo	.\Subprocess.h	/^  struct PipeInfo : private boost::totally_ordered<PipeInfo> {$/;"	s	class:folly::Subprocess	inherits:boost::totally_ordered	access:private
folly::Subprocess::PipeInfo::childFd	.\Subprocess.h	/^    int childFd = -1;$/;"	m	struct:folly::Subprocess::PipeInfo	access:public
folly::Subprocess::PipeInfo::direction	.\Subprocess.h	/^    int direction = PIPE_IN;  \/\/ one of PIPE_IN \/ PIPE_OUT$/;"	m	struct:folly::Subprocess::PipeInfo	access:public
folly::Subprocess::PipeInfo::enabled	.\Subprocess.h	/^    bool enabled = true;$/;"	m	struct:folly::Subprocess::PipeInfo	access:public
folly::Subprocess::PipeInfo::operator <	.\Subprocess.h	/^    bool operator<(const PipeInfo& other) const {$/;"	f	struct:folly::Subprocess::PipeInfo	access:public	signature:(const PipeInfo& other) const
folly::Subprocess::PipeInfo::operator ==	.\Subprocess.h	/^    bool operator==(const PipeInfo& other) const {$/;"	f	struct:folly::Subprocess::PipeInfo	access:public	signature:(const PipeInfo& other) const
folly::Subprocess::PipeInfo::parentFd	.\Subprocess.h	/^    int parentFd = -1;$/;"	m	struct:folly::Subprocess::PipeInfo	access:public
folly::Subprocess::RV_NOT_STARTED	.\Subprocess.h	/^  static const int RV_NOT_STARTED = ProcessReturnCode::RV_NOT_STARTED;$/;"	m	class:folly::Subprocess	access:private
folly::Subprocess::RV_RUNNING	.\Subprocess.h	/^  static const int RV_RUNNING = ProcessReturnCode::RV_RUNNING;$/;"	m	class:folly::Subprocess	access:private
folly::Subprocess::ReadLinesCallback	.\Subprocess.h	/^  class ReadLinesCallback {$/;"	c	class:folly::Subprocess	access:public
folly::Subprocess::ReadLinesCallback::LineSplitter	.\Subprocess.h	/^    typedef gen::StreamSplitter<StreamSplitterCallback> LineSplitter;$/;"	t	class:folly::Subprocess::ReadLinesCallback	access:private
folly::Subprocess::ReadLinesCallback::ReadLinesCallback	.\Subprocess.h	/^    explicit ReadLinesCallback($/;"	f	class:folly::Subprocess::ReadLinesCallback	access:public	signature:( Callback&& fdLineCb, uint64_t maxLineLength = 0, char delimiter = , uint64_t bufSize = 1024 )
folly::Subprocess::ReadLinesCallback::StreamSplitterCallback	.\Subprocess.h	/^    struct StreamSplitterCallback {$/;"	s	class:folly::Subprocess::ReadLinesCallback	access:private
folly::Subprocess::ReadLinesCallback::StreamSplitterCallback::StreamSplitterCallback	.\Subprocess.h	/^      StreamSplitterCallback(Callback& cb, int fd) : cb_(cb), fd_(fd) { }$/;"	f	struct:folly::Subprocess::ReadLinesCallback::StreamSplitterCallback	access:public	signature:(Callback& cb, int fd)
folly::Subprocess::ReadLinesCallback::StreamSplitterCallback::cb_	.\Subprocess.h	/^      Callback& cb_;$/;"	m	struct:folly::Subprocess::ReadLinesCallback::StreamSplitterCallback	access:public
folly::Subprocess::ReadLinesCallback::StreamSplitterCallback::fd_	.\Subprocess.h	/^      int fd_;$/;"	m	struct:folly::Subprocess::ReadLinesCallback::StreamSplitterCallback	access:public
folly::Subprocess::ReadLinesCallback::StreamSplitterCallback::operator ()	.\Subprocess.h	/^      bool operator()(StringPiece s) { return !cb_(fd_, s); }$/;"	f	struct:folly::Subprocess::ReadLinesCallback::StreamSplitterCallback	access:public	signature:(StringPiece s)
folly::Subprocess::ReadLinesCallback::bufSize_	.\Subprocess.h	/^    const uint64_t bufSize_;$/;"	m	class:folly::Subprocess::ReadLinesCallback	access:private
folly::Subprocess::ReadLinesCallback::delimiter_	.\Subprocess.h	/^    const char delimiter_;$/;"	m	class:folly::Subprocess::ReadLinesCallback	access:private
folly::Subprocess::ReadLinesCallback::fdLineCb_	.\Subprocess.h	/^    Callback fdLineCb_;$/;"	m	class:folly::Subprocess::ReadLinesCallback	access:private
folly::Subprocess::ReadLinesCallback::fdToSplitter_	.\Subprocess.h	/^    std::unordered_map<int, LineSplitter> fdToSplitter_;$/;"	m	class:folly::Subprocess::ReadLinesCallback	access:private
folly::Subprocess::ReadLinesCallback::maxLineLength_	.\Subprocess.h	/^    const uint64_t maxLineLength_;$/;"	m	class:folly::Subprocess::ReadLinesCallback	access:private
folly::Subprocess::ReadLinesCallback::operator ()	.\Subprocess.h	/^    bool operator()(int pfd, int cfd) {$/;"	f	class:folly::Subprocess::ReadLinesCallback	access:public	signature:(int pfd, int cfd)
folly::Subprocess::Subprocess	.\Subprocess.cpp	/^Subprocess::Subprocess($/;"	f	class:folly::Subprocess	signature:( const std::string& cmd, const Options& options, const std::vector<std::string>* env)
folly::Subprocess::Subprocess	.\Subprocess.cpp	/^Subprocess::Subprocess($/;"	f	class:folly::Subprocess	signature:( const std::vector<std::string>& argv, const Options& options, const char* executable, const std::vector<std::string>* env)
folly::Subprocess::Subprocess	.\Subprocess.h	/^  explicit Subprocess($/;"	p	class:folly::Subprocess	access:public	signature:( const std::string& cmd, const Options& options = Options(), const std::vector<std::string>* env = nullptr)
folly::Subprocess::Subprocess	.\Subprocess.h	/^  explicit Subprocess($/;"	p	class:folly::Subprocess	access:public	signature:( const std::vector<std::string>& argv, const Options& options = Options(), const char* executable = nullptr, const std::vector<std::string>* env = nullptr)
folly::Subprocess::closeAll	.\Subprocess.cpp	/^void Subprocess::closeAll() {$/;"	f	class:folly::Subprocess	signature:()
folly::Subprocess::closeAll	.\Subprocess.h	/^  void closeAll();$/;"	p	class:folly::Subprocess	access:private	signature:()
folly::Subprocess::closeParentFd	.\Subprocess.cpp	/^void Subprocess::closeParentFd(int childFd) {$/;"	f	class:folly::Subprocess	signature:(int childFd)
folly::Subprocess::closeParentFd	.\Subprocess.h	/^  void closeParentFd(int childFd);$/;"	p	class:folly::Subprocess	access:public	signature:(int childFd)
folly::Subprocess::communicate	.\Subprocess.cpp	/^std::pair<std::string, std::string> Subprocess::communicate($/;"	f	class:folly::Subprocess	signature:( StringPiece input)
folly::Subprocess::communicate	.\Subprocess.cpp	/^void Subprocess::communicate(FdCallback readCallback,$/;"	f	class:folly::Subprocess	signature:(FdCallback readCallback, FdCallback writeCallback)
folly::Subprocess::communicate	.\Subprocess.h	/^  std::pair<std::string, std::string> communicate($/;"	p	class:folly::Subprocess	access:public	signature:( StringPiece input = StringPiece())
folly::Subprocess::communicate	.\Subprocess.h	/^  void communicate(FdCallback readCallback, FdCallback writeCallback);$/;"	p	class:folly::Subprocess	access:public	signature:(FdCallback readCallback, FdCallback writeCallback)
folly::Subprocess::communicateIOBuf	.\Subprocess.cpp	/^std::pair<IOBufQueue, IOBufQueue> Subprocess::communicateIOBuf($/;"	f	class:folly::Subprocess	signature:( IOBufQueue input)
folly::Subprocess::communicateIOBuf	.\Subprocess.h	/^  std::pair<IOBufQueue, IOBufQueue> communicateIOBuf($/;"	p	class:folly::Subprocess	access:public	signature:( IOBufQueue input = IOBufQueue())
folly::Subprocess::enableNotifications	.\Subprocess.cpp	/^void Subprocess::enableNotifications(int childFd, bool enabled) {$/;"	f	class:folly::Subprocess	signature:(int childFd, bool enabled)
folly::Subprocess::enableNotifications	.\Subprocess.h	/^  void enableNotifications(int childFd, bool enabled);$/;"	p	class:folly::Subprocess	access:public	signature:(int childFd, bool enabled)
folly::Subprocess::findByChildFd	.\Subprocess.cpp	/^int Subprocess::findByChildFd(int childFd) const {$/;"	f	class:folly::Subprocess	signature:(int childFd) const
folly::Subprocess::findByChildFd	.\Subprocess.h	/^  int findByChildFd(int childFd) const;$/;"	p	class:folly::Subprocess	access:private	signature:(int childFd) const
folly::Subprocess::kill	.\Subprocess.h	/^  void kill() { sendSignal(SIGKILL); }$/;"	f	class:folly::Subprocess	access:public	signature:()
folly::Subprocess::notificationsEnabled	.\Subprocess.cpp	/^bool Subprocess::notificationsEnabled(int childFd) const {$/;"	f	class:folly::Subprocess	signature:(int childFd) const
folly::Subprocess::notificationsEnabled	.\Subprocess.h	/^  bool notificationsEnabled(int childFd) const;$/;"	p	class:folly::Subprocess	access:public	signature:(int childFd) const
folly::Subprocess::parentFd	.\Subprocess.h	/^  int parentFd(int childFd) const {$/;"	f	class:folly::Subprocess	access:public	signature:(int childFd) const
folly::Subprocess::pid	.\Subprocess.cpp	/^pid_t Subprocess::pid() const {$/;"	f	class:folly::Subprocess	signature:() const
folly::Subprocess::pid	.\Subprocess.h	/^  pid_t pid() const;$/;"	p	class:folly::Subprocess	access:public	signature:() const
folly::Subprocess::pid_	.\Subprocess.h	/^  pid_t pid_;$/;"	m	class:folly::Subprocess	access:private
folly::Subprocess::pipeStderr	.\Subprocess.h	/^  static Options pipeStderr() { return Options().stderr(PIPE); }$/;"	f	class:folly::Subprocess	access:public	signature:()
folly::Subprocess::pipeStdin	.\Subprocess.h	/^  static Options pipeStdin() { return Options().stdin(PIPE); }$/;"	f	class:folly::Subprocess	access:public	signature:()
folly::Subprocess::pipeStdout	.\Subprocess.h	/^  static Options pipeStdout() { return Options().stdout(PIPE); }$/;"	f	class:folly::Subprocess	access:public	signature:()
folly::Subprocess::pipes_	.\Subprocess.h	/^  std::vector<PipeInfo> pipes_;$/;"	m	class:folly::Subprocess	access:private
folly::Subprocess::poll	.\Subprocess.cpp	/^ProcessReturnCode Subprocess::poll() {$/;"	f	class:folly::Subprocess	signature:()
folly::Subprocess::poll	.\Subprocess.h	/^  ProcessReturnCode poll();$/;"	p	class:folly::Subprocess	access:public	signature:()
folly::Subprocess::pollChecked	.\Subprocess.cpp	/^bool Subprocess::pollChecked() {$/;"	f	class:folly::Subprocess	signature:()
folly::Subprocess::pollChecked	.\Subprocess.h	/^  bool pollChecked();$/;"	p	class:folly::Subprocess	access:public	signature:()
folly::Subprocess::prepareChild	.\Subprocess.cpp	/^int Subprocess::prepareChild(const Options& options,$/;"	f	class:folly::Subprocess	signature:(const Options& options, const sigset_t* sigmask, const char* childDir) const
folly::Subprocess::prepareChild	.\Subprocess.h	/^  int prepareChild(const Options& options,$/;"	p	class:folly::Subprocess	access:private	signature:(const Options& options, const sigset_t* sigmask, const char* childDir) const
folly::Subprocess::readChildErrorPipe	.\Subprocess.cpp	/^void Subprocess::readChildErrorPipe(int pfd, const char* executable) {$/;"	f	class:folly::Subprocess	signature:(int pfd, const char* executable)
folly::Subprocess::readChildErrorPipe	.\Subprocess.h	/^  void readChildErrorPipe(int pfd, const char* executable);$/;"	p	class:folly::Subprocess	access:private	signature:(int pfd, const char* executable)
folly::Subprocess::readLinesCallback	.\Subprocess.h	/^  static ReadLinesCallback<Callback> readLinesCallback($/;"	f	class:folly::Subprocess	access:public	signature:( Callback&& fdLineCb, uint64_t maxLineLength = 0, char delimiter = , uint64_t bufSize = 1024)
folly::Subprocess::returnCode	.\Subprocess.h	/^  ProcessReturnCode returnCode() const { return returnCode_; }$/;"	f	class:folly::Subprocess	access:public	signature:() const
folly::Subprocess::returnCode_	.\Subprocess.h	/^  ProcessReturnCode returnCode_;$/;"	m	class:folly::Subprocess	access:private
folly::Subprocess::runChild	.\Subprocess.cpp	/^int Subprocess::runChild(const char* executable,$/;"	f	class:folly::Subprocess	signature:(const char* executable, char** argv, char** env, const Options& options) const
folly::Subprocess::runChild	.\Subprocess.h	/^  int runChild(const char* executable, char** argv, char** env,$/;"	p	class:folly::Subprocess	access:private	signature:(const char* executable, char** argv, char** env, const Options& options) const
folly::Subprocess::sendSignal	.\Subprocess.cpp	/^void Subprocess::sendSignal(int signal) {$/;"	f	class:folly::Subprocess	signature:(int signal)
folly::Subprocess::sendSignal	.\Subprocess.h	/^  void sendSignal(int signal);$/;"	p	class:folly::Subprocess	access:public	signature:(int signal)
folly::Subprocess::setAllNonBlocking	.\Subprocess.cpp	/^void Subprocess::setAllNonBlocking() {$/;"	f	class:folly::Subprocess	signature:()
folly::Subprocess::setAllNonBlocking	.\Subprocess.h	/^  void setAllNonBlocking();$/;"	p	class:folly::Subprocess	access:public	signature:()
folly::Subprocess::spawn	.\Subprocess.cpp	/^void Subprocess::spawn($/;"	f	class:folly::Subprocess	signature:( std::unique_ptr<const char*[]> argv, const char* executable, const Options& optionsIn, const std::vector<std::string>* env)
folly::Subprocess::spawn	.\Subprocess.h	/^  void spawn($/;"	p	class:folly::Subprocess	access:private	signature:( std::unique_ptr<const char*[]> argv, const char* executable, const Options& options, const std::vector<std::string>* env)
folly::Subprocess::spawnInternal	.\Subprocess.cpp	/^void Subprocess::spawnInternal($/;"	f	class:folly::Subprocess	signature:( std::unique_ptr<const char*[]> argv, const char* executable, Options& options, const std::vector<std::string>* env, int errFd)
folly::Subprocess::spawnInternal	.\Subprocess.h	/^  void spawnInternal($/;"	p	class:folly::Subprocess	access:private	signature:( std::unique_ptr<const char*[]> argv, const char* executable, Options& options, const std::vector<std::string>* env, int errFd)
folly::Subprocess::stderr	.\Subprocess.h	/^  int stderr() const { return parentFd(2); }$/;"	f	class:folly::Subprocess	access:public	signature:() const
folly::Subprocess::stdin	.\Subprocess.h	/^  int stdin() const { return parentFd(0); }$/;"	f	class:folly::Subprocess	access:public	signature:() const
folly::Subprocess::stdout	.\Subprocess.h	/^  int stdout() const { return parentFd(1); }$/;"	f	class:folly::Subprocess	access:public	signature:() const
folly::Subprocess::terminate	.\Subprocess.h	/^  void terminate() { sendSignal(SIGTERM); }$/;"	f	class:folly::Subprocess	access:public	signature:()
folly::Subprocess::wait	.\Subprocess.cpp	/^ProcessReturnCode Subprocess::wait() {$/;"	f	class:folly::Subprocess	signature:()
folly::Subprocess::wait	.\Subprocess.h	/^  ProcessReturnCode wait();$/;"	p	class:folly::Subprocess	access:public	signature:()
folly::Subprocess::waitChecked	.\Subprocess.cpp	/^void Subprocess::waitChecked() {$/;"	f	class:folly::Subprocess	signature:()
folly::Subprocess::waitChecked	.\Subprocess.h	/^  void waitChecked();$/;"	p	class:folly::Subprocess	access:public	signature:()
folly::Subprocess::~Subprocess	.\Subprocess.cpp	/^Subprocess::~Subprocess() {$/;"	f	class:folly::Subprocess	signature:()
folly::Subprocess::~Subprocess	.\Subprocess.h	/^  ~Subprocess();$/;"	p	class:folly::Subprocess	access:public	signature:()
folly::SubprocessError	.\Subprocess.h	/^class SubprocessError : public std::exception {};$/;"	c	namespace:folly	inherits:std::exception
folly::SubprocessSpawnError	.\Subprocess.h	/^class SubprocessSpawnError : public SubprocessError {$/;"	c	namespace:folly	inherits:SubprocessError
folly::SubprocessSpawnError::SubprocessSpawnError	.\Subprocess.cpp	/^SubprocessSpawnError::SubprocessSpawnError(const char* executable,$/;"	f	class:folly::SubprocessSpawnError	signature:(const char* executable, int errCode, int errnoValue)
folly::SubprocessSpawnError::SubprocessSpawnError	.\Subprocess.h	/^  SubprocessSpawnError(const char* executable, int errCode, int errnoValue);$/;"	p	class:folly::SubprocessSpawnError	access:public	signature:(const char* executable, int errCode, int errnoValue)
folly::SubprocessSpawnError::errnoValue	.\Subprocess.h	/^  int errnoValue() const { return errnoValue_; }$/;"	f	class:folly::SubprocessSpawnError	access:public	signature:() const
folly::SubprocessSpawnError::errnoValue_	.\Subprocess.h	/^  int errnoValue_;$/;"	m	class:folly::SubprocessSpawnError	access:private
folly::SubprocessSpawnError::what_	.\Subprocess.h	/^  std::string what_;$/;"	m	class:folly::SubprocessSpawnError	access:private
folly::SubprocessSpawnError::~SubprocessSpawnError	.\Subprocess.h	/^  ~SubprocessSpawnError() throw() {}$/;"	f	class:folly::SubprocessSpawnError	access:public	signature:()
folly::Synchronized	.\Synchronized.h	/^struct Synchronized {$/;"	s	namespace:folly
folly::Synchronized::ConstLockedPtr	.\Synchronized.h	/^  struct ConstLockedPtr {$/;"	s	struct:folly::Synchronized	access:public
folly::Synchronized::ConstLockedPtr::ConstLockedPtr	.\Synchronized.h	/^    ConstLockedPtr() = delete;$/;"	p	struct:folly::Synchronized::ConstLockedPtr	access:public	signature:()
folly::Synchronized::ConstLockedPtr::ConstLockedPtr	.\Synchronized.h	/^    ConstLockedPtr(const ConstLockedPtr& rhs) : parent_(rhs.parent_) {$/;"	f	struct:folly::Synchronized::ConstLockedPtr	access:public	signature:(const ConstLockedPtr& rhs)
folly::Synchronized::ConstLockedPtr::ConstLockedPtr	.\Synchronized.h	/^    ConstLockedPtr(const Synchronized* parent, detail::InternalDoNotUse)$/;"	f	struct:folly::Synchronized::ConstLockedPtr	access:public	signature:(const Synchronized* parent, detail::InternalDoNotUse)
folly::Synchronized::ConstLockedPtr::ConstLockedPtr	.\Synchronized.h	/^    ConstLockedPtr(const Synchronized* parent, unsigned int milliseconds) {$/;"	f	struct:folly::Synchronized::ConstLockedPtr	access:public	signature:(const Synchronized* parent, unsigned int milliseconds)
folly::Synchronized::ConstLockedPtr::ConstLockedPtr	.\Synchronized.h	/^    explicit ConstLockedPtr(const LockedPtr& rhs) : parent_(rhs.parent_) {$/;"	f	struct:folly::Synchronized::ConstLockedPtr	access:public	signature:(const LockedPtr& rhs)
folly::Synchronized::ConstLockedPtr::ConstLockedPtr	.\Synchronized.h	/^    explicit ConstLockedPtr(const Synchronized* parent) : parent_(parent) {$/;"	f	struct:folly::Synchronized::ConstLockedPtr	access:public	signature:(const Synchronized* parent)
folly::Synchronized::ConstLockedPtr::Unsynchronizer	.\Synchronized.h	/^    friend struct Unsynchronizer;$/;"	x
folly::Synchronized::ConstLockedPtr::Unsynchronizer	.\Synchronized.h	/^    struct Unsynchronizer {$/;"	s	struct:folly::Synchronized::ConstLockedPtr	access:public
folly::Synchronized::ConstLockedPtr::Unsynchronizer::Unsynchronizer	.\Synchronized.h	/^      Unsynchronizer(const Unsynchronizer&) = delete;$/;"	p	struct:folly::Synchronized::ConstLockedPtr::Unsynchronizer	access:public	signature:(const Unsynchronizer&)
folly::Synchronized::ConstLockedPtr::Unsynchronizer::Unsynchronizer	.\Synchronized.h	/^      explicit Unsynchronizer(ConstLockedPtr* p) : parent_(p) {$/;"	f	struct:folly::Synchronized::ConstLockedPtr::Unsynchronizer	access:public	signature:(ConstLockedPtr* p)
folly::Synchronized::ConstLockedPtr::Unsynchronizer::operator ->	.\Synchronized.h	/^      ConstLockedPtr* operator->() const {$/;"	f	struct:folly::Synchronized::ConstLockedPtr::Unsynchronizer	access:public	signature:() const
folly::Synchronized::ConstLockedPtr::Unsynchronizer::operator =	.\Synchronized.h	/^      Unsynchronizer& operator=(const Unsynchronizer&) = delete;$/;"	p	struct:folly::Synchronized::ConstLockedPtr::Unsynchronizer	access:public	signature:(const Unsynchronizer&)
folly::Synchronized::ConstLockedPtr::Unsynchronizer::parent_	.\Synchronized.h	/^      ConstLockedPtr* parent_;$/;"	m	struct:folly::Synchronized::ConstLockedPtr::Unsynchronizer	access:private
folly::Synchronized::ConstLockedPtr::Unsynchronizer::~Unsynchronizer	.\Synchronized.h	/^      ~Unsynchronizer() {$/;"	f	struct:folly::Synchronized::ConstLockedPtr::Unsynchronizer	access:public	signature:()
folly::Synchronized::ConstLockedPtr::acquire	.\Synchronized.h	/^    void acquire() {$/;"	f	struct:folly::Synchronized::ConstLockedPtr	access:private	signature:()
folly::Synchronized::ConstLockedPtr::lockInOrder	.\Synchronized.h	/^    friend void lockInOrder(P1& p1, P2& p2);$/;"	p	struct:folly::Synchronized::ConstLockedPtr	access:friend	signature:(P1& p1, P2& p2)
folly::Synchronized::ConstLockedPtr::operator ->	.\Synchronized.h	/^    const T* operator->() const {$/;"	f	struct:folly::Synchronized::ConstLockedPtr	access:public	signature:() const
folly::Synchronized::ConstLockedPtr::operator =	.\Synchronized.h	/^    ConstLockedPtr& operator=(const ConstLockedPtr& rhs) {$/;"	f	struct:folly::Synchronized::ConstLockedPtr	access:public	signature:(const ConstLockedPtr& rhs)
folly::Synchronized::ConstLockedPtr::parent_	.\Synchronized.h	/^    const Synchronized* parent_;$/;"	m	struct:folly::Synchronized::ConstLockedPtr	access:private
folly::Synchronized::ConstLockedPtr::typeHackDoNotUse	.\Synchronized.h	/^    Unsynchronizer typeHackDoNotUse();$/;"	p	struct:folly::Synchronized::ConstLockedPtr	access:public	signature:()
folly::Synchronized::ConstLockedPtr::~ConstLockedPtr	.\Synchronized.h	/^    ~ConstLockedPtr() {$/;"	f	struct:folly::Synchronized::ConstLockedPtr	access:public	signature:()
folly::Synchronized::LockedPtr	.\Synchronized.h	/^  struct LockedPtr {$/;"	s	struct:folly::Synchronized	access:public
folly::Synchronized::LockedPtr::LockedPtr	.\Synchronized.h	/^    LockedPtr() = delete;$/;"	p	struct:folly::Synchronized::LockedPtr	access:public	signature:()
folly::Synchronized::LockedPtr::LockedPtr	.\Synchronized.h	/^    LockedPtr(Synchronized* parent, detail::InternalDoNotUse)$/;"	f	struct:folly::Synchronized::LockedPtr	access:public	signature:(Synchronized* parent, detail::InternalDoNotUse)
folly::Synchronized::LockedPtr::LockedPtr	.\Synchronized.h	/^    LockedPtr(Synchronized* parent, unsigned int milliseconds) {$/;"	f	struct:folly::Synchronized::LockedPtr	access:public	signature:(Synchronized* parent, unsigned int milliseconds)
folly::Synchronized::LockedPtr::LockedPtr	.\Synchronized.h	/^    LockedPtr(const LockedPtr& rhs) : parent_(rhs.parent_) {$/;"	f	struct:folly::Synchronized::LockedPtr	access:public	signature:(const LockedPtr& rhs)
folly::Synchronized::LockedPtr::LockedPtr	.\Synchronized.h	/^    explicit LockedPtr(Synchronized* parent) : parent_(parent) {$/;"	f	struct:folly::Synchronized::LockedPtr	access:public	signature:(Synchronized* parent)
folly::Synchronized::LockedPtr::Unsynchronizer	.\Synchronized.h	/^    friend struct Unsynchronizer;$/;"	x
folly::Synchronized::LockedPtr::Unsynchronizer	.\Synchronized.h	/^    struct Unsynchronizer {$/;"	s	struct:folly::Synchronized::LockedPtr	access:public
folly::Synchronized::LockedPtr::Unsynchronizer::Unsynchronizer	.\Synchronized.h	/^      Unsynchronizer(const Unsynchronizer&) = delete;$/;"	p	struct:folly::Synchronized::LockedPtr::Unsynchronizer	access:public	signature:(const Unsynchronizer&)
folly::Synchronized::LockedPtr::Unsynchronizer::Unsynchronizer	.\Synchronized.h	/^      explicit Unsynchronizer(LockedPtr* p) : parent_(p) {$/;"	f	struct:folly::Synchronized::LockedPtr::Unsynchronizer	access:public	signature:(LockedPtr* p)
folly::Synchronized::LockedPtr::Unsynchronizer::operator ->	.\Synchronized.h	/^      LockedPtr* operator->() const {$/;"	f	struct:folly::Synchronized::LockedPtr::Unsynchronizer	access:public	signature:() const
folly::Synchronized::LockedPtr::Unsynchronizer::operator =	.\Synchronized.h	/^      Unsynchronizer& operator=(const Unsynchronizer&) = delete;$/;"	p	struct:folly::Synchronized::LockedPtr::Unsynchronizer	access:public	signature:(const Unsynchronizer&)
folly::Synchronized::LockedPtr::Unsynchronizer::parent_	.\Synchronized.h	/^      LockedPtr* parent_;$/;"	m	struct:folly::Synchronized::LockedPtr::Unsynchronizer	access:private
folly::Synchronized::LockedPtr::Unsynchronizer::~Unsynchronizer	.\Synchronized.h	/^      ~Unsynchronizer() {$/;"	f	struct:folly::Synchronized::LockedPtr::Unsynchronizer	access:public	signature:()
folly::Synchronized::LockedPtr::acquire	.\Synchronized.h	/^    void acquire() {$/;"	f	struct:folly::Synchronized::LockedPtr	access:private	signature:()
folly::Synchronized::LockedPtr::lockInOrder	.\Synchronized.h	/^    friend void lockInOrder(P1& p1, P2& p2);$/;"	p	struct:folly::Synchronized::LockedPtr	access:friend	signature:(P1& p1, P2& p2)
folly::Synchronized::LockedPtr::operator ->	.\Synchronized.h	/^    T* operator->() {$/;"	f	struct:folly::Synchronized::LockedPtr	access:public	signature:()
folly::Synchronized::LockedPtr::operator =	.\Synchronized.h	/^    LockedPtr& operator=(const LockedPtr& rhs) {$/;"	f	struct:folly::Synchronized::LockedPtr	access:public	signature:(const LockedPtr& rhs)
folly::Synchronized::LockedPtr::parent_	.\Synchronized.h	/^    Synchronized* parent_;$/;"	m	struct:folly::Synchronized::LockedPtr	access:private
folly::Synchronized::LockedPtr::typeHackDoNotUse	.\Synchronized.h	/^    Unsynchronizer typeHackDoNotUse();$/;"	p	struct:folly::Synchronized::LockedPtr	access:public	signature:()
folly::Synchronized::LockedPtr::~LockedPtr	.\Synchronized.h	/^    ~LockedPtr() {$/;"	f	struct:folly::Synchronized::LockedPtr	access:public	signature:()
folly::Synchronized::Synchronized	.\Synchronized.h	/^  Synchronized() = default;$/;"	p	struct:folly::Synchronized	access:public	signature:()
folly::Synchronized::asConst	.\Synchronized.h	/^  const Synchronized& asConst() const {$/;"	f	struct:folly::Synchronized	access:public	signature:() const
folly::Synchronized::copy	.\Synchronized.h	/^  T copy() const {$/;"	f	struct:folly::Synchronized	access:public	signature:() const
folly::Synchronized::copy	.\Synchronized.h	/^  void copy(T* target) const {$/;"	f	struct:folly::Synchronized	access:public	signature:(T* target) const
folly::Synchronized::datum_	.\Synchronized.h	/^  T datum_;$/;"	m	struct:folly::Synchronized	access:private
folly::Synchronized::internalDoNotUse	.\Synchronized.h	/^  ConstLockedPtr internalDoNotUse() const {$/;"	f	struct:folly::Synchronized	access:public	signature:() const
folly::Synchronized::internalDoNotUse	.\Synchronized.h	/^  LockedPtr internalDoNotUse() {$/;"	f	struct:folly::Synchronized	access:public	signature:()
folly::Synchronized::mutex_	.\Synchronized.h	/^  mutable Mutex mutex_;$/;"	m	struct:folly::Synchronized	access:private
folly::Synchronized::noexcept	.\Synchronized.h	/^               const Guard& \/*guard*\/) noexcept(nxCopyCtor)$/;"	f	struct:folly::Synchronized	access:private	signature:(nxCopyCtor)
folly::Synchronized::noexcept	.\Synchronized.h	/^  Synchronized(Synchronized&& rhs) noexcept(nxMoveCtor)$/;"	f	struct:folly::Synchronized	access:public	signature:(nxMoveCtor)
folly::Synchronized::noexcept	.\Synchronized.h	/^  Synchronized(Synchronized&& rhs, const Guard& \/*guard*\/) noexcept(nxMoveCtor)$/;"	f	struct:folly::Synchronized	access:private	signature:(nxMoveCtor)
folly::Synchronized::noexcept	.\Synchronized.h	/^  Synchronized(const Synchronized& rhs) noexcept(nxCopyCtor)$/;"	f	struct:folly::Synchronized	access:public	signature:(nxCopyCtor)
folly::Synchronized::noexcept	.\Synchronized.h	/^  explicit Synchronized(T&& rhs) noexcept(nxMoveCtor)$/;"	f	struct:folly::Synchronized	access:public	signature:(nxMoveCtor)
folly::Synchronized::noexcept	.\Synchronized.h	/^  explicit Synchronized(const T& rhs) noexcept(nxCopyCtor) : datum_(rhs) {}$/;"	f	struct:folly::Synchronized	access:public	signature:(nxCopyCtor)
folly::Synchronized::operator ->	.\Synchronized.h	/^  ConstLockedPtr operator->() const {$/;"	f	struct:folly::Synchronized	access:public	signature:() const
folly::Synchronized::operator ->	.\Synchronized.h	/^  LockedPtr operator->() {$/;"	f	struct:folly::Synchronized	access:public	signature:()
folly::Synchronized::operator =	.\Synchronized.h	/^  Synchronized& operator=(Synchronized&& rhs) {$/;"	f	struct:folly::Synchronized	access:public	signature:(Synchronized&& rhs)
folly::Synchronized::operator =	.\Synchronized.h	/^  Synchronized& operator=(T&& rhs) {$/;"	f	struct:folly::Synchronized	access:public	signature:(T&& rhs)
folly::Synchronized::operator =	.\Synchronized.h	/^  Synchronized& operator=(const Synchronized& rhs) {$/;"	f	struct:folly::Synchronized	access:public	signature:(const Synchronized& rhs)
folly::Synchronized::operator =	.\Synchronized.h	/^  Synchronized& operator=(const T& rhs) {$/;"	f	struct:folly::Synchronized	access:public	signature:(const T& rhs)
folly::Synchronized::swap	.\Synchronized.h	/^  void swap(Synchronized& rhs) {$/;"	f	struct:folly::Synchronized	access:public	signature:(Synchronized& rhs)
folly::Synchronized::swap	.\Synchronized.h	/^  void swap(T& rhs) {$/;"	f	struct:folly::Synchronized	access:public	signature:(T& rhs)
folly::Synchronized::timedAcquire	.\Synchronized.h	/^  ConstLockedPtr timedAcquire(unsigned int milliseconds) const {$/;"	f	struct:folly::Synchronized	access:public	signature:(unsigned int milliseconds) const
folly::Synchronized::timedAcquire	.\Synchronized.h	/^  LockedPtr timedAcquire(unsigned int milliseconds) {$/;"	f	struct:folly::Synchronized	access:public	signature:(unsigned int milliseconds)
folly::SysAlloc	.\Memory.h	/^class SysAlloc {$/;"	c	namespace:folly
folly::SysAlloc::allocate	.\Memory.h	/^  void* allocate(size_t size) {$/;"	f	class:folly::SysAlloc	access:public	signature:(size_t size)
folly::SysAlloc::deallocate	.\Memory.h	/^  void deallocate(void* p) {$/;"	f	class:folly::SysAlloc	access:public	signature:(void* p)
folly::SysArena	.\Arena.h	/^class SysArena : public Arena<SysAlloc> {$/;"	c	namespace:folly	inherits:Arena
folly::SysArena::SysArena	.\Arena.h	/^  explicit SysArena(size_t minBlockSize = kDefaultMinBlockSize,$/;"	f	class:folly::SysArena	access:public	signature:(size_t minBlockSize = kDefaultMinBlockSize, size_t sizeLimit = kNoSizeLimit, size_t maxAlign = kDefaultMaxAlign)
folly::TEST	.\test\LazyTest.cpp	/^TEST(Lazy, Consty) {$/;"	f	namespace:folly	signature:(Lazy, Consty)
folly::TEST	.\test\LazyTest.cpp	/^TEST(Lazy, Global) {$/;"	f	namespace:folly	signature:(Lazy, Global)
folly::TEST	.\test\LazyTest.cpp	/^TEST(Lazy, Map) {$/;"	f	namespace:folly	signature:(Lazy, Map)
folly::TEST	.\test\LazyTest.cpp	/^TEST(Lazy, NonLambda) {$/;"	f	namespace:folly	signature:(Lazy, NonLambda)
folly::TEST	.\test\LazyTest.cpp	/^TEST(Lazy, Simple) {$/;"	f	namespace:folly	signature:(Lazy, Simple)
folly::TEST	.\test\MemoryMappingTest.cpp	/^TEST(MemoryMapping, Basic) {$/;"	f	namespace:folly	signature:(MemoryMapping, Basic)
folly::TEST	.\test\MemoryMappingTest.cpp	/^TEST(MemoryMapping, DoublyMapped) {$/;"	f	namespace:folly	signature:(MemoryMapping, DoublyMapped)
folly::TEST	.\test\MemoryMappingTest.cpp	/^TEST(MemoryMapping, LargeFile) {$/;"	f	namespace:folly	signature:(MemoryMapping, LargeFile)
folly::TEST	.\test\MemoryMappingTest.cpp	/^TEST(MemoryMapping, Move) {$/;"	f	namespace:folly	signature:(MemoryMapping, Move)
folly::TEST	.\test\MemoryMappingTest.cpp	/^TEST(MemoryMapping, Simple) {$/;"	f	namespace:folly	signature:(MemoryMapping, Simple)
folly::TEST	.\test\MemoryMappingTest.cpp	/^TEST(MemoryMapping, ZeroLength) {$/;"	f	namespace:folly	signature:(MemoryMapping, ZeroLength)
folly::TEST	.\test\MoveWrapperTest.cpp	/^TEST(makeMoveWrapper, Empty) {$/;"	f	namespace:folly	signature:(makeMoveWrapper, Empty)
folly::TEST	.\test\MoveWrapperTest.cpp	/^TEST(makeMoveWrapper, NonEmpty) {$/;"	f	namespace:folly	signature:(makeMoveWrapper, NonEmpty)
folly::TEST	.\test\OptionalTest.cpp	/^TEST(Optional, AssignmentContained) {$/;"	f	namespace:folly	signature:(Optional, AssignmentContained)
folly::TEST	.\test\OptionalTest.cpp	/^TEST(Optional, Comparisons) {$/;"	f	namespace:folly	signature:(Optional, Comparisons)
folly::TEST	.\test\OptionalTest.cpp	/^TEST(Optional, Const) {$/;"	f	namespace:folly	signature:(Optional, Const)
folly::TEST	.\test\OptionalTest.cpp	/^TEST(Optional, Conversions) {$/;"	f	namespace:folly	signature:(Optional, Conversions)
folly::TEST	.\test\OptionalTest.cpp	/^TEST(Optional, EmptyConstruct) {$/;"	f	namespace:folly	signature:(Optional, EmptyConstruct)
folly::TEST	.\test\OptionalTest.cpp	/^TEST(Optional, MakeOptional) {$/;"	f	namespace:folly	signature:(Optional, MakeOptional)
folly::TEST	.\test\OptionalTest.cpp	/^TEST(Optional, NoDefault) {$/;"	f	namespace:folly	signature:(Optional, NoDefault)
folly::TEST	.\test\OptionalTest.cpp	/^TEST(Optional, Order) {$/;"	f	namespace:folly	signature:(Optional, Order)
folly::TEST	.\test\OptionalTest.cpp	/^TEST(Optional, Pointee) {$/;"	f	namespace:folly	signature:(Optional, Pointee)
folly::TEST	.\test\OptionalTest.cpp	/^TEST(Optional, SelfAssignment) {$/;"	f	namespace:folly	signature:(Optional, SelfAssignment)
folly::TEST	.\test\OptionalTest.cpp	/^TEST(Optional, Shared) {$/;"	f	namespace:folly	signature:(Optional, Shared)
folly::TEST	.\test\OptionalTest.cpp	/^TEST(Optional, Simple) {$/;"	f	namespace:folly	signature:(Optional, Simple)
folly::TEST	.\test\OptionalTest.cpp	/^TEST(Optional, String) {$/;"	f	namespace:folly	signature:(Optional, String)
folly::TEST	.\test\OptionalTest.cpp	/^TEST(Optional, Swap) {$/;"	f	namespace:folly	signature:(Optional, Swap)
folly::TEST	.\test\OptionalTest.cpp	/^TEST(Optional, Unique) {$/;"	f	namespace:folly	signature:(Optional, Unique)
folly::TEST	.\test\OptionalTest.cpp	/^TEST(Optional, value_or_noncopyable) {$/;"	f	namespace:folly	signature:(Optional, value_or_noncopyable)
folly::TEST	.\test\OptionalTest.cpp	/^TEST(Optional, value_or_rvalue_arg) {$/;"	f	namespace:folly	signature:(Optional, value_or_rvalue_arg)
folly::TLPDestructionMode	.\ThreadLocal.h	/^enum class TLPDestructionMode {$/;"	c	namespace:folly
folly::TLPDestructionMode::THIS_THREAD	.\ThreadLocal.h	/^  THIS_THREAD,$/;"	m	class:folly::TLPDestructionMode	access:private
folly::ThreadCachedArena	.\ThreadCachedArena.h	/^class ThreadCachedArena {$/;"	c	namespace:folly
folly::ThreadCachedArena::ThreadCachedArena	.\ThreadCachedArena.cpp	/^ThreadCachedArena::ThreadCachedArena(size_t minBlockSize, size_t maxAlign)$/;"	f	class:folly::ThreadCachedArena	signature:(size_t minBlockSize, size_t maxAlign)
folly::ThreadCachedArena::ThreadCachedArena	.\ThreadCachedArena.h	/^  ThreadCachedArena(ThreadCachedArena&&) = delete;$/;"	p	class:folly::ThreadCachedArena	access:private	signature:(ThreadCachedArena&&)
folly::ThreadCachedArena::ThreadCachedArena	.\ThreadCachedArena.h	/^  ThreadCachedArena(const ThreadCachedArena&) = delete;$/;"	p	class:folly::ThreadCachedArena	access:private	signature:(const ThreadCachedArena&)
folly::ThreadCachedArena::ThreadCachedArena	.\ThreadCachedArena.h	/^  explicit ThreadCachedArena($/;"	p	class:folly::ThreadCachedArena	access:public	signature:( size_t minBlockSize = SysArena::kDefaultMinBlockSize, size_t maxAlign = SysArena::kDefaultMaxAlign)
folly::ThreadCachedArena::allocate	.\ThreadCachedArena.h	/^  void* allocate(size_t size) {$/;"	f	class:folly::ThreadCachedArena	access:public	signature:(size_t size)
folly::ThreadCachedArena::allocateThreadLocalArena	.\ThreadCachedArena.cpp	/^SysArena* ThreadCachedArena::allocateThreadLocalArena() {$/;"	f	class:folly::ThreadCachedArena	signature:()
folly::ThreadCachedArena::allocateThreadLocalArena	.\ThreadCachedArena.h	/^  SysArena* allocateThreadLocalArena();$/;"	p	class:folly::ThreadCachedArena	access:private	signature:()
folly::ThreadCachedArena::arena_	.\ThreadCachedArena.h	/^  ThreadLocalPtr<SysArena> arena_;  \/\/ per-thread arena$/;"	m	class:folly::ThreadCachedArena	access:private
folly::ThreadCachedArena::deallocate	.\ThreadCachedArena.h	/^  void deallocate(void* p) {$/;"	f	class:folly::ThreadCachedArena	access:public	signature:(void* p)
folly::ThreadCachedArena::maxAlign_	.\ThreadCachedArena.h	/^  const size_t maxAlign_;$/;"	m	class:folly::ThreadCachedArena	access:private
folly::ThreadCachedArena::minBlockSize_	.\ThreadCachedArena.h	/^  const size_t minBlockSize_;$/;"	m	class:folly::ThreadCachedArena	access:private
folly::ThreadCachedArena::operator =	.\ThreadCachedArena.h	/^  ThreadCachedArena& operator=(ThreadCachedArena&&) = delete;$/;"	p	class:folly::ThreadCachedArena	access:private	signature:(ThreadCachedArena&&)
folly::ThreadCachedArena::operator =	.\ThreadCachedArena.h	/^  ThreadCachedArena& operator=(const ThreadCachedArena&) = delete;$/;"	p	class:folly::ThreadCachedArena	access:private	signature:(const ThreadCachedArena&)
folly::ThreadCachedArena::zombiesMutex_	.\ThreadCachedArena.h	/^  std::mutex zombiesMutex_;$/;"	m	class:folly::ThreadCachedArena	access:private
folly::ThreadCachedArena::zombies_	.\ThreadCachedArena.h	/^  SysArena zombies_;  \/\/ allocated from threads that are now dead$/;"	m	class:folly::ThreadCachedArena	access:private
folly::ThreadCachedArena::zombify	.\ThreadCachedArena.cpp	/^void ThreadCachedArena::zombify(SysArena&& arena) {$/;"	f	class:folly::ThreadCachedArena	signature:(SysArena&& arena)
folly::ThreadCachedArena::zombify	.\ThreadCachedArena.h	/^  void zombify(SysArena&& arena);$/;"	p	class:folly::ThreadCachedArena	access:private	signature:(SysArena&& arena)
folly::ThreadCachedInt	.\ThreadCachedInt.h	/^class ThreadCachedInt : boost::noncopyable {$/;"	c	namespace:folly	inherits:boost::noncopyable
folly::ThreadCachedInt::IntCache	.\ThreadCachedInt.h	/^  struct IntCache {$/;"	s	class:folly::ThreadCachedInt	access:private
folly::ThreadCachedInt::IntCache	.\ThreadCachedInt.h	/^  struct IntCache;$/;"	x
folly::ThreadCachedInt::IntCache::IntCache	.\ThreadCachedInt.h	/^    explicit IntCache(ThreadCachedInt& parent)$/;"	f	struct:folly::ThreadCachedInt::IntCache	access:public	signature:(ThreadCachedInt& parent)
folly::ThreadCachedInt::IntCache::flush	.\ThreadCachedInt.h	/^    void flush() const {$/;"	f	struct:folly::ThreadCachedInt::IntCache	access:public	signature:() const
folly::ThreadCachedInt::IntCache::increment	.\ThreadCachedInt.h	/^    void increment(IntT inc) {$/;"	f	struct:folly::ThreadCachedInt::IntCache	access:public	signature:(IntT inc)
folly::ThreadCachedInt::IntCache::numUpdates_	.\ThreadCachedInt.h	/^    mutable uint32_t numUpdates_;$/;"	m	struct:folly::ThreadCachedInt::IntCache	access:public
folly::ThreadCachedInt::IntCache::parent_	.\ThreadCachedInt.h	/^    ThreadCachedInt* parent_;$/;"	m	struct:folly::ThreadCachedInt::IntCache	access:public
folly::ThreadCachedInt::IntCache::reset_	.\ThreadCachedInt.h	/^    std::atomic<bool> reset_;$/;"	m	struct:folly::ThreadCachedInt::IntCache	access:public
folly::ThreadCachedInt::IntCache::val_	.\ThreadCachedInt.h	/^    mutable std::atomic<IntT> val_;$/;"	m	struct:folly::ThreadCachedInt::IntCache	access:public
folly::ThreadCachedInt::IntCache::~IntCache	.\ThreadCachedInt.h	/^    ~IntCache() {$/;"	f	struct:folly::ThreadCachedInt::IntCache	access:public	signature:()
folly::ThreadCachedInt::ThreadCachedInt	.\ThreadCachedInt.h	/^  explicit ThreadCachedInt(IntT initialVal = 0, uint32_t cacheSize = 1000)$/;"	f	class:folly::ThreadCachedInt	access:public	signature:(IntT initialVal = 0, uint32_t cacheSize = 1000)
folly::ThreadCachedInt::cacheSize_	.\ThreadCachedInt.h	/^  std::atomic<uint32_t> cacheSize_;$/;"	m	class:folly::ThreadCachedInt	access:private
folly::ThreadCachedInt::cache_	.\ThreadCachedInt.h	/^  ThreadLocalPtr<IntCache,Tag> cache_; \/\/ Must be last for dtor ordering$/;"	m	class:folly::ThreadCachedInt	access:private
folly::ThreadCachedInt::getCacheSize	.\ThreadCachedInt.h	/^  uint32_t getCacheSize() const {$/;"	f	class:folly::ThreadCachedInt	access:public	signature:() const
folly::ThreadCachedInt::increment	.\ThreadCachedInt.h	/^  void increment(IntT inc) {$/;"	f	class:folly::ThreadCachedInt	access:public	signature:(IntT inc)
folly::ThreadCachedInt::operator ++	.\ThreadCachedInt.h	/^  ThreadCachedInt& operator++() { increment(1); return *this; }$/;"	f	class:folly::ThreadCachedInt	access:public	signature:()
folly::ThreadCachedInt::operator +=	.\ThreadCachedInt.h	/^  ThreadCachedInt& operator+=(IntT inc) { increment(inc); return *this; }$/;"	f	class:folly::ThreadCachedInt	access:public	signature:(IntT inc)
folly::ThreadCachedInt::operator --	.\ThreadCachedInt.h	/^  ThreadCachedInt& operator--() { increment(-1); return *this; }$/;"	f	class:folly::ThreadCachedInt	access:public	signature:()
folly::ThreadCachedInt::operator -=	.\ThreadCachedInt.h	/^  ThreadCachedInt& operator-=(IntT inc) { increment(-inc); return *this; }$/;"	f	class:folly::ThreadCachedInt	access:public	signature:(IntT inc)
folly::ThreadCachedInt::readFast	.\ThreadCachedInt.h	/^  IntT readFast() const {$/;"	f	class:folly::ThreadCachedInt	access:public	signature:() const
folly::ThreadCachedInt::readFastAndReset	.\ThreadCachedInt.h	/^  IntT readFastAndReset() {$/;"	f	class:folly::ThreadCachedInt	access:public	signature:()
folly::ThreadCachedInt::readFull	.\ThreadCachedInt.h	/^  IntT readFull() const {$/;"	f	class:folly::ThreadCachedInt	access:public	signature:() const
folly::ThreadCachedInt::readFullAndReset	.\ThreadCachedInt.h	/^  IntT readFullAndReset() {$/;"	f	class:folly::ThreadCachedInt	access:public	signature:()
folly::ThreadCachedInt::set	.\ThreadCachedInt.h	/^  void set(IntT newVal) {$/;"	f	class:folly::ThreadCachedInt	access:public	signature:(IntT newVal)
folly::ThreadCachedInt::setCacheSize	.\ThreadCachedInt.h	/^  void setCacheSize(uint32_t newSize) {$/;"	f	class:folly::ThreadCachedInt	access:public	signature:(uint32_t newSize)
folly::ThreadCachedInt::target_	.\ThreadCachedInt.h	/^  std::atomic<IntT> target_;$/;"	m	class:folly::ThreadCachedInt	access:private
folly::ThreadCachedInt::~ThreadCachedInt	.\ThreadCachedInt.h	/^  ~ThreadCachedInt() {$/;"	f	class:folly::ThreadCachedInt	access:public	signature:()
folly::ThreadLocal	.\ThreadLocal.h	/^class ThreadLocal {$/;"	c	namespace:folly
folly::ThreadLocal::Accessor	.\ThreadLocal.h	/^  typedef typename ThreadLocalPtr<T,Tag>::Accessor Accessor;$/;"	t	class:folly::ThreadLocal	access:public
folly::ThreadLocal::ThreadLocal	.\ThreadLocal.h	/^  ThreadLocal() { }$/;"	f	class:folly::ThreadLocal	access:public	signature:()
folly::ThreadLocal::ThreadLocal	.\ThreadLocal.h	/^  ThreadLocal(ThreadLocal&&) = default;$/;"	p	class:folly::ThreadLocal	access:public	signature:(ThreadLocal&&)
folly::ThreadLocal::ThreadLocal	.\ThreadLocal.h	/^  ThreadLocal(const ThreadLocal&) = delete;$/;"	p	class:folly::ThreadLocal	access:private	signature:(const ThreadLocal&)
folly::ThreadLocal::accessAllThreads	.\ThreadLocal.h	/^  Accessor accessAllThreads() const {$/;"	f	class:folly::ThreadLocal	access:public	signature:() const
folly::ThreadLocal::get	.\ThreadLocal.h	/^  T* get() const {$/;"	f	class:folly::ThreadLocal	access:public	signature:() const
folly::ThreadLocal::makeTlp	.\ThreadLocal.h	/^  T* makeTlp() const {$/;"	f	class:folly::ThreadLocal	access:private	signature:() const
folly::ThreadLocal::operator *	.\ThreadLocal.h	/^  T& operator*() const {$/;"	f	class:folly::ThreadLocal	access:public	signature:() const
folly::ThreadLocal::operator ->	.\ThreadLocal.h	/^  T* operator->() const {$/;"	f	class:folly::ThreadLocal	access:public	signature:() const
folly::ThreadLocal::operator =	.\ThreadLocal.h	/^  ThreadLocal& operator=(ThreadLocal&&) = default;$/;"	p	class:folly::ThreadLocal	access:public	signature:(ThreadLocal&&)
folly::ThreadLocal::operator =	.\ThreadLocal.h	/^  ThreadLocal& operator=(const ThreadLocal&) = delete;$/;"	p	class:folly::ThreadLocal	access:private	signature:(const ThreadLocal&)
folly::ThreadLocal::reset	.\ThreadLocal.h	/^  void reset(T* newPtr = nullptr) {$/;"	f	class:folly::ThreadLocal	access:public	signature:(T* newPtr = nullptr)
folly::ThreadLocal::tlp_	.\ThreadLocal.h	/^  mutable ThreadLocalPtr<T,Tag> tlp_;$/;"	m	class:folly::ThreadLocal	access:private
folly::ThreadLocalPRNG	.\Random.h	/^class ThreadLocalPRNG {$/;"	c	namespace:folly
folly::ThreadLocalPRNG::LocalInstancePRNG	.\Random.cpp	/^class ThreadLocalPRNG::LocalInstancePRNG {$/;"	c	class:folly::ThreadLocalPRNG	file:
folly::ThreadLocalPRNG::LocalInstancePRNG	.\Random.h	/^  class LocalInstancePRNG;$/;"	x
folly::ThreadLocalPRNG::LocalInstancePRNG::LocalInstancePRNG	.\Random.cpp	/^  LocalInstancePRNG() : rng(Random::create()) { }$/;"	f	class:folly::ThreadLocalPRNG::LocalInstancePRNG	access:public	signature:()
folly::ThreadLocalPRNG::LocalInstancePRNG::rng	.\Random.cpp	/^  Random::DefaultGenerator rng;$/;"	m	class:folly::ThreadLocalPRNG::LocalInstancePRNG	file:	access:public
folly::ThreadLocalPRNG::Random	.\Random.h	/^  friend class Random;$/;"	x
folly::ThreadLocalPRNG::ThreadLocalPRNG	.\Random.h	/^  ThreadLocalPRNG() {$/;"	f	class:folly::ThreadLocalPRNG	access:public	signature:()
folly::ThreadLocalPRNG::getImpl	.\Random.cpp	/^uint32_t ThreadLocalPRNG::getImpl(LocalInstancePRNG* local) {$/;"	f	class:folly::ThreadLocalPRNG	signature:(LocalInstancePRNG* local)
folly::ThreadLocalPRNG::getImpl	.\Random.h	/^  static result_type getImpl(LocalInstancePRNG* local);$/;"	p	class:folly::ThreadLocalPRNG	access:private	signature:(LocalInstancePRNG* local)
folly::ThreadLocalPRNG::initLocal	.\Random.cpp	/^ThreadLocalPRNG::LocalInstancePRNG* ThreadLocalPRNG::initLocal() {$/;"	f	class:folly::ThreadLocalPRNG	signature:()
folly::ThreadLocalPRNG::initLocal	.\Random.h	/^  static LocalInstancePRNG* initLocal();$/;"	p	class:folly::ThreadLocalPRNG	access:private	signature:()
folly::ThreadLocalPRNG::localInstance	.\Random.cpp	/^ThreadLocalPRNG::localInstance;$/;"	m	class:folly::ThreadLocalPRNG	file:
folly::ThreadLocalPRNG::localInstance	.\Random.h	/^    localInstance;$/;"	m	class:folly::ThreadLocalPRNG	access:private
folly::ThreadLocalPRNG::local_	.\Random.h	/^  LocalInstancePRNG* local_;$/;"	m	class:folly::ThreadLocalPRNG	access:private
folly::ThreadLocalPRNG::max	.\Random.h	/^  static constexpr result_type max() {$/;"	f	class:folly::ThreadLocalPRNG	access:public	signature:()
folly::ThreadLocalPRNG::min	.\Random.h	/^  static constexpr result_type min() {$/;"	f	class:folly::ThreadLocalPRNG	access:public	signature:()
folly::ThreadLocalPRNG::operator ()	.\Random.h	/^  uint32_t operator()() {$/;"	f	class:folly::ThreadLocalPRNG	access:public	signature:()
folly::ThreadLocalPRNG::result_type	.\Random.h	/^  typedef uint32_t result_type;$/;"	t	class:folly::ThreadLocalPRNG	access:public
folly::ThreadLocalPtr	.\ThreadLocal.h	/^class ThreadLocalPtr {$/;"	c	namespace:folly
folly::ThreadLocalPtr	.\ThreadLocal.h	/^template<class T, class Tag> class ThreadLocalPtr;$/;"	x
folly::ThreadLocalPtr::Accessor	.\ThreadLocal.h	/^  class Accessor {$/;"	c	class:folly::ThreadLocalPtr	access:public
folly::ThreadLocalPtr::Accessor::Accessor	.\ThreadLocal.h	/^    Accessor()$/;"	f	class:folly::ThreadLocalPtr::Accessor	access:public	signature:()
folly::ThreadLocalPtr::Accessor::Accessor	.\ThreadLocal.h	/^    Accessor(const Accessor&) = delete;$/;"	p	class:folly::ThreadLocalPtr::Accessor	access:public	signature:(const Accessor&)
folly::ThreadLocalPtr::Accessor::Accessor	.\ThreadLocal.h	/^    explicit Accessor(int id)$/;"	f	class:folly::ThreadLocalPtr::Accessor	access:private	signature:(int id)
folly::ThreadLocalPtr::Accessor::Iterator	.\ThreadLocal.h	/^    class Iterator : public boost::iterator_facade<$/;"	c	class:folly::ThreadLocalPtr::Accessor	inherits:boost::iterator_facade	access:public
folly::ThreadLocalPtr::Accessor::Iterator	.\ThreadLocal.h	/^    class Iterator;$/;"	x
folly::ThreadLocalPtr::Accessor::Iterator	.\ThreadLocal.h	/^    friend class Iterator;$/;"	x
folly::ThreadLocalPtr::Accessor::Iterator::Accessor	.\ThreadLocal.h	/^      friend class Accessor;$/;"	x
folly::ThreadLocalPtr::Accessor::Iterator::Iterator	.\ThreadLocal.h	/^      explicit Iterator(const Accessor* accessor)$/;"	f	class:folly::ThreadLocalPtr::Accessor::Iterator	access:private	signature:(const Accessor* accessor)
folly::ThreadLocalPtr::Accessor::Iterator::accessor_	.\ThreadLocal.h	/^      const Accessor* const accessor_;$/;"	m	class:folly::ThreadLocalPtr::Accessor::Iterator	access:private
folly::ThreadLocalPtr::Accessor::Iterator::decrement	.\ThreadLocal.h	/^      void decrement() {$/;"	f	class:folly::ThreadLocalPtr::Accessor::Iterator	access:private	signature:()
folly::ThreadLocalPtr::Accessor::Iterator::decrementToValid	.\ThreadLocal.h	/^      void decrementToValid() {$/;"	f	class:folly::ThreadLocalPtr::Accessor::Iterator	access:private	signature:()
folly::ThreadLocalPtr::Accessor::Iterator::dereference	.\ThreadLocal.h	/^      T& dereference() const {$/;"	f	class:folly::ThreadLocalPtr::Accessor::Iterator	access:private	signature:() const
folly::ThreadLocalPtr::Accessor::Iterator::e_	.\ThreadLocal.h	/^      threadlocal_detail::ThreadEntry* e_;$/;"	m	class:folly::ThreadLocalPtr::Accessor::Iterator	access:private
folly::ThreadLocalPtr::Accessor::Iterator::equal	.\ThreadLocal.h	/^      bool equal(const Iterator& other) const {$/;"	f	class:folly::ThreadLocalPtr::Accessor::Iterator	access:private	signature:(const Iterator& other) const
folly::ThreadLocalPtr::Accessor::Iterator::increment	.\ThreadLocal.h	/^      void increment() {$/;"	f	class:folly::ThreadLocalPtr::Accessor::Iterator	access:private	signature:()
folly::ThreadLocalPtr::Accessor::Iterator::incrementToValid	.\ThreadLocal.h	/^      void incrementToValid() {$/;"	f	class:folly::ThreadLocalPtr::Accessor::Iterator	access:private	signature:()
folly::ThreadLocalPtr::Accessor::Iterator::valid	.\ThreadLocal.h	/^      bool valid() const {$/;"	f	class:folly::ThreadLocalPtr::Accessor::Iterator	access:private	signature:() const
folly::ThreadLocalPtr::Accessor::ThreadLocalPtr	.\ThreadLocal.h	/^    friend class ThreadLocalPtr<T,Tag>;$/;"	x
folly::ThreadLocalPtr::Accessor::begin	.\ThreadLocal.h	/^    Iterator begin() const {$/;"	f	class:folly::ThreadLocalPtr::Accessor	access:public	signature:() const
folly::ThreadLocalPtr::Accessor::end	.\ThreadLocal.h	/^    Iterator end() const {$/;"	f	class:folly::ThreadLocalPtr::Accessor	access:public	signature:() const
folly::ThreadLocalPtr::Accessor::id_	.\ThreadLocal.h	/^        id_(other.id_) {$/;"	f	class:folly::ThreadLocalPtr::Accessor	access:public	signature:(other.id_)
folly::ThreadLocalPtr::Accessor::id_	.\ThreadLocal.h	/^    int id_;$/;"	m	class:folly::ThreadLocalPtr::Accessor	access:private
folly::ThreadLocalPtr::Accessor::lock_	.\ThreadLocal.h	/^        lock_(other.lock_),$/;"	p	class:folly::ThreadLocalPtr::Accessor	access:public	signature:(other.lock_)
folly::ThreadLocalPtr::Accessor::lock_	.\ThreadLocal.h	/^    std::mutex* lock_;$/;"	m	class:folly::ThreadLocalPtr::Accessor	access:private
folly::ThreadLocalPtr::Accessor::meta_	.\ThreadLocal.h	/^      : meta_(other.meta_),$/;"	p	class:folly::ThreadLocalPtr::Accessor	access:public	signature:(other.meta_)
folly::ThreadLocalPtr::Accessor::meta_	.\ThreadLocal.h	/^    threadlocal_detail::StaticMeta<Tag>& meta_;$/;"	m	class:folly::ThreadLocalPtr::Accessor	access:private
folly::ThreadLocalPtr::Accessor::operator =	.\ThreadLocal.h	/^    Accessor& operator=(const Accessor&) = delete;$/;"	p	class:folly::ThreadLocalPtr::Accessor	access:public	signature:(const Accessor&)
folly::ThreadLocalPtr::Accessor::release	.\ThreadLocal.h	/^    void release() {$/;"	f	class:folly::ThreadLocalPtr::Accessor	access:private	signature:()
folly::ThreadLocalPtr::Accessor::~Accessor	.\ThreadLocal.h	/^    ~Accessor() {$/;"	f	class:folly::ThreadLocalPtr::Accessor	access:public	signature:()
folly::ThreadLocalPtr::ThreadLocalPtr	.\ThreadLocal.h	/^  ThreadLocalPtr() : id_(threadlocal_detail::StaticMeta<Tag>::create()) { }$/;"	f	class:folly::ThreadLocalPtr	access:public	signature:()
folly::ThreadLocalPtr::ThreadLocalPtr	.\ThreadLocal.h	/^  ThreadLocalPtr(ThreadLocalPtr&& other) : id_(other.id_) {$/;"	f	class:folly::ThreadLocalPtr	access:public	signature:(ThreadLocalPtr&& other)
folly::ThreadLocalPtr::ThreadLocalPtr	.\ThreadLocal.h	/^  ThreadLocalPtr(const ThreadLocalPtr&) = delete;$/;"	p	class:folly::ThreadLocalPtr	access:private	signature:(const ThreadLocalPtr&)
folly::ThreadLocalPtr::accessAllThreads	.\ThreadLocal.h	/^  Accessor accessAllThreads() const {$/;"	f	class:folly::ThreadLocalPtr	access:public	signature:() const
folly::ThreadLocalPtr::destroy	.\ThreadLocal.h	/^  void destroy() {$/;"	f	class:folly::ThreadLocalPtr	access:private	signature:()
folly::ThreadLocalPtr::get	.\ThreadLocal.h	/^  T* get() const {$/;"	f	class:folly::ThreadLocalPtr	access:public	signature:() const
folly::ThreadLocalPtr::id_	.\ThreadLocal.h	/^  int id_;  \/\/ every instantiation has a unique id$/;"	m	class:folly::ThreadLocalPtr	access:private
folly::ThreadLocalPtr::operator *	.\ThreadLocal.h	/^  T& operator*() const {$/;"	f	class:folly::ThreadLocalPtr	access:public	signature:() const
folly::ThreadLocalPtr::operator ->	.\ThreadLocal.h	/^  T* operator->() const {$/;"	f	class:folly::ThreadLocalPtr	access:public	signature:() const
folly::ThreadLocalPtr::operator =	.\ThreadLocal.h	/^  ThreadLocalPtr& operator=(ThreadLocalPtr&& other) {$/;"	f	class:folly::ThreadLocalPtr	access:public	signature:(ThreadLocalPtr&& other)
folly::ThreadLocalPtr::operator =	.\ThreadLocal.h	/^  ThreadLocalPtr& operator=(const ThreadLocalPtr&) = delete;$/;"	p	class:folly::ThreadLocalPtr	access:private	signature:(const ThreadLocalPtr&)
folly::ThreadLocalPtr::operator bool	.\ThreadLocal.h	/^  explicit operator bool() const {$/;"	f	class:folly::ThreadLocalPtr	access:public	signature:() const
folly::ThreadLocalPtr::release	.\ThreadLocal.h	/^  T* release() {$/;"	f	class:folly::ThreadLocalPtr	access:public	signature:()
folly::ThreadLocalPtr::reset	.\ThreadLocal.h	/^  void reset(T* newPtr = nullptr) {$/;"	f	class:folly::ThreadLocalPtr	access:public	signature:(T* newPtr = nullptr)
folly::ThreadLocalPtr::reset	.\ThreadLocal.h	/^  void reset(T* newPtr, Deleter deleter) {$/;"	f	class:folly::ThreadLocalPtr	access:public	signature:(T* newPtr, Deleter deleter)
folly::ThreadLocalPtr::~ThreadLocalPtr	.\ThreadLocal.h	/^  ~ThreadLocalPtr() {$/;"	f	class:folly::ThreadLocalPtr	access:public	signature:()
folly::TimeoutManager	.\io\async\AsyncTimeout.h	/^class TimeoutManager;$/;"	x
folly::TimeoutManager	.\io\async\TimeoutManager.h	/^class TimeoutManager {$/;"	c	namespace:folly
folly::TimeoutManager::InternalEnum	.\io\async\TimeoutManager.h	/^  enum class InternalEnum {$/;"	c	class:folly::TimeoutManager	access:public
folly::TimeoutManager::InternalEnum::INTERNAL	.\io\async\TimeoutManager.h	/^    INTERNAL,$/;"	m	class:folly::TimeoutManager::InternalEnum	access:private
folly::TimeoutManager::attachTimeoutManager	.\io\async\TimeoutManager.h	/^  virtual void attachTimeoutManager(AsyncTimeout* obj,$/;"	p	class:folly::TimeoutManager	access:public	signature:(AsyncTimeout* obj, InternalEnum internal)
folly::TimeoutManager::bumpHandlingTime	.\io\async\TimeoutManager.h	/^  virtual bool bumpHandlingTime() = 0;$/;"	p	class:folly::TimeoutManager	access:public	signature:()
folly::TimeoutManager::cancelTimeout	.\io\async\TimeoutManager.h	/^  virtual void cancelTimeout(AsyncTimeout* obj) = 0;$/;"	p	class:folly::TimeoutManager	access:public	signature:(AsyncTimeout* obj)
folly::TimeoutManager::detachTimeoutManager	.\io\async\TimeoutManager.h	/^  virtual void detachTimeoutManager(AsyncTimeout* obj) = 0;$/;"	p	class:folly::TimeoutManager	access:public	signature:(AsyncTimeout* obj)
folly::TimeoutManager::isInTimeoutManagerThread	.\io\async\TimeoutManager.h	/^  virtual bool isInTimeoutManagerThread() = 0;$/;"	p	class:folly::TimeoutManager	access:public	signature:()
folly::TimeoutManager::scheduleTimeout	.\io\async\TimeoutManager.h	/^  virtual bool scheduleTimeout(AsyncTimeout* obj,$/;"	p	class:folly::TimeoutManager	access:public	signature:(AsyncTimeout* obj, std::chrono::milliseconds timeout)
folly::TimeoutManager::~TimeoutManager	.\io\async\TimeoutManager.h	/^  virtual ~TimeoutManager() {}$/;"	f	class:folly::TimeoutManager	access:public	signature:()
folly::TimeoutQueue	.\TimeoutQueue.h	/^class TimeoutQueue {$/;"	c	namespace:folly
folly::TimeoutQueue::BY_EXPIRATION	.\TimeoutQueue.h	/^    BY_EXPIRATION=1$/;"	e	enum:folly::TimeoutQueue::__anon150
folly::TimeoutQueue::BY_ID	.\TimeoutQueue.h	/^    BY_ID=0,$/;"	e	enum:folly::TimeoutQueue::__anon150
folly::TimeoutQueue::Callback	.\TimeoutQueue.h	/^  typedef std::function<void(Id, int64_t)> Callback;$/;"	t	class:folly::TimeoutQueue	access:public
folly::TimeoutQueue::Event	.\TimeoutQueue.h	/^  struct Event {$/;"	s	class:folly::TimeoutQueue	access:private
folly::TimeoutQueue::Event::callback	.\TimeoutQueue.h	/^    Callback callback;$/;"	m	struct:folly::TimeoutQueue::Event	access:public
folly::TimeoutQueue::Event::expiration	.\TimeoutQueue.h	/^    int64_t expiration;$/;"	m	struct:folly::TimeoutQueue::Event	access:public
folly::TimeoutQueue::Event::id	.\TimeoutQueue.h	/^    Id id;$/;"	m	struct:folly::TimeoutQueue::Event	access:public
folly::TimeoutQueue::Event::repeatInterval	.\TimeoutQueue.h	/^    int64_t repeatInterval;$/;"	m	struct:folly::TimeoutQueue::Event	access:public
folly::TimeoutQueue::Id	.\TimeoutQueue.h	/^  typedef int64_t Id;$/;"	t	class:folly::TimeoutQueue	access:public
folly::TimeoutQueue::Set	.\TimeoutQueue.h	/^  > Set;$/;"	t	class:folly::TimeoutQueue	access:private
folly::TimeoutQueue::TimeoutQueue	.\TimeoutQueue.h	/^  TimeoutQueue() : nextId_(1) { }$/;"	f	class:folly::TimeoutQueue	access:public	signature:()
folly::TimeoutQueue::TimeoutQueue	.\TimeoutQueue.h	/^  TimeoutQueue(const TimeoutQueue&) = delete;$/;"	p	class:folly::TimeoutQueue	access:private	signature:(const TimeoutQueue&)
folly::TimeoutQueue::add	.\TimeoutQueue.cpp	/^TimeoutQueue::Id TimeoutQueue::add($/;"	f	class:folly::TimeoutQueue	signature:( int64_t now, int64_t delay, Callback callback)
folly::TimeoutQueue::add	.\TimeoutQueue.h	/^  Id add(int64_t now, int64_t delay, Callback callback);$/;"	p	class:folly::TimeoutQueue	access:public	signature:(int64_t now, int64_t delay, Callback callback)
folly::TimeoutQueue::addRepeating	.\TimeoutQueue.cpp	/^TimeoutQueue::Id TimeoutQueue::addRepeating($/;"	f	class:folly::TimeoutQueue	signature:( int64_t now, int64_t interval, Callback callback)
folly::TimeoutQueue::addRepeating	.\TimeoutQueue.h	/^  Id addRepeating(int64_t now, int64_t interval, Callback callback);$/;"	p	class:folly::TimeoutQueue	access:public	signature:(int64_t now, int64_t interval, Callback callback)
folly::TimeoutQueue::erase	.\TimeoutQueue.cpp	/^bool TimeoutQueue::erase(Id id) {$/;"	f	class:folly::TimeoutQueue	signature:(Id id)
folly::TimeoutQueue::erase	.\TimeoutQueue.h	/^  bool erase(Id id);$/;"	p	class:folly::TimeoutQueue	access:public	signature:(Id id)
folly::TimeoutQueue::nextExpiration	.\TimeoutQueue.cpp	/^int64_t TimeoutQueue::nextExpiration() const {$/;"	f	class:folly::TimeoutQueue	signature:() const
folly::TimeoutQueue::nextExpiration	.\TimeoutQueue.h	/^  int64_t nextExpiration() const;$/;"	p	class:folly::TimeoutQueue	access:public	signature:() const
folly::TimeoutQueue::nextId_	.\TimeoutQueue.h	/^  Id nextId_;$/;"	m	class:folly::TimeoutQueue	access:private
folly::TimeoutQueue::operator =	.\TimeoutQueue.h	/^  TimeoutQueue& operator=(const TimeoutQueue&) = delete;$/;"	p	class:folly::TimeoutQueue	access:private	signature:(const TimeoutQueue&)
folly::TimeoutQueue::runInternal	.\TimeoutQueue.cpp	/^int64_t TimeoutQueue::runInternal(int64_t now, bool onceOnly) {$/;"	f	class:folly::TimeoutQueue	signature:(int64_t now, bool onceOnly)
folly::TimeoutQueue::runInternal	.\TimeoutQueue.h	/^  int64_t runInternal(int64_t now, bool runOnce);$/;"	p	class:folly::TimeoutQueue	access:private	signature:(int64_t now, bool runOnce)
folly::TimeoutQueue::runLoop	.\TimeoutQueue.h	/^  int64_t runLoop(int64_t now) { return runInternal(now, false); }$/;"	f	class:folly::TimeoutQueue	access:public	signature:(int64_t now)
folly::TimeoutQueue::runOnce	.\TimeoutQueue.h	/^  int64_t runOnce(int64_t now) { return runInternal(now, true); }$/;"	f	class:folly::TimeoutQueue	access:public	signature:(int64_t now)
folly::TimeoutQueue::timeouts_	.\TimeoutQueue.h	/^  Set timeouts_;$/;"	m	class:folly::TimeoutQueue	access:private
folly::TimeseriesHistogram	.\stats\Instantiations.cpp	/^template class TimeseriesHistogram<int64_t>;$/;"	x	file:
folly::TimeseriesHistogram	.\stats\TimeseriesHistogram.h	/^class TimeseriesHistogram {$/;"	c	namespace:folly
folly::TimeseriesHistogram::AvgFromInterval	.\stats\TimeseriesHistogram.h	/^  struct AvgFromInterval {$/;"	s	class:folly::TimeseriesHistogram	access:private
folly::TimeseriesHistogram::AvgFromInterval::AvgFromInterval	.\stats\TimeseriesHistogram.h	/^    explicit AvgFromInterval(TimeType start, TimeType end)$/;"	f	struct:folly::TimeseriesHistogram::AvgFromInterval	access:public	signature:(TimeType start, TimeType end)
folly::TimeseriesHistogram::AvgFromInterval::end_	.\stats\TimeseriesHistogram.h	/^    TimeType end_;$/;"	m	struct:folly::TimeseriesHistogram::AvgFromInterval	access:private
folly::TimeseriesHistogram::AvgFromInterval::operator ()	.\stats\TimeseriesHistogram.h	/^    ReturnType operator()(const ContainerType& bucket) const {$/;"	f	struct:folly::TimeseriesHistogram::AvgFromInterval	access:public	signature:(const ContainerType& bucket) const
folly::TimeseriesHistogram::AvgFromInterval::start_	.\stats\TimeseriesHistogram.h	/^    TimeType start_;$/;"	m	struct:folly::TimeseriesHistogram::AvgFromInterval	access:private
folly::TimeseriesHistogram::AvgFromLevel	.\stats\TimeseriesHistogram.h	/^  struct AvgFromLevel {$/;"	s	class:folly::TimeseriesHistogram	access:private
folly::TimeseriesHistogram::AvgFromLevel::AvgFromLevel	.\stats\TimeseriesHistogram.h	/^    explicit AvgFromLevel(int level) : level_(level) {}$/;"	f	struct:folly::TimeseriesHistogram::AvgFromLevel	access:public	signature:(int level)
folly::TimeseriesHistogram::AvgFromLevel::level_	.\stats\TimeseriesHistogram.h	/^    int level_;$/;"	m	struct:folly::TimeseriesHistogram::AvgFromLevel	access:private
folly::TimeseriesHistogram::AvgFromLevel::operator ()	.\stats\TimeseriesHistogram.h	/^    ValueType operator()(const ContainerType& bucket) const {$/;"	f	struct:folly::TimeseriesHistogram::AvgFromLevel	access:public	signature:(const ContainerType& bucket) const
folly::TimeseriesHistogram::BOOST_STATIC_ASSERT	.\stats\TimeseriesHistogram.h	/^   BOOST_STATIC_ASSERT(std::numeric_limits<T>::is_signed);$/;"	p	class:folly::TimeseriesHistogram	access:private	signature:(std::numeric_limits<T>::is_signed)
folly::TimeseriesHistogram::Bucket	.\stats\TimeseriesHistogram.h	/^  typedef ContainerType Bucket;$/;"	t	class:folly::TimeseriesHistogram	access:private
folly::TimeseriesHistogram::ContainerType	.\stats\TimeseriesHistogram.h	/^  typedef C ContainerType;$/;"	t	class:folly::TimeseriesHistogram	access:public
folly::TimeseriesHistogram::CountFromInterval	.\stats\TimeseriesHistogram.h	/^  struct CountFromInterval {$/;"	s	class:folly::TimeseriesHistogram	access:private
folly::TimeseriesHistogram::CountFromInterval::CountFromInterval	.\stats\TimeseriesHistogram.h	/^    explicit CountFromInterval(TimeType start, TimeType end)$/;"	f	struct:folly::TimeseriesHistogram::CountFromInterval	access:public	signature:(TimeType start, TimeType end)
folly::TimeseriesHistogram::CountFromInterval::end_	.\stats\TimeseriesHistogram.h	/^    TimeType end_;$/;"	m	struct:folly::TimeseriesHistogram::CountFromInterval	access:private
folly::TimeseriesHistogram::CountFromInterval::operator ()	.\stats\TimeseriesHistogram.h	/^    uint64_t operator()(const ContainerType& bucket) const {$/;"	f	struct:folly::TimeseriesHistogram::CountFromInterval	access:public	signature:(const ContainerType& bucket) const
folly::TimeseriesHistogram::CountFromInterval::start_	.\stats\TimeseriesHistogram.h	/^    TimeType start_;$/;"	m	struct:folly::TimeseriesHistogram::CountFromInterval	access:private
folly::TimeseriesHistogram::CountFromLevel	.\stats\TimeseriesHistogram.h	/^  struct CountFromLevel {$/;"	s	class:folly::TimeseriesHistogram	access:private
folly::TimeseriesHistogram::CountFromLevel::CountFromLevel	.\stats\TimeseriesHistogram.h	/^    explicit CountFromLevel(int level) : level_(level) {}$/;"	f	struct:folly::TimeseriesHistogram::CountFromLevel	access:public	signature:(int level)
folly::TimeseriesHistogram::CountFromLevel::level_	.\stats\TimeseriesHistogram.h	/^    int level_;$/;"	m	struct:folly::TimeseriesHistogram::CountFromLevel	access:private
folly::TimeseriesHistogram::CountFromLevel::operator ()	.\stats\TimeseriesHistogram.h	/^    uint64_t operator()(const ContainerType& bucket) const {$/;"	f	struct:folly::TimeseriesHistogram::CountFromLevel	access:public	signature:(const ContainerType& bucket) const
folly::TimeseriesHistogram::TimeType	.\stats\TimeseriesHistogram.h	/^  typedef TT TimeType;$/;"	t	class:folly::TimeseriesHistogram	access:public
folly::TimeseriesHistogram::TimeseriesHistogram	.\stats\TimeseriesHistogram-defs.h	/^TimeseriesHistogram<T, TT, C>::TimeseriesHistogram(ValueType bucketSize,$/;"	f	class:folly::TimeseriesHistogram	signature:(ValueType bucketSize, ValueType min, ValueType max, const ContainerType& copyMe)
folly::TimeseriesHistogram::TimeseriesHistogram	.\stats\TimeseriesHistogram.h	/^  TimeseriesHistogram(ValueType bucketSize, ValueType min, ValueType max,$/;"	p	class:folly::TimeseriesHistogram	access:public	signature:(ValueType bucketSize, ValueType min, ValueType max, const ContainerType& defaultContainer)
folly::TimeseriesHistogram::ValueType	.\stats\TimeseriesHistogram.h	/^  typedef T ValueType;$/;"	t	class:folly::TimeseriesHistogram	access:public
folly::TimeseriesHistogram::addValue	.\stats\TimeseriesHistogram-defs.h	/^void TimeseriesHistogram<T, TT, C>::addValue(TimeType now,$/;"	f	class:folly::TimeseriesHistogram	signature:(TimeType now, const ValueType& value)
folly::TimeseriesHistogram::addValue	.\stats\TimeseriesHistogram-defs.h	/^void TimeseriesHistogram<T, TT, C>::addValue(TimeType now,$/;"	f	class:folly::TimeseriesHistogram	signature:(TimeType now, const ValueType& value, int64_t times)
folly::TimeseriesHistogram::addValue	.\stats\TimeseriesHistogram.h	/^  void addValue(TimeType now, const ValueType& value);$/;"	p	class:folly::TimeseriesHistogram	access:public	signature:(TimeType now, const ValueType& value)
folly::TimeseriesHistogram::addValue	.\stats\TimeseriesHistogram.h	/^  void addValue(TimeType now, const ValueType& value, int64_t times);$/;"	p	class:folly::TimeseriesHistogram	access:public	signature:(TimeType now, const ValueType& value, int64_t times)
folly::TimeseriesHistogram::addValues	.\stats\TimeseriesHistogram-defs.h	/^void TimeseriesHistogram<T, TT, C>::addValues($/;"	f	class:folly::TimeseriesHistogram	signature:( TimeType now, const folly::Histogram<ValueType>& hist)
folly::TimeseriesHistogram::addValues	.\stats\TimeseriesHistogram.h	/^  void addValues(TimeType now, const folly::Histogram<ValueType>& values);$/;"	p	class:folly::TimeseriesHistogram	access:public	signature:(TimeType now, const folly::Histogram<ValueType>& values)
folly::TimeseriesHistogram::avg	.\stats\TimeseriesHistogram-defs.h	/^ReturnType TimeseriesHistogram<T, TT, C>::avg(TimeType start,$/;"	f	class:folly::TimeseriesHistogram	signature:(TimeType start, TimeType end) const
folly::TimeseriesHistogram::avg	.\stats\TimeseriesHistogram-defs.h	/^ReturnType TimeseriesHistogram<T, TT, C>::avg(int level) const {$/;"	f	class:folly::TimeseriesHistogram	signature:(int level) const
folly::TimeseriesHistogram::avg	.\stats\TimeseriesHistogram.h	/^  ReturnType avg(TimeType start, TimeType end) const;$/;"	p	class:folly::TimeseriesHistogram	access:public	signature:(TimeType start, TimeType end) const
folly::TimeseriesHistogram::avg	.\stats\TimeseriesHistogram.h	/^  ReturnType avg(int level) const;$/;"	p	class:folly::TimeseriesHistogram	access:public	signature:(int level) const
folly::TimeseriesHistogram::buckets_	.\stats\TimeseriesHistogram.h	/^  folly::detail::HistogramBuckets<ValueType, ContainerType> buckets_;$/;"	m	class:folly::TimeseriesHistogram	access:private
folly::TimeseriesHistogram::clear	.\stats\TimeseriesHistogram-defs.h	/^void TimeseriesHistogram<T, TT, C>::clear() {$/;"	f	class:folly::TimeseriesHistogram	signature:()
folly::TimeseriesHistogram::clear	.\stats\TimeseriesHistogram.h	/^  void clear();$/;"	p	class:folly::TimeseriesHistogram	access:public	signature:()
folly::TimeseriesHistogram::count	.\stats\TimeseriesHistogram.h	/^  int64_t count(TimeType start, TimeType end) const {$/;"	f	class:folly::TimeseriesHistogram	access:public	signature:(TimeType start, TimeType end) const
folly::TimeseriesHistogram::count	.\stats\TimeseriesHistogram.h	/^  int64_t count(int level) const {$/;"	f	class:folly::TimeseriesHistogram	access:public	signature:(int level) const
folly::TimeseriesHistogram::firstValue_	.\stats\TimeseriesHistogram.h	/^  ValueType firstValue_;$/;"	m	class:folly::TimeseriesHistogram	access:private
folly::TimeseriesHistogram::getBucket	.\stats\TimeseriesHistogram.h	/^  const ContainerType& getBucket(int bucketIdx) const {$/;"	f	class:folly::TimeseriesHistogram	access:public	signature:(int bucketIdx) const
folly::TimeseriesHistogram::getBucketIdx	.\stats\TimeseriesHistogram.h	/^  int getBucketIdx(const ValueType& value) const;$/;"	p	class:folly::TimeseriesHistogram	access:public	signature:(const ValueType& value) const
folly::TimeseriesHistogram::getBucketMin	.\stats\TimeseriesHistogram.h	/^  ValueType getBucketMin(int bucketIdx) const {$/;"	f	class:folly::TimeseriesHistogram	access:public	signature:(int bucketIdx) const
folly::TimeseriesHistogram::getBucketSize	.\stats\TimeseriesHistogram.h	/^  ValueType getBucketSize() const { return buckets_.getBucketSize(); }$/;"	f	class:folly::TimeseriesHistogram	access:public	signature:() const
folly::TimeseriesHistogram::getMax	.\stats\TimeseriesHistogram.h	/^  ValueType getMax() const { return buckets_.getMax(); }$/;"	f	class:folly::TimeseriesHistogram	access:public	signature:() const
folly::TimeseriesHistogram::getMin	.\stats\TimeseriesHistogram.h	/^  ValueType getMin() const { return buckets_.getMin(); }$/;"	f	class:folly::TimeseriesHistogram	access:public	signature:() const
folly::TimeseriesHistogram::getNumBuckets	.\stats\TimeseriesHistogram.h	/^  int getNumBuckets() const { return buckets_.getNumBuckets(); }$/;"	f	class:folly::TimeseriesHistogram	access:public	signature:() const
folly::TimeseriesHistogram::getNumLevels	.\stats\TimeseriesHistogram.h	/^  int getNumLevels() const {$/;"	f	class:folly::TimeseriesHistogram	access:public	signature:() const
folly::TimeseriesHistogram::getPercentileBucketIdx	.\stats\TimeseriesHistogram-defs.h	/^int TimeseriesHistogram<T, TT, C>::getPercentileBucketIdx($/;"	f	class:folly::TimeseriesHistogram	signature:( double pct, int level ) const
folly::TimeseriesHistogram::getPercentileBucketIdx	.\stats\TimeseriesHistogram-defs.h	/^int TimeseriesHistogram<T, TT, C>::getPercentileBucketIdx(double pct,$/;"	f	class:folly::TimeseriesHistogram	signature:(double pct, TimeType start, TimeType end) const
folly::TimeseriesHistogram::getPercentileBucketIdx	.\stats\TimeseriesHistogram.h	/^  int getPercentileBucketIdx(double pct, TimeType start, TimeType end) const;$/;"	p	class:folly::TimeseriesHistogram	access:public	signature:(double pct, TimeType start, TimeType end) const
folly::TimeseriesHistogram::getPercentileBucketIdx	.\stats\TimeseriesHistogram.h	/^  int getPercentileBucketIdx(double pct, int level) const;$/;"	p	class:folly::TimeseriesHistogram	access:public	signature:(double pct, int level) const
folly::TimeseriesHistogram::getPercentileBucketMin	.\stats\TimeseriesHistogram.h	/^  int getPercentileBucketMin(double pct, TimeType start, TimeType end) const {$/;"	f	class:folly::TimeseriesHistogram	access:public	signature:(double pct, TimeType start, TimeType end) const
folly::TimeseriesHistogram::getPercentileBucketMin	.\stats\TimeseriesHistogram.h	/^  int getPercentileBucketMin(double pct, int level) const {$/;"	f	class:folly::TimeseriesHistogram	access:public	signature:(double pct, int level) const
folly::TimeseriesHistogram::getPercentileEstimate	.\stats\TimeseriesHistogram-defs.h	/^T TimeseriesHistogram<T, TT, C>::getPercentileEstimate(double pct,$/;"	f	class:folly::TimeseriesHistogram	signature:(double pct, TimeType start, TimeType end) const
folly::TimeseriesHistogram::getPercentileEstimate	.\stats\TimeseriesHistogram-defs.h	/^T TimeseriesHistogram<T, TT, C>::getPercentileEstimate(double pct,$/;"	f	class:folly::TimeseriesHistogram	signature:(double pct, int level) const
folly::TimeseriesHistogram::getPercentileEstimate	.\stats\TimeseriesHistogram.h	/^  ValueType getPercentileEstimate(double pct, TimeType start, TimeType end)$/;"	p	class:folly::TimeseriesHistogram	access:public	signature:(double pct, TimeType start, TimeType end) const
folly::TimeseriesHistogram::getPercentileEstimate	.\stats\TimeseriesHistogram.h	/^  ValueType getPercentileEstimate(double pct, int level) const;$/;"	p	class:folly::TimeseriesHistogram	access:public	signature:(double pct, int level) const
folly::TimeseriesHistogram::getString	.\stats\TimeseriesHistogram-defs.h	/^std::string TimeseriesHistogram<T, TT, C>::getString(TimeType start,$/;"	f	class:folly::TimeseriesHistogram	signature:(TimeType start, TimeType end) const
folly::TimeseriesHistogram::getString	.\stats\TimeseriesHistogram-defs.h	/^std::string TimeseriesHistogram<T, TT, C>::getString(int level) const {$/;"	f	class:folly::TimeseriesHistogram	signature:(int level) const
folly::TimeseriesHistogram::getString	.\stats\TimeseriesHistogram.h	/^  std::string getString(TimeType start, TimeType end) const;$/;"	p	class:folly::TimeseriesHistogram	access:public	signature:(TimeType start, TimeType end) const
folly::TimeseriesHistogram::getString	.\stats\TimeseriesHistogram.h	/^  std::string getString(int level) const;$/;"	p	class:folly::TimeseriesHistogram	access:public	signature:(int level) const
folly::TimeseriesHistogram::haveNotSeenValue_	.\stats\TimeseriesHistogram.h	/^  bool haveNotSeenValue_;$/;"	m	class:folly::TimeseriesHistogram	access:private
folly::TimeseriesHistogram::maybeHandleSingleUniqueValue	.\stats\TimeseriesHistogram-defs.h	/^void TimeseriesHistogram<T, TT, C>::maybeHandleSingleUniqueValue($/;"	f	class:folly::TimeseriesHistogram	signature:( const ValueType& value)
folly::TimeseriesHistogram::maybeHandleSingleUniqueValue	.\stats\TimeseriesHistogram.h	/^  void maybeHandleSingleUniqueValue(const ValueType& value);$/;"	p	class:folly::TimeseriesHistogram	access:private	signature:(const ValueType& value)
folly::TimeseriesHistogram::rate	.\stats\TimeseriesHistogram-defs.h	/^ReturnType TimeseriesHistogram<T, TT, C>::rate(TimeType start,$/;"	f	class:folly::TimeseriesHistogram	signature:(TimeType start, TimeType end) const
folly::TimeseriesHistogram::rate	.\stats\TimeseriesHistogram-defs.h	/^T TimeseriesHistogram<T, TT, C>::rate(int level) const {$/;"	f	class:folly::TimeseriesHistogram	signature:(int level) const
folly::TimeseriesHistogram::rate	.\stats\TimeseriesHistogram.h	/^  ReturnType rate(TimeType start, TimeType end) const;$/;"	p	class:folly::TimeseriesHistogram	access:public	signature:(TimeType start, TimeType end) const
folly::TimeseriesHistogram::rate	.\stats\TimeseriesHistogram.h	/^  ValueType rate(int level) const;$/;"	p	class:folly::TimeseriesHistogram	access:public	signature:(int level) const
folly::TimeseriesHistogram::singleUniqueValue_	.\stats\TimeseriesHistogram.h	/^  bool singleUniqueValue_;$/;"	m	class:folly::TimeseriesHistogram	access:private
folly::TimeseriesHistogram::sum	.\stats\TimeseriesHistogram.h	/^  ValueType sum(TimeType start, TimeType end) const {$/;"	f	class:folly::TimeseriesHistogram	access:public	signature:(TimeType start, TimeType end) const
folly::TimeseriesHistogram::sum	.\stats\TimeseriesHistogram.h	/^  ValueType sum(int level) const {$/;"	f	class:folly::TimeseriesHistogram	access:public	signature:(int level) const
folly::TimeseriesHistogram::update	.\stats\TimeseriesHistogram-defs.h	/^void TimeseriesHistogram<T, TT, C>::update(TimeType now) {$/;"	f	class:folly::TimeseriesHistogram	signature:(TimeType now)
folly::TimeseriesHistogram::update	.\stats\TimeseriesHistogram.h	/^  void update(TimeType now);$/;"	p	class:folly::TimeseriesHistogram	access:public	signature:(TimeType now)
folly::TryFormatValue	.\Format-inl.h	/^class TryFormatValue {$/;"	c	namespace:folly
folly::TryFormatValue	.\Format-inl.h	/^class TryFormatValue<$/;"	x
folly::TryFormatValue::formatOrFail	.\Format-inl.h	/^  static void formatOrFail(T& value, FormatArg& arg, FormatCallback& cb) {$/;"	f	class:folly::TryFormatValue	access:public	signature:(T& value, FormatArg& arg, FormatCallback& cb)
folly::TupleHasher	.\Hash.h	/^struct TupleHasher {$/;"	s	namespace:folly
folly::TupleHasher	.\Hash.h	/^struct TupleHasher<0, Ts...> {$/;"	s	namespace:folly
folly::TupleHasher::operator ()	.\Hash.h	/^  size_t operator()(std::tuple<Ts...> const& key) const {$/;"	f	struct:folly::TupleHasher	access:public	signature:(std::tuple<Ts...> const& key) const
folly::TypeError	.\dynamic-inl.h	/^struct TypeError : std::runtime_error {$/;"	s	namespace:folly	inherits:std::runtime_error
folly::TypeError	.\dynamic.h	/^struct TypeError;$/;"	x
folly::TypeError::TypeError	.\dynamic-inl.h	/^  explicit TypeError(const std::string& expected, dynamic::Type actual)$/;"	f	struct:folly::TypeError	access:public	signature:(const std::string& expected, dynamic::Type actual)
folly::TypeError::TypeError	.\dynamic-inl.h	/^  explicit TypeError(const std::string& expected,$/;"	f	struct:folly::TypeError	access:public	signature:(const std::string& expected, dynamic::Type actual1, dynamic::Type actual2)
folly::TypedIOBuf	.\io\TypedIOBuf.h	/^class TypedIOBuf {$/;"	c	namespace:folly
folly::TypedIOBuf::TypedIOBuf	.\io\TypedIOBuf.h	/^  TypedIOBuf(TypedIOBuf&&) = default;$/;"	p	class:folly::TypedIOBuf	access:public	signature:(TypedIOBuf&&)
folly::TypedIOBuf::TypedIOBuf	.\io\TypedIOBuf.h	/^  TypedIOBuf(const TypedIOBuf&) = delete;$/;"	p	class:folly::TypedIOBuf	access:private	signature:(const TypedIOBuf&)
folly::TypedIOBuf::TypedIOBuf	.\io\TypedIOBuf.h	/^  explicit TypedIOBuf(IOBuf* buf) : buf_(buf) { }$/;"	f	class:folly::TypedIOBuf	access:public	signature:(IOBuf* buf)
folly::TypedIOBuf::advance	.\io\TypedIOBuf.h	/^  void advance(uint32_t n) {$/;"	f	class:folly::TypedIOBuf	access:public	signature:(uint32_t n)
folly::TypedIOBuf::append	.\io\TypedIOBuf.h	/^  void append(uint32_t n) {$/;"	f	class:folly::TypedIOBuf	access:public	signature:(uint32_t n)
folly::TypedIOBuf::back	.\io\TypedIOBuf.h	/^  T& back() {$/;"	f	class:folly::TypedIOBuf	access:public	signature:()
folly::TypedIOBuf::back	.\io\TypedIOBuf.h	/^  const T& back() const {$/;"	f	class:folly::TypedIOBuf	access:public	signature:() const
folly::TypedIOBuf::begin	.\io\TypedIOBuf.h	/^  T* begin() { return writableData(); }$/;"	f	class:folly::TypedIOBuf	access:public	signature:()
folly::TypedIOBuf::begin	.\io\TypedIOBuf.h	/^  const T* begin() const { return cbegin(); }$/;"	f	class:folly::TypedIOBuf	access:public	signature:() const
folly::TypedIOBuf::buf_	.\io\TypedIOBuf.h	/^  IOBuf* buf_;$/;"	m	class:folly::TypedIOBuf	access:private
folly::TypedIOBuf::buffer	.\io\TypedIOBuf.h	/^  const T* buffer() const {$/;"	f	class:folly::TypedIOBuf	access:public	signature:() const
folly::TypedIOBuf::bufferEnd	.\io\TypedIOBuf.h	/^  const T* bufferEnd() const {$/;"	f	class:folly::TypedIOBuf	access:public	signature:() const
folly::TypedIOBuf::capacity	.\io\TypedIOBuf.h	/^  uint32_t capacity() const {$/;"	f	class:folly::TypedIOBuf	access:public	signature:() const
folly::TypedIOBuf::cast	.\io\TypedIOBuf.h	/^  static T* cast(uint8_t* p) {$/;"	f	class:folly::TypedIOBuf	access:private	signature:(uint8_t* p)
folly::TypedIOBuf::cast	.\io\TypedIOBuf.h	/^  static const T* cast(const uint8_t* p) {$/;"	f	class:folly::TypedIOBuf	access:private	signature:(const uint8_t* p)
folly::TypedIOBuf::cbegin	.\io\TypedIOBuf.h	/^  const T* cbegin() const { return data(); }$/;"	f	class:folly::TypedIOBuf	access:public	signature:() const
folly::TypedIOBuf::cend	.\io\TypedIOBuf.h	/^  const T* cend() const { return tail(); }$/;"	f	class:folly::TypedIOBuf	access:public	signature:() const
folly::TypedIOBuf::clear	.\io\TypedIOBuf.h	/^  void clear() {$/;"	f	class:folly::TypedIOBuf	access:public	signature:()
folly::TypedIOBuf::const_iterator	.\io\TypedIOBuf.h	/^  typedef const value_type* const_iterator;$/;"	t	class:folly::TypedIOBuf	access:public
folly::TypedIOBuf::const_reference	.\io\TypedIOBuf.h	/^  typedef const value_type& const_reference;$/;"	t	class:folly::TypedIOBuf	access:public
folly::TypedIOBuf::data	.\io\TypedIOBuf.h	/^  const T* data() const {$/;"	f	class:folly::TypedIOBuf	access:public	signature:() const
folly::TypedIOBuf::empty	.\io\TypedIOBuf.h	/^  bool empty() const {$/;"	f	class:folly::TypedIOBuf	access:public	signature:() const
folly::TypedIOBuf::end	.\io\TypedIOBuf.h	/^  T* end() { return writableTail(); }$/;"	f	class:folly::TypedIOBuf	access:public	signature:()
folly::TypedIOBuf::end	.\io\TypedIOBuf.h	/^  const T* end() const { return cend(); }$/;"	f	class:folly::TypedIOBuf	access:public	signature:() const
folly::TypedIOBuf::front	.\io\TypedIOBuf.h	/^  T& front() {$/;"	f	class:folly::TypedIOBuf	access:public	signature:()
folly::TypedIOBuf::front	.\io\TypedIOBuf.h	/^  const T& front() const {$/;"	f	class:folly::TypedIOBuf	access:public	signature:() const
folly::TypedIOBuf::headroom	.\io\TypedIOBuf.h	/^  uint32_t headroom() const {$/;"	f	class:folly::TypedIOBuf	access:public	signature:() const
folly::TypedIOBuf::ioBuf	.\io\TypedIOBuf.h	/^  IOBuf* ioBuf() {$/;"	f	class:folly::TypedIOBuf	access:public	signature:()
folly::TypedIOBuf::ioBuf	.\io\TypedIOBuf.h	/^  const IOBuf* ioBuf() const {$/;"	f	class:folly::TypedIOBuf	access:public	signature:() const
folly::TypedIOBuf::iterator	.\io\TypedIOBuf.h	/^  typedef value_type* iterator;$/;"	t	class:folly::TypedIOBuf	access:public
folly::TypedIOBuf::length	.\io\TypedIOBuf.h	/^  uint32_t length() const {$/;"	f	class:folly::TypedIOBuf	access:public	signature:() const
folly::TypedIOBuf::operator =	.\io\TypedIOBuf.h	/^  TypedIOBuf& operator=(TypedIOBuf&&) = default;$/;"	p	class:folly::TypedIOBuf	access:public	signature:(TypedIOBuf&&)
folly::TypedIOBuf::operator =	.\io\TypedIOBuf.h	/^  TypedIOBuf& operator=(const TypedIOBuf&) = delete;$/;"	p	class:folly::TypedIOBuf	access:private	signature:(const TypedIOBuf&)
folly::TypedIOBuf::operator []	.\io\TypedIOBuf.h	/^  T& operator[](ssize_t idx) {$/;"	f	class:folly::TypedIOBuf	access:public	signature:(ssize_t idx)
folly::TypedIOBuf::operator []	.\io\TypedIOBuf.h	/^  const T& operator[](ssize_t idx) const {$/;"	f	class:folly::TypedIOBuf	access:public	signature:(ssize_t idx) const
folly::TypedIOBuf::prepend	.\io\TypedIOBuf.h	/^  void prepend(uint32_t n) {$/;"	f	class:folly::TypedIOBuf	access:public	signature:(uint32_t n)
folly::TypedIOBuf::push	.\io\TypedIOBuf.h	/^  void push(IT begin, IT end) {$/;"	f	class:folly::TypedIOBuf	access:public	signature:(IT begin, IT end)
folly::TypedIOBuf::push	.\io\TypedIOBuf.h	/^  void push(const T& data) {$/;"	f	class:folly::TypedIOBuf	access:public	signature:(const T& data)
folly::TypedIOBuf::push_back	.\io\TypedIOBuf.h	/^  void push_back(const T& data) { push(data); }$/;"	f	class:folly::TypedIOBuf	access:public	signature:(const T& data)
folly::TypedIOBuf::reference	.\io\TypedIOBuf.h	/^  typedef value_type& reference;$/;"	t	class:folly::TypedIOBuf	access:public
folly::TypedIOBuf::reserve	.\io\TypedIOBuf.h	/^  void reserve(uint32_t minHeadroom, uint32_t minTailroom) {$/;"	f	class:folly::TypedIOBuf	access:public	signature:(uint32_t minHeadroom, uint32_t minTailroom)
folly::TypedIOBuf::reserve	.\io\TypedIOBuf.h	/^  void reserve(uint32_t minTailroom) { reserve(0, minTailroom); }$/;"	f	class:folly::TypedIOBuf	access:public	signature:(uint32_t minTailroom)
folly::TypedIOBuf::retreat	.\io\TypedIOBuf.h	/^  void retreat(uint32_t n) {$/;"	f	class:folly::TypedIOBuf	access:public	signature:(uint32_t n)
folly::TypedIOBuf::sdiv	.\io\TypedIOBuf.h	/^  static uint32_t sdiv(uint32_t n) {$/;"	f	class:folly::TypedIOBuf	access:private	signature:(uint32_t n)
folly::TypedIOBuf::size	.\io\TypedIOBuf.h	/^  uint32_t size() const { return length(); }$/;"	f	class:folly::TypedIOBuf	access:public	signature:() const
folly::TypedIOBuf::size_type	.\io\TypedIOBuf.h	/^  typedef uint32_t size_type;$/;"	t	class:folly::TypedIOBuf	access:public
folly::TypedIOBuf::smul	.\io\TypedIOBuf.h	/^  static uint32_t smul(uint32_t n) {$/;"	f	class:folly::TypedIOBuf	access:private	signature:(uint32_t n)
folly::TypedIOBuf::static_assert	.\io\TypedIOBuf.h	/^  static_assert(std::is_standard_layout<T>::value, "must be standard layout");$/;"	p	class:folly::TypedIOBuf	access:private	signature:(std::is_standard_layout<T>::value, )
folly::TypedIOBuf::tail	.\io\TypedIOBuf.h	/^  const T* tail() const {$/;"	f	class:folly::TypedIOBuf	access:public	signature:() const
folly::TypedIOBuf::tailroom	.\io\TypedIOBuf.h	/^  uint32_t tailroom() const {$/;"	f	class:folly::TypedIOBuf	access:public	signature:() const
folly::TypedIOBuf::trimEnd	.\io\TypedIOBuf.h	/^  void trimEnd(uint32_t n) {$/;"	f	class:folly::TypedIOBuf	access:public	signature:(uint32_t n)
folly::TypedIOBuf::trimStart	.\io\TypedIOBuf.h	/^  void trimStart(uint32_t n) {$/;"	f	class:folly::TypedIOBuf	access:public	signature:(uint32_t n)
folly::TypedIOBuf::value_type	.\io\TypedIOBuf.h	/^  typedef T value_type;$/;"	t	class:folly::TypedIOBuf	access:public
folly::TypedIOBuf::writableBuffer	.\io\TypedIOBuf.h	/^  T* writableBuffer() {$/;"	f	class:folly::TypedIOBuf	access:public	signature:()
folly::TypedIOBuf::writableData	.\io\TypedIOBuf.h	/^  T* writableData() {$/;"	f	class:folly::TypedIOBuf	access:public	signature:()
folly::TypedIOBuf::writableTail	.\io\TypedIOBuf.h	/^  T* writableTail() {$/;"	f	class:folly::TypedIOBuf	access:public	signature:()
folly::UnalignedNoASan	.\experimental\Bits.h	/^struct UnalignedNoASan : public Unaligned<T> { };$/;"	s	namespace:folly	inherits:Unaligned
folly::Uri	.\Uri.h	/^class Uri {$/;"	c	namespace:folly
folly::Uri::Uri	.\Uri.cpp	/^Uri::Uri(StringPiece str) : port_(0) {$/;"	f	class:folly::Uri	signature:(StringPiece str)
folly::Uri::Uri	.\Uri.h	/^  explicit Uri(StringPiece str);$/;"	p	class:folly::Uri	access:public	signature:(StringPiece str)
folly::Uri::authority	.\Uri.cpp	/^fbstring Uri::authority() const {$/;"	f	class:folly::Uri	signature:() const
folly::Uri::authority	.\Uri.h	/^  fbstring authority() const;$/;"	p	class:folly::Uri	access:public	signature:() const
folly::Uri::fbstr	.\Uri.h	/^  fbstring fbstr() const { return toString<fbstring>(); }$/;"	f	class:folly::Uri	access:public	signature:() const
folly::Uri::fragment	.\Uri.h	/^  const fbstring& fragment() const { return fragment_; }$/;"	f	class:folly::Uri	access:public	signature:() const
folly::Uri::fragment_	.\Uri.h	/^  fbstring fragment_;$/;"	m	class:folly::Uri	access:private
folly::Uri::getQueryParams	.\Uri.h	/^  const std::vector<std::pair<fbstring, fbstring>>& getQueryParams() const {$/;"	f	class:folly::Uri	access:public	signature:() const
folly::Uri::host	.\Uri.h	/^  const fbstring& host() const { return host_; }$/;"	f	class:folly::Uri	access:public	signature:() const
folly::Uri::host_	.\Uri.h	/^  fbstring host_;$/;"	m	class:folly::Uri	access:private
folly::Uri::hostname	.\Uri.cpp	/^fbstring Uri::hostname() const {$/;"	f	class:folly::Uri	signature:() const
folly::Uri::hostname	.\Uri.h	/^  fbstring hostname() const;$/;"	p	class:folly::Uri	access:public	signature:() const
folly::Uri::password	.\Uri.h	/^  const fbstring& password() const { return password_; }$/;"	f	class:folly::Uri	access:public	signature:() const
folly::Uri::password_	.\Uri.h	/^  fbstring password_;$/;"	m	class:folly::Uri	access:private
folly::Uri::path	.\Uri.h	/^  const fbstring& path() const { return path_; }$/;"	f	class:folly::Uri	access:public	signature:() const
folly::Uri::path_	.\Uri.h	/^  fbstring path_;$/;"	m	class:folly::Uri	access:private
folly::Uri::port	.\Uri.h	/^  uint16_t port() const { return port_; }$/;"	f	class:folly::Uri	access:public	signature:() const
folly::Uri::port_	.\Uri.h	/^  uint16_t port_;$/;"	m	class:folly::Uri	access:private
folly::Uri::query	.\Uri.h	/^  const fbstring& query() const { return query_; }$/;"	f	class:folly::Uri	access:public	signature:() const
folly::Uri::queryParams_	.\Uri.h	/^  std::vector<std::pair<fbstring, fbstring>> queryParams_;$/;"	m	class:folly::Uri	access:private
folly::Uri::query_	.\Uri.h	/^  fbstring query_;$/;"	m	class:folly::Uri	access:private
folly::Uri::scheme	.\Uri.h	/^  const fbstring& scheme() const { return scheme_; }$/;"	f	class:folly::Uri	access:public	signature:() const
folly::Uri::scheme_	.\Uri.h	/^  fbstring scheme_;$/;"	m	class:folly::Uri	access:private
folly::Uri::setPort	.\Uri.h	/^  void setPort(uint16_t port) {port_ = port;}$/;"	f	class:folly::Uri	access:public	signature:(uint16_t port)
folly::Uri::str	.\Uri.h	/^  std::string str() const { return toString<std::string>(); }$/;"	f	class:folly::Uri	access:public	signature:() const
folly::Uri::toString	.\Uri-inl.h	/^String Uri::toString() const {$/;"	f	class:folly::Uri	signature:() const
folly::Uri::toString	.\Uri.h	/^  String toString() const;$/;"	p	class:folly::Uri	access:public	signature:() const
folly::Uri::username	.\Uri.h	/^  const fbstring& username() const { return username_; }$/;"	f	class:folly::Uri	access:public	signature:() const
folly::Uri::username_	.\Uri.h	/^  fbstring username_;$/;"	m	class:folly::Uri	access:private
folly::UriEscapeMode	.\String.h	/^enum class UriEscapeMode : unsigned char {$/;"	c	namespace:folly
folly::UriEscapeMode::ALL	.\String.h	/^  ALL = 0,$/;"	m	class:folly::UriEscapeMode	access:private
folly::UriEscapeMode::PATH	.\String.h	/^  PATH = 2$/;"	m	class:folly::UriEscapeMode	access:private
folly::UriEscapeMode::PRETTY_BYTES	.\String.h	/^  PRETTY_BYTES = PRETTY_BYTES_BINARY,$/;"	e	enum:folly::UriEscapeMode::PrettyType
folly::UriEscapeMode::PRETTY_BYTES_BINARY	.\String.h	/^  PRETTY_BYTES_BINARY,$/;"	e	enum:folly::UriEscapeMode::PrettyType
folly::UriEscapeMode::PRETTY_BYTES_BINARY_IEC	.\String.h	/^  PRETTY_BYTES_BINARY_IEC,$/;"	e	enum:folly::UriEscapeMode::PrettyType
folly::UriEscapeMode::PRETTY_BYTES_IEC	.\String.h	/^  PRETTY_BYTES_IEC = PRETTY_BYTES_BINARY_IEC,$/;"	e	enum:folly::UriEscapeMode::PrettyType
folly::UriEscapeMode::PRETTY_BYTES_METRIC	.\String.h	/^  PRETTY_BYTES_METRIC,$/;"	e	enum:folly::UriEscapeMode::PrettyType
folly::UriEscapeMode::PRETTY_NUM_TYPES	.\String.h	/^  PRETTY_NUM_TYPES,$/;"	e	enum:folly::UriEscapeMode::PrettyType
folly::UriEscapeMode::PRETTY_SI	.\String.h	/^  PRETTY_SI,$/;"	e	enum:folly::UriEscapeMode::PrettyType
folly::UriEscapeMode::PRETTY_TIME	.\String.h	/^  PRETTY_TIME,$/;"	e	enum:folly::UriEscapeMode::PrettyType
folly::UriEscapeMode::PRETTY_UNITS_BINARY	.\String.h	/^  PRETTY_UNITS_BINARY,$/;"	e	enum:folly::UriEscapeMode::PrettyType
folly::UriEscapeMode::PRETTY_UNITS_BINARY_IEC	.\String.h	/^  PRETTY_UNITS_BINARY_IEC,$/;"	e	enum:folly::UriEscapeMode::PrettyType
folly::UriEscapeMode::PRETTY_UNITS_METRIC	.\String.h	/^  PRETTY_UNITS_METRIC,$/;"	e	enum:folly::UriEscapeMode::PrettyType
folly::UriEscapeMode::PrettyType	.\String.h	/^enum PrettyType {$/;"	g	class:folly::UriEscapeMode	access:private
folly::UriEscapeMode::QUERY	.\String.h	/^  QUERY = 1,$/;"	m	class:folly::UriEscapeMode	access:private
folly::UriEscapeMode::backslashify	.\String.h	/^String backslashify(const String& input, bool hex_style=false) {$/;"	f	class:folly::UriEscapeMode	access:private	signature:(const String& input, bool hex_style=false)
folly::UriEscapeMode::backslashify	.\String.h	/^void backslashify(const String1& input, String2& output, bool hex_style=false);$/;"	p	class:folly::UriEscapeMode	access:private	signature:(const String1& input, String2& output, bool hex_style=false)
folly::UriEscapeMode::errnoStr	.\String.h	/^fbstring errnoStr(int err);$/;"	p	class:folly::UriEscapeMode	access:private	signature:(int err)
folly::UriEscapeMode::exceptionStr	.\String.h	/^inline fbstring exceptionStr(const std::exception& e) {$/;"	f	class:folly::UriEscapeMode	access:private	signature:(const std::exception& e)
folly::UriEscapeMode::exceptionStr	.\String.h	/^inline fbstring exceptionStr(std::exception_ptr ep) {$/;"	f	class:folly::UriEscapeMode	access:private	signature:(std::exception_ptr ep)
folly::UriEscapeMode::hexDump	.\String.h	/^std::string hexDump(const void* ptr, size_t size);$/;"	p	class:folly::UriEscapeMode	access:private	signature:(const void* ptr, size_t size)
folly::UriEscapeMode::hexDump	.\String.h	/^void hexDump(const void* ptr, size_t size, OutIt out);$/;"	p	class:folly::UriEscapeMode	access:private	signature:(const void* ptr, size_t size, OutIt out)
folly::UriEscapeMode::hexlify	.\String.h	/^bool hexlify(const InputString& input, OutputString& output,$/;"	p	class:folly::UriEscapeMode	access:private	signature:(const InputString& input, OutputString& output, bool append=false)
folly::UriEscapeMode::humanify	.\String.h	/^String humanify(const String& input) {$/;"	f	class:folly::UriEscapeMode	access:private	signature:(const String& input)
folly::UriEscapeMode::humanify	.\String.h	/^void humanify(const String1& input, String2& output);$/;"	p	class:folly::UriEscapeMode	access:private	signature:(const String1& input, String2& output)
folly::UriEscapeMode::join	.\String.h	/^std::string join(const Delim& delimiter,$/;"	f	class:folly::UriEscapeMode	access:private	signature:(const Delim& delimiter, const Container& container)
folly::UriEscapeMode::join	.\String.h	/^std::string join(const Delim& delimiter,$/;"	f	class:folly::UriEscapeMode	access:private	signature:(const Delim& delimiter, const std::initializer_list<Value>& values)
folly::UriEscapeMode::join	.\String.h	/^void join(const Delim& delimiter,$/;"	f	class:folly::UriEscapeMode	access:private	signature:(const Delim& delimiter, const Container& container, String& output)
folly::UriEscapeMode::join	.\String.h	/^void join(const Delim& delimiter,$/;"	f	class:folly::UriEscapeMode	access:private	signature:(const Delim& delimiter, const std::initializer_list<Value>& values, String& output)
folly::UriEscapeMode::join	.\String.h	/^void join(const Delim& delimiter,$/;"	p	class:folly::UriEscapeMode	access:private	signature:(const Delim& delimiter, Iterator begin, Iterator end, String& output)
folly::UriEscapeMode::prettyPrint	.\String.h	/^std::string prettyPrint(double val, PrettyType, bool addSpace = true);$/;"	p	class:folly::UriEscapeMode	access:private	signature:(double val, PrettyType, bool addSpace = true)
folly::UriEscapeMode::prettyToDouble	.\String.h	/^double prettyToDouble(folly::StringPiece *const prettyString,$/;"	p	class:folly::UriEscapeMode	access:private	signature:(folly::StringPiece *const prettyString, const PrettyType type)
folly::UriEscapeMode::prettyToDouble	.\String.h	/^double prettyToDouble(folly::StringPiece prettyString, const PrettyType type);$/;"	p	class:folly::UriEscapeMode	access:private	signature:(folly::StringPiece prettyString, const PrettyType type)
folly::UriEscapeMode::skipWhitespace	.\String.h	/^StringPiece skipWhitespace(StringPiece sp);$/;"	p	class:folly::UriEscapeMode	access:private	signature:(StringPiece sp)
folly::UriEscapeMode::split	.\String.h	/^void split(const Delim& delimiter,$/;"	p	class:folly::UriEscapeMode	access:private	signature:(const Delim& delimiter, const String& input, folly::fbvector<OutputType>& out, bool ignoreEmpty = false)
folly::UriEscapeMode::split	.\String.h	/^void split(const Delim& delimiter,$/;"	p	class:folly::UriEscapeMode	access:private	signature:(const Delim& delimiter, const String& input, std::vector<OutputType>& out, bool ignoreEmpty = false)
folly::UriEscapeMode::splitTo	.\String.h	/^void splitTo(const Delim& delimiter,$/;"	p	class:folly::UriEscapeMode	access:private	signature:(const Delim& delimiter, const String& input, OutputIterator out, bool ignoreEmpty = false)
folly::UriEscapeMode::toLowerAscii	.\String.h	/^inline void toLowerAscii(MutableStringPiece str) {$/;"	f	class:folly::UriEscapeMode	access:private	signature:(MutableStringPiece str)
folly::UriEscapeMode::toLowerAscii	.\String.h	/^void toLowerAscii(char* str, size_t length);$/;"	p	class:folly::UriEscapeMode	access:private	signature:(char* str, size_t length)
folly::UriEscapeMode::unhexlify	.\String.h	/^bool unhexlify(const InputString& input, OutputString& output);$/;"	p	class:folly::UriEscapeMode	access:private	signature:(const InputString& input, OutputString& output)
folly::UriEscapeMode::uriEscape	.\String.h	/^String uriEscape(StringPiece str, UriEscapeMode mode = UriEscapeMode::ALL) {$/;"	f	class:folly::UriEscapeMode	access:private	signature:(StringPiece str, UriEscapeMode mode = UriEscapeMode::ALL)
folly::UriEscapeMode::uriEscape	.\String.h	/^void uriEscape(StringPiece str,$/;"	p	class:folly::UriEscapeMode	access:private	signature:(StringPiece str, String& out, UriEscapeMode mode = UriEscapeMode::ALL)
folly::UriEscapeMode::uriUnescape	.\String.h	/^String uriUnescape(StringPiece str, UriEscapeMode mode = UriEscapeMode::ALL) {$/;"	f	class:folly::UriEscapeMode	access:private	signature:(StringPiece str, UriEscapeMode mode = UriEscapeMode::ALL)
folly::UriEscapeMode::uriUnescape	.\String.h	/^void uriUnescape(StringPiece str,$/;"	p	class:folly::UriEscapeMode	access:private	signature:(StringPiece str, String& out, UriEscapeMode mode = UriEscapeMode::ALL)
folly::__anon100::Initializer	.\Subprocess.cpp	/^class Initializer {$/;"	c	namespace:folly::__anon100	file:
folly::__anon100::Initializer::Initializer	.\Subprocess.cpp	/^  Initializer() {$/;"	f	class:folly::__anon100::Initializer	access:public	signature:()
folly::__anon100::initializer	.\Subprocess.cpp	/^Initializer initializer;$/;"	m	namespace:folly::__anon100	file:
folly::__anon10::DemangleBuf	.\Demangle.cpp	/^struct DemangleBuf {$/;"	s	namespace:folly::__anon10	file:
folly::__anon10::DemangleBuf::dest	.\Demangle.cpp	/^  char* dest;$/;"	m	struct:folly::__anon10::DemangleBuf	file:	access:public
folly::__anon10::DemangleBuf::remaining	.\Demangle.cpp	/^  size_t remaining;$/;"	m	struct:folly::__anon10::DemangleBuf	file:	access:public
folly::__anon10::DemangleBuf::total	.\Demangle.cpp	/^  size_t total;$/;"	m	struct:folly::__anon10::DemangleBuf	file:	access:public
folly::__anon10::demangleCallback	.\Demangle.cpp	/^void demangleCallback(const char* str, size_t size, void* p) {$/;"	f	namespace:folly::__anon10	signature:(const char* str, size_t size, void* p)
folly::__anon125::writeStringToFileOrDie	.\test\MemoryMappingTest.cpp	/^void writeStringToFileOrDie(const std::string& str, int fd) {$/;"	f	namespace:folly::__anon125	signature:(const std::string& str, int fd)
folly::__anon153::submatch	.\Uri.cpp	/^fbstring submatch(const boost::cmatch& m, size_t idx) {$/;"	f	namespace:folly::__anon153	signature:(const boost::cmatch& m, size_t idx)
folly::__anon153::toLower	.\Uri.cpp	/^void toLower(String& s) {$/;"	f	namespace:folly::__anon153	signature:(String& s)
folly::__anon28::asyncIoOpStateToString	.\experimental\io\AsyncIO.cpp	/^const char* asyncIoOpStateToString(AsyncIOOp::State state) {$/;"	f	namespace:folly::__anon28	signature:(AsyncIOOp::State state)
folly::__anon28::fd2name	.\experimental\io\AsyncIO.cpp	/^std::string fd2name(int fd) {$/;"	f	namespace:folly::__anon28	signature:(int fd)
folly::__anon28::iocbCmdToString	.\experimental\io\AsyncIO.cpp	/^const char* iocbCmdToString(short int cmd_short) {$/;"	f	namespace:folly::__anon28	signature:(short int cmd_short)
folly::__anon28::operator <<	.\experimental\io\AsyncIO.cpp	/^std::ostream& operator<<(std::ostream& os, const iocb& cb) {$/;"	f	namespace:folly::__anon28	signature:(std::ostream& os, const iocb& cb)
folly::__anon30::getDefaultHugePageSize	.\experimental\io\HugePages.cpp	/^size_t getDefaultHugePageSize() {$/;"	f	namespace:folly::__anon30	signature:()
folly::__anon30::parsePageSizeValue	.\experimental\io\HugePages.cpp	/^size_t parsePageSizeValue(StringPiece value) {$/;"	f	namespace:folly::__anon30	signature:(StringPiece value)
folly::__anon30::readHugePageSizes	.\experimental\io\HugePages.cpp	/^HugePageSizeVec readHugePageSizes() {$/;"	f	namespace:folly::__anon30	signature:()
folly::__anon30::readRawHugePageSizes	.\experimental\io\HugePages.cpp	/^HugePageSizeVec readRawHugePageSizes() {$/;"	f	namespace:folly::__anon30	signature:()
folly::__anon50::std::allocator_traits::destroy	.\FBVector.h	/^      std::allocator_traits<Allocator>::destroy(impl_, p);$/;"	p	class:folly::__anon50::std::allocator_traits	access:private	signature:(impl_, p)
folly::__anon53::doFormatFrom	.\Format.h	/^      doFormatFrom<K+1>(i, arg, cb);$/;"	p	class:folly::__anon53	access:private	signature:(i, arg, cb)
folly::__anon77::getDeviceOptions	.\MemoryMapping.cpp	/^void getDeviceOptions(dev_t device, off_t& pageSize, bool& autoExtend) {$/;"	f	namespace:folly::__anon77	signature:(dev_t device, off_t& pageSize, bool& autoExtend)
folly::__anon78::memOpChunkSize	.\MemoryMapping.cpp	/^off_t memOpChunkSize(off_t length, off_t pageSize) {$/;"	f	namespace:folly::__anon78	signature:(off_t length, off_t pageSize)
folly::__anon78::memOpInChunks	.\MemoryMapping.cpp	/^bool memOpInChunks(std::function<int(void*, size_t)> op,$/;"	f	namespace:folly::__anon78	signature:(std::function<int(void*, size_t)> op, void* mem, size_t bufSize, off_t pageSize, size_t& amountSucceeded)
folly::__anon82::BufferedRandomDevice	.\Random.cpp	/^class BufferedRandomDevice {$/;"	c	namespace:folly::__anon82	file:
folly::__anon82::BufferedRandomDevice::BufferedRandomDevice	.\Random.cpp	/^  explicit BufferedRandomDevice(size_t bufferSize = kDefaultBufferSize);$/;"	p	class:folly::__anon82::BufferedRandomDevice	file:	access:public	signature:(size_t bufferSize = kDefaultBufferSize)
folly::__anon82::BufferedRandomDevice::BufferedRandomDevice	.\Random.cpp	/^BufferedRandomDevice::BufferedRandomDevice(size_t bufferSize)$/;"	f	class:folly::__anon82::BufferedRandomDevice	signature:(size_t bufferSize)
folly::__anon82::BufferedRandomDevice::bufferSize_	.\Random.cpp	/^  const size_t bufferSize_;$/;"	m	class:folly::__anon82::BufferedRandomDevice	file:	access:private
folly::__anon82::BufferedRandomDevice::buffer_	.\Random.cpp	/^  std::unique_ptr<unsigned char[]> buffer_;$/;"	m	class:folly::__anon82::BufferedRandomDevice	file:	access:private
folly::__anon82::BufferedRandomDevice::get	.\Random.cpp	/^  void get(void* data, size_t size) {$/;"	f	class:folly::__anon82::BufferedRandomDevice	access:public	signature:(void* data, size_t size)
folly::__anon82::BufferedRandomDevice::getSlow	.\Random.cpp	/^  void getSlow(unsigned char* data, size_t size);$/;"	p	class:folly::__anon82::BufferedRandomDevice	file:	access:private	signature:(unsigned char* data, size_t size)
folly::__anon82::BufferedRandomDevice::getSlow	.\Random.cpp	/^void BufferedRandomDevice::getSlow(unsigned char* data, size_t size) {$/;"	f	class:folly::__anon82::BufferedRandomDevice	signature:(unsigned char* data, size_t size)
folly::__anon82::BufferedRandomDevice::kDefaultBufferSize	.\Random.cpp	/^  static constexpr size_t kDefaultBufferSize = 128;$/;"	m	class:folly::__anon82::BufferedRandomDevice	file:	access:public
folly::__anon82::BufferedRandomDevice::ptr_	.\Random.cpp	/^  unsigned char* ptr_;$/;"	m	class:folly::__anon82::BufferedRandomDevice	file:	access:private
folly::__anon82::BufferedRandomDevice::remaining	.\Random.cpp	/^  inline size_t remaining() const {$/;"	f	class:folly::__anon82::BufferedRandomDevice	file:	access:private	signature:() const
folly::__anon82::bufferedRandomDevice	.\Random.cpp	/^ThreadLocal<BufferedRandomDevice> bufferedRandomDevice;$/;"	m	namespace:folly::__anon82	file:
folly::__anon82::readRandomDevice	.\Random.cpp	/^void readRandomDevice(void* data, size_t size) {$/;"	f	namespace:folly::__anon82	signature:(void* data, size_t size)
folly::__anon83::FOLLY_DISABLE_ADDRESS_SANITIZER	.\Range.cpp	/^  FOLLY_DISABLE_ADDRESS_SANITIZER;$/;"	m	namespace:folly::__anon83	file:
folly::__anon83::FastByteSet	.\Range.cpp	/^class FastByteSet {$/;"	c	namespace:folly::__anon83	file:
folly::__anon83::FastByteSet::FastByteSet	.\Range.cpp	/^  FastByteSet() : size_(0) { }  \/\/ no init of arrays required!$/;"	f	class:folly::__anon83::FastByteSet	access:public	signature:()
folly::__anon83::FastByteSet::add	.\Range.cpp	/^  inline void add(uint8_t i) {$/;"	f	class:folly::__anon83::FastByteSet	access:public	signature:(uint8_t i)
folly::__anon83::FastByteSet::contains	.\Range.cpp	/^  inline bool contains(uint8_t i) const {$/;"	f	class:folly::__anon83::FastByteSet	access:public	signature:(uint8_t i) const
folly::__anon83::FastByteSet::dense_	.\Range.cpp	/^  uint8_t dense_[256];$/;"	m	class:folly::__anon83::FastByteSet	file:	access:private
folly::__anon83::FastByteSet::size_	.\Range.cpp	/^  uint16_t size_;  \/\/ can't use uint8_t because it would overflow if all$/;"	m	class:folly::__anon83::FastByteSet	file:	access:private
folly::__anon83::FastByteSet::sparse_	.\Range.cpp	/^  uint8_t sparse_[256];$/;"	m	class:folly::__anon83::FastByteSet	file:	access:private
folly::__anon83::kMinPageSize	.\Range.cpp	/^constexpr size_t kMinPageSize = 4096;$/;"	m	namespace:folly::__anon83	file:
folly::__anon83::nextAlignedIndex	.\Range.cpp	/^inline size_t nextAlignedIndex(const char* arr) {$/;"	f	namespace:folly::__anon83	signature:(const char* arr)
folly::__anon83::qfind_first_byte_of_needles16	.\Range.cpp	/^size_t qfind_first_byte_of_needles16(const StringPiece& haystack,$/;"	f	namespace:folly::__anon83	signature:(const StringPiece& haystack, const StringPiece& needles)
folly::__anon93::stringPrintfImpl	.\String.cpp	/^inline void stringPrintfImpl(std::string& output, const char* format,$/;"	f	namespace:folly::__anon93	signature:(std::string& output, const char* format, va_list args)
folly::__anon94::PrettySuffix	.\String.cpp	/^struct PrettySuffix {$/;"	s	namespace:folly::__anon94	file:
folly::__anon94::PrettySuffix::suffix	.\String.cpp	/^  const char* suffix;$/;"	m	struct:folly::__anon94::PrettySuffix	file:	access:public
folly::__anon94::PrettySuffix::val	.\String.cpp	/^  double val;$/;"	m	struct:folly::__anon94::PrettySuffix	file:	access:public
folly::__anon94::kPrettyBytesBinaryIECSuffixes	.\String.cpp	/^const PrettySuffix kPrettyBytesBinaryIECSuffixes[] = {$/;"	m	namespace:folly::__anon94	file:
folly::__anon94::kPrettyBytesBinarySuffixes	.\String.cpp	/^const PrettySuffix kPrettyBytesBinarySuffixes[] = {$/;"	m	namespace:folly::__anon94	file:
folly::__anon94::kPrettyBytesMetricSuffixes	.\String.cpp	/^const PrettySuffix kPrettyBytesMetricSuffixes[] = {$/;"	m	namespace:folly::__anon94	file:
folly::__anon94::kPrettySISuffixes	.\String.cpp	/^const PrettySuffix kPrettySISuffixes[] = {$/;"	m	namespace:folly::__anon94	file:
folly::__anon94::kPrettySuffixes	.\String.cpp	/^const PrettySuffix* const kPrettySuffixes[PRETTY_NUM_TYPES] = {$/;"	m	namespace:folly::__anon94	file:
folly::__anon94::kPrettyTimeSuffixes	.\String.cpp	/^const PrettySuffix kPrettyTimeSuffixes[] = {$/;"	m	namespace:folly::__anon94	file:
folly::__anon94::kPrettyUnitsBinaryIECSuffixes	.\String.cpp	/^const PrettySuffix kPrettyUnitsBinaryIECSuffixes[] = {$/;"	m	namespace:folly::__anon94	file:
folly::__anon94::kPrettyUnitsBinarySuffixes	.\String.cpp	/^const PrettySuffix kPrettyUnitsBinarySuffixes[] = {$/;"	m	namespace:folly::__anon94	file:
folly::__anon94::kPrettyUnitsMetricSuffixes	.\String.cpp	/^const PrettySuffix kPrettyUnitsMetricSuffixes[] = {$/;"	m	namespace:folly::__anon94	file:
folly::__anon95::toLowerAscii32	.\String.cpp	/^void toLowerAscii32(uint32_t& c) {$/;"	f	namespace:folly::__anon95	signature:(uint32_t& c)
folly::__anon95::toLowerAscii64	.\String.cpp	/^void toLowerAscii64(uint64_t& c) {$/;"	f	namespace:folly::__anon95	signature:(uint64_t& c)
folly::__anon95::toLowerAscii8	.\String.cpp	/^void toLowerAscii8(char& c) {$/;"	f	namespace:folly::__anon95	signature:(char& c)
folly::__anon97::checkStatus	.\Subprocess.cpp	/^void checkStatus(ProcessReturnCode returnCode) {$/;"	f	namespace:folly::__anon97	signature:(ProcessReturnCode returnCode)
folly::__anon97::cloneStrings	.\Subprocess.cpp	/^std::unique_ptr<const char*[]> cloneStrings(const std::vector<std::string>& s) {$/;"	f	namespace:folly::__anon97	signature:(const std::vector<std::string>& s)
folly::__anon98::ChildErrorInfo	.\Subprocess.cpp	/^struct ChildErrorInfo {$/;"	s	namespace:folly::__anon98	file:
folly::__anon98::ChildErrorInfo::errCode	.\Subprocess.cpp	/^  int errCode;$/;"	m	struct:folly::__anon98::ChildErrorInfo	file:	access:public
folly::__anon98::ChildErrorInfo::errnoValue	.\Subprocess.cpp	/^  int errnoValue;$/;"	m	struct:folly::__anon98::ChildErrorInfo	file:	access:public
folly::__anon98::childError	.\Subprocess.cpp	/^FOLLY_NORETURN void childError(int errFd, int errCode, int errnoValue);$/;"	p	namespace:folly::__anon98	file:	signature:(int errFd, int errCode, int errnoValue)
folly::__anon98::childError	.\Subprocess.cpp	/^void childError(int errFd, int errCode, int errnoValue) {$/;"	f	namespace:folly::__anon98	signature:(int errFd, int errCode, int errnoValue)
folly::__anon98::closeChecked	.\Subprocess.cpp	/^void closeChecked(int fd) {$/;"	f	namespace:folly::__anon98	signature:(int fd)
folly::__anon99::discardRead	.\Subprocess.cpp	/^bool discardRead(int fd) {$/;"	f	namespace:folly::__anon99	signature:(int fd)
folly::__anon99::handleRead	.\Subprocess.cpp	/^bool handleRead(int fd, IOBufQueue& queue) {$/;"	f	namespace:folly::__anon99	signature:(int fd, IOBufQueue& queue)
folly::__anon99::handleWrite	.\Subprocess.cpp	/^bool handleWrite(int fd, IOBufQueue& queue) {$/;"	f	namespace:folly::__anon99	signature:(int fd, IOBufQueue& queue)
folly::__anon99::queueFront	.\Subprocess.cpp	/^std::pair<const uint8_t*, size_t> queueFront(const IOBufQueue& queue) {$/;"	f	namespace:folly::__anon99	signature:(const IOBufQueue& queue)
folly::actualCapacity_	.\IndexedMemPool.h	/^  size_t actualCapacity_;$/;"	m	namespace:folly
folly::addBenchmark	.\Benchmark.h	/^addBenchmark(const char* file, const char* name, Lambda&& lambda) {$/;"	f	namespace:folly	signature:(const char* file, const char* name, Lambda&& lambda)
folly::alignedForwardMemcpy	.\MemoryMapping.cpp	/^void alignedForwardMemcpy(void* dst, const void* src, size_t size) {$/;"	f	namespace:folly	signature:(void* dst, const void* src, size_t size)
folly::alignedForwardMemcpy	.\MemoryMapping.h	/^void alignedForwardMemcpy(void* dest, const void* src, size_t size);$/;"	p	namespace:folly	signature:(void* dest, const void* src, size_t size)
folly::allocate_shared	.\Memory.h	/^std::shared_ptr<T> allocate_shared(Allocator&& allocator, Args&&... args) {$/;"	f	namespace:folly	signature:(Allocator&& allocator, Args&&... args)
folly::allocate_unique	.\Memory.h	/^typename AllocatorUniquePtr<T, Allocator>::type allocate_unique($/;"	f	namespace:folly	signature:( Allocator&& allocator, Args&&... args )
folly::allocator_delete	.\Memory.h	/^class allocator_delete$/;"	c	namespace:folly	inherits:std::remove_reference::type
folly::allocator_delete::allocator_delete	.\Memory.h	/^  allocator_delete() = default;$/;"	p	class:folly::allocator_delete	access:public	signature:()
folly::allocator_delete::allocator_delete	.\Memory.h	/^  allocator_delete(const allocator_delete<U>& other)$/;"	f	class:folly::allocator_delete	access:public	signature:(const allocator_delete<U>& other)
folly::allocator_delete::allocator_delete	.\Memory.h	/^  explicit allocator_delete(allocator_type&& allocator)$/;"	f	class:folly::allocator_delete	access:public	signature:(allocator_type&& allocator)
folly::allocator_delete::allocator_delete	.\Memory.h	/^  explicit allocator_delete(const allocator_type& allocator)$/;"	f	class:folly::allocator_delete	access:public	signature:(const allocator_type& allocator)
folly::allocator_delete::allocator_type	.\Memory.h	/^  typedef typename std::remove_reference<Allocator>::type allocator_type;$/;"	t	class:folly::allocator_delete	access:private
folly::allocator_delete::get_allocator	.\Memory.h	/^  allocator_type& get_allocator() const {$/;"	f	class:folly::allocator_delete	access:public	signature:() const
folly::allocator_delete::operator ()	.\Memory.h	/^  void operator()(pointer p) const {$/;"	f	class:folly::allocator_delete	access:public	signature:(pointer p) const
folly::allocator_delete::pointer	.\Memory.h	/^  typedef typename Allocator::pointer pointer;$/;"	t	class:folly::allocator_delete	access:public
folly::as_stl_allocator	.\Memory.h	/^struct as_stl_allocator {$/;"	s	namespace:folly
folly::as_stl_allocator::type	.\Memory.h	/^  >::type type;$/;"	t	struct:folly::as_stl_allocator	access:public
folly::asciiCaseInsensitive	.\Range.cpp	/^const AsciiCaseInsensitive asciiCaseInsensitive = AsciiCaseInsensitive();$/;"	m	namespace:folly	file:
folly::asciiCaseSensitive	.\Range.cpp	/^const AsciiCaseSensitive asciiCaseSensitive = AsciiCaseSensitive();$/;"	m	namespace:folly	file:
folly::backslashify	.\String-inl.h	/^void backslashify(const String1& input, String2& output, bool hex_style) {$/;"	f	namespace:folly	signature:(const String1& input, String2& output, bool hex_style)
folly::begin	.\Padded.h	/^Iterator<typename Container::const_iterator> begin(const Container& c) {$/;"	f	namespace:folly	signature:(const Container& c)
folly::begin	.\Padded.h	/^Iterator<typename Container::iterator> begin(Container& c) {$/;"	f	namespace:folly	signature:(Container& c)
folly::benchmarks	.\Benchmark.cpp	/^static vector<tuple<const char*, const char*, BenchmarkFun>> benchmarks;$/;"	m	namespace:folly	file:
folly::bititerator_detail	.\detail\BitIteratorDetail.h	/^namespace bititerator_detail {$/;"	n	namespace:folly
folly::bititerator_detail::BitIteratorBase	.\detail\BitIteratorDetail.h	/^struct BitIteratorBase {$/;"	s	namespace:folly::bititerator_detail
folly::bititerator_detail::BitIteratorBase::static_assert	.\detail\BitIteratorDetail.h	/^  static_assert(std::is_integral<typename BaseIter::value_type>::value,$/;"	p	struct:folly::bititerator_detail::BitIteratorBase	access:public	signature:(std::is_integral<typename BaseIter::value_type>::value, )
folly::bititerator_detail::BitIteratorBase::type	.\detail\BitIteratorDetail.h	/^    ssize_t> type;$/;"	t	struct:folly::bititerator_detail::BitIteratorBase	access:public
folly::bititerator_detail::BitReference	.\detail\BitIteratorDetail.h	/^class BitReference {$/;"	c	namespace:folly::bititerator_detail
folly::bititerator_detail::BitReference::BitReference	.\detail\BitIteratorDetail.h	/^  BitReference(Ref r, size_t bit) : ref_(r), bit_(bit) { }$/;"	f	class:folly::bititerator_detail::BitReference	access:public	signature:(Ref r, size_t bit)
folly::bititerator_detail::BitReference::bit_	.\detail\BitIteratorDetail.h	/^  size_t bit_;$/;"	m	class:folly::bititerator_detail::BitReference	access:private
folly::bititerator_detail::BitReference::clear	.\detail\BitIteratorDetail.h	/^  void clear() {$/;"	f	class:folly::bititerator_detail::BitReference	access:public	signature:()
folly::bititerator_detail::BitReference::flip	.\detail\BitIteratorDetail.h	/^  void flip() {$/;"	f	class:folly::bititerator_detail::BitReference	access:public	signature:()
folly::bititerator_detail::BitReference::one_	.\detail\BitIteratorDetail.h	/^  const static Value one_ = 1;$/;"	m	class:folly::bititerator_detail::BitReference	access:private
folly::bititerator_detail::BitReference::operator =	.\detail\BitIteratorDetail.h	/^  BitReference& operator=(bool b) {$/;"	f	class:folly::bititerator_detail::BitReference	access:public	signature:(bool b)
folly::bititerator_detail::BitReference::operator bool	.\detail\BitIteratorDetail.h	/^  operator bool() const {$/;"	f	class:folly::bititerator_detail::BitReference	access:public	signature:() const
folly::bititerator_detail::BitReference::ref_	.\detail\BitIteratorDetail.h	/^  Ref ref_;$/;"	m	class:folly::bititerator_detail::BitReference	access:private
folly::bititerator_detail::BitReference::set	.\detail\BitIteratorDetail.h	/^  void set() {$/;"	f	class:folly::bititerator_detail::BitReference	access:public	signature:()
folly::boost	.\String.h	/^namespace boost {$/;"	n	namespace:folly
folly::boost::has_nothrow_constructor	.\String.h	/^struct has_nothrow_constructor<folly::basic_fbstring<T> > : true_type {$/;"	s	namespace:folly::boost	inherits:true_type
folly::boost::has_nothrow_constructor::value	.\String.h	/^  enum { value = true };$/;"	e	enum:folly::boost::has_nothrow_constructor::__anon96
folly::cEscape	.\String-inl.h	/^void cEscape(StringPiece str, String& out) {$/;"	f	namespace:folly	signature:(StringPiece str, String& out)
folly::cEscape	.\String.h	/^String cEscape(StringPiece str) {$/;"	f	namespace:folly	signature:(StringPiece str)
folly::cEscape	.\String.h	/^void cEscape(StringPiece str, String& out);$/;"	p	namespace:folly	signature:(StringPiece str, String& out)
folly::cUnescape	.\String-inl.h	/^void cUnescape(StringPiece str, String& out, bool strict) {$/;"	f	namespace:folly	signature:(StringPiece str, String& out, bool strict)
folly::cUnescape	.\String.h	/^String cUnescape(StringPiece str, bool strict = true) {$/;"	f	namespace:folly	signature:(StringPiece str, bool strict = true)
folly::cUnescape	.\String.h	/^void cUnescape(StringPiece str, String& out, bool strict = true);$/;"	p	namespace:folly	signature:(StringPiece str, String& out, bool strict = true)
folly::cbegin	.\Padded.h	/^Iterator<typename Container::const_iterator> cbegin(const Container& c) {$/;"	f	namespace:folly	signature:(const Container& c)
folly::cend	.\Padded.h	/^Iterator<typename Container::const_iterator> cend(const Container& c) {$/;"	f	namespace:folly	signature:(const Container& c)
folly::checkFopenError	.\Exception.h	/^void checkFopenError(FILE* fp, Args&&... args) {$/;"	f	namespace:folly	signature:(FILE* fp, Args&&... args)
folly::checkFopenErrorExplicit	.\Exception.h	/^void checkFopenErrorExplicit(FILE* fp, int savedErrno, Args&&... args) {$/;"	f	namespace:folly	signature:(FILE* fp, int savedErrno, Args&&... args)
folly::checkKernelError	.\Exception.h	/^void checkKernelError(ssize_t ret, Args&&... args) {$/;"	f	namespace:folly	signature:(ssize_t ret, Args&&... args)
folly::checkPosixError	.\Exception.h	/^void checkPosixError(int err, Args&&... args) {$/;"	f	namespace:folly	signature:(int err, Args&&... args)
folly::checkUnixError	.\Exception.h	/^void checkUnixError(ssize_t ret, Args&&... args) {$/;"	f	namespace:folly	signature:(ssize_t ret, Args&&... args)
folly::checkUnixErrorExplicit	.\Exception.h	/^void checkUnixErrorExplicit(ssize_t ret, int savedErrno, Args&&... args) {$/;"	f	namespace:folly	signature:(ssize_t ret, int savedErrno, Args&&... args)
folly::closeNoInt	.\FileUtil.cpp	/^int closeNoInt(int fd) {$/;"	f	namespace:folly	signature:(int fd)
folly::closeNoInt	.\FileUtil.h	/^int closeNoInt(int fd);$/;"	p	namespace:folly	signature:(int fd)
folly::codePointToUtf8	.\Unicode.cpp	/^fbstring codePointToUtf8(char32_t cp) {$/;"	f	namespace:folly	signature:(char32_t cp)
folly::codePointToUtf8	.\Unicode.h	/^fbstring codePointToUtf8(char32_t cp);$/;"	p	namespace:folly	signature:(char32_t cp)
folly::compression	.\experimental\EliasFanoCoding.h	/^namespace folly { namespace compression {$/;"	n	namespace:folly
folly::compression	.\experimental\test\CodingTestUtils.h	/^namespace folly { namespace compression {$/;"	n	namespace:folly
folly::compression::EliasFanoCompressedList	.\experimental\EliasFanoCoding.h	/^struct EliasFanoCompressedList {$/;"	s	namespace:folly::compression
folly::compression::EliasFanoCompressedList::EliasFanoCompressedList	.\experimental\EliasFanoCoding.h	/^  EliasFanoCompressedList() { }$/;"	f	struct:folly::compression::EliasFanoCompressedList	access:public	signature:()
folly::compression::EliasFanoCompressedList::forwardPointers	.\experimental\EliasFanoCoding.h	/^  folly::ByteRange forwardPointers;$/;"	m	struct:folly::compression::EliasFanoCompressedList	access:public
folly::compression::EliasFanoCompressedList::free	.\experimental\EliasFanoCoding.h	/^  void free() {$/;"	f	struct:folly::compression::EliasFanoCompressedList	access:public	signature:()
folly::compression::EliasFanoCompressedList::lower	.\experimental\EliasFanoCoding.h	/^  folly::ByteRange lower;$/;"	m	struct:folly::compression::EliasFanoCompressedList	access:public
folly::compression::EliasFanoCompressedList::numLowerBits	.\experimental\EliasFanoCoding.h	/^  uint8_t numLowerBits = 0;$/;"	m	struct:folly::compression::EliasFanoCompressedList	access:public
folly::compression::EliasFanoCompressedList::size	.\experimental\EliasFanoCoding.h	/^  size_t size = 0;$/;"	m	struct:folly::compression::EliasFanoCompressedList	access:public
folly::compression::EliasFanoCompressedList::skipPointers	.\experimental\EliasFanoCoding.h	/^  folly::ByteRange skipPointers;$/;"	m	struct:folly::compression::EliasFanoCompressedList	access:public
folly::compression::EliasFanoCompressedList::upper	.\experimental\EliasFanoCoding.h	/^  folly::ByteRange upper;$/;"	m	struct:folly::compression::EliasFanoCompressedList	access:public
folly::compression::EliasFanoEncoder	.\experimental\EliasFanoCoding.h	/^struct EliasFanoEncoder {$/;"	s	namespace:folly::compression
folly::compression::EliasFanoEncoder::CompressedList	.\experimental\EliasFanoCoding.h	/^  typedef EliasFanoCompressedList CompressedList;$/;"	t	struct:folly::compression::EliasFanoEncoder	access:public
folly::compression::EliasFanoEncoder::EliasFanoEncoder	.\experimental\EliasFanoCoding.h	/^  EliasFanoEncoder(size_t size, ValueType upperBound) {$/;"	f	struct:folly::compression::EliasFanoEncoder	access:public	signature:(size_t size, ValueType upperBound)
folly::compression::EliasFanoEncoder::SkipValueType	.\experimental\EliasFanoCoding.h	/^  typedef SkipValue SkipValueType;$/;"	t	struct:folly::compression::EliasFanoEncoder	access:public
folly::compression::EliasFanoEncoder::ValueType	.\experimental\EliasFanoCoding.h	/^  typedef Value ValueType;$/;"	t	struct:folly::compression::EliasFanoEncoder	access:public
folly::compression::EliasFanoEncoder::add	.\experimental\EliasFanoCoding.h	/^  void add(ValueType value) {$/;"	f	struct:folly::compression::EliasFanoEncoder	access:public	signature:(ValueType value)
folly::compression::EliasFanoEncoder::defaultNumLowerBits	.\experimental\EliasFanoCoding.h	/^  static uint8_t defaultNumLowerBits(size_t upperBound, size_t size) {$/;"	f	struct:folly::compression::EliasFanoEncoder	access:public	signature:(size_t upperBound, size_t size)
folly::compression::EliasFanoEncoder::encode	.\experimental\EliasFanoCoding.h	/^  static EliasFanoCompressedList encode(RandomAccessIterator begin,$/;"	f	struct:folly::compression::EliasFanoEncoder	access:public	signature:(RandomAccessIterator begin, RandomAccessIterator end)
folly::compression::EliasFanoEncoder::finish	.\experimental\EliasFanoCoding.h	/^  const EliasFanoCompressedList& finish() const {$/;"	f	struct:folly::compression::EliasFanoEncoder	access:public	signature:() const
folly::compression::EliasFanoEncoder::forwardPointers_	.\experimental\EliasFanoCoding.h	/^  SkipValueType* forwardPointers_ = nullptr;$/;"	m	struct:folly::compression::EliasFanoEncoder	access:private
folly::compression::EliasFanoEncoder::forwardQuantum	.\experimental\EliasFanoCoding.h	/^  static constexpr size_t forwardQuantum = kForwardQuantum;$/;"	m	struct:folly::compression::EliasFanoEncoder	access:public
folly::compression::EliasFanoEncoder::lastValue_	.\experimental\EliasFanoCoding.h	/^  ValueType lastValue_ = 0;$/;"	m	struct:folly::compression::EliasFanoEncoder	access:private
folly::compression::EliasFanoEncoder::lower_	.\experimental\EliasFanoCoding.h	/^  unsigned char* lower_ = nullptr;$/;"	m	struct:folly::compression::EliasFanoEncoder	access:private
folly::compression::EliasFanoEncoder::result_	.\experimental\EliasFanoCoding.h	/^  EliasFanoCompressedList result_;$/;"	m	struct:folly::compression::EliasFanoEncoder	access:private
folly::compression::EliasFanoEncoder::size_	.\experimental\EliasFanoCoding.h	/^  size_t size_ = 0;$/;"	m	struct:folly::compression::EliasFanoEncoder	access:private
folly::compression::EliasFanoEncoder::skipPointersSize_	.\experimental\EliasFanoCoding.h	/^  size_t skipPointersSize_ = 0;$/;"	m	struct:folly::compression::EliasFanoEncoder	access:private
folly::compression::EliasFanoEncoder::skipPointers_	.\experimental\EliasFanoCoding.h	/^  SkipValueType* skipPointers_ = nullptr;$/;"	m	struct:folly::compression::EliasFanoEncoder	access:private
folly::compression::EliasFanoEncoder::skipQuantum	.\experimental\EliasFanoCoding.h	/^  static constexpr size_t skipQuantum = kSkipQuantum;$/;"	m	struct:folly::compression::EliasFanoEncoder	access:public
folly::compression::EliasFanoEncoder::static_assert	.\experimental\EliasFanoCoding.h	/^  static_assert(std::is_integral<Value>::value &&$/;"	p	struct:folly::compression::EliasFanoEncoder	access:public	signature:(std::is_integral<Value>::value && std::is_unsigned<Value>::value, )
folly::compression::EliasFanoEncoder::upper_	.\experimental\EliasFanoCoding.h	/^  unsigned char* upper_ = nullptr;$/;"	m	struct:folly::compression::EliasFanoEncoder	access:private
folly::compression::EliasFanoEncoder::version	.\experimental\EliasFanoCoding.h	/^  static constexpr size_t version = kVersion;$/;"	m	struct:folly::compression::EliasFanoEncoder	access:public
folly::compression::EliasFanoEncoder::writeBits56	.\experimental\EliasFanoCoding.h	/^  static void writeBits56(unsigned char* data, size_t pos,$/;"	f	struct:folly::compression::EliasFanoEncoder	access:private	signature:(unsigned char* data, size_t pos, uint8_t len, uint64_t value)
folly::compression::EliasFanoReader	.\experimental\EliasFanoCoding.h	/^class EliasFanoReader : private boost::noncopyable {$/;"	c	namespace:folly::compression	inherits:boost::noncopyable
folly::compression::EliasFanoReader::EliasFanoReader	.\experimental\EliasFanoCoding.h	/^  explicit EliasFanoReader(const EliasFanoCompressedList& list)$/;"	f	class:folly::compression::EliasFanoReader	access:public	signature:(const EliasFanoCompressedList& list)
folly::compression::EliasFanoReader::EncoderType	.\experimental\EliasFanoCoding.h	/^  typedef Encoder EncoderType;$/;"	t	class:folly::compression::EliasFanoReader	access:public
folly::compression::EliasFanoReader::ValueType	.\experimental\EliasFanoCoding.h	/^  typedef typename Encoder::ValueType ValueType;$/;"	t	class:folly::compression::EliasFanoReader	access:public
folly::compression::EliasFanoReader::iterateTo	.\experimental\EliasFanoCoding.h	/^  void iterateTo(ValueType value) {$/;"	f	class:folly::compression::EliasFanoReader	access:private	signature:(ValueType value)
folly::compression::EliasFanoReader::jump	.\experimental\EliasFanoCoding.h	/^  bool jump(size_t n) {$/;"	f	class:folly::compression::EliasFanoReader	access:public	signature:(size_t n)
folly::compression::EliasFanoReader::jumpTo	.\experimental\EliasFanoCoding.h	/^  ValueType jumpTo(ValueType value) {$/;"	f	class:folly::compression::EliasFanoReader	access:public	signature:(ValueType value)
folly::compression::EliasFanoReader::lastValue_	.\experimental\EliasFanoCoding.h	/^  ValueType lastValue_;$/;"	m	class:folly::compression::EliasFanoReader	access:private
folly::compression::EliasFanoReader::list_	.\experimental\EliasFanoCoding.h	/^  const EliasFanoCompressedList list_;$/;"	m	class:folly::compression::EliasFanoReader	access:private
folly::compression::EliasFanoReader::lowerMask_	.\experimental\EliasFanoCoding.h	/^  const ValueType lowerMask_;$/;"	m	class:folly::compression::EliasFanoReader	access:private
folly::compression::EliasFanoReader::next	.\experimental\EliasFanoCoding.h	/^  bool next() {$/;"	f	class:folly::compression::EliasFanoReader	access:public	signature:()
folly::compression::EliasFanoReader::position	.\experimental\EliasFanoCoding.h	/^  size_t position() const { return progress_ - 1; }$/;"	f	class:folly::compression::EliasFanoReader	access:public	signature:() const
folly::compression::EliasFanoReader::progress_	.\experimental\EliasFanoCoding.h	/^  size_t progress_ = 0;$/;"	m	class:folly::compression::EliasFanoReader	access:private
folly::compression::EliasFanoReader::readLowerPart	.\experimental\EliasFanoCoding.h	/^  ValueType readLowerPart(size_t i) const {$/;"	f	class:folly::compression::EliasFanoReader	access:private	signature:(size_t i) const
folly::compression::EliasFanoReader::reset	.\experimental\EliasFanoCoding.h	/^  void reset() {$/;"	f	class:folly::compression::EliasFanoReader	access:public	signature:()
folly::compression::EliasFanoReader::size	.\experimental\EliasFanoCoding.h	/^  size_t size() const { return list_.size; }$/;"	f	class:folly::compression::EliasFanoReader	access:public	signature:() const
folly::compression::EliasFanoReader::skip	.\experimental\EliasFanoCoding.h	/^  bool skip(size_t n) {$/;"	f	class:folly::compression::EliasFanoReader	access:public	signature:(size_t n)
folly::compression::EliasFanoReader::skipTo	.\experimental\EliasFanoCoding.h	/^  bool skipTo(ValueType value) {$/;"	f	class:folly::compression::EliasFanoReader	access:public	signature:(ValueType value)
folly::compression::EliasFanoReader::upper_	.\experimental\EliasFanoCoding.h	/^  detail::UpperBitsReader<Encoder, Instructions> upper_;$/;"	m	class:folly::compression::EliasFanoReader	access:private
folly::compression::EliasFanoReader::value	.\experimental\EliasFanoCoding.h	/^  ValueType value() const { return value_; }$/;"	f	class:folly::compression::EliasFanoReader	access:public	signature:() const
folly::compression::EliasFanoReader::value_	.\experimental\EliasFanoCoding.h	/^  ValueType value_ = 0;$/;"	m	class:folly::compression::EliasFanoReader	access:private
folly::compression::bmJump	.\experimental\test\CodingTestUtils.h	/^void bmJump(const List& list, const std::vector<uint32_t>& data,$/;"	f	namespace:folly::compression	signature:(const List& list, const std::vector<uint32_t>& data, const std::vector<size_t>& order, size_t iters)
folly::compression::bmJumpTo	.\experimental\test\CodingTestUtils.h	/^void bmJumpTo(const List& list, const std::vector<uint32_t>& data,$/;"	f	namespace:folly::compression	signature:(const List& list, const std::vector<uint32_t>& data, const std::vector<size_t>& order, size_t iters)
folly::compression::bmNext	.\experimental\test\CodingTestUtils.h	/^void bmNext(const List& list, const std::vector<uint32_t>& data,$/;"	f	namespace:folly::compression	signature:(const List& list, const std::vector<uint32_t>& data, size_t iters)
folly::compression::bmSkip	.\experimental\test\CodingTestUtils.h	/^void bmSkip(const List& list, const std::vector<uint32_t>& data,$/;"	f	namespace:folly::compression	signature:(const List& list, const std::vector<uint32_t>& data, size_t skip, size_t iters)
folly::compression::bmSkipTo	.\experimental\test\CodingTestUtils.h	/^void bmSkipTo(const List& list, const std::vector<uint32_t>& data,$/;"	f	namespace:folly::compression	signature:(const List& list, const std::vector<uint32_t>& data, size_t skip, size_t iters)
folly::compression::detail	.\experimental\EliasFanoCoding.h	/^namespace detail {$/;"	n	namespace:folly::compression
folly::compression::detail::UpperBitsReader	.\experimental\EliasFanoCoding.h	/^class UpperBitsReader {$/;"	c	namespace:folly::compression::detail
folly::compression::detail::UpperBitsReader::SkipValueType	.\experimental\EliasFanoCoding.h	/^  typedef typename Encoder::SkipValueType SkipValueType;$/;"	t	class:folly::compression::detail::UpperBitsReader	access:private
folly::compression::detail::UpperBitsReader::UpperBitsReader	.\experimental\EliasFanoCoding.h	/^  explicit UpperBitsReader(const EliasFanoCompressedList& list)$/;"	f	class:folly::compression::detail::UpperBitsReader	access:public	signature:(const EliasFanoCompressedList& list)
folly::compression::detail::UpperBitsReader::ValueType	.\experimental\EliasFanoCoding.h	/^  typedef typename Encoder::ValueType ValueType;$/;"	t	class:folly::compression::detail::UpperBitsReader	access:public
folly::compression::detail::UpperBitsReader::block_	.\experimental\EliasFanoCoding.h	/^  block_t block_;$/;"	m	class:folly::compression::detail::UpperBitsReader	access:private
folly::compression::detail::UpperBitsReader::block_t	.\experimental\EliasFanoCoding.h	/^  typedef unsigned long long block_t;$/;"	t	class:folly::compression::detail::UpperBitsReader	access:private
folly::compression::detail::UpperBitsReader::forwardPointers_	.\experimental\EliasFanoCoding.h	/^  const unsigned char* const forwardPointers_;$/;"	m	class:folly::compression::detail::UpperBitsReader	access:private
folly::compression::detail::UpperBitsReader::inner_	.\experimental\EliasFanoCoding.h	/^  size_t inner_;  \/\/ Inner offset: (bit) position in current block.$/;"	m	class:folly::compression::detail::UpperBitsReader	access:private
folly::compression::detail::UpperBitsReader::jump	.\experimental\EliasFanoCoding.h	/^  ValueType jump(size_t n) {$/;"	f	class:folly::compression::detail::UpperBitsReader	access:public	signature:(size_t n)
folly::compression::detail::UpperBitsReader::jumpToNext	.\experimental\EliasFanoCoding.h	/^  ValueType jumpToNext(ValueType v) {$/;"	f	class:folly::compression::detail::UpperBitsReader	access:public	signature:(ValueType v)
folly::compression::detail::UpperBitsReader::next	.\experimental\EliasFanoCoding.h	/^  ValueType next() {$/;"	f	class:folly::compression::detail::UpperBitsReader	access:public	signature:()
folly::compression::detail::UpperBitsReader::outer_	.\experimental\EliasFanoCoding.h	/^  size_t outer_;  \/\/ Outer offset: number of consumed bytes in upper.$/;"	m	class:folly::compression::detail::UpperBitsReader	access:private
folly::compression::detail::UpperBitsReader::position	.\experimental\EliasFanoCoding.h	/^  size_t position() const { return position_; }$/;"	f	class:folly::compression::detail::UpperBitsReader	access:public	signature:() const
folly::compression::detail::UpperBitsReader::position_	.\experimental\EliasFanoCoding.h	/^  size_t position_;  \/\/ Index of current value (= #reads - 1).$/;"	m	class:folly::compression::detail::UpperBitsReader	access:private
folly::compression::detail::UpperBitsReader::reposition	.\experimental\EliasFanoCoding.h	/^  void reposition(size_t dest) {$/;"	f	class:folly::compression::detail::UpperBitsReader	access:private	signature:(size_t dest)
folly::compression::detail::UpperBitsReader::reset	.\experimental\EliasFanoCoding.h	/^  void reset() {$/;"	f	class:folly::compression::detail::UpperBitsReader	access:public	signature:()
folly::compression::detail::UpperBitsReader::setValue	.\experimental\EliasFanoCoding.h	/^  ValueType setValue() {$/;"	f	class:folly::compression::detail::UpperBitsReader	access:private	signature:()
folly::compression::detail::UpperBitsReader::skip	.\experimental\EliasFanoCoding.h	/^  ValueType skip(size_t n) {$/;"	f	class:folly::compression::detail::UpperBitsReader	access:public	signature:(size_t n)
folly::compression::detail::UpperBitsReader::skipPointers_	.\experimental\EliasFanoCoding.h	/^  const unsigned char* const skipPointers_;$/;"	m	class:folly::compression::detail::UpperBitsReader	access:private
folly::compression::detail::UpperBitsReader::skipToNext	.\experimental\EliasFanoCoding.h	/^  ValueType skipToNext(ValueType v) {$/;"	f	class:folly::compression::detail::UpperBitsReader	access:public	signature:(ValueType v)
folly::compression::detail::UpperBitsReader::start_	.\experimental\EliasFanoCoding.h	/^  const unsigned char* const start_;$/;"	m	class:folly::compression::detail::UpperBitsReader	access:private
folly::compression::detail::UpperBitsReader::value	.\experimental\EliasFanoCoding.h	/^  ValueType value() const { return value_; }$/;"	f	class:folly::compression::detail::UpperBitsReader	access:public	signature:() const
folly::compression::detail::UpperBitsReader::value_	.\experimental\EliasFanoCoding.h	/^  ValueType value_;$/;"	m	class:folly::compression::detail::UpperBitsReader	access:private
folly::compression::generateRandomList	.\experimental\test\CodingTestUtils.h	/^inline std::vector<uint32_t> generateRandomList(size_t n, uint32_t maxId) {$/;"	f	namespace:folly::compression	signature:(size_t n, uint32_t maxId)
folly::compression::generateRandomList	.\experimental\test\CodingTestUtils.h	/^std::vector<uint32_t> generateRandomList(size_t n, uint32_t maxId, URNG&& g) {$/;"	f	namespace:folly::compression	signature:(size_t n, uint32_t maxId, URNG&& g)
folly::compression::generateSeqList	.\experimental\test\CodingTestUtils.h	/^inline std::vector<uint32_t> generateSeqList(uint32_t minId, uint32_t maxId,$/;"	f	namespace:folly::compression	signature:(uint32_t minId, uint32_t maxId, uint32_t step = 1)
folly::compression::instructions	.\experimental\EliasFanoCoding.h	/^namespace instructions {$/;"	n	namespace:folly::compression
folly::compression::instructions::Default	.\experimental\EliasFanoCoding.h	/^struct Default {$/;"	s	namespace:folly::compression::instructions
folly::compression::instructions::Default::ctz	.\experimental\EliasFanoCoding.h	/^  static inline int ctz(uint64_t value) {$/;"	f	struct:folly::compression::instructions::Default	access:public	signature:(uint64_t value)
folly::compression::instructions::Default::popcount	.\experimental\EliasFanoCoding.h	/^  static inline uint64_t popcount(uint64_t value) {$/;"	f	struct:folly::compression::instructions::Default	access:public	signature:(uint64_t value)
folly::compression::instructions::Default::supported	.\experimental\EliasFanoCoding.h	/^  static bool supported() {$/;"	f	struct:folly::compression::instructions::Default	access:public	signature:()
folly::compression::instructions::Fast	.\experimental\EliasFanoCoding.h	/^struct Fast : public Default {$/;"	s	namespace:folly::compression::instructions	inherits:Default
folly::compression::instructions::Fast::popcount	.\experimental\EliasFanoCoding.h	/^  static inline uint64_t popcount(uint64_t value) {$/;"	f	struct:folly::compression::instructions::Fast	access:public	signature:(uint64_t value)
folly::compression::instructions::Fast::supported	.\experimental\EliasFanoCoding.h	/^  static bool supported() {$/;"	f	struct:folly::compression::instructions::Fast	access:public	signature:()
folly::compression::loadList	.\experimental\test\CodingTestUtils.h	/^inline std::vector<uint32_t> loadList(const std::string& filename) {$/;"	f	namespace:folly::compression	signature:(const std::string& filename)
folly::compression::testAll	.\experimental\test\CodingTestUtils.h	/^void testAll(const std::vector<uint32_t>& data) {$/;"	f	namespace:folly::compression	signature:(const std::vector<uint32_t>& data)
folly::compression::testEmpty	.\experimental\test\CodingTestUtils.h	/^void testEmpty() {$/;"	f	namespace:folly::compression	signature:()
folly::compression::testJump	.\experimental\test\CodingTestUtils.h	/^void testJump(const std::vector<uint32_t>& data, const List& list) {$/;"	f	namespace:folly::compression	signature:(const std::vector<uint32_t>& data, const List& list)
folly::compression::testJumpTo	.\experimental\test\CodingTestUtils.h	/^void testJumpTo(const std::vector<uint32_t>& data, const List& list) {$/;"	f	namespace:folly::compression	signature:(const std::vector<uint32_t>& data, const List& list)
folly::compression::testNext	.\experimental\test\CodingTestUtils.h	/^void testNext(const std::vector<uint32_t>& data, const List& list) {$/;"	f	namespace:folly::compression	signature:(const std::vector<uint32_t>& data, const List& list)
folly::compression::testSkip	.\experimental\test\CodingTestUtils.h	/^void testSkip(const std::vector<uint32_t>& data, const List& list) {$/;"	f	namespace:folly::compression	signature:(const std::vector<uint32_t>& data, const List& list)
folly::compression::testSkip	.\experimental\test\CodingTestUtils.h	/^void testSkip(const std::vector<uint32_t>& data, const List& list,$/;"	f	namespace:folly::compression	signature:(const std::vector<uint32_t>& data, const List& list, size_t skipStep)
folly::compression::testSkipTo	.\experimental\test\CodingTestUtils.h	/^void testSkipTo(const std::vector<uint32_t>& data, const List& list) {$/;"	f	namespace:folly::compression	signature:(const std::vector<uint32_t>& data, const List& list)
folly::compression::testSkipTo	.\experimental\test\CodingTestUtils.h	/^void testSkipTo(const std::vector<uint32_t>& data, const List& list,$/;"	f	namespace:folly::compression	signature:(const std::vector<uint32_t>& data, const List& list, size_t skipToStep)
folly::convertTo	.\DynamicConverter.h	/^  template <typename T> T convertTo(const dynamic&);$/;"	p	namespace:folly	signature:(const dynamic&)
folly::convertTo	.\DynamicConverter.h	/^T convertTo(const dynamic& d) {$/;"	f	namespace:folly	signature:(const dynamic& d)
folly::crc32c	.\Checksum.cpp	/^uint32_t crc32c(const uint8_t *data, size_t nbytes,$/;"	f	namespace:folly	signature:(const uint8_t *data, size_t nbytes, uint32_t startingChecksum)
folly::crc32c	.\Checksum.h	/^uint32_t crc32c(const uint8_t* data, size_t nbytes,$/;"	p	namespace:folly	signature:(const uint8_t* data, size_t nbytes, uint32_t startingChecksum = ~0U)
folly::decodeVarint	.\Varint.h	/^inline uint64_t decodeVarint(ByteRange& data) {$/;"	f	namespace:folly	signature:(ByteRange& data)
folly::decodeVarint	.\Varint.h	/^uint64_t decodeVarint(ByteRange& data);$/;"	p	namespace:folly	signature:(ByteRange& data)
folly::decodeZigZag	.\Varint.h	/^inline int64_t decodeZigZag(uint64_t val) {$/;"	f	namespace:folly	signature:(uint64_t val)
folly::defaultContext	.\io\async\Request.cpp	/^RequestContext* defaultContext;$/;"	m	namespace:folly	file:
folly::demangle	.\Demangle.cpp	/^fbstring demangle(const char* name) {$/;"	f	namespace:folly	signature:(const char* name)
folly::demangle	.\Demangle.cpp	/^size_t demangle(const char* name, char* out, size_t outSize) {$/;"	f	namespace:folly	signature:(const char* name, char* out, size_t outSize)
folly::demangle	.\Demangle.h	/^fbstring demangle(const char* name);$/;"	p	namespace:folly	signature:(const char* name)
folly::demangle	.\Demangle.h	/^inline fbstring demangle(const std::type_info& type) {$/;"	f	namespace:folly	signature:(const std::type_info& type)
folly::demangle	.\Demangle.h	/^inline size_t demangle(const std::type_info& type, char* buf, size_t bufSize) {$/;"	f	namespace:folly	signature:(const std::type_info& type, char* buf, size_t bufSize)
folly::demangle	.\Demangle.h	/^size_t demangle(const char* name, char* buf, size_t bufSize);$/;"	p	namespace:folly	signature:(const char* name, char* buf, size_t bufSize)
folly::density	.\Benchmark.cpp	/^static double density(const double * begin, const double *const end,$/;"	f	namespace:folly	signature:(const double * begin, const double *const end, const double where, const double bandwidth)
folly::detail	.\ApplyTuple.h	/^namespace detail {$/;"	n	namespace:folly
folly::detail	.\AtomicStruct.h	/^namespace detail {$/;"	n	namespace:folly
folly::detail	.\Benchmark.h	/^namespace detail {$/;"	n	namespace:folly
folly::detail	.\Bits.cpp	/^namespace detail {$/;"	n	namespace:folly	file:
folly::detail	.\Checksum.cpp	/^namespace detail {$/;"	n	namespace:folly	file:
folly::detail	.\ConcurrentSkipList-inl.h	/^namespace folly { namespace detail {$/;"	n	namespace:folly
folly::detail	.\Conv.cpp	/^namespace detail {$/;"	n	namespace:folly	file:
folly::detail	.\Conv.h	/^namespace detail {$/;"	n	namespace:folly
folly::detail	.\Fingerprint.h	/^namespace detail {$/;"	n	namespace:folly
folly::detail	.\Foreach.h	/^namespace folly { namespace detail {$/;"	n	namespace:folly
folly::detail	.\Format-inl.h	/^namespace detail {$/;"	n	namespace:folly
folly::detail	.\Format.cpp	/^namespace detail {$/;"	n	namespace:folly	file:
folly::detail	.\Format.h	/^namespace detail {$/;"	n	namespace:folly
folly::detail	.\GroupVarint.h	/^namespace detail {$/;"	n	namespace:folly
folly::detail	.\IndexedMemPool.h	/^namespace detail {$/;"	n	namespace:folly
folly::detail	.\Lazy.h	/^namespace detail {$/;"	n	namespace:folly
folly::detail	.\LifoSem.h	/^namespace detail {$/;"	n	namespace:folly
folly::detail	.\MPMCQueue.h	/^namespace detail {$/;"	n	namespace:folly
folly::detail	.\Optional.h	/^namespace detail { struct NoneHelper {}; }$/;"	n	namespace:folly
folly::detail	.\RWSpinLock.h	/^namespace detail {$/;"	n	namespace:folly
folly::detail	.\Random-inl.h	/^namespace detail {$/;"	n	namespace:folly
folly::detail	.\Range.cpp	/^namespace detail {$/;"	n	namespace:folly	file:
folly::detail	.\Range.h	/^namespace detail {$/;"	n	namespace:folly
folly::detail	.\SafeAssert.cpp	/^namespace folly { namespace detail {$/;"	n	namespace:folly	file:
folly::detail	.\SafeAssert.h	/^namespace folly { namespace detail {$/;"	n	namespace:folly
folly::detail	.\ScopeGuard.h	/^namespace detail {$/;"	n	namespace:folly
folly::detail	.\SmallLocks.h	/^namespace detail {$/;"	n	namespace:folly
folly::detail	.\String-inl.h	/^namespace detail {$/;"	n	namespace:folly
folly::detail	.\String.cpp	/^namespace detail {$/;"	n	namespace:folly	file:
folly::detail	.\Synchronized.h	/^namespace detail {$/;"	n	namespace:folly
folly::detail	.\Traits.h	/^namespace detail {$/;"	n	namespace:folly
folly::detail	.\Version.cpp	/^namespace folly { namespace detail {$/;"	n	namespace:folly	file:
folly::detail	.\detail\BitsDetail.h	/^namespace detail {$/;"	n	namespace:folly
folly::detail	.\detail\CacheLocality.cpp	/^namespace folly { namespace detail {$/;"	n	namespace:folly	file:
folly::detail	.\detail\CacheLocality.h	/^namespace folly { namespace detail {$/;"	n	namespace:folly
folly::detail	.\detail\ChecksumDetail.h	/^namespace folly { namespace detail {$/;"	n	namespace:folly
folly::detail	.\detail\ExceptionWrapper.h	/^namespace folly { namespace detail {$/;"	n	namespace:folly
folly::detail	.\detail\FingerprintPolynomial.h	/^namespace detail {$/;"	n	namespace:folly
folly::detail	.\detail\Futex.cpp	/^namespace folly { namespace detail {$/;"	n	namespace:folly	file:
folly::detail	.\detail\Futex.h	/^namespace folly { namespace detail {$/;"	n	namespace:folly
folly::detail	.\detail\GroupVarintDetail.h	/^namespace detail {$/;"	n	namespace:folly
folly::detail	.\detail\IPAddress.h	/^namespace folly { namespace detail {$/;"	n	namespace:folly
folly::detail	.\detail\MPMCPipelineDetail.h	/^namespace detail {$/;"	n	namespace:folly
folly::detail	.\detail\MemoryIdler.cpp	/^namespace folly { namespace detail {$/;"	n	namespace:folly	file:
folly::detail	.\detail\MemoryIdler.h	/^namespace folly { namespace detail {$/;"	n	namespace:folly
folly::detail	.\detail\SlowFingerprint.h	/^namespace detail {$/;"	n	namespace:folly
folly::detail	.\detail\Stats.h	/^namespace folly { namespace detail {$/;"	n	namespace:folly
folly::detail	.\detail\UncaughtExceptionCounter.h	/^namespace folly { namespace detail {$/;"	n	namespace:folly
folly::detail	.\dynamic-inl.h	/^namespace detail {$/;"	n	namespace:folly
folly::detail	.\experimental\Bits.h	/^namespace detail {$/;"	n	namespace:folly
folly::detail	.\experimental\EventCount.h	/^namespace detail {$/;"	n	namespace:folly
folly::detail	.\experimental\Singleton.h	/^namespace detail {$/;"	n	namespace:folly
folly::detail	.\io\IOBuf.h	/^namespace detail {$/;"	n	namespace:folly
folly::detail	.\small_vector.h	/^namespace detail {$/;"	n	namespace:folly
folly::detail	.\sorted_vector_types.h	/^namespace detail {$/;"	n	namespace:folly
folly::detail	.\stats\Histogram-defs.h	/^namespace detail {$/;"	n	namespace:folly
folly::detail	.\stats\Histogram.h	/^namespace detail {$/;"	n	namespace:folly
folly::detail	.\test\DeterministicSchedule.cpp	/^namespace folly { namespace detail {$/;"	n	namespace:folly	file:
folly::detail	.\test\MemoryIdlerTest.cpp	/^namespace folly { namespace detail {$/;"	n	namespace:folly	file:
folly::detail	.\test\RangeFindBenchmark.cpp	/^namespace folly { namespace detail {$/;"	n	namespace:folly	file:
folly::detail	.\test\RangeTest.cpp	/^namespace folly { namespace detail {$/;"	n	namespace:folly	file:
folly::detail::AccessSpreader	.\detail\CacheLocality.h	/^struct AccessSpreader {$/;"	s	namespace:folly::detail
folly::detail::AccessSpreader::AccessSpreader	.\detail\CacheLocality.h	/^  explicit AccessSpreader(size_t spreaderNumStripes,$/;"	f	struct:folly::detail::AccessSpreader	access:public	signature:(size_t spreaderNumStripes, const CacheLocality& cacheLocality = CacheLocality::system<Atom>(), Getcpu::Func getcpuFunc = nullptr)
folly::detail::AccessSpreader::CompactStripe	.\detail\CacheLocality.h	/^  typedef uint8_t CompactStripe;$/;"	t	struct:folly::detail::AccessSpreader	access:private
folly::detail::AccessSpreader::current	.\detail\CacheLocality.h	/^  size_t current() const {$/;"	f	struct:folly::detail::AccessSpreader	access:public	signature:() const
folly::detail::AccessSpreader::current	.\detail\CacheLocality.h	/^  static size_t current(size_t numStripes) {$/;"	f	struct:folly::detail::AccessSpreader	access:public	signature:(size_t numStripes)
folly::detail::AccessSpreader::getcpuFunc_	.\detail\CacheLocality.h	/^  Getcpu::Func getcpuFunc_;$/;"	m	struct:folly::detail::AccessSpreader	access:private
folly::detail::AccessSpreader::kMaxCpus	.\detail\CacheLocality.h	/^  enum { kMaxCpus = 128 };$/;"	e	enum:folly::detail::AccessSpreader::__anon12
folly::detail::AccessSpreader::numStripes	.\detail\CacheLocality.h	/^  size_t numStripes() const {$/;"	f	struct:folly::detail::AccessSpreader	access:public	signature:() const
folly::detail::AccessSpreader::numStripes_	.\detail\CacheLocality.h	/^  size_t numStripes_;$/;"	m	struct:folly::detail::AccessSpreader	access:private
folly::detail::AccessSpreader::pickGetcpuFunc	.\detail\CacheLocality.cpp	/^Getcpu::Func AccessSpreader<std::atomic>::pickGetcpuFunc(size_t numStripes) {$/;"	f	class:folly::detail::AccessSpreader	signature:(size_t numStripes)
folly::detail::AccessSpreader::pickGetcpuFunc	.\detail\CacheLocality.h	/^  static Getcpu::Func pickGetcpuFunc(size_t numStripes);$/;"	p	struct:folly::detail::AccessSpreader	access:private	signature:(size_t numStripes)
folly::detail::AccessSpreader::pickGetcpuFunc	.\test\DeterministicSchedule.cpp	/^AccessSpreader<test::DeterministicAtomic>::pickGetcpuFunc(size_t numStripes) {$/;"	f	class:folly::detail::AccessSpreader	signature:(size_t numStripes)
folly::detail::AccessSpreader::shared	.\detail\CacheLocality.h	/^  static const AccessSpreader& shared(size_t numStripes) {$/;"	f	struct:folly::detail::AccessSpreader	access:public	signature:(size_t numStripes)
folly::detail::AccessSpreader::static_assert	.\detail\CacheLocality.h	/^  static_assert((kMaxCpus & (kMaxCpus - 1)) == 0,$/;"	p	struct:folly::detail::AccessSpreader	access:private	signature:(kMaxCpus & (kMaxCpus - 1)) == 0, 
folly::detail::AccessSpreader::stripeByChip	.\detail\CacheLocality.h	/^  static const AccessSpreader stripeByChip;$/;"	m	struct:folly::detail::AccessSpreader	access:public
folly::detail::AccessSpreader::stripeByCore	.\detail\CacheLocality.h	/^  static const AccessSpreader stripeByCore;$/;"	m	struct:folly::detail::AccessSpreader	access:public
folly::detail::AccessSpreader::stripeByCpu	.\detail\CacheLocality.h	/^  CompactStripe stripeByCpu[kMaxCpus];$/;"	m	struct:folly::detail::AccessSpreader	access:private
folly::detail::AccessSpreaderArray	.\detail\CacheLocality.h	/^struct AccessSpreaderArray {$/;"	s	namespace:folly::detail
folly::detail::AccessSpreaderArray	.\detail\CacheLocality.h	/^struct AccessSpreaderArray;$/;"	x
folly::detail::AccessSpreaderArray::AccessSpreaderArray	.\detail\CacheLocality.h	/^  AccessSpreaderArray() {$/;"	f	struct:folly::detail::AccessSpreaderArray	access:public	signature:()
folly::detail::AccessSpreaderArray::operator []	.\detail\CacheLocality.h	/^  AccessSpreader<Atom> const& operator[] (size_t index) const {$/;"	f	struct:folly::detail::AccessSpreaderArray	access:public	signature:(size_t index) const
folly::detail::AccessSpreaderArray::raw	.\detail\CacheLocality.h	/^      raw[kMaxStripe + 1];$/;"	m	struct:folly::detail::AccessSpreaderArray	access:private
folly::detail::AccessSpreaderArray::sharedInstance	.\detail\CacheLocality.cpp	/^AccessSpreaderArray<std::atomic,128>::sharedInstance = {};$/;"	m	class:folly::detail::AccessSpreaderArray	file:
folly::detail::AccessSpreaderArray::sharedInstance	.\detail\CacheLocality.h	/^  static AccessSpreaderArray<Atom,kMaxStripe> sharedInstance;$/;"	m	struct:folly::detail::AccessSpreaderArray	access:private
folly::detail::AccessSpreaderArray::sharedInstance	.\test\DeterministicSchedule.cpp	/^AccessSpreaderArray<test::DeterministicAtomic,128>::sharedInstance = {};$/;"	m	class:folly::detail::AccessSpreaderArray	file:
folly::detail::AccessSpreaderArray::~AccessSpreaderArray	.\detail\CacheLocality.h	/^  ~AccessSpreaderArray() {$/;"	f	struct:folly::detail::AccessSpreaderArray	access:public	signature:()
folly::detail::AmplificationProduct	.\detail\MPMCPipelineDetail.h	/^struct AmplificationProduct<std::tuple<T, Ts...>> {$/;"	s	namespace:folly::detail
folly::detail::AmplificationProduct	.\detail\MPMCPipelineDetail.h	/^template <> struct AmplificationProduct<std::tuple<>> {$/;"	s	namespace:folly::detail
folly::detail::AmplificationProduct	.\detail\MPMCPipelineDetail.h	/^template <class Tuple> struct AmplificationProduct;$/;"	x
folly::detail::AmplificationProduct::value	.\detail\MPMCPipelineDetail.h	/^  static constexpr size_t value = 1;$/;"	m	struct:folly::detail::AmplificationProduct	access:public
folly::detail::AmplificationProduct::value	.\detail\MPMCPipelineDetail.h	/^  static constexpr size_t value =$/;"	m	struct:folly::detail::AmplificationProduct	access:public
folly::detail::AtomicStructIntPick	.\AtomicStruct.h	/^template <> struct AtomicStructIntPick<1> { typedef uint8_t type; };$/;"	s	namespace:folly::detail
folly::detail::AtomicStructIntPick	.\AtomicStruct.h	/^template <> struct AtomicStructIntPick<2> { typedef uint16_t type; };$/;"	s	namespace:folly::detail
folly::detail::AtomicStructIntPick	.\AtomicStruct.h	/^template <> struct AtomicStructIntPick<3> { typedef uint32_t type; };$/;"	s	namespace:folly::detail
folly::detail::AtomicStructIntPick	.\AtomicStruct.h	/^template <> struct AtomicStructIntPick<4> { typedef uint32_t type; };$/;"	s	namespace:folly::detail
folly::detail::AtomicStructIntPick	.\AtomicStruct.h	/^template <> struct AtomicStructIntPick<5> { typedef uint64_t type; };$/;"	s	namespace:folly::detail
folly::detail::AtomicStructIntPick	.\AtomicStruct.h	/^template <> struct AtomicStructIntPick<6> { typedef uint64_t type; };$/;"	s	namespace:folly::detail
folly::detail::AtomicStructIntPick	.\AtomicStruct.h	/^template <> struct AtomicStructIntPick<7> { typedef uint64_t type; };$/;"	s	namespace:folly::detail
folly::detail::AtomicStructIntPick	.\AtomicStruct.h	/^template <> struct AtomicStructIntPick<8> { typedef uint64_t type; };$/;"	s	namespace:folly::detail
folly::detail::AtomicStructIntPick	.\AtomicStruct.h	/^template <int N> struct AtomicStructIntPick {};$/;"	s	namespace:folly::detail
folly::detail::AtomicStructIntPick::type	.\AtomicStruct.h	/^template <> struct AtomicStructIntPick<1> { typedef uint8_t type; };$/;"	t	struct:folly::detail::AtomicStructIntPick	access:public
folly::detail::AtomicStructIntPick::type	.\AtomicStruct.h	/^template <> struct AtomicStructIntPick<2> { typedef uint16_t type; };$/;"	t	struct:folly::detail::AtomicStructIntPick	access:public
folly::detail::AtomicStructIntPick::type	.\AtomicStruct.h	/^template <> struct AtomicStructIntPick<3> { typedef uint32_t type; };$/;"	t	struct:folly::detail::AtomicStructIntPick	access:public
folly::detail::AtomicStructIntPick::type	.\AtomicStruct.h	/^template <> struct AtomicStructIntPick<4> { typedef uint32_t type; };$/;"	t	struct:folly::detail::AtomicStructIntPick	access:public
folly::detail::AtomicStructIntPick::type	.\AtomicStruct.h	/^template <> struct AtomicStructIntPick<5> { typedef uint64_t type; };$/;"	t	struct:folly::detail::AtomicStructIntPick	access:public
folly::detail::AtomicStructIntPick::type	.\AtomicStruct.h	/^template <> struct AtomicStructIntPick<6> { typedef uint64_t type; };$/;"	t	struct:folly::detail::AtomicStructIntPick	access:public
folly::detail::AtomicStructIntPick::type	.\AtomicStruct.h	/^template <> struct AtomicStructIntPick<7> { typedef uint64_t type; };$/;"	t	struct:folly::detail::AtomicStructIntPick	access:public
folly::detail::AtomicStructIntPick::type	.\AtomicStruct.h	/^template <> struct AtomicStructIntPick<8> { typedef uint64_t type; };$/;"	t	struct:folly::detail::AtomicStructIntPick	access:public
folly::detail::BitsTraits	.\experimental\Bits.h	/^struct BitsTraits;$/;"	x
folly::detail::BitsTraits	.\experimental\Bits.h	/^struct BitsTraits<T, typename std::enable_if<$/;"	s	namespace:folly::detail
folly::detail::BitsTraits	.\experimental\Bits.h	/^struct BitsTraits<Unaligned<T>, typename std::enable_if<$/;"	s	namespace:folly::detail
folly::detail::BitsTraits	.\experimental\Bits.h	/^struct BitsTraits<UnalignedNoASan<T>, typename std::enable_if<$/;"	s	namespace:folly::detail
folly::detail::BitsTraits::UnderlyingType	.\experimental\Bits.h	/^  typedef T UnderlyingType;$/;"	t	struct:folly::detail::BitsTraits	access:public
folly::detail::BitsTraits::load	.\experimental\Bits.h	/^  load(const UnalignedNoASan<T>& x) { return x.value; }$/;"	f	struct:folly::detail::BitsTraits	access:public	signature:(const UnalignedNoASan<T>& x)
folly::detail::BitsTraits::load	.\experimental\Bits.h	/^  static T load(const T& x) { return x; }$/;"	f	struct:folly::detail::BitsTraits	access:public	signature:(const T& x)
folly::detail::BitsTraits::load	.\experimental\Bits.h	/^  static T load(const Unaligned<T>& x) { return x.value; }$/;"	f	struct:folly::detail::BitsTraits	access:public	signature:(const Unaligned<T>& x)
folly::detail::BitsTraits::loadRMW	.\experimental\Bits.h	/^  loadRMW(const UnalignedNoASan<T>& x) {$/;"	f	struct:folly::detail::BitsTraits	access:public	signature:(const UnalignedNoASan<T>& x)
folly::detail::BitsTraits::loadRMW	.\experimental\Bits.h	/^  static T loadRMW(const T& x) {$/;"	f	struct:folly::detail::BitsTraits	access:public	signature:(const T& x)
folly::detail::BitsTraits::loadRMW	.\experimental\Bits.h	/^  static T loadRMW(const Unaligned<T>& x) {$/;"	f	struct:folly::detail::BitsTraits	access:public	signature:(const Unaligned<T>& x)
folly::detail::BitsTraits::store	.\experimental\Bits.h	/^  static void store(T& x, T v) { x = v; }$/;"	f	struct:folly::detail::BitsTraits	access:public	signature:(T& x, T v)
folly::detail::BitsTraits::store	.\experimental\Bits.h	/^  static void store(Unaligned<T>& x, T v) { x.value = v; }$/;"	f	struct:folly::detail::BitsTraits	access:public	signature:(Unaligned<T>& x, T v)
folly::detail::BitsTraits::store	.\experimental\Bits.h	/^  store(UnalignedNoASan<T>& x, T v) { x.value = v; }$/;"	f	struct:folly::detail::BitsTraits	access:public	signature:(UnalignedNoASan<T>& x, T v)
folly::detail::Bucket	.\detail\Stats.h	/^struct Bucket {$/;"	s	namespace:folly::detail
folly::detail::Bucket::Bucket	.\detail\Stats.h	/^  Bucket()$/;"	f	struct:folly::detail::Bucket	access:public	signature:()
folly::detail::Bucket::ValueType	.\detail\Stats.h	/^  typedef T ValueType;$/;"	t	struct:folly::detail::Bucket	access:public
folly::detail::Bucket::add	.\detail\Stats.h	/^  void add(const ValueType& s, uint64_t c) {$/;"	f	struct:folly::detail::Bucket	access:public	signature:(const ValueType& s, uint64_t c)
folly::detail::Bucket::avg	.\detail\Stats.h	/^  ReturnType avg() const {$/;"	f	struct:folly::detail::Bucket	access:public	signature:() const
folly::detail::Bucket::clear	.\detail\Stats.h	/^  void clear() {$/;"	f	struct:folly::detail::Bucket	access:public	signature:()
folly::detail::Bucket::count	.\detail\Stats.h	/^  uint64_t count;$/;"	m	struct:folly::detail::Bucket	access:public
folly::detail::Bucket::operator +=	.\detail\Stats.h	/^  Bucket& operator+=(const Bucket& o) {$/;"	f	struct:folly::detail::Bucket	access:public	signature:(const Bucket& o)
folly::detail::Bucket::operator -=	.\detail\Stats.h	/^  Bucket& operator-=(const Bucket& o) {$/;"	f	struct:folly::detail::Bucket	access:public	signature:(const Bucket& o)
folly::detail::Bucket::sum	.\detail\Stats.h	/^  ValueType sum;$/;"	m	struct:folly::detail::Bucket	access:public
folly::detail::Bytes	.\detail\IPAddress.h	/^struct Bytes : private boost::noncopyable {$/;"	s	namespace:folly::detail	inherits:boost::noncopyable
folly::detail::Bytes::Bytes	.\detail\IPAddress.h	/^  Bytes() = delete;$/;"	p	struct:folly::detail::Bytes	access:private	signature:()
folly::detail::Bytes::isZero	.\detail\IPAddress.h	/^  static bool isZero(const uint8_t* src, std::size_t len) {$/;"	f	struct:folly::detail::Bytes	access:public	signature:(const uint8_t* src, std::size_t len)
folly::detail::Bytes::longestCommonPrefix	.\detail\IPAddress.h	/^  longestCommonPrefix($/;"	f	struct:folly::detail::Bytes	access:public	signature:( const std::array<uint8_t, N>& one, uint8_t oneMask, const std::array<uint8_t, N>& two, uint8_t twoMask)
folly::detail::Bytes::mask	.\detail\IPAddress.h	/^  static std::array<uint8_t, N> mask(const std::array<uint8_t, N>& a,$/;"	f	struct:folly::detail::Bytes	access:public	signature:(const std::array<uint8_t, N>& a, const std::array<uint8_t, N>& b)
folly::detail::Bytes::mkAddress4	.\detail\IPAddress.h	/^  static inline in_addr mkAddress4(const uint8_t* src) {$/;"	f	struct:folly::detail::Bytes	access:public	signature:(const uint8_t* src)
folly::detail::Bytes::mkAddress6	.\detail\IPAddress.h	/^  static inline in6_addr mkAddress6(const uint8_t* src) {$/;"	f	struct:folly::detail::Bytes	access:public	signature:(const uint8_t* src)
folly::detail::Bytes::toHex	.\detail\IPAddress.h	/^  static std::string toHex(const uint8_t* src, std::size_t len) {$/;"	f	struct:folly::detail::Bytes	access:public	signature:(const uint8_t* src, std::size_t len)
folly::detail::Bytes::~Bytes	.\detail\IPAddress.h	/^  ~Bytes() = delete;$/;"	p	struct:folly::detail::Bytes	access:private	signature:()
folly::detail::CacheLocality	.\detail\CacheLocality.h	/^struct CacheLocality {$/;"	s	namespace:folly::detail
folly::detail::CacheLocality::kFalseSharingRange	.\detail\CacheLocality.h	/^    kFalseSharingRange = 128$/;"	e	enum:folly::detail::CacheLocality::__anon11
folly::detail::CacheLocality::localityIndexByCpu	.\detail\CacheLocality.h	/^  std::vector<size_t> localityIndexByCpu;$/;"	m	struct:folly::detail::CacheLocality	access:public
folly::detail::CacheLocality::numCachesByLevel	.\detail\CacheLocality.h	/^  std::vector<size_t> numCachesByLevel;$/;"	m	struct:folly::detail::CacheLocality	access:public
folly::detail::CacheLocality::numCpus	.\detail\CacheLocality.h	/^  size_t numCpus;$/;"	m	struct:folly::detail::CacheLocality	access:public
folly::detail::CacheLocality::readFromSysfs	.\detail\CacheLocality.cpp	/^CacheLocality CacheLocality::readFromSysfs() {$/;"	f	class:folly::detail::CacheLocality	signature:()
folly::detail::CacheLocality::readFromSysfs	.\detail\CacheLocality.h	/^  static CacheLocality readFromSysfs();$/;"	p	struct:folly::detail::CacheLocality	access:public	signature:()
folly::detail::CacheLocality::readFromSysfsTree	.\detail\CacheLocality.cpp	/^CacheLocality CacheLocality::readFromSysfsTree($/;"	f	class:folly::detail::CacheLocality	signature:( const std::function<std::string(std::string)>& mapping)
folly::detail::CacheLocality::readFromSysfsTree	.\detail\CacheLocality.h	/^  static CacheLocality readFromSysfsTree($/;"	p	struct:folly::detail::CacheLocality	access:public	signature:( const std::function<std::string(std::string)>& mapping)
folly::detail::CacheLocality::static_assert	.\detail\CacheLocality.h	/^  static_assert(kFalseSharingRange == 128,$/;"	p	struct:folly::detail::CacheLocality	access:public	signature:(kFalseSharingRange == 128, )
folly::detail::CacheLocality::system	.\detail\CacheLocality.cpp	/^const CacheLocality& CacheLocality::system<std::atomic>() {$/;"	f	class:folly::detail::CacheLocality	signature:()
folly::detail::CacheLocality::system	.\detail\CacheLocality.h	/^  static const CacheLocality& system();$/;"	p	struct:folly::detail::CacheLocality	access:public	signature:()
folly::detail::CacheLocality::system	.\test\DeterministicSchedule.cpp	/^CacheLocality const& CacheLocality::system<test::DeterministicAtomic>() {$/;"	f	class:folly::detail::CacheLocality	signature:()
folly::detail::CacheLocality::uniform	.\detail\CacheLocality.cpp	/^CacheLocality CacheLocality::uniform(size_t numCpus) {$/;"	f	class:folly::detail::CacheLocality	signature:(size_t numCpus)
folly::detail::CacheLocality::uniform	.\detail\CacheLocality.h	/^  static CacheLocality uniform(size_t numCpus);$/;"	p	struct:folly::detail::CacheLocality	access:public	signature:(size_t numCpus)
folly::detail::Clock	.\Benchmark.h	/^enum Clock { DEFAULT_CLOCK_ID = CLOCK_REALTIME };$/;"	g	namespace:folly::detail
folly::detail::ComparableAsStringPiece	.\Range.h	/^struct ComparableAsStringPiece {$/;"	s	namespace:folly::detail
folly::detail::ComparableAsStringPiece::value	.\Range.h	/^    value =$/;"	e	enum:folly::detail::ComparableAsStringPiece::__anon84
folly::detail::ConversionHelper	.\dynamic-inl.h	/^  struct ConversionHelper<$/;"	s	namespace:folly::detail
folly::detail::ConversionHelper	.\dynamic-inl.h	/^  template<class T, class Enable = void> struct ConversionHelper;$/;"	x
folly::detail::ConversionHelper::type	.\dynamic-inl.h	/^    typedef T type;$/;"	t	struct:folly::detail::ConversionHelper	access:public
folly::detail::ConversionHelper::type	.\dynamic-inl.h	/^    typedef int64_t type;$/;"	t	struct:folly::detail::ConversionHelper	access:public
folly::detail::ConversionHelper::type	.\dynamic-inl.h	/^    typedef void* type;$/;"	t	struct:folly::detail::ConversionHelper	access:public
folly::detail::DEFAULT_CLOCK_ID	.\Benchmark.h	/^enum Clock { DEFAULT_CLOCK_ID = CLOCK_REALTIME };$/;"	e	enum:folly::detail::Clock
folly::detail::DerefSize	.\ApplyTuple.h	/^struct DerefSize$/;"	s	namespace:folly::detail	inherits:std::tuple_size
folly::detail::Destroy	.\dynamic-inl.h	/^  struct Destroy {$/;"	s	namespace:folly::detail
folly::detail::Destroy::destroy	.\dynamic-inl.h	/^    template<class T> static void destroy(T* t) { t->~T(); }$/;"	f	struct:folly::detail::Destroy	access:public	signature:(T* t)
folly::detail::ExprDoUnpack	.\ApplyTuple.h	/^template<class Tuple, class ...Unpacked> struct ExprDoUnpack {$/;"	s	namespace:folly::detail
folly::detail::ExprDoUnpack::value	.\ApplyTuple.h	/^    value = sizeof...(Unpacked) < DerefSize<Tuple>::value$/;"	e	enum:folly::detail::ExprDoUnpack::__anon1
folly::detail::FOLLY_DISABLE_ADDRESS_SANITIZER	.\Range.cpp	/^  FOLLY_DISABLE_ADDRESS_SANITIZER;$/;"	m	namespace:folly::detail	file:
folly::detail::FingerprintPolynomial	.\detail\FingerprintPolynomial.h	/^class FingerprintPolynomial {$/;"	c	namespace:folly::detail
folly::detail::FingerprintPolynomial::FingerprintPolynomial	.\detail\FingerprintPolynomial.h	/^  FingerprintPolynomial() {$/;"	f	class:folly::detail::FingerprintPolynomial	access:public	signature:()
folly::detail::FingerprintPolynomial::FingerprintPolynomial	.\detail\FingerprintPolynomial.h	/^  explicit FingerprintPolynomial(const uint64_t* vals) {$/;"	f	class:folly::detail::FingerprintPolynomial	access:public	signature:(const uint64_t* vals)
folly::detail::FingerprintPolynomial::add	.\detail\FingerprintPolynomial.h	/^  void add(const FingerprintPolynomial<DEG>& other) {$/;"	f	class:folly::detail::FingerprintPolynomial	access:public	signature:(const FingerprintPolynomial<DEG>& other)
folly::detail::FingerprintPolynomial::addXk	.\detail\FingerprintPolynomial.h	/^  void addXk(int k) {$/;"	f	class:folly::detail::FingerprintPolynomial	access:public	signature:(int k)
folly::detail::FingerprintPolynomial::mulX	.\detail\FingerprintPolynomial.h	/^  void mulX() {$/;"	f	class:folly::detail::FingerprintPolynomial	access:public	signature:()
folly::detail::FingerprintPolynomial::mulXkmod	.\detail\FingerprintPolynomial.h	/^  void mulXkmod(int k, const FingerprintPolynomial<DEG>& p) {$/;"	f	class:folly::detail::FingerprintPolynomial	access:public	signature:(int k, const FingerprintPolynomial<DEG>& p)
folly::detail::FingerprintPolynomial::mulXmod	.\detail\FingerprintPolynomial.h	/^  void mulXmod(const FingerprintPolynomial<DEG>& p) {$/;"	f	class:folly::detail::FingerprintPolynomial	access:public	signature:(const FingerprintPolynomial<DEG>& p)
folly::detail::FingerprintPolynomial::setHigh8Bits	.\detail\FingerprintPolynomial.h	/^  void setHigh8Bits(uint8_t val) {$/;"	f	class:folly::detail::FingerprintPolynomial	access:public	signature:(uint8_t val)
folly::detail::FingerprintPolynomial::size	.\detail\FingerprintPolynomial.h	/^  static int size() {$/;"	f	class:folly::detail::FingerprintPolynomial	access:public	signature:()
folly::detail::FingerprintPolynomial::val_	.\detail\FingerprintPolynomial.h	/^  uint64_t val_[1 + DEG\/64];$/;"	m	class:folly::detail::FingerprintPolynomial	access:private
folly::detail::FingerprintPolynomial::write	.\detail\FingerprintPolynomial.h	/^  void write(uint64_t* out) const {$/;"	f	class:folly::detail::FingerprintPolynomial	access:public	signature:(uint64_t* out) const
folly::detail::FingerprintTable	.\Fingerprint.h	/^struct FingerprintTable {$/;"	s	namespace:folly::detail
folly::detail::FingerprintTable::poly	.\Fingerprint.h	/^  static const uint64_t poly[1 + (BITS-1)\/64];$/;"	m	struct:folly::detail::FingerprintTable	access:public
folly::detail::FingerprintTable::table	.\Fingerprint.h	/^  static const uint64_t table[8][256][1 + (BITS-1)\/64];$/;"	m	struct:folly::detail::FingerprintTable	access:public
folly::detail::FormatterTag	.\Format.h	/^class FormatterTag {};$/;"	c	namespace:folly::detail
folly::detail::Futex	.\detail\Futex.h	/^struct Futex : Atom<uint32_t>, boost::noncopyable {$/;"	s	namespace:folly::detail	inherits:Atom,boost::noncopyable
folly::detail::Futex	.\test\MemoryIdlerTest.cpp	/^struct Futex<MockAtom> {$/;"	s	namespace:folly::detail	file:
folly::detail::Futex::Futex	.\detail\Futex.h	/^  explicit Futex(uint32_t init = 0) : Atom<uint32_t>(init) {}$/;"	f	struct:folly::detail::Futex	access:public	signature:(uint32_t init = 0)
folly::detail::Futex::MOCK_METHOD2	.\test\MemoryIdlerTest.cpp	/^  MOCK_METHOD2(futexWait, bool(uint32_t, uint32_t));$/;"	p	struct:folly::detail::Futex	file:	access:public	signature:(futexWait, bool(uint32_t, uint32_t))
folly::detail::Futex::MOCK_METHOD3	.\test\MemoryIdlerTest.cpp	/^  MOCK_METHOD3(futexWaitUntil,$/;"	p	struct:folly::detail::Futex	file:	access:public	signature:(futexWaitUntil, FutexResult(uint32_t, const MockClock::time_point&, uint32_t))
folly::detail::Futex::futexWait	.\detail\Futex.h	/^  bool futexWait(uint32_t expected, uint32_t waitMask = -1);$/;"	p	struct:folly::detail::Futex	access:public	signature:(uint32_t expected, uint32_t waitMask = -1)
folly::detail::Futex::futexWait	.\detail\Futex.h	/^inline bool Futex<std::atomic>::futexWait(uint32_t expected,$/;"	f	class:folly::detail::Futex	signature:(uint32_t expected, uint32_t waitMask)
folly::detail::Futex::futexWait	.\test\DeterministicSchedule.cpp	/^bool Futex<DeterministicAtomic>::futexWait(uint32_t expected,$/;"	f	class:folly::detail::Futex	signature:(uint32_t expected, uint32_t waitMask)
folly::detail::Futex::futexWaitImpl	.\detail\Futex.h	/^  int futexWaitImpl(uint32_t expected,$/;"	p	struct:folly::detail::Futex	access:private	signature:(uint32_t expected, const struct timespec* absTimeout, int extraOpFlags, uint32_t waitMask)
folly::detail::Futex::futexWaitImpl	.\detail\Futex.h	/^Futex<std::atomic>::futexWaitImpl(uint32_t expected,$/;"	f	class:folly::detail::Futex	signature:(uint32_t expected, const struct timespec* absTimeout, int extraOpFlags, uint32_t waitMask)
folly::detail::Futex::futexWaitUntil	.\detail\Futex.h	/^  FutexResult futexWaitUntil(uint32_t expected,$/;"	p	struct:folly::detail::Futex	access:public	signature:(uint32_t expected, const time_point<Clock, Duration>& absTime, uint32_t waitMask = -1)
folly::detail::Futex::futexWaitUntil	.\detail\Futex.h	/^Futex<Atom>::futexWaitUntil($/;"	f	class:folly::detail::Futex	signature:( uint32_t expected, const time_point<Clock, Duration>& absTime, uint32_t waitMask)
folly::detail::Futex::futexWake	.\detail\Futex.h	/^  int futexWake(int count = std::numeric_limits<int>::max(),$/;"	p	struct:folly::detail::Futex	access:public	signature:(int count = std::numeric_limits<int>::max(), uint32_t wakeMask = -1)
folly::detail::Futex::futexWake	.\detail\Futex.h	/^inline int Futex<std::atomic>::futexWake(int count, uint32_t wakeMask) {$/;"	f	class:folly::detail::Futex	signature:(int count, uint32_t wakeMask)
folly::detail::Futex::futexWake	.\test\DeterministicSchedule.cpp	/^int Futex<DeterministicAtomic>::futexWake(int count, uint32_t wakeMask) {$/;"	f	class:folly::detail::Futex	signature:(int count, uint32_t wakeMask)
folly::detail::FutexResult	.\detail\Futex.h	/^enum class FutexResult {$/;"	c	namespace:folly::detail
folly::detail::FutexResult::AWOKEN	.\detail\Futex.h	/^  AWOKEN,        \/* futex wait matched with a futex wake *\/$/;"	m	class:folly::detail::FutexResult	access:private
folly::detail::FutexResult::INTERRUPTED	.\detail\Futex.h	/^  INTERRUPTED,   \/* Spurious wake-up or signal caused futex wait failure *\/$/;"	m	class:folly::detail::FutexResult	access:private
folly::detail::FutexResult::VALUE_CHANGED	.\detail\Futex.h	/^  VALUE_CHANGED, \/* Futex value didn't match expected *\/$/;"	m	class:folly::detail::FutexResult	access:private
folly::detail::Getcpu	.\detail\CacheLocality.h	/^struct Getcpu {$/;"	s	namespace:folly::detail
folly::detail::Getcpu::Func	.\detail\CacheLocality.h	/^  typedef int (*Func)(unsigned* cpu, unsigned* node, void* unused);$/;"	t	struct:folly::detail::Getcpu	access:public
folly::detail::Getcpu::vdsoFunc	.\detail\CacheLocality.cpp	/^Getcpu::Func Getcpu::vdsoFunc() {$/;"	f	class:folly::detail::Getcpu	signature:()
folly::detail::Getcpu::vdsoFunc	.\detail\CacheLocality.h	/^  static Func vdsoFunc();$/;"	p	struct:folly::detail::Getcpu	access:public	signature:()
folly::detail::GroupVarintBase	.\detail\GroupVarintDetail.h	/^class GroupVarintBase {$/;"	c	namespace:folly::detail
folly::detail::GroupVarintBase::Derived	.\detail\GroupVarintDetail.h	/^  typedef GroupVarint<T> Derived;$/;"	t	class:folly::detail::GroupVarintBase	access:private
folly::detail::GroupVarintBase::Traits	.\detail\GroupVarintDetail.h	/^  typedef GroupVarintTraits<T> Traits;$/;"	t	class:folly::detail::GroupVarintBase	access:protected
folly::detail::GroupVarintBase::kFullGroupSize	.\detail\GroupVarintDetail.h	/^  enum { kFullGroupSize = kHeaderSize + kGroupSize * sizeof(type) };$/;"	e	enum:folly::detail::GroupVarintBase::__anon18
folly::detail::GroupVarintBase::kGroupSize	.\detail\GroupVarintDetail.h	/^  enum { kGroupSize = Traits::kGroupSize };$/;"	e	enum:folly::detail::GroupVarintBase::__anon16
folly::detail::GroupVarintBase::kHeaderSize	.\detail\GroupVarintDetail.h	/^  enum { kHeaderSize = Traits::kHeaderSize };$/;"	e	enum:folly::detail::GroupVarintBase::__anon15
folly::detail::GroupVarintBase::kMaxSize	.\detail\GroupVarintDetail.h	/^  enum { kMaxSize = kHeaderSize + sizeof(type) * kGroupSize };$/;"	e	enum:folly::detail::GroupVarintBase::__anon17
folly::detail::GroupVarintBase::maxSize	.\detail\GroupVarintDetail.h	/^  static size_t maxSize(size_t n) {$/;"	f	class:folly::detail::GroupVarintBase	access:public	signature:(size_t n)
folly::detail::GroupVarintBase::totalSize	.\detail\GroupVarintDetail.h	/^  static size_t totalSize(const T* p, size_t n) {$/;"	f	class:folly::detail::GroupVarintBase	access:public	signature:(const T* p, size_t n)
folly::detail::GroupVarintBase::type	.\detail\GroupVarintDetail.h	/^  typedef T type;$/;"	t	class:folly::detail::GroupVarintBase	access:public
folly::detail::GroupVarintTraits	.\detail\GroupVarintDetail.h	/^struct GroupVarintTraits;$/;"	x
folly::detail::GroupVarintTraits	.\detail\GroupVarintDetail.h	/^struct GroupVarintTraits<uint32_t> {$/;"	s	namespace:folly::detail
folly::detail::GroupVarintTraits	.\detail\GroupVarintDetail.h	/^struct GroupVarintTraits<uint64_t> {$/;"	s	namespace:folly::detail
folly::detail::GroupVarintTraits::kGroupSize	.\detail\GroupVarintDetail.h	/^    kGroupSize = 4,$/;"	e	enum:folly::detail::GroupVarintTraits::__anon13
folly::detail::GroupVarintTraits::kGroupSize	.\detail\GroupVarintDetail.h	/^    kGroupSize = 5,$/;"	e	enum:folly::detail::GroupVarintTraits::__anon14
folly::detail::GroupVarintTraits::kHeaderSize	.\detail\GroupVarintDetail.h	/^    kHeaderSize = 1,$/;"	e	enum:folly::detail::GroupVarintTraits::__anon13
folly::detail::GroupVarintTraits::kHeaderSize	.\detail\GroupVarintDetail.h	/^    kHeaderSize = 2,$/;"	e	enum:folly::detail::GroupVarintTraits::__anon14
folly::detail::HasLess	.\Foreach.h	/^class HasLess {$/;"	c	namespace:folly::detail
folly::detail::HasLess::BiggerThanChar	.\Foreach.h	/^  struct BiggerThanChar { char unused[2]; };$/;"	s	class:folly::detail::HasLess	access:private
folly::detail::HasLess::BiggerThanChar::unused	.\Foreach.h	/^  struct BiggerThanChar { char unused[2]; };$/;"	m	struct:folly::detail::HasLess::BiggerThanChar	access:public
folly::detail::HasLess::D	.\Foreach.h	/^  template <typename C, typename D> static char test(decltype(C() < D())*);$/;"	p	class:folly::detail::HasLess	access:private	signature:()
folly::detail::HasLess::test	.\Foreach.h	/^  template <typename, typename> static BiggerThanChar test(...);$/;"	p	class:folly::detail::HasLess	access:private	signature:(....)
folly::detail::HasLess::value	.\Foreach.h	/^  enum { value = sizeof(test<T, U>(0)) == 1 };$/;"	e	enum:folly::detail::HasLess::__anon51
folly::detail::HasLockUnlock	.\Synchronized.h	/^struct HasLockUnlock {$/;"	s	namespace:folly::detail
folly::detail::HasLockUnlock::value	.\Synchronized.h	/^  enum { value = IsOneOf<T,$/;"	e	enum:folly::detail::HasLockUnlock::__anon101
folly::detail::HistogramBuckets	.\stats\Histogram.h	/^class HistogramBuckets {$/;"	c	namespace:folly::detail
folly::detail::HistogramBuckets	.\stats\Instantiations.cpp	/^template class detail::HistogramBuckets<int64_t, Histogram<int64_t>::Bucket>;$/;"	m	class:folly::detail	typeref:class:folly::detail::	file:
folly::detail::HistogramBuckets::BucketType	.\stats\Histogram.h	/^  typedef BucketT BucketType;$/;"	t	class:folly::detail::HistogramBuckets	access:public
folly::detail::HistogramBuckets::HistogramBuckets	.\stats\Histogram-defs.h	/^HistogramBuckets<T, BucketT>::HistogramBuckets(ValueType bucketSize,$/;"	f	class:folly::detail::HistogramBuckets	signature:(ValueType bucketSize, ValueType min, ValueType max, const BucketType& defaultBucket)
folly::detail::HistogramBuckets::HistogramBuckets	.\stats\Histogram.h	/^  HistogramBuckets(ValueType bucketSize, ValueType min, ValueType max,$/;"	p	class:folly::detail::HistogramBuckets	access:public	signature:(ValueType bucketSize, ValueType min, ValueType max, const BucketType& defaultBucket)
folly::detail::HistogramBuckets::ValueType	.\stats\Histogram.h	/^  typedef T ValueType;$/;"	t	class:folly::detail::HistogramBuckets	access:public
folly::detail::HistogramBuckets::begin	.\stats\Histogram.h	/^  typename std::vector<BucketType>::const_iterator begin() const {$/;"	f	class:folly::detail::HistogramBuckets	access:public	signature:() const
folly::detail::HistogramBuckets::begin	.\stats\Histogram.h	/^  typename std::vector<BucketType>::iterator begin() {$/;"	f	class:folly::detail::HistogramBuckets	access:public	signature:()
folly::detail::HistogramBuckets::bucketSize_	.\stats\Histogram.h	/^  ValueType bucketSize_;$/;"	m	class:folly::detail::HistogramBuckets	access:private
folly::detail::HistogramBuckets::buckets_	.\stats\Histogram.h	/^  std::vector<BucketType> buckets_;$/;"	m	class:folly::detail::HistogramBuckets	access:private
folly::detail::HistogramBuckets::end	.\stats\Histogram.h	/^  typename std::vector<BucketType>::const_iterator end() const {$/;"	f	class:folly::detail::HistogramBuckets	access:public	signature:() const
folly::detail::HistogramBuckets::end	.\stats\Histogram.h	/^  typename std::vector<BucketType>::iterator end() {$/;"	f	class:folly::detail::HistogramBuckets	access:public	signature:()
folly::detail::HistogramBuckets::getBucketIdx	.\stats\Histogram-defs.h	/^unsigned int HistogramBuckets<T, BucketType>::getBucketIdx($/;"	f	class:folly::detail::HistogramBuckets	signature:( ValueType value) const
folly::detail::HistogramBuckets::getBucketIdx	.\stats\Histogram.h	/^  unsigned int getBucketIdx(ValueType value) const;$/;"	p	class:folly::detail::HistogramBuckets	access:public	signature:(ValueType value) const
folly::detail::HistogramBuckets::getBucketMax	.\stats\Histogram.h	/^  ValueType getBucketMax(unsigned int idx) const {$/;"	f	class:folly::detail::HistogramBuckets	access:public	signature:(unsigned int idx) const
folly::detail::HistogramBuckets::getBucketMin	.\stats\Histogram.h	/^  ValueType getBucketMin(unsigned int idx) const {$/;"	f	class:folly::detail::HistogramBuckets	access:public	signature:(unsigned int idx) const
folly::detail::HistogramBuckets::getBucketSize	.\stats\Histogram.h	/^  ValueType getBucketSize() const {$/;"	f	class:folly::detail::HistogramBuckets	access:public	signature:() const
folly::detail::HistogramBuckets::getByIndex	.\stats\Histogram.h	/^  BucketType& getByIndex(unsigned int idx) {$/;"	f	class:folly::detail::HistogramBuckets	access:public	signature:(unsigned int idx)
folly::detail::HistogramBuckets::getByIndex	.\stats\Histogram.h	/^  const BucketType& getByIndex(unsigned int idx) const {$/;"	f	class:folly::detail::HistogramBuckets	access:public	signature:(unsigned int idx) const
folly::detail::HistogramBuckets::getByValue	.\stats\Histogram.h	/^  BucketType& getByValue(ValueType value) {$/;"	f	class:folly::detail::HistogramBuckets	access:public	signature:(ValueType value)
folly::detail::HistogramBuckets::getByValue	.\stats\Histogram.h	/^  const BucketType& getByValue(ValueType value) const {$/;"	f	class:folly::detail::HistogramBuckets	access:public	signature:(ValueType value) const
folly::detail::HistogramBuckets::getMax	.\stats\Histogram.h	/^  ValueType getMax() const {$/;"	f	class:folly::detail::HistogramBuckets	access:public	signature:() const
folly::detail::HistogramBuckets::getMin	.\stats\Histogram.h	/^  ValueType getMin() const {$/;"	f	class:folly::detail::HistogramBuckets	access:public	signature:() const
folly::detail::HistogramBuckets::getNumBuckets	.\stats\Histogram.h	/^  unsigned int getNumBuckets() const {$/;"	f	class:folly::detail::HistogramBuckets	access:public	signature:() const
folly::detail::HistogramBuckets::getPercentileBucketIdx	.\stats\Histogram-defs.h	/^unsigned int HistogramBuckets<T, BucketType>::getPercentileBucketIdx($/;"	f	class:folly::detail::HistogramBuckets	signature:( double pct, CountFn countFromBucket, double* lowPct, double* highPct) const
folly::detail::HistogramBuckets::getPercentileBucketIdx	.\stats\Histogram.h	/^  unsigned int getPercentileBucketIdx(double pct,$/;"	p	class:folly::detail::HistogramBuckets	access:public	signature:(double pct, CountFn countFromBucket, double* lowPct = nullptr, double* highPct = nullptr) const
folly::detail::HistogramBuckets::getPercentileEstimate	.\stats\Histogram-defs.h	/^T HistogramBuckets<T, BucketType>::getPercentileEstimate($/;"	f	class:folly::detail::HistogramBuckets	signature:( double pct, CountFn countFromBucket, AvgFn avgFromBucket) const
folly::detail::HistogramBuckets::getPercentileEstimate	.\stats\Histogram.h	/^  ValueType getPercentileEstimate(double pct,$/;"	p	class:folly::detail::HistogramBuckets	access:public	signature:(double pct, CountFn countFromBucket, AvgFn avgFromBucket) const
folly::detail::HistogramBuckets::max_	.\stats\Histogram.h	/^  ValueType max_;$/;"	m	class:folly::detail::HistogramBuckets	access:private
folly::detail::HistogramBuckets::min_	.\stats\Histogram.h	/^  ValueType min_;$/;"	m	class:folly::detail::HistogramBuckets	access:private
folly::detail::IndexedMemPoolRecycler	.\IndexedMemPool.h	/^struct IndexedMemPoolRecycler;$/;"	x
folly::detail::IntegralSizePolicy	.\small_vector.h	/^  struct IntegralSizePolicy {$/;"	s	namespace:folly::detail
folly::detail::IntegralSizePolicy::IntegralSizePolicy	.\small_vector.h	/^    IntegralSizePolicy() : size_(0) {}$/;"	f	struct:folly::detail::IntegralSizePolicy	access:public	signature:()
folly::detail::IntegralSizePolicy::InternalSizeType	.\small_vector.h	/^    typedef SizeType InternalSizeType;$/;"	t	struct:folly::detail::IntegralSizePolicy	access:public
folly::detail::IntegralSizePolicy::doSize	.\small_vector.h	/^    std::size_t doSize() const {$/;"	f	struct:folly::detail::IntegralSizePolicy	access:protected	signature:() const
folly::detail::IntegralSizePolicy::isExtern	.\small_vector.h	/^    std::size_t isExtern() const {$/;"	f	struct:folly::detail::IntegralSizePolicy	access:protected	signature:() const
folly::detail::IntegralSizePolicy::kExternMask	.\small_vector.h	/^    static SizeType const kExternMask =$/;"	m	struct:folly::detail::IntegralSizePolicy	access:private
folly::detail::IntegralSizePolicy::kShouldUseHeap	.\small_vector.h	/^    static bool const kShouldUseHeap = ShouldUseHeap;$/;"	m	struct:folly::detail::IntegralSizePolicy	access:protected
folly::detail::IntegralSizePolicy::policyMaxSize	.\small_vector.h	/^    static constexpr std::size_t policyMaxSize() {$/;"	f	struct:folly::detail::IntegralSizePolicy	access:protected	signature:()
folly::detail::IntegralSizePolicy::setExtern	.\small_vector.h	/^    void setExtern(bool b) {$/;"	f	struct:folly::detail::IntegralSizePolicy	access:protected	signature:(bool b)
folly::detail::IntegralSizePolicy::setSize	.\small_vector.h	/^    void setSize(std::size_t sz) {$/;"	f	struct:folly::detail::IntegralSizePolicy	access:protected	signature:(std::size_t sz)
folly::detail::IntegralSizePolicy::size_	.\small_vector.h	/^    SizeType size_;$/;"	m	struct:folly::detail::IntegralSizePolicy	access:private
folly::detail::IntegralSizePolicy::swapSizePolicy	.\small_vector.h	/^    void swapSizePolicy(IntegralSizePolicy& o) {$/;"	f	struct:folly::detail::IntegralSizePolicy	access:protected	signature:(IntegralSizePolicy& o)
folly::detail::InternalDoNotUse	.\Synchronized.h	/^enum InternalDoNotUse {};$/;"	g	namespace:folly::detail
folly::detail::IsSizableString	.\String-inl.h	/^template <class T> struct IsSizableString {$/;"	s	namespace:folly::detail
folly::detail::IsSizableString::value	.\String-inl.h	/^  enum { value = IsSomeString<T>::value$/;"	e	enum:folly::detail::IsSizableString::__anon92
folly::detail::IsSizableStringContainerIterator	.\String-inl.h	/^struct IsSizableStringContainerIterator :$/;"	s	namespace:folly::detail	inherits:IsSizableString
folly::detail::IsUniquePtrToSL	.\io\IOBuf.h	/^struct IsUniquePtrToSL<$/;"	s	namespace:folly::detail	inherits:std::true_type
folly::detail::IsUniquePtrToSL	.\io\IOBuf.h	/^template <class T, class Enable=void> struct IsUniquePtrToSL$/;"	s	namespace:folly::detail	inherits:std::false_type
folly::detail::Lazy	.\Lazy.h	/^struct Lazy {$/;"	s	namespace:folly::detail
folly::detail::Lazy::Lazy	.\Lazy.h	/^  Lazy(Lazy&& o)$/;"	f	struct:folly::detail::Lazy	access:public	signature:(Lazy&& o)
folly::detail::Lazy::Lazy	.\Lazy.h	/^  Lazy(const Lazy&) = delete;$/;"	p	struct:folly::detail::Lazy	access:public	signature:(const Lazy&)
folly::detail::Lazy::Lazy	.\Lazy.h	/^  explicit Lazy(Func& f)  : func_(f) {}$/;"	f	struct:folly::detail::Lazy	access:public	signature:(Func& f)
folly::detail::Lazy::Lazy	.\Lazy.h	/^  explicit Lazy(Func&& f) : func_(std::move(f)) {}$/;"	f	struct:folly::detail::Lazy	access:public	signature:(Func&& f)
folly::detail::Lazy::func_	.\Lazy.h	/^  Func func_;$/;"	m	struct:folly::detail::Lazy	access:private
folly::detail::Lazy::operator ()	.\Lazy.h	/^  const result_type& operator()() const {$/;"	f	struct:folly::detail::Lazy	access:public	signature:() const
folly::detail::Lazy::operator ()	.\Lazy.h	/^  result_type& operator()() {$/;"	f	struct:folly::detail::Lazy	access:public	signature:()
folly::detail::Lazy::operator =	.\Lazy.h	/^  Lazy& operator=(Lazy&&) = delete;$/;"	p	struct:folly::detail::Lazy	access:public	signature:(Lazy&&)
folly::detail::Lazy::operator =	.\Lazy.h	/^  Lazy& operator=(const Lazy&) = delete;$/;"	p	struct:folly::detail::Lazy	access:public	signature:(const Lazy&)
folly::detail::Lazy::result_type	.\Lazy.h	/^  typedef typename std::result_of<Func()>::type result_type;$/;"	t	struct:folly::detail::Lazy	access:public
folly::detail::Lazy::value_	.\Lazy.h	/^  Optional<result_type> value_;$/;"	m	struct:folly::detail::Lazy	access:private
folly::detail::LifoSemBase	.\LifoSem.h	/^struct LifoSemBase : boost::noncopyable {$/;"	s	namespace:folly::detail	inherits:boost::noncopyable
folly::detail::LifoSemBase::FOLLY_ALIGN_TO_AVOID_FALSE_SHARING	.\LifoSem.h	/^      FOLLY_ALIGN_TO_AVOID_FALSE_SHARING;$/;"	m	struct:folly::detail::LifoSemBase	access:private
folly::detail::LifoSemBase::LifoSemBase	.\LifoSem.h	/^  explicit LifoSemBase(uint32_t initialValue = 0)$/;"	f	struct:folly::detail::LifoSemBase	access:public	signature:(uint32_t initialValue = 0)
folly::detail::LifoSemBase::UniquePtr	.\LifoSem.h	/^                          LifoSemNodeRecycler<Handoff, Atom>> UniquePtr;$/;"	t	struct:folly::detail::LifoSemBase	access:protected
folly::detail::LifoSemBase::WaitResult	.\LifoSem.h	/^  enum class WaitResult {$/;"	c	struct:folly::detail::LifoSemBase	access:protected
folly::detail::LifoSemBase::WaitResult::DECR	.\LifoSem.h	/^    DECR,$/;"	m	class:folly::detail::LifoSemBase::WaitResult	access:private
folly::detail::LifoSemBase::WaitResult::PUSH	.\LifoSem.h	/^    PUSH,$/;"	m	class:folly::detail::LifoSemBase::WaitResult	access:private
folly::detail::LifoSemBase::WaitResult::SHUTDOWN	.\LifoSem.h	/^    SHUTDOWN,$/;"	m	class:folly::detail::LifoSemBase::WaitResult	access:private
folly::detail::LifoSemBase::allocateNode	.\LifoSem.h	/^  UniquePtr allocateNode(Args&&... args) {$/;"	f	struct:folly::detail::LifoSemBase	access:protected	signature:(Args&&.... args)
folly::detail::LifoSemBase::decrOrPush	.\LifoSem.h	/^  WaitResult decrOrPush(uint32_t& n, uint32_t idx) {$/;"	f	struct:folly::detail::LifoSemBase	access:private	signature:(uint32_t& n, uint32_t idx)
folly::detail::LifoSemBase::idxToNode	.\LifoSem.h	/^  static LifoSemNode<Handoff, Atom>& idxToNode(uint32_t idx) {$/;"	f	struct:folly::detail::LifoSemBase	access:private	signature:(uint32_t idx)
folly::detail::LifoSemBase::incrOrPop	.\LifoSem.h	/^  uint32_t incrOrPop(uint32_t n) {$/;"	f	struct:folly::detail::LifoSemBase	access:private	signature:(uint32_t n)
folly::detail::LifoSemBase::isShutdown	.\LifoSem.h	/^  bool isShutdown() const {$/;"	f	struct:folly::detail::LifoSemBase	access:public	signature:() const
folly::detail::LifoSemBase::nodeToIdx	.\LifoSem.h	/^  static uint32_t nodeToIdx(const LifoSemNode<Handoff, Atom>& node) {$/;"	f	struct:folly::detail::LifoSemBase	access:private	signature:(const LifoSemNode<Handoff, Atom>& node)
folly::detail::LifoSemBase::padding_	.\LifoSem.h	/^  char padding_[folly::detail::CacheLocality::kFalseSharingRange -$/;"	m	struct:folly::detail::LifoSemBase	access:private
folly::detail::LifoSemBase::post	.\LifoSem.h	/^  void post() {$/;"	f	struct:folly::detail::LifoSemBase	access:public	signature:()
folly::detail::LifoSemBase::post	.\LifoSem.h	/^  void post(uint32_t n) {$/;"	f	struct:folly::detail::LifoSemBase	access:public	signature:(uint32_t n)
folly::detail::LifoSemBase::shutdown	.\LifoSem.h	/^  void shutdown() {$/;"	f	struct:folly::detail::LifoSemBase	access:public	signature:()
folly::detail::LifoSemBase::tryWait	.\LifoSem.h	/^  bool tryWait() {$/;"	f	struct:folly::detail::LifoSemBase	access:public	signature:()
folly::detail::LifoSemBase::tryWait	.\LifoSem.h	/^  uint32_t tryWait(uint32_t n) {$/;"	f	struct:folly::detail::LifoSemBase	access:public	signature:(uint32_t n)
folly::detail::LifoSemBase::tryWaitOrPush	.\LifoSem.h	/^  WaitResult tryWaitOrPush(LifoSemNode<Handoff, Atom>& waiterNode) {$/;"	f	struct:folly::detail::LifoSemBase	access:protected	signature:(LifoSemNode<Handoff, Atom>& waiterNode)
folly::detail::LifoSemBase::valueGuess	.\LifoSem.h	/^  uint32_t valueGuess() const {$/;"	f	struct:folly::detail::LifoSemBase	access:public	signature:() const
folly::detail::LifoSemBase::wait	.\LifoSem.h	/^  void wait() {$/;"	f	struct:folly::detail::LifoSemBase	access:public	signature:()
folly::detail::LifoSemHead	.\LifoSem.h	/^class LifoSemHead {$/;"	c	namespace:folly::detail
folly::detail::LifoSemHead::IsNodeIdxShift	.\LifoSem.h	/^    IsNodeIdxShift = 32,$/;"	e	enum:folly::detail::LifoSemHead::__anon76
folly::detail::LifoSemHead::IsShutdownShift	.\LifoSem.h	/^    IsShutdownShift = 33,$/;"	e	enum:folly::detail::LifoSemHead::__anon76
folly::detail::LifoSemHead::SeqShift	.\LifoSem.h	/^    SeqShift = 34,$/;"	e	enum:folly::detail::LifoSemHead::__anon76
folly::detail::LifoSemHead::bits	.\LifoSem.h	/^  uint64_t bits;$/;"	m	class:folly::detail::LifoSemHead	access:public
folly::detail::LifoSemHead::fresh	.\LifoSem.h	/^  static inline constexpr LifoSemHead fresh(uint32_t value) {$/;"	f	class:folly::detail::LifoSemHead	access:public	signature:(uint32_t value)
folly::detail::LifoSemHead::idx	.\LifoSem.h	/^  inline uint32_t idx() const {$/;"	f	class:folly::detail::LifoSemHead	access:public	signature:() const
folly::detail::LifoSemHead::isNodeIdx	.\LifoSem.h	/^  inline constexpr bool isNodeIdx() const {$/;"	f	class:folly::detail::LifoSemHead	access:public	signature:() const
folly::detail::LifoSemHead::isShutdown	.\LifoSem.h	/^  inline constexpr bool isShutdown() const {$/;"	f	class:folly::detail::LifoSemHead	access:public	signature:() const
folly::detail::LifoSemHead::operator !=	.\LifoSem.h	/^  inline constexpr bool operator!= (const LifoSemHead& rhs) const {$/;"	f	class:folly::detail::LifoSemHead	access:public	signature:(const LifoSemHead& rhs) const
folly::detail::LifoSemHead::operator ==	.\LifoSem.h	/^  inline constexpr bool operator== (const LifoSemHead& rhs) const {$/;"	f	class:folly::detail::LifoSemHead	access:public	signature:(const LifoSemHead& rhs) const
folly::detail::LifoSemHead::seq	.\LifoSem.h	/^  inline constexpr uint32_t seq() const {$/;"	f	class:folly::detail::LifoSemHead	access:public	signature:() const
folly::detail::LifoSemHead::value	.\LifoSem.h	/^  inline uint32_t value() const {$/;"	f	class:folly::detail::LifoSemHead	access:public	signature:() const
folly::detail::LifoSemHead::withPop	.\LifoSem.h	/^  inline LifoSemHead withPop(uint32_t idxNext) const {$/;"	f	class:folly::detail::LifoSemHead	access:public	signature:(uint32_t idxNext) const
folly::detail::LifoSemHead::withPush	.\LifoSem.h	/^  inline LifoSemHead withPush(uint32_t _idx) const {$/;"	f	class:folly::detail::LifoSemHead	access:public	signature:(uint32_t _idx) const
folly::detail::LifoSemHead::withShutdown	.\LifoSem.h	/^  inline LifoSemHead withShutdown() const {$/;"	f	class:folly::detail::LifoSemHead	access:public	signature:() const
folly::detail::LifoSemHead::withValueDecr	.\LifoSem.h	/^  inline LifoSemHead withValueDecr(uint32_t delta) const {$/;"	f	class:folly::detail::LifoSemHead	access:public	signature:(uint32_t delta) const
folly::detail::LifoSemHead::withValueIncr	.\LifoSem.h	/^  inline LifoSemHead withValueIncr(uint32_t delta) const {$/;"	f	class:folly::detail::LifoSemHead	access:public	signature:(uint32_t delta) const
folly::detail::LifoSemNode	.\LifoSem.h	/^struct LifoSemNode : public LifoSemRawNode<Atom> {$/;"	s	namespace:folly::detail	inherits:LifoSemRawNode
folly::detail::LifoSemNode::alignof	.\LifoSem.h	/^  static_assert(alignof(Handoff) <=$/;"	p	struct:folly::detail::LifoSemNode	access:public	signature:(Handoff)
folly::detail::LifoSemNode::destroy	.\LifoSem.h	/^  void destroy() {$/;"	f	struct:folly::detail::LifoSemNode	access:public	signature:()
folly::detail::LifoSemNode::handoff	.\LifoSem.h	/^  Handoff& handoff() {$/;"	f	struct:folly::detail::LifoSemNode	access:public	signature:()
folly::detail::LifoSemNode::handoff	.\LifoSem.h	/^  const Handoff& handoff() const {$/;"	f	struct:folly::detail::LifoSemNode	access:public	signature:() const
folly::detail::LifoSemNode::init	.\LifoSem.h	/^  void init(Args&&... args) {$/;"	f	struct:folly::detail::LifoSemNode	access:public	signature:(Args&&.... args)
folly::detail::LifoSemNode::sizeof	.\LifoSem.h	/^  static_assert(sizeof(Handoff) <= sizeof(LifoSemRawNode<Atom>::raw),$/;"	p	struct:folly::detail::LifoSemNode	access:public	signature:(Handoff)
folly::detail::LifoSemNodeRecycler	.\LifoSem.h	/^struct LifoSemNodeRecycler {$/;"	s	namespace:folly::detail
folly::detail::LifoSemNodeRecycler::operator ()	.\LifoSem.h	/^  void operator()(LifoSemNode<Handoff,Atom>* elem) const {$/;"	f	struct:folly::detail::LifoSemNodeRecycler	access:public	signature:(LifoSemNode<Handoff,Atom>* elem) const
folly::detail::LifoSemRawNode	.\LifoSem.h	/^struct LifoSemRawNode {$/;"	s	namespace:folly::detail
folly::detail::LifoSemRawNode::Pool	.\LifoSem.h	/^  typedef folly::IndexedMemPool<LifoSemRawNode<Atom>,32,200,Atom> Pool;$/;"	t	struct:folly::detail::LifoSemRawNode	access:public
folly::detail::LifoSemRawNode::clearShutdownNotice	.\LifoSem.h	/^  void clearShutdownNotice() { next = 0; }$/;"	f	struct:folly::detail::LifoSemRawNode	access:public	signature:()
folly::detail::LifoSemRawNode::isShutdownNotice	.\LifoSem.h	/^  bool isShutdownNotice() const { return next == uint32_t(-1); }$/;"	f	struct:folly::detail::LifoSemRawNode	access:public	signature:() const
folly::detail::LifoSemRawNode::next	.\LifoSem.h	/^  uint32_t next;$/;"	m	struct:folly::detail::LifoSemRawNode	access:public
folly::detail::LifoSemRawNode::pool	.\LifoSem.h	/^  static Pool pool;$/;"	m	struct:folly::detail::LifoSemRawNode	access:public
folly::detail::LifoSemRawNode::raw	.\LifoSem.h	/^  std::aligned_storage<sizeof(void*),alignof(void*)>::type raw;$/;"	m	struct:folly::detail::LifoSemRawNode	access:public
folly::detail::LifoSemRawNode::setShutdownNotice	.\LifoSem.h	/^  void setShutdownNotice() { next = uint32_t(-1); }$/;"	f	struct:folly::detail::LifoSemRawNode	access:public	signature:()
folly::detail::MPMCPipelineStageImpl	.\MPMCQueue.h	/^template <typename T> class MPMCPipelineStageImpl;$/;"	x
folly::detail::MPMCPipelineStageImpl	.\detail\MPMCPipelineDetail.h	/^class MPMCPipelineStageImpl {$/;"	c	namespace:folly::detail
folly::detail::MPMCPipelineStageImpl::MPMCPipeline	.\detail\MPMCPipelineDetail.h	/^  template <class U, class... Stages> friend class MPMCPipeline;$/;"	x
folly::detail::MPMCPipelineStageImpl::MPMCPipelineStageImpl	.\detail\MPMCPipelineDetail.h	/^  MPMCPipelineStageImpl() { }$/;"	f	class:folly::detail::MPMCPipelineStageImpl	access:public	signature:()
folly::detail::MPMCPipelineStageImpl::MPMCPipelineStageImpl	.\detail\MPMCPipelineDetail.h	/^  \/* implicit *\/ MPMCPipelineStageImpl(size_t capacity) : queue_(capacity) { }$/;"	f	class:folly::detail::MPMCPipelineStageImpl	access:public	signature:(size_t capacity)
folly::detail::MPMCPipelineStageImpl::queue_	.\detail\MPMCPipelineDetail.h	/^  MPMCQueue<T> queue_;$/;"	m	class:folly::detail::MPMCPipelineStageImpl	access:private
folly::detail::MPMCPipelineStageImpl::value_type	.\detail\MPMCPipelineDetail.h	/^  typedef T value_type;$/;"	t	class:folly::detail::MPMCPipelineStageImpl	access:public
folly::detail::MaxString::value	.\Conv.cpp	/^template <> const char *const MaxString<__uint128_t>::value =$/;"	m	class:folly::detail::MaxString	file:
folly::detail::MaxString::value	.\Conv.cpp	/^template <> const char *const MaxString<bool>::value = "true";$/;"	m	class:folly::detail::MaxString	file:
folly::detail::MaxString::value	.\Conv.cpp	/^template <> const char *const MaxString<uint16_t>::value = "65535";$/;"	m	class:folly::detail::MaxString	file:
folly::detail::MaxString::value	.\Conv.cpp	/^template <> const char *const MaxString<uint32_t>::value = "4294967295";$/;"	m	class:folly::detail::MaxString	file:
folly::detail::MaxString::value	.\Conv.cpp	/^template <> const char *const MaxString<uint8_t>::value = "255";$/;"	m	class:folly::detail::MaxString	file:
folly::detail::MaxString::value	.\Conv.cpp	/^template <> const char *const MaxString<unsigned long long>::value =$/;"	m	class:folly::detail::MaxString	file:
folly::detail::MaxString::value	.\Conv.cpp	/^template <> const char *const MaxString<unsigned long>::value =$/;"	m	class:folly::detail::MaxString	file:
folly::detail::MemoryIdler	.\detail\MemoryIdler.h	/^struct MemoryIdler {$/;"	s	namespace:folly::detail
folly::detail::MemoryIdler::defaultIdleTimeout	.\detail\MemoryIdler.h	/^  static AtomicStruct<std::chrono::steady_clock::duration> defaultIdleTimeout;$/;"	m	struct:folly::detail::MemoryIdler	access:public
folly::detail::MemoryIdler::flushLocalMallocCaches	.\detail\MemoryIdler.cpp	/^void MemoryIdler::flushLocalMallocCaches() {$/;"	f	class:folly::detail::MemoryIdler	signature:()
folly::detail::MemoryIdler::flushLocalMallocCaches	.\detail\MemoryIdler.h	/^  static void flushLocalMallocCaches();$/;"	p	struct:folly::detail::MemoryIdler	access:public	signature:()
folly::detail::MemoryIdler::futexWait	.\detail\MemoryIdler.h	/^  static bool futexWait($/;"	f	struct:folly::detail::MemoryIdler	access:public	signature:( Futex<Atom>& fut, uint32_t expected, uint32_t waitMask = -1, typename Clock::duration idleTimeout = defaultIdleTimeout.load(std::memory_order_acquire), size_t stackToRetain = kDefaultStackToRetain, float timeoutVariationFrac = 0.5)
folly::detail::MemoryIdler::kDefaultStackToRetain	.\detail\MemoryIdler.h	/^    kDefaultStackToRetain = 1024,$/;"	e	enum:folly::detail::MemoryIdler::__anon19
folly::detail::MemoryIdler::unmapUnusedStack	.\detail\MemoryIdler.cpp	/^void MemoryIdler::unmapUnusedStack(size_t retain) {$/;"	f	class:folly::detail::MemoryIdler	signature:(size_t retain)
folly::detail::MemoryIdler::unmapUnusedStack	.\detail\MemoryIdler.h	/^  static void unmapUnusedStack(size_t retain = kDefaultStackToRetain);$/;"	p	struct:folly::detail::MemoryIdler	access:public	signature:(size_t retain = kDefaultStackToRetain)
folly::detail::NodeRecycler	.\ConcurrentSkipList-inl.h	/^class NodeRecycler;$/;"	x
folly::detail::NodeRecycler	.\ConcurrentSkipList-inl.h	/^class NodeRecycler<NodeType, NodeAlloc, typename std::enable_if<$/;"	c	namespace:folly::detail
folly::detail::NodeRecycler::NodeRecycler	.\ConcurrentSkipList-inl.h	/^  explicit NodeRecycler(const NodeAlloc& alloc) : alloc_(alloc) { }$/;"	f	class:folly::detail::NodeRecycler	access:public	signature:(const NodeAlloc& alloc)
folly::detail::NodeRecycler::NodeRecycler	.\ConcurrentSkipList-inl.h	/^  explicit NodeRecycler(const NodeAlloc& alloc)$/;"	f	class:folly::detail::NodeRecycler	access:public	signature:(const NodeAlloc& alloc)
folly::detail::NodeRecycler::add	.\ConcurrentSkipList-inl.h	/^  void add(NodeType* node) { }$/;"	f	class:folly::detail::NodeRecycler	access:public	signature:(NodeType* node)
folly::detail::NodeRecycler::add	.\ConcurrentSkipList-inl.h	/^  void add(NodeType* node) {$/;"	f	class:folly::detail::NodeRecycler	access:public	signature:(NodeType* node)
folly::detail::NodeRecycler::addRef	.\ConcurrentSkipList-inl.h	/^  int addRef() {$/;"	f	class:folly::detail::NodeRecycler	access:public	signature:()
folly::detail::NodeRecycler::addRef	.\ConcurrentSkipList-inl.h	/^  void addRef() { }$/;"	f	class:folly::detail::NodeRecycler	access:public	signature:()
folly::detail::NodeRecycler::alloc	.\ConcurrentSkipList-inl.h	/^  NodeAlloc& alloc() { return alloc_; }$/;"	f	class:folly::detail::NodeRecycler	access:public	signature:()
folly::detail::NodeRecycler::alloc_	.\ConcurrentSkipList-inl.h	/^  NodeAlloc alloc_;$/;"	m	class:folly::detail::NodeRecycler	access:private
folly::detail::NodeRecycler::dirty_	.\ConcurrentSkipList-inl.h	/^  std::atomic<bool> dirty_; \/\/ whether *nodes_ is non-empty$/;"	m	class:folly::detail::NodeRecycler	access:private
folly::detail::NodeRecycler::lock_	.\ConcurrentSkipList-inl.h	/^  MicroSpinLock lock_; \/\/ protects access to *nodes_$/;"	m	class:folly::detail::NodeRecycler	access:private
folly::detail::NodeRecycler::nodes_	.\ConcurrentSkipList-inl.h	/^  std::unique_ptr<std::vector<NodeType*>> nodes_;$/;"	m	class:folly::detail::NodeRecycler	access:private
folly::detail::NodeRecycler::refs	.\ConcurrentSkipList-inl.h	/^  int refs() const {$/;"	f	class:folly::detail::NodeRecycler	access:private	signature:() const
folly::detail::NodeRecycler::refs_	.\ConcurrentSkipList-inl.h	/^  std::atomic<int32_t> refs_; \/\/ current number of visitors to the list$/;"	m	class:folly::detail::NodeRecycler	access:private
folly::detail::NodeRecycler::releaseRef	.\ConcurrentSkipList-inl.h	/^  int releaseRef() {$/;"	f	class:folly::detail::NodeRecycler	access:public	signature:()
folly::detail::NodeRecycler::releaseRef	.\ConcurrentSkipList-inl.h	/^  void releaseRef() { }$/;"	f	class:folly::detail::NodeRecycler	access:public	signature:()
folly::detail::NodeRecycler::~NodeRecycler	.\ConcurrentSkipList-inl.h	/^  ~NodeRecycler() {$/;"	f	class:folly::detail::NodeRecycler	access:public	signature:()
folly::detail::NoneHelper	.\Optional.h	/^namespace detail { struct NoneHelper {}; }$/;"	s	namespace:folly::detail
folly::detail::NoneHelper::None	.\Optional.h	/^typedef int detail::NoneHelper::*None;$/;"	t	class:folly::detail::NoneHelper
folly::detail::OutputConverter	.\String-inl.h	/^template<> struct OutputConverter<StringPiece> {$/;"	s	namespace:folly::detail
folly::detail::OutputConverter	.\String-inl.h	/^template<> struct OutputConverter<fbstring> {$/;"	s	namespace:folly::detail
folly::detail::OutputConverter	.\String-inl.h	/^template<> struct OutputConverter<std::string> {$/;"	s	namespace:folly::detail
folly::detail::OutputConverter	.\String-inl.h	/^template<class OutStringT> struct OutputConverter {};$/;"	s	namespace:folly::detail
folly::detail::OutputConverter::operator ()	.\String-inl.h	/^  StringPiece operator()(StringPiece sp) const { return sp; }$/;"	f	struct:folly::detail::OutputConverter	access:public	signature:(StringPiece sp) const
folly::detail::OutputConverter::operator ()	.\String-inl.h	/^  fbstring operator()(StringPiece sp) const {$/;"	f	struct:folly::detail::OutputConverter	access:public	signature:(StringPiece sp) const
folly::detail::OutputConverter::operator ()	.\String-inl.h	/^  std::string operator()(StringPiece sp) const {$/;"	f	struct:folly::detail::OutputConverter	access:public	signature:(StringPiece sp) const
folly::detail::PipelineStageInfo	.\detail\MPMCPipelineDetail.h	/^struct PipelineStageInfo<MPMCPipelineStage<T, Amp>> {$/;"	s	namespace:folly::detail
folly::detail::PipelineStageInfo	.\detail\MPMCPipelineDetail.h	/^template <class T> struct PipelineStageInfo {$/;"	s	namespace:folly::detail
folly::detail::PipelineStageInfo::kAmplification	.\detail\MPMCPipelineDetail.h	/^  static constexpr size_t kAmplification = 1;$/;"	m	struct:folly::detail::PipelineStageInfo	access:public
folly::detail::PipelineStageInfo::kAmplification	.\detail\MPMCPipelineDetail.h	/^  static constexpr size_t kAmplification = Amp;$/;"	m	struct:folly::detail::PipelineStageInfo	access:public
folly::detail::PipelineStageInfo::value_type	.\detail\MPMCPipelineDetail.h	/^  typedef T value_type;$/;"	t	struct:folly::detail::PipelineStageInfo	access:public
folly::detail::RWTicketIntTrait	.\RWSpinLock.h	/^struct RWTicketIntTrait<32> {$/;"	s	namespace:folly::detail
folly::detail::RWTicketIntTrait	.\RWSpinLock.h	/^struct RWTicketIntTrait<64> {$/;"	s	namespace:folly::detail
folly::detail::RWTicketIntTrait	.\RWSpinLock.h	/^template <size_t kBitWidth> struct RWTicketIntTrait {$/;"	s	namespace:folly::detail
folly::detail::RWTicketIntTrait::FullInt	.\RWSpinLock.h	/^  typedef uint32_t FullInt;$/;"	t	struct:folly::detail::RWTicketIntTrait	access:public
folly::detail::RWTicketIntTrait::FullInt	.\RWSpinLock.h	/^  typedef uint64_t FullInt;$/;"	t	struct:folly::detail::RWTicketIntTrait	access:public
folly::detail::RWTicketIntTrait::HalfInt	.\RWSpinLock.h	/^  typedef uint16_t HalfInt;$/;"	t	struct:folly::detail::RWTicketIntTrait	access:public
folly::detail::RWTicketIntTrait::HalfInt	.\RWSpinLock.h	/^  typedef uint32_t HalfInt;$/;"	t	struct:folly::detail::RWTicketIntTrait	access:public
folly::detail::RWTicketIntTrait::QuarterInt	.\RWSpinLock.h	/^  typedef uint16_t QuarterInt;$/;"	t	struct:folly::detail::RWTicketIntTrait	access:public
folly::detail::RWTicketIntTrait::QuarterInt	.\RWSpinLock.h	/^  typedef uint8_t QuarterInt;$/;"	t	struct:folly::detail::RWTicketIntTrait	access:public
folly::detail::RWTicketIntTrait::addParallel	.\RWSpinLock.h	/^  static inline uint32_t addParallel(__m128i in, __m128i kDelta) {$/;"	f	struct:folly::detail::RWTicketIntTrait	access:public	signature:(__m128i in, __m128i kDelta)
folly::detail::RWTicketIntTrait::addParallel	.\RWSpinLock.h	/^  static inline uint64_t addParallel(__m128i in, __m128i kDelta) {$/;"	f	struct:folly::detail::RWTicketIntTrait	access:public	signature:(__m128i in, __m128i kDelta)
folly::detail::RWTicketIntTrait::fromInteger	.\RWSpinLock.h	/^  static inline __m128i fromInteger(uint32_t from) {$/;"	f	struct:folly::detail::RWTicketIntTrait	access:public	signature:(uint32_t from)
folly::detail::RWTicketIntTrait::fromInteger	.\RWSpinLock.h	/^  static inline __m128i fromInteger(uint64_t from) {$/;"	f	struct:folly::detail::RWTicketIntTrait	access:public	signature:(uint64_t from)
folly::detail::RWTicketIntTrait::make128	.\RWSpinLock.h	/^  static __m128i make128(const uint16_t v[4]) {$/;"	f	struct:folly::detail::RWTicketIntTrait	access:public	signature:(const uint16_t v[4])
folly::detail::RWTicketIntTrait::make128	.\RWSpinLock.h	/^  static __m128i make128(const uint8_t v[4]) {$/;"	f	struct:folly::detail::RWTicketIntTrait	access:public	signature:(const uint8_t v[4])
folly::detail::RWTicketIntTrait::static_assert	.\RWSpinLock.h	/^  static_assert(kBitWidth == 32 || kBitWidth == 64,$/;"	p	struct:folly::detail::RWTicketIntTrait	access:public	signature:(kBitWidth == 32 || kBitWidth == 64, )
folly::detail::RWTicketIntTrait::toInteger	.\RWSpinLock.h	/^  static inline uint32_t toInteger(__m128i in) {$/;"	f	struct:folly::detail::RWTicketIntTrait	access:public	signature:(__m128i in)
folly::detail::RWTicketIntTrait::toInteger	.\RWSpinLock.h	/^  static inline uint64_t toInteger(__m128i in) {$/;"	f	struct:folly::detail::RWTicketIntTrait	access:public	signature:(__m128i in)
folly::detail::ScopeGuardForNewException	.\ScopeGuard.h	/^class ScopeGuardForNewException {$/;"	c	namespace:folly::detail
folly::detail::ScopeGuardForNewException::ScopeGuardForNewException	.\ScopeGuard.h	/^  ScopeGuardForNewException(ScopeGuardForNewException&& other)$/;"	f	class:folly::detail::ScopeGuardForNewException	access:public	signature:(ScopeGuardForNewException&& other)
folly::detail::ScopeGuardForNewException::ScopeGuardForNewException	.\ScopeGuard.h	/^  explicit ScopeGuardForNewException(FunctionType&& fn)$/;"	f	class:folly::detail::ScopeGuardForNewException	access:public	signature:(FunctionType&& fn)
folly::detail::ScopeGuardForNewException::ScopeGuardForNewException	.\ScopeGuard.h	/^  explicit ScopeGuardForNewException(const FunctionType& fn)$/;"	f	class:folly::detail::ScopeGuardForNewException	access:public	signature:(const FunctionType& fn)
folly::detail::ScopeGuardForNewException::exceptionCounter_	.\ScopeGuard.h	/^  UncaughtExceptionCounter exceptionCounter_;$/;"	m	class:folly::detail::ScopeGuardForNewException	access:private
folly::detail::ScopeGuardForNewException::function_	.\ScopeGuard.h	/^  FunctionType function_;$/;"	m	class:folly::detail::ScopeGuardForNewException	access:private
folly::detail::ScopeGuardForNewException::noexcept	.\ScopeGuard.h	/^  ~ScopeGuardForNewException() noexcept(executeOnException) {$/;"	f	class:folly::detail::ScopeGuardForNewException	access:public	signature:(executeOnException)
folly::detail::ScopeGuardForNewException::other	.\ScopeGuard.h	/^  ScopeGuardForNewException(const ScopeGuardForNewException& other) = delete;$/;"	m	class:folly::detail::ScopeGuardForNewException	access:private
folly::detail::ScopeGuardForNewException::size_t	.\ScopeGuard.h	/^  void* operator new(size_t) = delete;$/;"	m	class:folly::detail::ScopeGuardForNewException	access:private
folly::detail::ScopeGuardOnExit	.\ScopeGuard.h	/^enum class ScopeGuardOnExit {};$/;"	c	namespace:folly::detail
folly::detail::ScopeGuardOnFail	.\ScopeGuard.h	/^enum class ScopeGuardOnFail {};$/;"	c	namespace:folly::detail
folly::detail::ScopeGuardOnSuccess	.\ScopeGuard.h	/^enum class ScopeGuardOnSuccess {};$/;"	c	namespace:folly::detail
folly::detail::SeedData	.\Random-inl.h	/^struct SeedData {$/;"	s	namespace:folly::detail
folly::detail::SeedData::SeedData	.\Random-inl.h	/^  SeedData() {$/;"	f	struct:folly::detail::SeedData	access:public	signature:()
folly::detail::SeedData::seedData	.\Random-inl.h	/^  std::array<uint32_t, stateSize> seedData;$/;"	m	struct:folly::detail::SeedData	access:public
folly::detail::SeedData::stateSize	.\Random-inl.h	/^  static constexpr size_t stateSize = StateSize<RNG>::value;$/;"	m	struct:folly::detail::SeedData	access:public
folly::detail::SequentialThreadId	.\detail\CacheLocality.h	/^struct SequentialThreadId {$/;"	s	namespace:folly::detail
folly::detail::SequentialThreadId::currentId	.\detail\CacheLocality.h	/^  static FOLLY_TLS size_t currentId;$/;"	m	struct:folly::detail::SequentialThreadId	access:private
folly::detail::SequentialThreadId::get	.\detail\CacheLocality.h	/^  static size_t get() {$/;"	f	struct:folly::detail::SequentialThreadId	access:public	signature:()
folly::detail::SequentialThreadId::getcpu	.\detail\CacheLocality.h	/^  static int getcpu(unsigned* cpu, unsigned* node, void* unused) {$/;"	f	struct:folly::detail::SequentialThreadId	access:public	signature:(unsigned* cpu, unsigned* node, void* unused)
folly::detail::SequentialThreadId::prevId	.\detail\CacheLocality.h	/^  static Atom<size_t> prevId;$/;"	m	struct:folly::detail::SequentialThreadId	access:private
folly::detail::SingleElementQueue	.\MPMCQueue.h	/^class SingleElementQueue;$/;"	x
folly::detail::SkipListNode	.\ConcurrentSkipList-inl.h	/^class SkipListNode : private boost::noncopyable {$/;"	c	namespace:folly::detail	inherits:boost::noncopyable
folly::detail::SkipListNode::FULLY_LINKED	.\ConcurrentSkipList-inl.h	/^    FULLY_LINKED = (1 << 2),$/;"	e	enum:folly::detail::SkipListNode::__anon5
folly::detail::SkipListNode::IS_HEAD_NODE	.\ConcurrentSkipList-inl.h	/^    IS_HEAD_NODE = 1,$/;"	e	enum:folly::detail::SkipListNode::__anon5
folly::detail::SkipListNode::MARKED_FOR_REMOVAL	.\ConcurrentSkipList-inl.h	/^    MARKED_FOR_REMOVAL = (1 << 1),$/;"	e	enum:folly::detail::SkipListNode::__anon5
folly::detail::SkipListNode::SkipListNode	.\ConcurrentSkipList-inl.h	/^  SkipListNode(uint8_t height, U&& data, bool isHead) :$/;"	f	class:folly::detail::SkipListNode	access:private	signature:(uint8_t height, U&& data, bool isHead)
folly::detail::SkipListNode::acquireGuard	.\ConcurrentSkipList-inl.h	/^  std::unique_lock<MicroSpinLock> acquireGuard() {$/;"	f	class:folly::detail::SkipListNode	access:public	signature:()
folly::detail::SkipListNode::copyHead	.\ConcurrentSkipList-inl.h	/^  SkipListNode* copyHead(SkipListNode* node) {$/;"	f	class:folly::detail::SkipListNode	access:public	signature:(SkipListNode* node)
folly::detail::SkipListNode::create	.\ConcurrentSkipList-inl.h	/^  static SkipListNode* create($/;"	f	class:folly::detail::SkipListNode	access:public	signature:( NodeAlloc& alloc, int height, U&& data, bool isHead = false)
folly::detail::SkipListNode::data	.\ConcurrentSkipList-inl.h	/^  const value_type& data() const { return data_; }$/;"	f	class:folly::detail::SkipListNode	access:public	signature:() const
folly::detail::SkipListNode::data	.\ConcurrentSkipList-inl.h	/^  value_type& data() { return data_; }$/;"	f	class:folly::detail::SkipListNode	access:public	signature:()
folly::detail::SkipListNode::data_	.\ConcurrentSkipList-inl.h	/^  value_type data_;$/;"	m	class:folly::detail::SkipListNode	access:private
folly::detail::SkipListNode::destroy	.\ConcurrentSkipList-inl.h	/^  static void destroy(NodeAlloc& alloc, SkipListNode* node) {$/;"	f	class:folly::detail::SkipListNode	access:public	signature:(NodeAlloc& alloc, SkipListNode* node)
folly::detail::SkipListNode::destroyIsNoOp	.\ConcurrentSkipList-inl.h	/^  static constexpr bool destroyIsNoOp() {$/;"	f	class:folly::detail::SkipListNode	access:public	signature:()
folly::detail::SkipListNode::flags_	.\ConcurrentSkipList-inl.h	/^  std::atomic<uint16_t> flags_;$/;"	m	class:folly::detail::SkipListNode	access:private
folly::detail::SkipListNode::fullyLinked	.\ConcurrentSkipList-inl.h	/^  bool fullyLinked() const      { return getFlags() & FULLY_LINKED; }$/;"	f	class:folly::detail::SkipListNode	access:public	signature:() const
folly::detail::SkipListNode::getFlags	.\ConcurrentSkipList-inl.h	/^  uint16_t getFlags() const {$/;"	f	class:folly::detail::SkipListNode	access:private	signature:() const
folly::detail::SkipListNode::height	.\ConcurrentSkipList-inl.h	/^  int height() const { return height_; }$/;"	f	class:folly::detail::SkipListNode	access:public	signature:() const
folly::detail::SkipListNode::height_	.\ConcurrentSkipList-inl.h	/^  const uint8_t height_;$/;"	m	class:folly::detail::SkipListNode	access:private
folly::detail::SkipListNode::isHeadNode	.\ConcurrentSkipList-inl.h	/^  bool isHeadNode() const       { return getFlags() & IS_HEAD_NODE; }$/;"	f	class:folly::detail::SkipListNode	access:public	signature:() const
folly::detail::SkipListNode::markedForRemoval	.\ConcurrentSkipList-inl.h	/^  bool markedForRemoval() const { return getFlags() & MARKED_FOR_REMOVAL; }$/;"	f	class:folly::detail::SkipListNode	access:public	signature:() const
folly::detail::SkipListNode::maxLayer	.\ConcurrentSkipList-inl.h	/^  int maxLayer() const { return height_ - 1; }$/;"	f	class:folly::detail::SkipListNode	access:public	signature:() const
folly::detail::SkipListNode::next	.\ConcurrentSkipList-inl.h	/^  SkipListNode* next() {$/;"	f	class:folly::detail::SkipListNode	access:public	signature:()
folly::detail::SkipListNode::setFlags	.\ConcurrentSkipList-inl.h	/^  void setFlags(uint16_t flags) {$/;"	f	class:folly::detail::SkipListNode	access:private	signature:(uint16_t flags)
folly::detail::SkipListNode::setFullyLinked	.\ConcurrentSkipList-inl.h	/^  void setFullyLinked() {$/;"	f	class:folly::detail::SkipListNode	access:public	signature:()
folly::detail::SkipListNode::setIsHeadNode	.\ConcurrentSkipList-inl.h	/^  void setIsHeadNode() {$/;"	f	class:folly::detail::SkipListNode	access:public	signature:()
folly::detail::SkipListNode::setMarkedForRemoval	.\ConcurrentSkipList-inl.h	/^  void setMarkedForRemoval() {$/;"	f	class:folly::detail::SkipListNode	access:public	signature:()
folly::detail::SkipListNode::setSkip	.\ConcurrentSkipList-inl.h	/^  void setSkip(uint8_t h, SkipListNode* next) {$/;"	f	class:folly::detail::SkipListNode	access:public	signature:(uint8_t h, SkipListNode* next)
folly::detail::SkipListNode::skip	.\ConcurrentSkipList-inl.h	/^  inline SkipListNode* skip(int layer) const {$/;"	f	class:folly::detail::SkipListNode	access:public	signature:(int layer) const
folly::detail::SkipListNode::skip_	.\ConcurrentSkipList-inl.h	/^  std::atomic<SkipListNode*> skip_[0];$/;"	m	class:folly::detail::SkipListNode	access:private
folly::detail::SkipListNode::spinLock_	.\ConcurrentSkipList-inl.h	/^  MicroSpinLock spinLock_;$/;"	m	class:folly::detail::SkipListNode	access:private
folly::detail::SkipListNode::value_type	.\ConcurrentSkipList-inl.h	/^  typedef T value_type;$/;"	t	class:folly::detail::SkipListNode	access:public
folly::detail::SkipListNode::~SkipListNode	.\ConcurrentSkipList-inl.h	/^  ~SkipListNode() {$/;"	f	class:folly::detail::SkipListNode	access:private	signature:()
folly::detail::SkipListRandomHeight	.\ConcurrentSkipList-inl.h	/^class SkipListRandomHeight {$/;"	c	namespace:folly::detail
folly::detail::SkipListRandomHeight::SkipListRandomHeight	.\ConcurrentSkipList-inl.h	/^  SkipListRandomHeight() { initLookupTable(); }$/;"	f	class:folly::detail::SkipListRandomHeight	access:private	signature:()
folly::detail::SkipListRandomHeight::getHeight	.\ConcurrentSkipList-inl.h	/^  int getHeight(int maxHeight) const {$/;"	f	class:folly::detail::SkipListRandomHeight	access:public	signature:(int maxHeight) const
folly::detail::SkipListRandomHeight::getSizeLimit	.\ConcurrentSkipList-inl.h	/^  size_t getSizeLimit(int height) const {$/;"	f	class:folly::detail::SkipListRandomHeight	access:public	signature:(int height) const
folly::detail::SkipListRandomHeight::initLookupTable	.\ConcurrentSkipList-inl.h	/^  void initLookupTable() {$/;"	f	class:folly::detail::SkipListRandomHeight	access:private	signature:()
folly::detail::SkipListRandomHeight::instance	.\ConcurrentSkipList-inl.h	/^  static SkipListRandomHeight *instance() {$/;"	f	class:folly::detail::SkipListRandomHeight	access:public	signature:()
folly::detail::SkipListRandomHeight::kMaxHeight	.\ConcurrentSkipList-inl.h	/^  enum { kMaxHeight = 64 };$/;"	e	enum:folly::detail::SkipListRandomHeight::__anon6
folly::detail::SkipListRandomHeight::lookupTable_	.\ConcurrentSkipList-inl.h	/^  double lookupTable_[kMaxHeight];$/;"	m	class:folly::detail::SkipListRandomHeight	access:private
folly::detail::SkipListRandomHeight::randomProb	.\ConcurrentSkipList-inl.h	/^  static double randomProb() {$/;"	f	class:folly::detail::SkipListRandomHeight	access:private	signature:()
folly::detail::SkipListRandomHeight::sizeLimitTable_	.\ConcurrentSkipList-inl.h	/^  size_t sizeLimitTable_[kMaxHeight];$/;"	m	class:folly::detail::SkipListRandomHeight	access:private
folly::detail::Sleeper	.\SmallLocks.h	/^  class Sleeper {$/;"	c	namespace:folly::detail
folly::detail::Sleeper::Sleeper	.\SmallLocks.h	/^    Sleeper() : spinCount(0) {}$/;"	f	class:folly::detail::Sleeper	access:public	signature:()
folly::detail::Sleeper::kMaxActiveSpin	.\SmallLocks.h	/^    static const uint32_t kMaxActiveSpin = 4000;$/;"	m	class:folly::detail::Sleeper	access:private
folly::detail::Sleeper::spinCount	.\SmallLocks.h	/^    uint32_t spinCount;$/;"	m	class:folly::detail::Sleeper	access:private
folly::detail::Sleeper::wait	.\SmallLocks.h	/^    void wait() {$/;"	f	class:folly::detail::Sleeper	access:public	signature:()
folly::detail::SlowFingerprint	.\detail\SlowFingerprint.h	/^class SlowFingerprint {$/;"	c	namespace:folly::detail
folly::detail::SlowFingerprint::SlowFingerprint	.\detail\SlowFingerprint.h	/^  SlowFingerprint()$/;"	f	class:folly::detail::SlowFingerprint	access:public	signature:()
folly::detail::SlowFingerprint::fp_	.\detail\SlowFingerprint.h	/^  FingerprintPolynomial<BITS-1> fp_;$/;"	m	class:folly::detail::SlowFingerprint	access:private
folly::detail::SlowFingerprint::poly_	.\detail\SlowFingerprint.h	/^  const FingerprintPolynomial<BITS-1> poly_;$/;"	m	class:folly::detail::SlowFingerprint	access:private
folly::detail::SlowFingerprint::update	.\detail\SlowFingerprint.h	/^  SlowFingerprint& update(const folly::StringPiece& str) {$/;"	f	class:folly::detail::SlowFingerprint	access:public	signature:(const folly::StringPiece& str)
folly::detail::SlowFingerprint::update32	.\detail\SlowFingerprint.h	/^  SlowFingerprint& update32(uint32_t v) {$/;"	f	class:folly::detail::SlowFingerprint	access:public	signature:(uint32_t v)
folly::detail::SlowFingerprint::update64	.\detail\SlowFingerprint.h	/^  SlowFingerprint& update64(uint64_t v) {$/;"	f	class:folly::detail::SlowFingerprint	access:public	signature:(uint64_t v)
folly::detail::SlowFingerprint::update8	.\detail\SlowFingerprint.h	/^  SlowFingerprint& update8(uint8_t v) {$/;"	f	class:folly::detail::SlowFingerprint	access:public	signature:(uint8_t v)
folly::detail::SlowFingerprint::updateBit	.\detail\SlowFingerprint.h	/^  void updateBit(bool bit) {$/;"	f	class:folly::detail::SlowFingerprint	access:private	signature:(bool bit)
folly::detail::SlowFingerprint::updateLSB	.\detail\SlowFingerprint.h	/^  void updateLSB(uint64_t val, int bits) {$/;"	f	class:folly::detail::SlowFingerprint	access:private	signature:(uint64_t val, int bits)
folly::detail::SlowFingerprint::write	.\detail\SlowFingerprint.h	/^  void write(uint64_t* out) const {$/;"	f	class:folly::detail::SlowFingerprint	access:public	signature:(uint64_t* out) const
folly::detail::StateSize	.\Random-inl.h	/^struct StateSize<__gnu_cxx::simd_fast_mersenne_twister_engine<$/;"	s	namespace:folly::detail
folly::detail::StateSize	.\Random-inl.h	/^struct StateSize<std::linear_congruential_engine<UIntType, a, c, m>> {$/;"	s	namespace:folly::detail
folly::detail::StateSize	.\Random-inl.h	/^struct StateSize<std::mersenne_twister_engine<UIntType, w, n, m, r,$/;"	s	namespace:folly::detail
folly::detail::StateSize	.\Random-inl.h	/^struct StateSize<std::subtract_with_carry_engine<UIntType, w, s, r>> {$/;"	s	namespace:folly::detail
folly::detail::StateSize	.\Random-inl.h	/^template <class RNG> struct StateSize {$/;"	s	namespace:folly::detail
folly::detail::StateSize::value	.\Random-inl.h	/^                                       a, u, d, s, b, t, c, l, f>>::value;$/;"	m	class:folly::detail::StateSize
folly::detail::StateSize::value	.\Random-inl.h	/^    parity1, parity2, parity3, parity4>>::value;$/;"	m	class:folly::detail::StateSize
folly::detail::StateSize::value	.\Random-inl.h	/^  static constexpr size_t value = 512;$/;"	m	struct:folly::detail::StateSize	access:public
folly::detail::StateSize::value	.\Random-inl.h	/^  static constexpr size_t value = r * ((w + 31) \/ 32);$/;"	m	struct:folly::detail::StateSize	access:public
folly::detail::StateSize::value	.\Random-inl.h	/^  static constexpr size_t value =$/;"	m	struct:folly::detail::StateSize	access:public
folly::detail::StateSize::value	.\Random-inl.h	/^StateSize<std::linear_congruential_engine<UIntType, a, c, m>>::value;$/;"	m	class:folly::detail::StateSize
folly::detail::StateSize::value	.\Random-inl.h	/^StateSize<std::subtract_with_carry_engine<UIntType, w, s, r>>::value;$/;"	m	class:folly::detail::StateSize
folly::detail::StateSize::value	.\Random-inl.h	/^constexpr size_t StateSize<RNG>::value;$/;"	m	class:folly::detail::StateSize
folly::detail::Thrower	.\detail\ExceptionWrapper.h	/^class Thrower {$/;"	c	namespace:folly::detail
folly::detail::Thrower::doThrow	.\detail\ExceptionWrapper.h	/^  static void doThrow(std::exception* obj) {$/;"	f	class:folly::detail::Thrower	access:public	signature:(std::exception* obj)
folly::detail::TimeIterPair	.\Benchmark.h	/^typedef std::pair<uint64_t, unsigned int> TimeIterPair;$/;"	t	namespace:folly::detail
folly::detail::TurnSequencer	.\MPMCQueue.h	/^struct TurnSequencer {$/;"	s	namespace:folly::detail
folly::detail::TurnSequencer::kMaxSpins	.\MPMCQueue.h	/^    kMaxSpins = 2000,$/;"	m	struct:folly::detail::TurnSequencer	typeref:enum:folly::detail::TurnSequencer::	access:private
folly::detail::TurnSequencer::kMinSpins	.\MPMCQueue.h	/^    kMinSpins = 20,$/;"	m	struct:folly::detail::TurnSequencer	typeref:enum:folly::detail::TurnSequencer::	access:private
folly::detail::TurnSequencer::kWaitersMask	.\MPMCQueue.h	/^    kWaitersMask = (1 << kTurnShift) - 1,$/;"	m	struct:folly::detail::TurnSequencer	typeref:enum:folly::detail::TurnSequencer::	access:private
folly::detail::TurnSequencer::noexcept	.\MPMCQueue.h	/^  explicit TurnSequencer(const uint32_t firstTurn = 0) noexcept$/;"	m	struct:folly::detail::TurnSequencer	access:public
folly::detail::TypeDescriptor	.\experimental\Singleton.h	/^class TypeDescriptor {$/;"	c	namespace:folly::detail
folly::detail::TypeDescriptor::TypeDescriptor	.\experimental\Singleton.h	/^  TypeDescriptor(const std::type_info& ti, std::string name)$/;"	f	class:folly::detail::TypeDescriptor	access:public	signature:(const std::type_info& ti, std::string name)
folly::detail::TypeDescriptor::TypeDescriptorHasher	.\experimental\Singleton.h	/^  friend class TypeDescriptorHasher;$/;"	x
folly::detail::TypeDescriptor::name	.\experimental\Singleton.h	/^  std::string name() const {$/;"	f	class:folly::detail::TypeDescriptor	access:public	signature:() const
folly::detail::TypeDescriptor::name_	.\experimental\Singleton.h	/^  const std::string name_;$/;"	m	class:folly::detail::TypeDescriptor	access:private
folly::detail::TypeDescriptor::operator ==	.\experimental\Singleton.h	/^  bool operator==(const TypeDescriptor& other) const {$/;"	f	class:folly::detail::TypeDescriptor	access:public	signature:(const TypeDescriptor& other) const
folly::detail::TypeDescriptor::ti_	.\experimental\Singleton.h	/^  const std::type_index ti_;$/;"	m	class:folly::detail::TypeDescriptor	access:private
folly::detail::TypeDescriptorHasher	.\experimental\Singleton.h	/^class TypeDescriptorHasher {$/;"	c	namespace:folly::detail
folly::detail::TypeDescriptorHasher::operator ()	.\experimental\Singleton.h	/^  size_t operator()(const TypeDescriptor& ti) const {$/;"	f	class:folly::detail::TypeDescriptorHasher	access:public	signature:(const TypeDescriptor& ti) const
folly::detail::UncaughtExceptionCounter	.\detail\UncaughtExceptionCounter.h	/^class UncaughtExceptionCounter {$/;"	c	namespace:folly::detail
folly::detail::UncaughtExceptionCounter::UncaughtExceptionCounter	.\detail\UncaughtExceptionCounter.h	/^  UncaughtExceptionCounter()$/;"	f	class:folly::detail::UncaughtExceptionCounter	access:public	signature:()
folly::detail::UncaughtExceptionCounter::UncaughtExceptionCounter	.\detail\UncaughtExceptionCounter.h	/^  UncaughtExceptionCounter(const UncaughtExceptionCounter& other)$/;"	f	class:folly::detail::UncaughtExceptionCounter	access:public	signature:(const UncaughtExceptionCounter& other)
folly::detail::UncaughtExceptionCounter::exceptionCount_	.\detail\UncaughtExceptionCounter.h	/^  int exceptionCount_;$/;"	m	class:folly::detail::UncaughtExceptionCounter	access:private
folly::detail::UncaughtExceptionCounter::noexcept	.\detail\UncaughtExceptionCounter.h	/^  int getUncaughtExceptionCount() noexcept;$/;"	m	class:folly::detail::UncaughtExceptionCounter	access:private
folly::detail::__anon86::writeStderr	.\SafeAssert.cpp	/^void writeStderr(const char* s) {$/;"	f	namespace:folly::detail::__anon86	signature:(const char* s)
folly::detail::acquireRead	.\Synchronized.h	/^acquireRead(T& mutex) {$/;"	f	namespace:folly::detail	signature:(T& mutex)
folly::detail::acquireRead	.\Synchronized.h	/^acquireRead(T& mutex,$/;"	f	namespace:folly::detail	signature:(T& mutex, unsigned int milliseconds)
folly::detail::acquireReadWrite	.\Synchronized.h	/^acquireReadWrite(T& mutex) {$/;"	f	namespace:folly::detail	signature:(T& mutex)
folly::detail::acquireReadWrite	.\Synchronized.h	/^acquireReadWrite(T& mutex,$/;"	f	namespace:folly::detail	signature:(T& mutex, unsigned int milliseconds)
folly::detail::addBenchmarkImpl	.\Benchmark.cpp	/^void detail::addBenchmarkImpl(const char* file, const char* name,$/;"	f	class:folly::detail	signature:(const char* file, const char* name, BenchmarkFun fun)
folly::detail::addBenchmarkImpl	.\Benchmark.h	/^void addBenchmarkImpl(const char* file,$/;"	p	namespace:folly::detail	signature:(const char* file, const char* name, std::function<TimeIterPair(unsigned int)>)
folly::detail::assertionFailure	.\SafeAssert.cpp	/^void assertionFailure(const char* expr, const char* msg, const char* file,$/;"	f	namespace:folly::detail	signature:(const char* expr, const char* msg, const char* file, unsigned int line, const char* function)
folly::detail::assertionFailure	.\SafeAssert.h	/^FOLLY_NORETURN void assertionFailure(const char* expr, const char* msg,$/;"	p	namespace:folly::detail	signature:(const char* expr, const char* msg, const char* file, unsigned int line, const char* function)
folly::detail::atDelim	.\String-inl.h	/^inline bool atDelim(const char* s, StringPiece sp) {$/;"	f	namespace:folly::detail	signature:(const char* s, StringPiece sp)
folly::detail::atDelim	.\String-inl.h	/^inline bool atDelim(const char* s, char c) {$/;"	f	namespace:folly::detail	signature:(const char* s, char c)
folly::detail::avgHelper	.\detail\Stats.h	/^ReturnType avgHelper(long double sum, uint64_t count) {$/;"	f	namespace:folly::detail	signature:(long double sum, uint64_t count)
folly::detail::avgHelper	.\detail\Stats.h	/^avgHelper(ValueType sum, uint64_t count) {$/;"	f	namespace:folly::detail	signature:(ValueType sum, uint64_t count)
folly::detail::back	.\detail\CacheLocality.cpp	/^    CacheLocality::system<>().numCachesByLevel.back());$/;"	p	namespace:folly::detail	file:	signature:()
folly::detail::back	.\test\DeterministicSchedule.cpp	/^    CacheLocality::system<>().numCachesByLevel.back());$/;"	p	namespace:folly::detail	file:	signature:()
folly::detail::bool_str_cmp	.\Conv.cpp	/^inline bool bool_str_cmp(const char** b, size_t len, const char* value) {$/;"	f	namespace:folly::detail	signature:(const char** b, size_t len, const char* value)
folly::detail::convertTo	.\String-inl.h	/^struct convertTo {$/;"	s	namespace:folly::detail
folly::detail::convertTo::from	.\String-inl.h	/^  static Dst from(const Dst& src) { return src; }$/;"	f	struct:folly::detail::convertTo	access:public	signature:(const Dst& src)
folly::detail::convertTo::from	.\String-inl.h	/^  static Dst from(const Src& src) { return folly::to<Dst>(src); }$/;"	f	struct:folly::detail::convertTo	access:public	signature:(const Src& src)
folly::detail::crc32c_hw	.\Checksum.cpp	/^uint32_t crc32c_hw(const uint8_t *data, size_t nbytes,$/;"	f	namespace:folly::detail	signature:(const uint8_t *data, size_t nbytes, uint32_t startingChecksum)
folly::detail::crc32c_hw	.\detail\ChecksumDetail.h	/^uint32_t crc32c_hw(const uint8_t* data, size_t nbytes,$/;"	p	namespace:folly::detail	signature:(const uint8_t* data, size_t nbytes, uint32_t startingChecksum = ~0U)
folly::detail::crc32c_hw_supported	.\Checksum.cpp	/^bool crc32c_hw_supported() {$/;"	f	namespace:folly::detail	signature:()
folly::detail::crc32c_hw_supported	.\detail\ChecksumDetail.h	/^bool crc32c_hw_supported();$/;"	p	namespace:folly::detail	signature:()
folly::detail::crc32c_sw	.\Checksum.cpp	/^uint32_t crc32c_sw(const uint8_t *data, size_t nbytes,$/;"	f	namespace:folly::detail	signature:(const uint8_t *data, size_t nbytes, uint32_t startingChecksum)
folly::detail::crc32c_sw	.\detail\ChecksumDetail.h	/^uint32_t crc32c_sw(const uint8_t* data, size_t nbytes,$/;"	p	namespace:folly::detail	signature:(const uint8_t* data, size_t nbytes, uint32_t startingChecksum = ~0U)
folly::detail::csl_iterator	.\ConcurrentSkipList-inl.h	/^template<typename ValT, typename NodeT> class csl_iterator;$/;"	x
folly::detail::csl_iterator	.\ConcurrentSkipList.h	/^class detail::csl_iterator :$/;"	c	class:folly::detail	inherits:boost::iterator_facade
folly::detail::csl_iterator::csl_iterator	.\ConcurrentSkipList.h	/^  csl_iterator(const csl_iterator<OtherVal, OtherNode> &other,$/;"	f	class:folly::detail::csl_iterator	access:public	signature:(const csl_iterator<OtherVal, OtherNode> &other, typename std::enable_if<std::is_convertible<OtherVal, ValT>::value>::type* = 0)
folly::detail::csl_iterator::csl_iterator	.\ConcurrentSkipList.h	/^  explicit csl_iterator(NodeT* node = nullptr) : node_(node) {}$/;"	f	class:folly::detail::csl_iterator	access:public	signature:(NodeT* node = nullptr)
folly::detail::csl_iterator::csl_iterator	.\ConcurrentSkipList.h	/^  template<class,class> friend class csl_iterator;$/;"	x
folly::detail::csl_iterator::dereference	.\ConcurrentSkipList.h	/^  value_type& dereference() const { return node_->data(); }$/;"	f	class:folly::detail::csl_iterator	access:private	signature:() const
folly::detail::csl_iterator::difference_type	.\ConcurrentSkipList.h	/^  typedef ptrdiff_t difference_type;$/;"	t	class:folly::detail::csl_iterator	access:public
folly::detail::csl_iterator::equal	.\ConcurrentSkipList.h	/^  bool equal(const csl_iterator& other) const { return node_ == other.node_; }$/;"	f	class:folly::detail::csl_iterator	access:private	signature:(const csl_iterator& other) const
folly::detail::csl_iterator::good	.\ConcurrentSkipList.h	/^  bool good() const { return node_ != nullptr; }$/;"	f	class:folly::detail::csl_iterator	access:public	signature:() const
folly::detail::csl_iterator::increment	.\ConcurrentSkipList.h	/^  void increment() { node_ = node_->next(); };$/;"	f	class:folly::detail::csl_iterator	access:private	signature:()
folly::detail::csl_iterator::nodeSize	.\ConcurrentSkipList.h	/^  size_t nodeSize() const {$/;"	f	class:folly::detail::csl_iterator	access:public	signature:() const
folly::detail::csl_iterator::node_	.\ConcurrentSkipList.h	/^  NodeT* node_;$/;"	m	class:folly::detail::csl_iterator	access:private
folly::detail::csl_iterator::pointer	.\ConcurrentSkipList.h	/^  typedef value_type* pointer;$/;"	t	class:folly::detail::csl_iterator	access:public
folly::detail::csl_iterator::reference	.\ConcurrentSkipList.h	/^  typedef value_type& reference;$/;"	t	class:folly::detail::csl_iterator	access:public
folly::detail::csl_iterator::value_type	.\ConcurrentSkipList.h	/^  typedef ValT value_type;$/;"	t	class:folly::detail::csl_iterator	access:public
folly::detail::degenerateGetcpu	.\detail\CacheLocality.cpp	/^static int degenerateGetcpu(unsigned* cpu, unsigned* node, void* unused) {$/;"	f	namespace:folly::detail	signature:(unsigned* cpu, unsigned* node, void* unused)
folly::detail::delimFront	.\String-inl.h	/^inline char delimFront(StringPiece s) {$/;"	f	namespace:folly::detail	signature:(StringPiece s)
folly::detail::delimFront	.\String-inl.h	/^inline char delimFront(char c) {$/;"	f	namespace:folly::detail	signature:(char c)
folly::detail::delimSize	.\String-inl.h	/^inline size_t delimSize(StringPiece s) { return s.size(); }$/;"	f	namespace:folly::detail	signature:(StringPiece s)
folly::detail::delimSize	.\String-inl.h	/^inline size_t delimSize(char)          { return 1; }$/;"	f	namespace:folly::detail	signature:(char)
folly::detail::digit1	.\Conv.cpp	/^extern const char digit1[101] =$/;"	m	namespace:folly::detail	file:
folly::detail::digit2	.\Conv.cpp	/^extern const char digit2[101] =$/;"	m	namespace:folly::detail	file:
folly::detail::digitsEnough	.\Conv.h	/^digitsEnough() {$/;"	f	namespace:folly::detail	signature:()
folly::detail::distance_if_multipass	.\sorted_vector_types.h	/^  int distance_if_multipass(Iterator first, Iterator last) {$/;"	f	namespace:folly::detail	signature:(Iterator first, Iterator last)
folly::detail::downTo	.\Foreach.h	/^downTo(T& iter, const U& begin) {$/;"	f	namespace:folly::detail	signature:(T& iter, const U& begin)
folly::detail::familyNameStr	.\detail\IPAddress.h	/^inline std::string familyNameStr(sa_family_t family) {$/;"	f	namespace:folly::detail	signature:(sa_family_t family)
folly::detail::fastIpv4ToString	.\detail\IPAddress.h	/^inline std::string fastIpv4ToString($/;"	f	namespace:folly::detail	signature:( const in_addr& inAddr)
folly::detail::fastIpv6ToString	.\detail\IPAddress.h	/^inline std::string fastIpv6ToString(const in6_addr& in6Addr) {$/;"	f	namespace:folly::detail	signature:(const in6_addr& in6Addr)
folly::detail::fetchStackLimits	.\detail\MemoryIdler.cpp	/^static void fetchStackLimits() {$/;"	f	namespace:folly::detail	signature:()
folly::detail::front	.\detail\CacheLocality.cpp	/^    CacheLocality::system<>().numCachesByLevel.front());$/;"	p	namespace:folly::detail	file:	signature:()
folly::detail::front	.\test\DeterministicSchedule.cpp	/^    CacheLocality::system<>().numCachesByLevel.front());$/;"	p	namespace:folly::detail	file:	signature:()
folly::detail::futexErrnoToFutexResult	.\detail\Futex.cpp	/^FutexResult futexErrnoToFutexResult(int returnVal, int futexErrno) {$/;"	f	namespace:folly::detail	signature:(int returnVal, int futexErrno)
folly::detail::futexErrnoToFutexResult	.\detail\Futex.h	/^FutexResult futexErrnoToFutexResult(int returnVal, int futexErrno);$/;"	p	namespace:folly::detail	signature:(int returnVal, int futexErrno)
folly::detail::futexWaitUntilImpl	.\test\DeterministicSchedule.cpp	/^FutexResult futexWaitUntilImpl(Futex<DeterministicAtomic>* futex,$/;"	f	namespace:folly::detail	signature:(Futex<DeterministicAtomic>* futex, uint32_t expected, uint32_t waitMask)
folly::detail::getLastElement	.\Conv.h	/^const T& getLastElement(const T & v) {$/;"	f	namespace:folly::detail	signature:(const T & v)
folly::detail::getNthMSBitImpl	.\detail\IPAddress.h	/^inline bool getNthMSBitImpl(const IPAddrType& ip, uint8_t bitIndex,$/;"	f	namespace:folly::detail	signature:(const IPAddrType& ip, uint8_t bitIndex, sa_family_t family)
folly::detail::getStackPtr	.\detail\MemoryIdler.cpp	/^FOLLY_NOINLINE static uintptr_t getStackPtr() {$/;"	f	namespace:folly::detail	signature:()
folly::detail::getSystemLocalityInfo	.\detail\CacheLocality.cpp	/^static CacheLocality getSystemLocalityInfo() {$/;"	f	namespace:folly::detail	signature:()
folly::detail::greater_than_impl	.\Traits.h	/^bool greater_than_impl($/;"	f	namespace:folly::detail	signature:( typename std::enable_if< (rhs < std::numeric_limits<LHS>::min()), LHS >::type const )
folly::detail::greater_than_impl	.\Traits.h	/^bool greater_than_impl($/;"	f	namespace:folly::detail	signature:( typename std::enable_if< (rhs <= std::numeric_limits<LHS>::max() && rhs >= std::numeric_limits<LHS>::min()), LHS >::type const lhs )
folly::detail::greater_than_impl	.\Traits.h	/^bool greater_than_impl($/;"	f	namespace:folly::detail	signature:( typename std::enable_if< (rhs > std::numeric_limits<LHS>::max()), LHS >::type const )
folly::detail::growth_policy_wrapper	.\sorted_vector_types.h	/^  struct growth_policy_wrapper : private Policy {$/;"	s	namespace:folly::detail	inherits:Policy
folly::detail::growth_policy_wrapper	.\sorted_vector_types.h	/^  struct growth_policy_wrapper<void> {$/;"	s	namespace:folly::detail
folly::detail::growth_policy_wrapper::increase_capacity	.\sorted_vector_types.h	/^    Iterator increase_capacity(Container& c, Iterator desired_insertion)$/;"	f	struct:folly::detail::growth_policy_wrapper	access:public	signature:(Container& c, Iterator desired_insertion)
folly::detail::growth_policy_wrapper::increase_capacity	.\sorted_vector_types.h	/^    Iterator increase_capacity(Container&, Iterator it) {$/;"	f	struct:folly::detail::growth_policy_wrapper	access:public	signature:(Container&, Iterator it)
folly::detail::hexDumpLine	.\String-inl.h	/^size_t hexDumpLine(const void* ptr, size_t offset, size_t size,$/;"	p	namespace:folly::detail	signature:(const void* ptr, size_t offset, size_t size, std::string& line)
folly::detail::hexDumpLine	.\String.cpp	/^size_t hexDumpLine(const void* ptr, size_t offset, size_t size,$/;"	f	namespace:folly::detail	signature:(const void* ptr, size_t offset, size_t size, std::string& line)
folly::detail::insert_with_hint	.\sorted_vector_types.h	/^  insert_with_hint(OurContainer& sorted,$/;"	f	namespace:folly::detail	signature:(OurContainer& sorted, Vector& cont, typename OurContainer::iterator hint, typename OurContainer::value_type&& value, GrowthPolicy& po)
folly::detail::internalJoin	.\String-inl.h	/^internalJoin(Delim delimiter,$/;"	f	namespace:folly::detail	signature:(Delim delimiter, Iterator begin, Iterator end, String& output)
folly::detail::internalJoinAppend	.\String-inl.h	/^void internalJoinAppend(Delim delimiter,$/;"	f	namespace:folly::detail	signature:(Delim delimiter, Iterator begin, Iterator end, String& output)
folly::detail::internalSplit	.\String-inl.h	/^void internalSplit(DelimT delim, StringPiece sp, OutputIterator out,$/;"	f	namespace:folly::detail	signature:(DelimT delim, StringPiece sp, OutputIterator out, bool ignoreEmpty)
folly::detail::is_negative_impl	.\Traits.h	/^struct is_negative_impl {$/;"	s	namespace:folly::detail
folly::detail::is_negative_impl	.\Traits.h	/^struct is_negative_impl<T, false> {$/;"	s	namespace:folly::detail
folly::detail::is_negative_impl::check	.\Traits.h	/^  constexpr static bool check(T x) { return false; }$/;"	f	struct:folly::detail::is_negative_impl	access:public	signature:(T x)
folly::detail::is_negative_impl::check	.\Traits.h	/^  constexpr static bool check(T x) { return x < 0; }$/;"	f	struct:folly::detail::is_negative_impl	access:public	signature:(T x)
folly::detail::kDefaultTypeDescriptorName	.\experimental\Singleton.h	/^const char* const kDefaultTypeDescriptorName = "(default)";$/;"	m	namespace:folly::detail
folly::detail::kMaxBinaryLength	.\Format-inl.h	/^const size_t kMaxBinaryLength = 8 * sizeof(uintmax_t);$/;"	m	namespace:folly::detail
folly::detail::kMaxHexLength	.\Format-inl.h	/^const size_t kMaxHexLength = 2 * sizeof(uintmax_t);$/;"	m	namespace:folly::detail
folly::detail::kMaxOctalLength	.\Format-inl.h	/^const size_t kMaxOctalLength = 3 * sizeof(uintmax_t);$/;"	m	namespace:folly::detail
folly::detail::last_element	.\Conv.h	/^struct last_element {$/;"	s	namespace:folly::detail
folly::detail::last_element	.\Conv.h	/^struct last_element<> {$/;"	s	namespace:folly::detail
folly::detail::last_element::std::enable_if	.\Conv.h	/^  typedef typename std::enable_if<$/;"	t	class:folly::detail::last_element::std	access:public
folly::detail::last_element::type	.\Conv.h	/^    >::type>::type type;$/;"	t	struct:folly::detail::last_element	access:public
folly::detail::last_element::type	.\Conv.h	/^  typedef void type;$/;"	t	struct:folly::detail::last_element	access:public
folly::detail::less_than_impl	.\Traits.h	/^bool less_than_impl($/;"	f	namespace:folly::detail	signature:( typename std::enable_if< (rhs <= std::numeric_limits<LHS>::max() && rhs > std::numeric_limits<LHS>::min()), LHS >::type const lhs )
folly::detail::less_than_impl	.\Traits.h	/^bool less_than_impl($/;"	f	namespace:folly::detail	signature:( typename std::enable_if< (rhs <= std::numeric_limits<LHS>::min()), LHS >::type const )
folly::detail::less_than_impl	.\Traits.h	/^bool less_than_impl($/;"	f	namespace:folly::detail	signature:( typename std::enable_if< (rhs > std::numeric_limits<LHS>::max()), LHS >::type const )
folly::detail::loadVdsoGetcpu	.\detail\CacheLocality.cpp	/^static Getcpu::Func loadVdsoGetcpu() {$/;"	f	namespace:folly::detail	signature:()
folly::detail::makeCallable	.\ApplyTuple.h	/^template<class F> F& makeCallable(F& f) { return f; }$/;"	f	namespace:folly::detail	signature:(F& f)
folly::detail::mallctlWrapper	.\detail\MemoryIdler.cpp	/^static unsigned mallctlWrapper(const char* cmd, const unsigned* in,$/;"	f	namespace:folly::detail	signature:(const char* cmd, const unsigned* in, unsigned* out)
folly::detail::mem_fn	.\ApplyTuple.h	/^auto makeCallable(R (C::*d)(A...)) -> decltype(std::mem_fn(d)) {$/;"	f	namespace:folly::detail	signature:(d)
folly::detail::moveObjectsRight	.\small_vector.h	/^  moveObjectsRight(T* first, T* lastConstructed, T* realLast) {$/;"	f	namespace:folly::detail	signature:(T* first, T* lastConstructed, T* realLast)
folly::detail::moveToUninitialized	.\small_vector.h	/^  moveToUninitialized(T* first, T* last, T* out) {$/;"	f	namespace:folly::detail	signature:(T* first, T* last, T* out)
folly::detail::mpl	.\small_vector.h	/^  namespace mpl = boost::mpl;$/;"	x
folly::detail::notThereYet	.\Foreach.h	/^notThereYet(T& iter, const U& end) {$/;"	f	namespace:folly::detail	signature:(T& iter, const U& end)
folly::detail::numericOp	.\dynamic-inl.h	/^  dynamic numericOp(dynamic const& a, dynamic const& b) {$/;"	f	namespace:folly::detail	signature:(dynamic const& a, dynamic const& b)
folly::detail::operator +	.\ScopeGuard.h	/^operator+(ScopeGuardOnSuccess, FunctionType&& fn) {$/;"	f	namespace:folly::detail	signature:(ScopeGuardOnSuccess, FunctionType&& fn)
folly::detail::operator +	.\ScopeGuard.h	/^operator+(detail::ScopeGuardOnExit, FunctionType&& fn) {$/;"	f	namespace:folly::detail	signature:(detail::ScopeGuardOnExit, FunctionType&& fn)
folly::detail::operator +	.\ScopeGuard.h	/^operator+(detail::ScopeGuardOnFail, FunctionType&& fn) {$/;"	f	namespace:folly::detail	signature:(detail::ScopeGuardOnFail, FunctionType&& fn)
folly::detail::parseLeadingNumber	.\detail\CacheLocality.cpp	/^static ssize_t parseLeadingNumber(const std::string& line) {$/;"	f	namespace:folly::detail	signature:(const std::string& line)
folly::detail::pointerFlagClear	.\small_vector.h	/^  T* pointerFlagClear(T* p) {$/;"	f	namespace:folly::detail	signature:(T* p)
folly::detail::pointerFlagGet	.\small_vector.h	/^  bool pointerFlagGet(T* p) {$/;"	f	namespace:folly::detail	signature:(T* p)
folly::detail::pointerFlagSet	.\small_vector.h	/^  T* pointerFlagSet(T* p) {$/;"	f	namespace:folly::detail	signature:(T* p)
folly::detail::popcount	.\Bits.cpp	/^int popcount(unsigned int x)$/;"	p	namespace:folly::detail	file:	signature:(unsigned int x)
folly::detail::popcount	.\detail\BitsDetail.h	/^inline int popcount(unsigned int x) {$/;"	f	namespace:folly::detail	signature:(unsigned int x)
folly::detail::popcountll	.\Bits.cpp	/^int popcountll(unsigned long long x)$/;"	p	namespace:folly::detail	file:	signature:(unsigned long long x)
folly::detail::popcountll	.\detail\BitsDetail.h	/^inline int popcountll(unsigned long long x) {$/;"	f	namespace:folly::detail	signature:(unsigned long long x)
folly::detail::populateMemForward	.\small_vector.h	/^  void populateMemForward(T* mem, std::size_t n, Function const& op) {$/;"	f	namespace:folly::detail	signature:(T* mem, std::size_t n, Function const& op)
folly::detail::prepareDelim	.\String-inl.h	/^inline char prepareDelim(char c) { return c; }$/;"	f	namespace:folly::detail	signature:(char c)
folly::detail::prepareDelim	.\String-inl.h	/^template<class String> StringPiece prepareDelim(const String& s) {$/;"	f	namespace:folly::detail	signature:(const String& s)
folly::detail::qfind_first_byte_of	.\Range.h	/^inline size_t qfind_first_byte_of(const StringPiece& haystack,$/;"	f	namespace:folly::detail	signature:(const StringPiece& haystack, const StringPiece& needles)
folly::detail::qfind_first_byte_of_byteset	.\Range.cpp	/^size_t qfind_first_byte_of_byteset(const StringPiece& haystack,$/;"	f	namespace:folly::detail	signature:(const StringPiece& haystack, const StringPiece& needles)
folly::detail::qfind_first_byte_of_byteset	.\test\RangeFindBenchmark.cpp	/^size_t qfind_first_byte_of_byteset(const StringPiece& haystack,$/;"	p	namespace:folly::detail	file:	signature:(const StringPiece& haystack, const StringPiece& needles)
folly::detail::qfind_first_byte_of_byteset	.\test\RangeTest.cpp	/^size_t qfind_first_byte_of_byteset(const StringPiece& haystack,$/;"	p	namespace:folly::detail	file:	signature:(const StringPiece& haystack, const StringPiece& needles)
folly::detail::qfind_first_byte_of_memchr	.\Range.cpp	/^size_t qfind_first_byte_of_memchr(const StringPiece& haystack,$/;"	f	namespace:folly::detail	signature:(const StringPiece& haystack, const StringPiece& needles)
folly::detail::qfind_first_byte_of_memchr	.\test\RangeFindBenchmark.cpp	/^size_t qfind_first_byte_of_memchr(const StringPiece& haystack,$/;"	p	namespace:folly::detail	file:	signature:(const StringPiece& haystack, const StringPiece& needles)
folly::detail::qfind_first_byte_of_memchr	.\test\RangeTest.cpp	/^size_t qfind_first_byte_of_memchr(const StringPiece& haystack,$/;"	p	namespace:folly::detail	file:	signature:(const StringPiece& haystack, const StringPiece& needles)
folly::detail::qfind_first_byte_of_nosse	.\Range.cpp	/^size_t qfind_first_byte_of_nosse(const StringPiece& haystack,$/;"	f	namespace:folly::detail	signature:(const StringPiece& haystack, const StringPiece& needles)
folly::detail::qfind_first_byte_of_nosse	.\Range.h	/^size_t qfind_first_byte_of_nosse(const StringPiece& haystack,$/;"	p	namespace:folly::detail	signature:(const StringPiece& haystack, const StringPiece& needles)
folly::detail::qfind_first_byte_of_nosse	.\test\RangeFindBenchmark.cpp	/^size_t qfind_first_byte_of_nosse(const StringPiece& haystack,$/;"	p	namespace:folly::detail	file:	signature:(const StringPiece& haystack, const StringPiece& needles)
folly::detail::qfind_first_byte_of_sse42	.\Range.cpp	/^size_t qfind_first_byte_of_sse42(const StringPiece& haystack,$/;"	f	namespace:folly::detail	signature:(const StringPiece& haystack, const StringPiece& needles)
folly::detail::qfind_first_byte_of_sse42	.\Range.cpp	/^size_t qfind_first_byte_of_sse42(const StringPiece& haystack,$/;"	p	namespace:folly::detail	file:	signature:(const StringPiece& haystack, const StringPiece& needles)
folly::detail::qfind_first_byte_of_sse42	.\Range.h	/^size_t qfind_first_byte_of_sse42(const StringPiece& haystack,$/;"	p	namespace:folly::detail	signature:(const StringPiece& haystack, const StringPiece& needles)
folly::detail::rateHelper	.\detail\Stats.h	/^ReturnType rateHelper(ReturnType count, TimeType elapsed) {$/;"	f	namespace:folly::detail	signature:(ReturnType count, TimeType elapsed)
folly::detail::releaseRead	.\Synchronized.h	/^releaseRead(T& mutex) {$/;"	f	namespace:folly::detail	signature:(T& mutex)
folly::detail::releaseReadWrite	.\Synchronized.h	/^releaseReadWrite(T& mutex) {$/;"	f	namespace:folly::detail	signature:(T& mutex)
folly::detail::s_pageSize	.\detail\MemoryIdler.cpp	/^static const size_t s_pageSize = sysconf(_SC_PAGESIZE);$/;"	m	namespace:folly::detail	file:
folly::detail::scanHaystackBlock	.\Range.cpp	/^size_t scanHaystackBlock(const StringPiece& haystack,$/;"	f	namespace:folly::detail	signature:(const StringPiece& haystack, const StringPiece& needles, int64_t blockStartIdx)
folly::detail::shiftPointer	.\small_vector.h	/^  inline void* shiftPointer(void* p, size_t sizeBytes) {$/;"	f	namespace:folly::detail	signature:(void* p, size_t sizeBytes)
folly::detail::sizeof	.\Conv.cpp	/^static_assert(sizeof(unsigned long long) >= 8,$/;"	p	namespace:folly::detail	file:	signature:(unsigned long long)
folly::detail::sizeof	.\Conv.cpp	/^static_assert(sizeof(unsigned long) >= 4,$/;"	p	namespace:folly::detail	file:	signature:(unsigned long)
folly::detail::small_vector_base	.\small_vector.h	/^  struct small_vector_base {$/;"	s	namespace:folly::detail
folly::detail::small_vector_base::ActualSizePolicy	.\small_vector.h	/^      ActualSizePolicy;$/;"	t	struct:folly::detail::small_vector_base	access:public
folly::detail::small_vector_base::HasNoHeap	.\small_vector.h	/^    >::type HasNoHeap;$/;"	t	struct:folly::detail::small_vector_base	access:public
folly::detail::small_vector_base::Integrals	.\small_vector.h	/^    >::type Integrals;$/;"	t	struct:folly::detail::small_vector_base	access:public
folly::detail::small_vector_base::PolicyList	.\small_vector.h	/^    typedef mpl::vector<InPolicyA,InPolicyB,InPolicyC> PolicyList;$/;"	t	struct:folly::detail::small_vector_base	access:public
folly::detail::small_vector_base::SizeType	.\small_vector.h	/^    >::type SizeType;$/;"	t	struct:folly::detail::small_vector_base	access:public
folly::detail::small_vector_base::static_assert	.\small_vector.h	/^    static_assert(HasNoHeap::value == 0 || HasNoHeap::value == 1,$/;"	p	struct:folly::detail::small_vector_base	access:public	signature:(HasNoHeap::value == 0 || HasNoHeap::value == 1,  )
folly::detail::small_vector_base::static_assert	.\small_vector.h	/^    static_assert(mpl::size<Integrals>::value == 0 ||$/;"	p	struct:folly::detail::small_vector_base	access:public	signature:(mpl::size<Integrals>::value == 0 || mpl::size<Integrals>::value == 1, )
folly::detail::small_vector_base::static_assert	.\small_vector.h	/^    static_assert(std::is_unsigned<SizeType>::value,$/;"	p	struct:folly::detail::small_vector_base	access:public	signature:(std::is_unsigned<SizeType>::value, )
folly::detail::small_vector_base::type	.\small_vector.h	/^    > type;$/;"	t	struct:folly::detail::small_vector_base	access:public
folly::detail::splitFixed	.\String-inl.h	/^splitFixed(const Delim& delimiter,$/;"	f	namespace:folly::detail	signature:(const Delim& delimiter, StringPiece input, OutputType& out)
folly::detail::splitFixed	.\String-inl.h	/^splitFixed(const Delim& delimiter,$/;"	f	namespace:folly::detail	signature:(const Delim& delimiter, StringPiece input, OutputType& outHead, OutputTypes&... outTail)
folly::detail::state_	.\MPMCQueue.h	/^  Futex<Atom> state_;$/;"	m	namespace:folly::detail
folly::detail::std::tuple_element::getLastElement	.\Conv.h	/^  getLastElement(const T& v, const Ts&... vs) {$/;"	f	class:folly::detail::std::tuple_element	signature:(const T& v, const Ts&... vs)
folly::detail::str_to_bool	.\Conv.cpp	/^bool str_to_bool(StringPiece* src) {$/;"	f	namespace:folly::detail	signature:(StringPiece* src)
folly::detail::timePointToTimeSpec	.\detail\Futex.h	/^struct timespec timePointToTimeSpec(const time_point<Clock, Duration>& tp) {$/;"	f	namespace:folly::detail	signature:(const time_point<Clock, Duration>& tp)
folly::detail::timespecDiff	.\Benchmark.h	/^inline uint64_t timespecDiff(timespec end, timespec start) {$/;"	f	namespace:folly::detail	signature:(timespec end, timespec start)
folly::detail::timespecDiff	.\Benchmark.h	/^inline uint64_t timespecDiff(timespec end, timespec start,$/;"	f	namespace:folly::detail	signature:(timespec end, timespec start, timespec endCoarse, timespec startCoarse)
folly::detail::tls_stackLimit	.\detail\MemoryIdler.cpp	/^static FOLLY_TLS uintptr_t tls_stackLimit;$/;"	m	namespace:folly::detail	file:
folly::detail::tls_stackSize	.\detail\MemoryIdler.cpp	/^static FOLLY_TLS size_t tls_stackSize;$/;"	m	namespace:folly::detail	file:
folly::detail::uintToBinary	.\Format-inl.h	/^size_t uintToBinary(char* buffer, size_t bufLen, Uint v) {$/;"	f	namespace:folly::detail	signature:(char* buffer, size_t bufLen, Uint v)
folly::detail::uintToHex	.\Format-inl.h	/^size_t uintToHex(char* buffer, size_t bufLen, Uint v,$/;"	f	namespace:folly::detail	signature:(char* buffer, size_t bufLen, Uint v, const char (&repr)[256][2])
folly::detail::uintToHexLower	.\Format-inl.h	/^inline size_t uintToHexLower(char* buffer, size_t bufLen, Uint v) {$/;"	f	namespace:folly::detail	signature:(char* buffer, size_t bufLen, Uint v)
folly::detail::uintToHexUpper	.\Format-inl.h	/^inline size_t uintToHexUpper(char* buffer, size_t bufLen, Uint v) {$/;"	f	namespace:folly::detail	signature:(char* buffer, size_t bufLen, Uint v)
folly::detail::uintToOctal	.\Format-inl.h	/^size_t uintToOctal(char* buffer, size_t bufLen, Uint v) {$/;"	f	namespace:folly::detail	signature:(char* buffer, size_t bufLen, Uint v)
folly::detail::unsafeTelescope128	.\Conv.h	/^unsafeTelescope128(char * buffer, unsigned int room, unsigned __int128 x) {$/;"	f	namespace:folly::detail	signature:(char * buffer, unsigned int room, unsigned __int128 x)
folly::detail::value_before	.\Range.h	/^value_before(Iter i) {$/;"	f	namespace:folly::detail	signature:(Iter i)
folly::detail::writeIntegerString	.\detail\IPAddress.h	/^  inline void writeIntegerString($/;"	f	namespace:folly::detail	signature:( IntegralType val, char** buffer)
folly::digits10	.\Conv.h	/^inline uint32_t digits10(uint64_t v) {$/;"	f	namespace:folly	signature:(uint64_t v)
folly::doNotOptimizeAway	.\Benchmark.h	/^void doNotOptimizeAway(T&& datum) {$/;"	f	namespace:folly	signature:(T&& datum)
folly::dptr_detail	.\detail\DiscriminatedPtrDetail.h	/^namespace dptr_detail {$/;"	n	namespace:folly
folly::dptr_detail::ApplyConstVisitor	.\detail\DiscriminatedPtrDetail.h	/^struct ApplyConstVisitor$/;"	s	namespace:folly::dptr_detail	inherits:ApplyConstVisitor1
folly::dptr_detail::ApplyConstVisitor1	.\detail\DiscriminatedPtrDetail.h	/^struct ApplyConstVisitor1<V, R, T, Types...> {$/;"	s	namespace:folly::dptr_detail
folly::dptr_detail::ApplyConstVisitor1	.\detail\DiscriminatedPtrDetail.h	/^struct ApplyConstVisitor1<V, R> {$/;"	s	namespace:folly::dptr_detail
folly::dptr_detail::ApplyConstVisitor1	.\detail\DiscriminatedPtrDetail.h	/^template <typename V, typename R, typename... Types> struct ApplyConstVisitor1;$/;"	x
folly::dptr_detail::ApplyConstVisitor1::operator ()	.\detail\DiscriminatedPtrDetail.h	/^  R operator()(size_t index, V&& visitor, void* ptr) const {$/;"	f	struct:folly::dptr_detail::ApplyConstVisitor1	access:public	signature:(size_t index, V&& visitor, void* ptr) const
folly::dptr_detail::ApplyVisitor	.\detail\DiscriminatedPtrDetail.h	/^struct ApplyVisitor$/;"	s	namespace:folly::dptr_detail	inherits:ApplyVisitor1
folly::dptr_detail::ApplyVisitor1	.\detail\DiscriminatedPtrDetail.h	/^struct ApplyVisitor1<V, R, T, Types...> {$/;"	s	namespace:folly::dptr_detail
folly::dptr_detail::ApplyVisitor1	.\detail\DiscriminatedPtrDetail.h	/^struct ApplyVisitor1<V, R> {$/;"	s	namespace:folly::dptr_detail
folly::dptr_detail::ApplyVisitor1	.\detail\DiscriminatedPtrDetail.h	/^template <typename V, typename R, typename... Types> struct ApplyVisitor1;$/;"	x
folly::dptr_detail::ApplyVisitor1::operator ()	.\detail\DiscriminatedPtrDetail.h	/^  R operator()(size_t index, V&& visitor, void* ptr) const {$/;"	f	struct:folly::dptr_detail::ApplyVisitor1	access:public	signature:(size_t index, V&& visitor, void* ptr) const
folly::dptr_detail::ConstVisitorResult	.\detail\DiscriminatedPtrDetail.h	/^struct ConstVisitorResult {$/;"	s	namespace:folly::dptr_detail
folly::dptr_detail::ConstVisitorResult1	.\detail\DiscriminatedPtrDetail.h	/^struct ConstVisitorResult1 {$/;"	s	namespace:folly::dptr_detail
folly::dptr_detail::ConstVisitorResult1::type	.\detail\DiscriminatedPtrDetail.h	/^  typedef typename std::result_of<V (const T*)>::type type;$/;"	t	struct:folly::dptr_detail::ConstVisitorResult1	access:public
folly::dptr_detail::ConstVisitorResult::type	.\detail\DiscriminatedPtrDetail.h	/^    typename ConstVisitorResult1<V,Types>::type...>::type type;$/;"	t	struct:folly::dptr_detail::ConstVisitorResult	access:public
folly::dptr_detail::GetTypeIndex	.\detail\DiscriminatedPtrDetail.h	/^struct GetTypeIndex<T, T, Types...> {$/;"	s	namespace:folly::dptr_detail
folly::dptr_detail::GetTypeIndex	.\detail\DiscriminatedPtrDetail.h	/^struct GetTypeIndex<T, U, Types...> {$/;"	s	namespace:folly::dptr_detail
folly::dptr_detail::GetTypeIndex	.\detail\DiscriminatedPtrDetail.h	/^template <typename... Types> struct GetTypeIndex;$/;"	x
folly::dptr_detail::GetTypeIndex::value	.\detail\DiscriminatedPtrDetail.h	/^  static const size_t value = 1 + GetTypeIndex<T, Types...>::value;$/;"	m	struct:folly::dptr_detail::GetTypeIndex	access:public
folly::dptr_detail::GetTypeIndex::value	.\detail\DiscriminatedPtrDetail.h	/^  static const size_t value = 1;$/;"	m	struct:folly::dptr_detail::GetTypeIndex	access:public
folly::dptr_detail::IsSameType	.\detail\DiscriminatedPtrDetail.h	/^struct IsSameType;$/;"	x
folly::dptr_detail::IsSameType	.\detail\DiscriminatedPtrDetail.h	/^struct IsSameType<> {$/;"	s	namespace:folly::dptr_detail
folly::dptr_detail::IsSameType	.\detail\DiscriminatedPtrDetail.h	/^struct IsSameType<T, U, Types...> {$/;"	s	namespace:folly::dptr_detail
folly::dptr_detail::IsSameType	.\detail\DiscriminatedPtrDetail.h	/^struct IsSameType<T> {$/;"	s	namespace:folly::dptr_detail
folly::dptr_detail::IsSameType::value	.\detail\DiscriminatedPtrDetail.h	/^  static const bool value = true;$/;"	m	struct:folly::dptr_detail::IsSameType	access:public
folly::dptr_detail::IsSameType::value	.\detail\DiscriminatedPtrDetail.h	/^  static const bool value =$/;"	m	struct:folly::dptr_detail::IsSameType	access:public
folly::dptr_detail::SameType	.\detail\DiscriminatedPtrDetail.h	/^struct SameType;$/;"	x
folly::dptr_detail::SameType	.\detail\DiscriminatedPtrDetail.h	/^struct SameType<T, Types...> {$/;"	s	namespace:folly::dptr_detail
folly::dptr_detail::SameType::static_assert	.\detail\DiscriminatedPtrDetail.h	/^  static_assert(IsSameType<T, Types...>::value,$/;"	p	struct:folly::dptr_detail::SameType	access:public	signature:(IsSameType<T, Types...>::value, )
folly::dptr_detail::SameType::type	.\detail\DiscriminatedPtrDetail.h	/^  typedef T type;$/;"	t	struct:folly::dptr_detail::SameType	access:public
folly::dptr_detail::VisitorResult	.\detail\DiscriminatedPtrDetail.h	/^struct VisitorResult {$/;"	s	namespace:folly::dptr_detail
folly::dptr_detail::VisitorResult1	.\detail\DiscriminatedPtrDetail.h	/^struct VisitorResult1 {$/;"	s	namespace:folly::dptr_detail
folly::dptr_detail::VisitorResult1::type	.\detail\DiscriminatedPtrDetail.h	/^  typedef typename std::result_of<V (T*)>::type type;$/;"	t	struct:folly::dptr_detail::VisitorResult1	access:public
folly::dptr_detail::VisitorResult::type	.\detail\DiscriminatedPtrDetail.h	/^    typename VisitorResult1<V,Types>::type...>::type type;$/;"	t	struct:folly::dptr_detail::VisitorResult	access:public
folly::dup2NoInt	.\FileUtil.cpp	/^int dup2NoInt(int oldfd, int newfd) {$/;"	f	namespace:folly	signature:(int oldfd, int newfd)
folly::dup2NoInt	.\FileUtil.h	/^int dup2NoInt(int oldfd, int newfd);$/;"	p	namespace:folly	signature:(int oldfd, int newfd)
folly::dupNoInt	.\FileUtil.cpp	/^int dupNoInt(int fd) {$/;"	f	namespace:folly	signature:(int fd)
folly::dupNoInt	.\FileUtil.h	/^int dupNoInt(int fd);$/;"	p	namespace:folly	signature:(int fd)
folly::dynamic	.\dynamic.h	/^struct dynamic : private boost::operators<dynamic> {$/;"	s	namespace:folly	inherits:boost::operators
folly::dynamic	.\dynamic.h	/^struct dynamic;$/;"	x
folly::dynamic::ARRAY	.\dynamic.h	/^    ARRAY,$/;"	e	enum:folly::dynamic::Type
folly::dynamic::Array	.\dynamic.h	/^  typedef std::vector<dynamic> Array;$/;"	t	struct:folly::dynamic	access:private
folly::dynamic::BOOL	.\dynamic.h	/^    BOOL,$/;"	e	enum:folly::dynamic::Type
folly::dynamic::CompareOp	.\dynamic-inl.h	/^struct dynamic::CompareOp {$/;"	s	class:folly::dynamic
folly::dynamic::CompareOp	.\dynamic-inl.h	/^struct dynamic::CompareOp<dynamic::ObjectImpl> {$/;"	s	class:folly::dynamic
folly::dynamic::CompareOp	.\dynamic.h	/^  template<class T> struct CompareOp;$/;"	x
folly::dynamic::CompareOp::comp	.\dynamic-inl.h	/^  static bool comp(ObjectImpl const& a, ObjectImpl const& b) {$/;"	f	struct:folly::dynamic::CompareOp	access:public	signature:(ObjectImpl const& a, ObjectImpl const& b)
folly::dynamic::CompareOp::comp	.\dynamic-inl.h	/^  static bool comp(T const& a, T const& b) { return a < b; }$/;"	f	struct:folly::dynamic::CompareOp	access:public	signature:(T const& a, T const& b)
folly::dynamic::DOUBLE	.\dynamic.h	/^    DOUBLE,$/;"	e	enum:folly::dynamic::Type
folly::dynamic::Data	.\dynamic.h	/^  union Data {$/;"	u	struct:folly::dynamic	access:private
folly::dynamic::Data::Data	.\dynamic.h	/^    explicit Data() : nul(nullptr) {}$/;"	f	union:folly::dynamic::Data	access:public	signature:()
folly::dynamic::Data::array	.\dynamic.h	/^    Array array;$/;"	m	union:folly::dynamic::Data	access:public
folly::dynamic::Data::boolean	.\dynamic.h	/^    bool boolean;$/;"	m	union:folly::dynamic::Data	access:public
folly::dynamic::Data::doubl	.\dynamic.h	/^    double doubl;$/;"	m	union:folly::dynamic::Data	access:public
folly::dynamic::Data::integer	.\dynamic.h	/^    int64_t integer;$/;"	m	union:folly::dynamic::Data	access:public
folly::dynamic::Data::nul	.\dynamic.h	/^    void* nul;$/;"	m	union:folly::dynamic::Data	access:public
folly::dynamic::Data::objectBuffer	.\dynamic.h	/^    >::type objectBuffer;$/;"	m	union:folly::dynamic::Data	access:public
folly::dynamic::Data::string	.\dynamic.h	/^    fbstring string;$/;"	m	union:folly::dynamic::Data	access:public
folly::dynamic::Data::~Data	.\dynamic.h	/^    ~Data() {}$/;"	f	union:folly::dynamic::Data	access:public	signature:()
folly::dynamic::GetAddrImpl	.\dynamic-inl.h	/^template<> struct dynamic::GetAddrImpl<bool> {$/;"	s	class:folly::dynamic
folly::dynamic::GetAddrImpl	.\dynamic-inl.h	/^template<> struct dynamic::GetAddrImpl<double> {$/;"	s	class:folly::dynamic
folly::dynamic::GetAddrImpl	.\dynamic-inl.h	/^template<> struct dynamic::GetAddrImpl<dynamic::Array> {$/;"	s	class:folly::dynamic
folly::dynamic::GetAddrImpl	.\dynamic-inl.h	/^template<> struct dynamic::GetAddrImpl<dynamic::ObjectImpl> {$/;"	s	class:folly::dynamic
folly::dynamic::GetAddrImpl	.\dynamic-inl.h	/^template<> struct dynamic::GetAddrImpl<fbstring> {$/;"	s	class:folly::dynamic
folly::dynamic::GetAddrImpl	.\dynamic-inl.h	/^template<> struct dynamic::GetAddrImpl<int64_t> {$/;"	s	class:folly::dynamic
folly::dynamic::GetAddrImpl	.\dynamic-inl.h	/^template<> struct dynamic::GetAddrImpl<void*> {$/;"	s	class:folly::dynamic
folly::dynamic::GetAddrImpl	.\dynamic-inl.h	/^template<class T> struct dynamic::GetAddrImpl {};$/;"	s	class:folly::dynamic
folly::dynamic::GetAddrImpl	.\dynamic.h	/^  template<class T> struct GetAddrImpl;$/;"	x
folly::dynamic::GetAddrImpl::get	.\dynamic-inl.h	/^  static Array* get(Data& d) { return &d.array; }$/;"	f	struct:folly::dynamic::GetAddrImpl	access:public	signature:(Data& d)
folly::dynamic::GetAddrImpl::get	.\dynamic-inl.h	/^  static ObjectImpl* get(Data& d) {$/;"	f	struct:folly::dynamic::GetAddrImpl	access:public	signature:(Data& d)
folly::dynamic::GetAddrImpl::get	.\dynamic-inl.h	/^  static bool* get(Data& d) { return &d.boolean; }$/;"	f	struct:folly::dynamic::GetAddrImpl	access:public	signature:(Data& d)
folly::dynamic::GetAddrImpl::get	.\dynamic-inl.h	/^  static double* get(Data& d) { return &d.doubl; }$/;"	f	struct:folly::dynamic::GetAddrImpl	access:public	signature:(Data& d)
folly::dynamic::GetAddrImpl::get	.\dynamic-inl.h	/^  static fbstring* get(Data& d) { return &d.string; }$/;"	f	struct:folly::dynamic::GetAddrImpl	access:public	signature:(Data& d)
folly::dynamic::GetAddrImpl::get	.\dynamic-inl.h	/^  static int64_t* get(Data& d) { return &d.integer; }$/;"	f	struct:folly::dynamic::GetAddrImpl	access:public	signature:(Data& d)
folly::dynamic::GetAddrImpl::get	.\dynamic-inl.h	/^  static void** get(Data& d) { return &d.nul; }$/;"	f	struct:folly::dynamic::GetAddrImpl	access:public	signature:(Data& d)
folly::dynamic::GetAddrImpl::sizeof	.\dynamic-inl.h	/^  static_assert(sizeof(ObjectImpl) <= sizeof(Data::objectBuffer),$/;"	p	struct:folly::dynamic::GetAddrImpl	access:public	signature:(ObjectImpl)
folly::dynamic::INT64	.\dynamic.h	/^    INT64,$/;"	e	enum:folly::dynamic::Type
folly::dynamic::IterableProxy	.\dynamic-inl.h	/^struct dynamic::IterableProxy {$/;"	s	class:folly::dynamic
folly::dynamic::IterableProxy	.\dynamic.h	/^  template <class T> struct IterableProxy;$/;"	x
folly::dynamic::IterableProxy::IterableProxy	.\dynamic-inl.h	/^  \/* implicit *\/ IterableProxy(const dynamic::ObjectImpl* o) : o_(o) { }$/;"	f	struct:folly::dynamic::IterableProxy	access:public	signature:(const dynamic::ObjectImpl* o)
folly::dynamic::IterableProxy::begin	.\dynamic-inl.h	/^  It begin() const {$/;"	f	struct:folly::dynamic::IterableProxy	access:public	signature:() const
folly::dynamic::IterableProxy::const_iterator	.\dynamic-inl.h	/^  typedef It const_iterator;$/;"	t	struct:folly::dynamic::IterableProxy	access:public
folly::dynamic::IterableProxy::end	.\dynamic-inl.h	/^  It end() const {$/;"	f	struct:folly::dynamic::IterableProxy	access:public	signature:() const
folly::dynamic::IterableProxy::o_	.\dynamic-inl.h	/^  const dynamic::ObjectImpl* o_;$/;"	m	struct:folly::dynamic::IterableProxy	access:private
folly::dynamic::IterableProxy::value_type	.\dynamic-inl.h	/^  typedef typename It::value_type value_type;$/;"	t	struct:folly::dynamic::IterableProxy	access:public
folly::dynamic::NULLT	.\dynamic.h	/^    NULLT,$/;"	e	enum:folly::dynamic::Type
folly::dynamic::OBJECT	.\dynamic.h	/^    OBJECT,$/;"	e	enum:folly::dynamic::Type
folly::dynamic::ObjectImpl	.\dynamic-inl.h	/^struct dynamic::ObjectImpl : std::unordered_map<dynamic, dynamic> {};$/;"	s	class:folly::dynamic	inherits:std::unordered_map
folly::dynamic::ObjectImpl	.\dynamic.h	/^  struct ObjectImpl;$/;"	x
folly::dynamic::ObjectMaker	.\dynamic-inl.h	/^struct dynamic::ObjectMaker {$/;"	s	class:folly::dynamic
folly::dynamic::ObjectMaker	.\dynamic.h	/^  struct ObjectMaker;$/;"	x
folly::dynamic::ObjectMaker::ObjectMaker	.\dynamic-inl.h	/^  ObjectMaker(ObjectMaker const&) = delete;$/;"	p	struct:folly::dynamic::ObjectMaker	access:public	signature:(ObjectMaker const&)
folly::dynamic::ObjectMaker::ObjectMaker	.\dynamic-inl.h	/^  ObjectMaker(ObjectMaker&&) = default;$/;"	p	struct:folly::dynamic::ObjectMaker	access:public	signature:(ObjectMaker&&)
folly::dynamic::ObjectMaker::ObjectMaker	.\dynamic-inl.h	/^  explicit ObjectMaker() : val_(dynamic::object) {}$/;"	f	struct:folly::dynamic::ObjectMaker	access:public	signature:()
folly::dynamic::ObjectMaker::ObjectMaker	.\dynamic-inl.h	/^  explicit ObjectMaker(dynamic const& key, dynamic val)$/;"	f	struct:folly::dynamic::ObjectMaker	access:public	signature:(dynamic const& key, dynamic val)
folly::dynamic::ObjectMaker::ObjectMaker	.\dynamic-inl.h	/^  explicit ObjectMaker(dynamic&& key, dynamic val)$/;"	f	struct:folly::dynamic::ObjectMaker	access:public	signature:(dynamic&& key, dynamic val)
folly::dynamic::ObjectMaker::dynamic	.\dynamic-inl.h	/^  friend struct dynamic;$/;"	x
folly::dynamic::ObjectMaker::operator ()	.\dynamic-inl.h	/^  ObjectMaker&& operator()(dynamic const& key, dynamic val) {$/;"	f	struct:folly::dynamic::ObjectMaker	access:public	signature:(dynamic const& key, dynamic val)
folly::dynamic::ObjectMaker::operator ()	.\dynamic-inl.h	/^  ObjectMaker&& operator()(dynamic&& key, dynamic val) {$/;"	f	struct:folly::dynamic::ObjectMaker	access:public	signature:(dynamic&& key, dynamic val)
folly::dynamic::ObjectMaker::operator =	.\dynamic-inl.h	/^  ObjectMaker& operator=(ObjectMaker const&) = delete;$/;"	p	struct:folly::dynamic::ObjectMaker	access:public	signature:(ObjectMaker const&)
folly::dynamic::ObjectMaker::operator =	.\dynamic-inl.h	/^  ObjectMaker& operator=(ObjectMaker&&) = delete;$/;"	p	struct:folly::dynamic::ObjectMaker	access:public	signature:(ObjectMaker&&)
folly::dynamic::ObjectMaker::val_	.\dynamic-inl.h	/^  dynamic val_;$/;"	m	struct:folly::dynamic::ObjectMaker	access:private
folly::dynamic::PrintImpl	.\dynamic-inl.h	/^struct dynamic::PrintImpl {$/;"	s	class:folly::dynamic
folly::dynamic::PrintImpl	.\dynamic-inl.h	/^struct dynamic::PrintImpl<dynamic::Array> {$/;"	s	class:folly::dynamic
folly::dynamic::PrintImpl	.\dynamic-inl.h	/^struct dynamic::PrintImpl<dynamic::ObjectImpl> {$/;"	s	class:folly::dynamic
folly::dynamic::PrintImpl	.\dynamic.h	/^  template<class T> struct PrintImpl;$/;"	x
folly::dynamic::PrintImpl::print	.\dynamic-inl.h	/^  static void print(dynamic const& d,$/;"	f	struct:folly::dynamic::PrintImpl	access:public	signature:(dynamic const& d, std::ostream& out, dynamic::Array const&)
folly::dynamic::PrintImpl::print	.\dynamic-inl.h	/^  static void print(dynamic const& d,$/;"	f	struct:folly::dynamic::PrintImpl	access:public	signature:(dynamic const& d, std::ostream& out, dynamic::ObjectImpl const&)
folly::dynamic::PrintImpl::print	.\dynamic-inl.h	/^  static void print(dynamic const&, std::ostream& out, T const& t) {$/;"	f	struct:folly::dynamic::PrintImpl	access:public	signature:(dynamic const&, std::ostream& out, T const& t)
folly::dynamic::STRING	.\dynamic.h	/^    STRING,$/;"	e	enum:folly::dynamic::Type
folly::dynamic::Type	.\dynamic.h	/^  enum Type {$/;"	g	struct:folly::dynamic	access:public
folly::dynamic::TypeError	.\dynamic.h	/^  friend struct TypeError;$/;"	x
folly::dynamic::TypeInfo	.\dynamic-inl.h	/^template<class T> struct dynamic::TypeInfo {$/;"	s	class:folly::dynamic
folly::dynamic::TypeInfo	.\dynamic.h	/^  template<class T> struct TypeInfo;$/;"	x
folly::dynamic::TypeInfo::name	.\dynamic-inl.h	/^  static char const name[];$/;"	m	struct:folly::dynamic::TypeInfo	access:public
folly::dynamic::TypeInfo::type	.\dynamic-inl.h	/^  static Type const type;$/;"	m	struct:folly::dynamic::TypeInfo	access:public
folly::dynamic::asBool	.\dynamic-inl.h	/^inline bool     dynamic::asBool()   const { return asImpl<bool>(); }$/;"	f	class:folly::dynamic	signature:() const
folly::dynamic::asBool	.\dynamic.h	/^  bool     asBool() const;$/;"	p	struct:folly::dynamic	access:public	signature:() const
folly::dynamic::asDouble	.\dynamic-inl.h	/^inline double   dynamic::asDouble() const { return asImpl<double>(); }$/;"	f	class:folly::dynamic	signature:() const
folly::dynamic::asDouble	.\dynamic.h	/^  double   asDouble() const;$/;"	p	struct:folly::dynamic	access:public	signature:() const
folly::dynamic::asImpl	.\dynamic-inl.h	/^T dynamic::asImpl() const {$/;"	f	class:folly::dynamic	signature:() const
folly::dynamic::asImpl	.\dynamic.h	/^  template<class T> T asImpl() const;$/;"	p	struct:folly::dynamic	access:private	signature:() const
folly::dynamic::asInt	.\dynamic-inl.h	/^inline int64_t  dynamic::asInt()    const { return asImpl<int64_t>(); }$/;"	f	class:folly::dynamic	signature:() const
folly::dynamic::asInt	.\dynamic.h	/^  int64_t  asInt() const;$/;"	p	struct:folly::dynamic	access:public	signature:() const
folly::dynamic::asString	.\dynamic-inl.h	/^inline fbstring dynamic::asString() const { return asImpl<fbstring>(); }$/;"	f	class:folly::dynamic	signature:() const
folly::dynamic::asString	.\dynamic.h	/^  fbstring asString() const;$/;"	p	struct:folly::dynamic	access:public	signature:() const
folly::dynamic::at	.\dynamic-inl.h	/^inline dynamic const& dynamic::at(dynamic const& idx) const {$/;"	f	class:folly::dynamic	signature:(dynamic const& idx) const
folly::dynamic::at	.\dynamic-inl.h	/^inline dynamic& dynamic::at(dynamic const& idx) {$/;"	f	class:folly::dynamic	signature:(dynamic const& idx)
folly::dynamic::at	.\dynamic.h	/^  dynamic const& at(dynamic const&) const;$/;"	p	struct:folly::dynamic	access:public	signature:(dynamic const&) const
folly::dynamic::at	.\dynamic.h	/^  dynamic&       at(dynamic const&);$/;"	p	struct:folly::dynamic	access:public	signature:(dynamic const&)
folly::dynamic::begin	.\dynamic-inl.h	/^inline dynamic::const_iterator dynamic::begin() const {$/;"	f	class:folly::dynamic	signature:() const
folly::dynamic::begin	.\dynamic.h	/^  const_iterator begin()  const;$/;"	p	struct:folly::dynamic	access:public	signature:() const
folly::dynamic::c_str	.\dynamic-inl.h	/^inline const char* dynamic::c_str() const { return get<fbstring>().c_str(); }$/;"	f	class:folly::dynamic	signature:() const
folly::dynamic::c_str	.\dynamic.h	/^  const char* c_str() const;$/;"	p	struct:folly::dynamic	access:public	signature:() const
folly::dynamic::const_item_iterator	.\dynamic-inl.h	/^struct dynamic::const_item_iterator$/;"	s	class:folly::dynamic	inherits:boost::iterator_adaptor
folly::dynamic::const_item_iterator	.\dynamic.h	/^  struct const_item_iterator;$/;"	x
folly::dynamic::const_item_iterator::const_item_iterator	.\dynamic-inl.h	/^  \/* implicit *\/ const_item_iterator(base_type b) : iterator_adaptor_(b) { }$/;"	f	struct:folly::dynamic::const_item_iterator	access:public	signature:(base_type b)
folly::dynamic::const_iterator	.\dynamic.h	/^  typedef Array::const_iterator const_iterator;$/;"	t	struct:folly::dynamic	access:public
folly::dynamic::const_key_iterator	.\dynamic-inl.h	/^struct dynamic::const_key_iterator$/;"	s	class:folly::dynamic	inherits:boost::iterator_adaptor
folly::dynamic::const_key_iterator	.\dynamic.h	/^  struct const_key_iterator;$/;"	x
folly::dynamic::const_key_iterator::const_key_iterator	.\dynamic-inl.h	/^  \/* implicit *\/ const_key_iterator(base_type b) : iterator_adaptor_(b) { }$/;"	f	struct:folly::dynamic::const_key_iterator	access:public	signature:(base_type b)
folly::dynamic::const_key_iterator::dereference	.\dynamic-inl.h	/^  dynamic const& dereference() const {$/;"	f	struct:folly::dynamic::const_key_iterator	access:private	signature:() const
folly::dynamic::const_value_iterator	.\dynamic-inl.h	/^struct dynamic::const_value_iterator$/;"	s	class:folly::dynamic	inherits:boost::iterator_adaptor
folly::dynamic::const_value_iterator	.\dynamic.h	/^  struct const_value_iterator;$/;"	x
folly::dynamic::const_value_iterator::const_value_iterator	.\dynamic-inl.h	/^  \/* implicit *\/ const_value_iterator(base_type b) : iterator_adaptor_(b) { }$/;"	f	struct:folly::dynamic::const_value_iterator	access:public	signature:(base_type b)
folly::dynamic::const_value_iterator::dereference	.\dynamic-inl.h	/^  dynamic const& dereference() const {$/;"	f	struct:folly::dynamic::const_value_iterator	access:private	signature:() const
folly::dynamic::count	.\dynamic-inl.h	/^inline std::size_t dynamic::count(dynamic const& key) const {$/;"	f	class:folly::dynamic	signature:(dynamic const& key) const
folly::dynamic::count	.\dynamic.h	/^  std::size_t count(dynamic const&) const;$/;"	p	struct:folly::dynamic	access:public	signature:(dynamic const&) const
folly::dynamic::data	.\dynamic-inl.h	/^inline const char* dynamic::data()  const { return get<fbstring>().data();  }$/;"	f	class:folly::dynamic	signature:() const
folly::dynamic::data	.\dynamic.h	/^  const char* data()  const;$/;"	p	struct:folly::dynamic	access:public	signature:() const
folly::dynamic::destroy	.\dynamic-inl.h	/^inline void dynamic::destroy() {$/;"	f	class:folly::dynamic	signature:()
folly::dynamic::destroy	.\dynamic.h	/^  void destroy();$/;"	p	struct:folly::dynamic	access:private	signature:()
folly::dynamic::dynamic	.\dynamic-inl.h	/^dynamic::dynamic(Iterator first, Iterator last)$/;"	f	class:folly::dynamic	signature:(Iterator first, Iterator last)
folly::dynamic::dynamic	.\dynamic-inl.h	/^dynamic::dynamic(T t) {$/;"	f	class:folly::dynamic	signature:(T t)
folly::dynamic::dynamic	.\dynamic-inl.h	/^inline dynamic::dynamic(ObjectMaker (*)())$/;"	f	class:folly::dynamic	signature:(ObjectMaker ()))
folly::dynamic::dynamic	.\dynamic-inl.h	/^inline dynamic::dynamic(ObjectMaker&& maker)$/;"	f	class:folly::dynamic	signature:(ObjectMaker&& maker)
folly::dynamic::dynamic	.\dynamic-inl.h	/^inline dynamic::dynamic(StringPiece s)$/;"	f	class:folly::dynamic	signature:(StringPiece s)
folly::dynamic::dynamic	.\dynamic-inl.h	/^inline dynamic::dynamic(char const* s)$/;"	f	class:folly::dynamic	signature:(char const* s)
folly::dynamic::dynamic	.\dynamic-inl.h	/^inline dynamic::dynamic(dynamic const& o)$/;"	f	class:folly::dynamic	signature:(dynamic const& o)
folly::dynamic::dynamic	.\dynamic-inl.h	/^inline dynamic::dynamic(dynamic&& o)$/;"	f	class:folly::dynamic	signature:(dynamic&& o)
folly::dynamic::dynamic	.\dynamic-inl.h	/^inline dynamic::dynamic(fbstring const& s)$/;"	f	class:folly::dynamic	signature:(fbstring const& s)
folly::dynamic::dynamic	.\dynamic-inl.h	/^inline dynamic::dynamic(fbstring&& s)$/;"	f	class:folly::dynamic	signature:(fbstring&& s)
folly::dynamic::dynamic	.\dynamic-inl.h	/^inline dynamic::dynamic(std::initializer_list<dynamic> il)$/;"	f	class:folly::dynamic	signature:(std::initializer_list<dynamic> il)
folly::dynamic::dynamic	.\dynamic-inl.h	/^inline dynamic::dynamic(std::string const& s)$/;"	f	class:folly::dynamic	signature:(std::string const& s)
folly::dynamic::dynamic	.\dynamic.h	/^  \/* implicit *\/ dynamic(ObjectMaker (*)());$/;"	p	struct:folly::dynamic	access:public	signature:(ObjectMaker ()))
folly::dynamic::dynamic	.\dynamic.h	/^  \/* implicit *\/ dynamic(ObjectMaker const&) = delete;$/;"	p	struct:folly::dynamic	access:public	signature:(ObjectMaker const&)
folly::dynamic::dynamic	.\dynamic.h	/^  \/* implicit *\/ dynamic(ObjectMaker&&);$/;"	p	struct:folly::dynamic	access:public	signature:(ObjectMaker&&)
folly::dynamic::dynamic	.\dynamic.h	/^  \/* implicit *\/ dynamic(StringPiece val);$/;"	p	struct:folly::dynamic	access:public	signature:(StringPiece val)
folly::dynamic::dynamic	.\dynamic.h	/^  \/* implicit *\/ dynamic(char const* val);$/;"	p	struct:folly::dynamic	access:public	signature:(char const* val)
folly::dynamic::dynamic	.\dynamic.h	/^  \/* implicit *\/ dynamic(fbstring const& val);$/;"	p	struct:folly::dynamic	access:public	signature:(fbstring const& val)
folly::dynamic::dynamic	.\dynamic.h	/^  \/* implicit *\/ dynamic(fbstring&& val);$/;"	p	struct:folly::dynamic	access:public	signature:(fbstring&& val)
folly::dynamic::dynamic	.\dynamic.h	/^  \/* implicit *\/ dynamic(std::initializer_list<dynamic> il);$/;"	p	struct:folly::dynamic	access:public	signature:(std::initializer_list<dynamic> il)
folly::dynamic::dynamic	.\dynamic.h	/^  \/* implicit *\/ dynamic(std::string const& val);$/;"	p	struct:folly::dynamic	access:public	signature:(std::string const& val)
folly::dynamic::dynamic	.\dynamic.h	/^  dynamic(dynamic const&);$/;"	p	struct:folly::dynamic	access:public	signature:(dynamic const&)
folly::dynamic::dynamic	.\dynamic.h	/^  dynamic(dynamic&&);$/;"	p	struct:folly::dynamic	access:public	signature:(dynamic&&)
folly::dynamic::dynamic	.\dynamic.h	/^  template<class Iterator> dynamic(Iterator first, Iterator last);$/;"	p	struct:folly::dynamic	access:public	signature:(Iterator first, Iterator last)
folly::dynamic::dynamic	.\dynamic.h	/^  template<class T> \/* implicit *\/ dynamic(T t);$/;"	p	struct:folly::dynamic	access:public	signature:(T t)
folly::dynamic::empty	.\dynamic-inl.h	/^inline bool dynamic::empty() const {$/;"	f	class:folly::dynamic	signature:() const
folly::dynamic::empty	.\dynamic.h	/^  bool empty() const;$/;"	p	struct:folly::dynamic	access:public	signature:() const
folly::dynamic::end	.\dynamic-inl.h	/^inline dynamic::const_iterator dynamic::end() const {$/;"	f	class:folly::dynamic	signature:() const
folly::dynamic::end	.\dynamic.h	/^  const_iterator end()    const;$/;"	p	struct:folly::dynamic	access:public	signature:() const
folly::dynamic::erase	.\dynamic-inl.h	/^dynamic::erase(const_iterator first, const_iterator last) {$/;"	f	class:folly::dynamic	signature:(const_iterator first, const_iterator last)
folly::dynamic::erase	.\dynamic-inl.h	/^inline dynamic::const_item_iterator dynamic::erase(const_item_iterator first,$/;"	f	class:folly::dynamic	signature:(const_item_iterator first, const_item_iterator last)
folly::dynamic::erase	.\dynamic-inl.h	/^inline dynamic::const_item_iterator dynamic::erase(const_item_iterator it) {$/;"	f	class:folly::dynamic	signature:(const_item_iterator it)
folly::dynamic::erase	.\dynamic-inl.h	/^inline dynamic::const_iterator dynamic::erase(const_iterator it) {$/;"	f	class:folly::dynamic	signature:(const_iterator it)
folly::dynamic::erase	.\dynamic-inl.h	/^inline dynamic::const_key_iterator dynamic::erase(const_key_iterator first,$/;"	f	class:folly::dynamic	signature:(const_key_iterator first, const_key_iterator last)
folly::dynamic::erase	.\dynamic-inl.h	/^inline dynamic::const_key_iterator dynamic::erase(const_key_iterator it) {$/;"	f	class:folly::dynamic	signature:(const_key_iterator it)
folly::dynamic::erase	.\dynamic-inl.h	/^inline dynamic::const_value_iterator dynamic::erase(const_value_iterator first,$/;"	f	class:folly::dynamic	signature:(const_value_iterator first, const_value_iterator last)
folly::dynamic::erase	.\dynamic-inl.h	/^inline dynamic::const_value_iterator dynamic::erase(const_value_iterator it) {$/;"	f	class:folly::dynamic	signature:(const_value_iterator it)
folly::dynamic::erase	.\dynamic-inl.h	/^inline std::size_t dynamic::erase(dynamic const& key) {$/;"	f	class:folly::dynamic	signature:(dynamic const& key)
folly::dynamic::erase	.\dynamic.h	/^  const_item_iterator erase(const_item_iterator first,$/;"	p	struct:folly::dynamic	access:public	signature:(const_item_iterator first, const_item_iterator last)
folly::dynamic::erase	.\dynamic.h	/^  const_item_iterator erase(const_item_iterator it);$/;"	p	struct:folly::dynamic	access:public	signature:(const_item_iterator it)
folly::dynamic::erase	.\dynamic.h	/^  const_iterator erase(const_iterator first, const_iterator last);$/;"	p	struct:folly::dynamic	access:public	signature:(const_iterator first, const_iterator last)
folly::dynamic::erase	.\dynamic.h	/^  const_iterator erase(const_iterator it);$/;"	p	struct:folly::dynamic	access:public	signature:(const_iterator it)
folly::dynamic::erase	.\dynamic.h	/^  const_key_iterator erase(const_key_iterator first, const_key_iterator last);$/;"	p	struct:folly::dynamic	access:public	signature:(const_key_iterator first, const_key_iterator last)
folly::dynamic::erase	.\dynamic.h	/^  const_key_iterator erase(const_key_iterator it);$/;"	p	struct:folly::dynamic	access:public	signature:(const_key_iterator it)
folly::dynamic::erase	.\dynamic.h	/^  const_value_iterator erase(const_value_iterator first,$/;"	p	struct:folly::dynamic	access:public	signature:(const_value_iterator first, const_value_iterator last)
folly::dynamic::erase	.\dynamic.h	/^  const_value_iterator erase(const_value_iterator it);$/;"	p	struct:folly::dynamic	access:public	signature:(const_value_iterator it)
folly::dynamic::erase	.\dynamic.h	/^  std::size_t erase(dynamic const& key);$/;"	p	struct:folly::dynamic	access:public	signature:(dynamic const& key)
folly::dynamic::find	.\dynamic-inl.h	/^inline dynamic::const_item_iterator dynamic::find(dynamic const& key) const {$/;"	f	class:folly::dynamic	signature:(dynamic const& key) const
folly::dynamic::find	.\dynamic.h	/^  const_item_iterator find(dynamic const&) const;$/;"	p	struct:folly::dynamic	access:public	signature:(dynamic const&) const
folly::dynamic::get	.\dynamic-inl.h	/^T const& dynamic::get() const {$/;"	f	class:folly::dynamic	signature:() const
folly::dynamic::get	.\dynamic-inl.h	/^T& dynamic::get() {$/;"	f	class:folly::dynamic	signature:()
folly::dynamic::get	.\dynamic.h	/^  template<class T> T const& get() const;$/;"	p	struct:folly::dynamic	access:private	signature:() const
folly::dynamic::get	.\dynamic.h	/^  template<class T> T&       get();$/;"	p	struct:folly::dynamic	access:private	signature:()
folly::dynamic::getAddress	.\dynamic-inl.h	/^T const* dynamic::getAddress() const {$/;"	f	class:folly::dynamic	signature:() const
folly::dynamic::getAddress	.\dynamic-inl.h	/^T* dynamic::getAddress() {$/;"	f	class:folly::dynamic	signature:()
folly::dynamic::getAddress	.\dynamic.h	/^  template<class T> T const* getAddress() const;$/;"	p	struct:folly::dynamic	access:private	signature:() const
folly::dynamic::getAddress	.\dynamic.h	/^  template<class T> T*       getAddress();$/;"	p	struct:folly::dynamic	access:private	signature:()
folly::dynamic::getDefault	.\dynamic-inl.h	/^inline dynamic dynamic::getDefault(const dynamic& k, const dynamic& v) const {$/;"	f	class:folly::dynamic	signature:(const dynamic& k, const dynamic& v) const
folly::dynamic::getDefault	.\dynamic-inl.h	/^inline dynamic&& dynamic::getDefault(const dynamic& k, dynamic&& v) const {$/;"	f	class:folly::dynamic	signature:(const dynamic& k, dynamic&& v) const
folly::dynamic::getDefault	.\dynamic.h	/^  dynamic&& getDefault(const dynamic& k, dynamic&& v) const;$/;"	p	struct:folly::dynamic	access:public	signature:(const dynamic& k, dynamic&& v) const
folly::dynamic::getDefault	.\dynamic.h	/^  getDefault(const dynamic& k, const dynamic& v = dynamic::object) const;$/;"	p	struct:folly::dynamic	access:public	signature:(const dynamic& k, const dynamic& v = dynamic::object) const
folly::dynamic::get_nothrow	.\dynamic-inl.h	/^T const* dynamic::get_nothrow() const {$/;"	f	class:folly::dynamic	signature:() const
folly::dynamic::get_nothrow	.\dynamic-inl.h	/^T* dynamic::get_nothrow() {$/;"	f	class:folly::dynamic	signature:()
folly::dynamic::get_nothrow	.\dynamic.h	/^  template<class T> T const* get_nothrow() const;$/;"	p	struct:folly::dynamic	access:private	signature:() const
folly::dynamic::get_nothrow	.\dynamic.h	/^  template<class T> T*       get_nothrow();$/;"	p	struct:folly::dynamic	access:private	signature:()
folly::dynamic::get_ptr	.\dynamic-inl.h	/^inline const dynamic* dynamic::get_ptr(dynamic const& idx) const {$/;"	f	class:folly::dynamic	signature:(dynamic const& idx) const
folly::dynamic::get_ptr	.\dynamic-inl.h	/^inline dynamic* dynamic::get_ptr(dynamic const& idx) {$/;"	f	class:folly::dynamic	signature:(dynamic const& idx)
folly::dynamic::get_ptr	.\dynamic.h	/^  const dynamic* get_ptr(dynamic const&) const;$/;"	p	struct:folly::dynamic	access:public	signature:(dynamic const&) const
folly::dynamic::get_ptr	.\dynamic.h	/^  dynamic* get_ptr(dynamic const&);$/;"	p	struct:folly::dynamic	access:public	signature:(dynamic const&)
folly::dynamic::hash	.\dynamic-inl.h	/^inline std::size_t dynamic::hash() const {$/;"	f	class:folly::dynamic	signature:() const
folly::dynamic::hash	.\dynamic.h	/^  std::size_t hash() const;$/;"	p	struct:folly::dynamic	access:public	signature:() const
folly::dynamic::insert	.\dynamic-inl.h	/^template<class K, class V> inline void dynamic::insert(K&& key, V&& val) {$/;"	f	class:folly::dynamic	signature:(K&& key, V&& val)
folly::dynamic::insert	.\dynamic.h	/^  template<class K, class V> void insert(K&&, V&& val);$/;"	p	struct:folly::dynamic	access:public	signature:(K&&, V&& val)
folly::dynamic::isArray	.\dynamic-inl.h	/^inline bool dynamic::isArray()  const { return get_nothrow<Array>(); }$/;"	f	class:folly::dynamic	signature:() const
folly::dynamic::isArray	.\dynamic.h	/^  bool isArray() const;$/;"	p	struct:folly::dynamic	access:public	signature:() const
folly::dynamic::isBool	.\dynamic-inl.h	/^inline bool dynamic::isBool()   const { return get_nothrow<bool>(); }$/;"	f	class:folly::dynamic	signature:() const
folly::dynamic::isBool	.\dynamic.h	/^  bool isBool() const;$/;"	p	struct:folly::dynamic	access:public	signature:() const
folly::dynamic::isDouble	.\dynamic-inl.h	/^inline bool dynamic::isDouble() const { return get_nothrow<double>(); }$/;"	f	class:folly::dynamic	signature:() const
folly::dynamic::isDouble	.\dynamic.h	/^  bool isDouble() const;$/;"	p	struct:folly::dynamic	access:public	signature:() const
folly::dynamic::isInt	.\dynamic-inl.h	/^inline bool dynamic::isInt()    const { return get_nothrow<int64_t>(); }$/;"	f	class:folly::dynamic	signature:() const
folly::dynamic::isInt	.\dynamic.h	/^  bool isInt() const;$/;"	p	struct:folly::dynamic	access:public	signature:() const
folly::dynamic::isNull	.\dynamic-inl.h	/^inline bool dynamic::isNull()   const { return get_nothrow<void*>(); }$/;"	f	class:folly::dynamic	signature:() const
folly::dynamic::isNull	.\dynamic.h	/^  bool isNull() const;$/;"	p	struct:folly::dynamic	access:public	signature:() const
folly::dynamic::isNumber	.\dynamic-inl.h	/^inline bool dynamic::isNumber() const { return isInt() || isDouble(); }$/;"	f	class:folly::dynamic	signature:() const
folly::dynamic::isNumber	.\dynamic.h	/^  bool isNumber() const;$/;"	p	struct:folly::dynamic	access:public	signature:() const
folly::dynamic::isObject	.\dynamic-inl.h	/^inline bool dynamic::isObject() const { return get_nothrow<ObjectImpl>(); }$/;"	f	class:folly::dynamic	signature:() const
folly::dynamic::isObject	.\dynamic.h	/^  bool isObject() const;$/;"	p	struct:folly::dynamic	access:public	signature:() const
folly::dynamic::isString	.\dynamic-inl.h	/^inline bool dynamic::isString() const { return get_nothrow<fbstring>(); }$/;"	f	class:folly::dynamic	signature:() const
folly::dynamic::isString	.\dynamic.h	/^  bool isString() const;$/;"	p	struct:folly::dynamic	access:public	signature:() const
folly::dynamic::items	.\dynamic-inl.h	/^inline dynamic::IterableProxy<dynamic::const_item_iterator> dynamic::items()$/;"	f	class:folly::dynamic	signature:() const
folly::dynamic::items	.\dynamic.h	/^  IterableProxy<const_item_iterator> items() const;$/;"	p	struct:folly::dynamic	access:public	signature:() const
folly::dynamic::keys	.\dynamic-inl.h	/^inline dynamic::IterableProxy<dynamic::const_key_iterator> dynamic::keys()$/;"	f	class:folly::dynamic	signature:() const
folly::dynamic::keys	.\dynamic.h	/^  IterableProxy<const_key_iterator> keys() const;$/;"	p	struct:folly::dynamic	access:public	signature:() const
folly::dynamic::object	.\dynamic-inl.h	/^dynamic::object(dynamic const& a, dynamic const& b) {$/;"	f	class:folly::dynamic	signature:(dynamic const& a, dynamic const& b)
folly::dynamic::object	.\dynamic-inl.h	/^inline dynamic::ObjectMaker dynamic::object() { return ObjectMaker(); }$/;"	f	class:folly::dynamic	signature:()
folly::dynamic::object	.\dynamic-inl.h	/^inline dynamic::ObjectMaker dynamic::object(dynamic const& a, dynamic&& b) {$/;"	f	class:folly::dynamic	signature:(dynamic const& a, dynamic&& b)
folly::dynamic::object	.\dynamic-inl.h	/^inline dynamic::ObjectMaker dynamic::object(dynamic&& a, dynamic const& b) {$/;"	f	class:folly::dynamic	signature:(dynamic&& a, dynamic const& b)
folly::dynamic::object	.\dynamic-inl.h	/^inline dynamic::ObjectMaker dynamic::object(dynamic&& a, dynamic&& b) {$/;"	f	class:folly::dynamic	signature:(dynamic&& a, dynamic&& b)
folly::dynamic::object	.\dynamic.h	/^  static ObjectMaker object();$/;"	p	struct:folly::dynamic	access:public	signature:()
folly::dynamic::object	.\dynamic.h	/^  static ObjectMaker object(dynamic const&, dynamic const&);$/;"	p	struct:folly::dynamic	access:public	signature:(dynamic const&, dynamic const&)
folly::dynamic::object	.\dynamic.h	/^  static ObjectMaker object(dynamic const&, dynamic&&);$/;"	p	struct:folly::dynamic	access:public	signature:(dynamic const&, dynamic&&)
folly::dynamic::object	.\dynamic.h	/^  static ObjectMaker object(dynamic&&, dynamic const&);$/;"	p	struct:folly::dynamic	access:public	signature:(dynamic&&, dynamic const&)
folly::dynamic::object	.\dynamic.h	/^  static ObjectMaker object(dynamic&&, dynamic&&);$/;"	p	struct:folly::dynamic	access:public	signature:(dynamic&&, dynamic&&)
folly::dynamic::operator %=	.\dynamic.h	/^  dynamic& operator%=(dynamic const&);$/;"	p	struct:folly::dynamic	access:public	signature:(dynamic const&)
folly::dynamic::operator &=	.\dynamic.h	/^  dynamic& operator&=(dynamic const&);$/;"	p	struct:folly::dynamic	access:public	signature:(dynamic const&)
folly::dynamic::operator *=	.\dynamic-inl.h	/^inline dynamic& dynamic::operator*=(dynamic const& o) {$/;"	f	class:folly::dynamic	signature:(dynamic const& o)
folly::dynamic::operator *=	.\dynamic.h	/^  dynamic& operator*=(dynamic const&);$/;"	p	struct:folly::dynamic	access:public	signature:(dynamic const&)
folly::dynamic::operator ++	.\dynamic-inl.h	/^inline dynamic& dynamic::operator++() {$/;"	f	class:folly::dynamic	signature:()
folly::dynamic::operator ++	.\dynamic.h	/^  dynamic& operator++();$/;"	p	struct:folly::dynamic	access:public	signature:()
folly::dynamic::operator +=	.\dynamic-inl.h	/^inline dynamic& dynamic::operator+=(dynamic const& o) {$/;"	f	class:folly::dynamic	signature:(dynamic const& o)
folly::dynamic::operator +=	.\dynamic.h	/^  dynamic& operator+=(dynamic const&);$/;"	p	struct:folly::dynamic	access:public	signature:(dynamic const&)
folly::dynamic::operator --	.\dynamic-inl.h	/^inline dynamic& dynamic::operator--() {$/;"	f	class:folly::dynamic	signature:()
folly::dynamic::operator --	.\dynamic.h	/^  dynamic& operator--();$/;"	p	struct:folly::dynamic	access:public	signature:()
folly::dynamic::operator -=	.\dynamic-inl.h	/^inline dynamic& dynamic::operator-=(dynamic const& o) {$/;"	f	class:folly::dynamic	signature:(dynamic const& o)
folly::dynamic::operator -=	.\dynamic.h	/^  dynamic& operator-=(dynamic const&);$/;"	p	struct:folly::dynamic	access:public	signature:(dynamic const&)
folly::dynamic::operator /=	.\dynamic-inl.h	/^inline dynamic& dynamic::operator\/=(dynamic const& o) {$/;"	f	class:folly::dynamic	signature:(dynamic const& o)
folly::dynamic::operator /=	.\dynamic.h	/^  dynamic& operator\/=(dynamic const&);$/;"	p	struct:folly::dynamic	access:public	signature:(dynamic const&)
folly::dynamic::operator <	.\dynamic-inl.h	/^inline bool dynamic::operator<(dynamic const& o) const {$/;"	f	class:folly::dynamic	signature:(dynamic const& o) const
folly::dynamic::operator <	.\dynamic.h	/^  bool operator<(dynamic const& o) const;$/;"	p	struct:folly::dynamic	access:public	signature:(dynamic const& o) const
folly::dynamic::operator <<	.\dynamic.h	/^  friend std::ostream& operator<<(std::ostream&, dynamic const&);$/;"	p	struct:folly::dynamic	access:friend	signature:(std::ostream&, dynamic const&)
folly::dynamic::operator =	.\dynamic-inl.h	/^inline dynamic& dynamic::operator=(dynamic const& o) {$/;"	f	class:folly::dynamic	signature:(dynamic const& o)
folly::dynamic::operator =	.\dynamic-inl.h	/^inline dynamic& dynamic::operator=(dynamic&& o) {$/;"	f	class:folly::dynamic	signature:(dynamic&& o)
folly::dynamic::operator =	.\dynamic.h	/^  dynamic& operator=(dynamic const&);$/;"	p	struct:folly::dynamic	access:public	signature:(dynamic const&)
folly::dynamic::operator =	.\dynamic.h	/^  dynamic& operator=(dynamic&&);$/;"	p	struct:folly::dynamic	access:public	signature:(dynamic&&)
folly::dynamic::operator ==	.\dynamic-inl.h	/^inline bool dynamic::operator==(dynamic const& o) const {$/;"	f	class:folly::dynamic	signature:(dynamic const& o) const
folly::dynamic::operator ==	.\dynamic.h	/^  bool operator==(dynamic const& o) const;$/;"	p	struct:folly::dynamic	access:public	signature:(dynamic const& o) const
folly::dynamic::operator []	.\dynamic-inl.h	/^inline dynamic const& dynamic::operator[](dynamic const& idx) const {$/;"	f	class:folly::dynamic	signature:(dynamic const& idx) const
folly::dynamic::operator []	.\dynamic-inl.h	/^inline dynamic& dynamic::operator[](dynamic const& k) {$/;"	f	class:folly::dynamic	signature:(dynamic const& k)
folly::dynamic::operator []	.\dynamic.h	/^  dynamic const& operator[](dynamic const&) const;$/;"	p	struct:folly::dynamic	access:public	signature:(dynamic const&) const
folly::dynamic::operator []	.\dynamic.h	/^  dynamic&       operator[](dynamic const&);$/;"	p	struct:folly::dynamic	access:public	signature:(dynamic const&)
folly::dynamic::operator ^=	.\dynamic.h	/^  dynamic& operator^=(dynamic const&);$/;"	p	struct:folly::dynamic	access:public	signature:(dynamic const&)
folly::dynamic::operator |=	.\dynamic.h	/^  dynamic& operator|=(dynamic const&);$/;"	p	struct:folly::dynamic	access:public	signature:(dynamic const&)
folly::dynamic::pop_back	.\dynamic-inl.h	/^inline void dynamic::pop_back() {$/;"	f	class:folly::dynamic	signature:()
folly::dynamic::pop_back	.\dynamic.h	/^  void pop_back();$/;"	p	struct:folly::dynamic	access:public	signature:()
folly::dynamic::print	.\dynamic-inl.h	/^inline void dynamic::print(std::ostream& out) const {$/;"	f	class:folly::dynamic	signature:(std::ostream& out) const
folly::dynamic::print	.\dynamic.h	/^  void print(std::ostream&) const;$/;"	p	struct:folly::dynamic	access:private	signature:(std::ostream&) const
folly::dynamic::print_as_pseudo_json	.\dynamic.h	/^  void print_as_pseudo_json(std::ostream&) const; \/\/ see json.cpp$/;"	p	struct:folly::dynamic	access:private	signature:(std::ostream&) const
folly::dynamic::print_as_pseudo_json	.\json.cpp	/^void dynamic::print_as_pseudo_json(std::ostream& out) const {$/;"	f	class:folly::dynamic	signature:(std::ostream& out) const
folly::dynamic::push_back	.\dynamic-inl.h	/^inline void dynamic::push_back(dynamic const& v) {$/;"	f	class:folly::dynamic	signature:(dynamic const& v)
folly::dynamic::push_back	.\dynamic-inl.h	/^inline void dynamic::push_back(dynamic&& v) {$/;"	f	class:folly::dynamic	signature:(dynamic&& v)
folly::dynamic::push_back	.\dynamic.h	/^  void push_back(dynamic const&);$/;"	p	struct:folly::dynamic	access:public	signature:(dynamic const&)
folly::dynamic::push_back	.\dynamic.h	/^  void push_back(dynamic&&);$/;"	p	struct:folly::dynamic	access:public	signature:(dynamic&&)
folly::dynamic::resize	.\dynamic-inl.h	/^inline void dynamic::resize(std::size_t sz, dynamic const& c) {$/;"	f	class:folly::dynamic	signature:(std::size_t sz, dynamic const& c)
folly::dynamic::resize	.\dynamic.h	/^  void resize(std::size_t n, dynamic const& = nullptr);$/;"	p	struct:folly::dynamic	access:public	signature:(std::size_t n, dynamic const& = nullptr)
folly::dynamic::setDefault	.\dynamic-inl.h	/^template<class K, class V> inline dynamic& dynamic::setDefault(K&& k, V&& v) {$/;"	f	class:folly::dynamic	signature:(K&& k, V&& v)
folly::dynamic::setDefault	.\dynamic.h	/^  dynamic& setDefault(K&& k, V&& v = dynamic::object);$/;"	p	struct:folly::dynamic	access:public	signature:(K&& k, V&& v = dynamic::object)
folly::dynamic::size	.\dynamic-inl.h	/^inline std::size_t dynamic::size() const {$/;"	f	class:folly::dynamic	signature:() const
folly::dynamic::size	.\dynamic.h	/^  std::size_t size() const;$/;"	p	struct:folly::dynamic	access:public	signature:() const
folly::dynamic::type	.\dynamic-inl.h	/^inline dynamic::Type dynamic::type() const {$/;"	f	class:folly::dynamic	signature:() const
folly::dynamic::type	.\dynamic.h	/^  Type type() const;$/;"	p	struct:folly::dynamic	access:public	signature:() const
folly::dynamic::typeName	.\dynamic-inl.h	/^inline char const* dynamic::typeName(Type t) {$/;"	f	class:folly::dynamic	signature:(Type t)
folly::dynamic::typeName	.\dynamic.cpp	/^const char* dynamic::typeName() const {$/;"	f	class:folly::dynamic	signature:() const
folly::dynamic::typeName	.\dynamic.h	/^  const char* typeName() const;$/;"	p	struct:folly::dynamic	access:public	signature:() const
folly::dynamic::typeName	.\dynamic.h	/^  static char const* typeName(Type);$/;"	p	struct:folly::dynamic	access:private	signature:(Type)
folly::dynamic::type_	.\dynamic.h	/^  Type type_;$/;"	m	struct:folly::dynamic	access:private
folly::dynamic::u_	.\dynamic.h	/^  } u_;$/;"	m	struct:folly::dynamic	typeref:union:folly::dynamic::Data	access:private
folly::dynamic::value_type	.\dynamic.h	/^  typedef dynamic value_type;$/;"	t	struct:folly::dynamic	access:public
folly::dynamic::values	.\dynamic-inl.h	/^inline dynamic::IterableProxy<dynamic::const_value_iterator> dynamic::values()$/;"	f	class:folly::dynamic	signature:() const
folly::dynamic::values	.\dynamic.h	/^  IterableProxy<const_value_iterator> values() const;$/;"	p	struct:folly::dynamic	access:public	signature:() const
folly::dynamic::~dynamic	.\dynamic-inl.h	/^inline dynamic::~dynamic() { destroy(); }$/;"	f	class:folly::dynamic	signature:()
folly::dynamic::~dynamic	.\dynamic.h	/^  ~dynamic();$/;"	p	struct:folly::dynamic	access:public	signature:()
folly::dynamicconverter_detail	.\DynamicConverter.h	/^namespace dynamicconverter_detail {$/;"	n	namespace:folly
folly::dynamicconverter_detail::BOOST_MPL_HAS_XXX_TRAIT_DEF	.\DynamicConverter.h	/^BOOST_MPL_HAS_XXX_TRAIT_DEF(iterator);$/;"	p	namespace:folly::dynamicconverter_detail	signature:(iterator)
folly::dynamicconverter_detail::BOOST_MPL_HAS_XXX_TRAIT_DEF	.\DynamicConverter.h	/^BOOST_MPL_HAS_XXX_TRAIT_DEF(mapped_type);$/;"	p	namespace:folly::dynamicconverter_detail	signature:(mapped_type)
folly::dynamicconverter_detail::BOOST_MPL_HAS_XXX_TRAIT_DEF	.\DynamicConverter.h	/^BOOST_MPL_HAS_XXX_TRAIT_DEF(value_type);$/;"	p	namespace:folly::dynamicconverter_detail	signature:(value_type)
folly::dynamicconverter_detail::Dereferencer	.\DynamicConverter.h	/^struct Dereferencer {$/;"	s	namespace:folly::dynamicconverter_detail
folly::dynamicconverter_detail::Dereferencer	.\DynamicConverter.h	/^struct Dereferencer<std::pair<F, S>> {$/;"	s	namespace:folly::dynamicconverter_detail
folly::dynamicconverter_detail::Dereferencer::derefToCache	.\DynamicConverter.h	/^  derefToCache(T* mem, const dynamic::const_item_iterator& it) {$/;"	f	struct:folly::dynamicconverter_detail::Dereferencer	access:public	signature:(T* mem, const dynamic::const_item_iterator& it)
folly::dynamicconverter_detail::Dereferencer::derefToCache	.\DynamicConverter.h	/^  derefToCache(std::pair<F, S>* mem, const dynamic::const_item_iterator& it) {$/;"	f	struct:folly::dynamicconverter_detail::Dereferencer	access:public	signature:(std::pair<F, S>* mem, const dynamic::const_item_iterator& it)
folly::dynamicconverter_detail::Dereferencer::derefToCache	.\DynamicConverter.h	/^  static inline void derefToCache(T* mem, const dynamic::const_iterator& it) {$/;"	f	struct:folly::dynamicconverter_detail::Dereferencer	access:public	signature:(T* mem, const dynamic::const_iterator& it)
folly::dynamicconverter_detail::Transformer	.\DynamicConverter.h	/^class Transformer : public boost::iterator_adaptor<$/;"	c	namespace:folly::dynamicconverter_detail	inherits:boost::iterator_adaptor
folly::dynamicconverter_detail::Transformer::Transformer	.\DynamicConverter.h	/^  explicit Transformer(const It& it)$/;"	f	class:folly::dynamicconverter_detail::Transformer	access:public	signature:(const It& it)
folly::dynamicconverter_detail::Transformer::cache_	.\DynamicConverter.h	/^  mutable ttype cache_;$/;"	m	class:folly::dynamicconverter_detail::Transformer	access:private
folly::dynamicconverter_detail::Transformer::dereference	.\DynamicConverter.h	/^  ttype& dereference() const {$/;"	f	class:folly::dynamicconverter_detail::Transformer	access:private	signature:() const
folly::dynamicconverter_detail::Transformer::increment	.\DynamicConverter.h	/^  void increment() {$/;"	f	class:folly::dynamicconverter_detail::Transformer	access:private	signature:()
folly::dynamicconverter_detail::Transformer::ttype	.\DynamicConverter.h	/^  typedef typename T::value_type ttype;$/;"	t	class:folly::dynamicconverter_detail::Transformer	access:private
folly::dynamicconverter_detail::Transformer::valid_	.\DynamicConverter.h	/^  mutable bool valid_;$/;"	m	class:folly::dynamicconverter_detail::Transformer	access:private
folly::dynamicconverter_detail::class_is_container	.\DynamicConverter.h	/^template <typename T> struct class_is_container {$/;"	s	namespace:folly::dynamicconverter_detail
folly::dynamicconverter_detail::class_is_container::some_iterator	.\DynamicConverter.h	/^  typedef std::reverse_iterator<T*> some_iterator;$/;"	t	struct:folly::dynamicconverter_detail::class_is_container	access:public
folly::dynamicconverter_detail::class_is_container::value	.\DynamicConverter.h	/^  enum { value = has_value_type<T>::value &&$/;"	e	enum:folly::dynamicconverter_detail::class_is_container::__anon20
folly::dynamicconverter_detail::class_is_range	.\DynamicConverter.h	/^template <typename T> struct class_is_range {$/;"	s	namespace:folly::dynamicconverter_detail
folly::dynamicconverter_detail::class_is_range::value	.\DynamicConverter.h	/^  enum { value = has_value_type<T>::value &&$/;"	e	enum:folly::dynamicconverter_detail::class_is_range::__anon21
folly::dynamicconverter_detail::conversionIterator	.\DynamicConverter.h	/^conversionIterator(const It& it) {$/;"	f	namespace:folly::dynamicconverter_detail	signature:(const It& it)
folly::dynamicconverter_detail::is_container	.\DynamicConverter.h	/^template <typename T> struct is_container$/;"	s	namespace:folly::dynamicconverter_detail	inherits:std::conditional::type
folly::dynamicconverter_detail::is_map	.\DynamicConverter.h	/^template <typename T> struct is_map$/;"	s	namespace:folly::dynamicconverter_detail	inherits:std::integral_constant
folly::dynamicconverter_detail::is_range	.\DynamicConverter.h	/^template <typename T> struct is_range$/;"	s	namespace:folly::dynamicconverter_detail	inherits:std::conditional::type
folly::encodeVarint	.\Varint.h	/^inline size_t encodeVarint(uint64_t val, uint8_t* buf) {$/;"	f	namespace:folly	signature:(uint64_t val, uint8_t* buf)
folly::encodeVarint	.\Varint.h	/^size_t encodeVarint(uint64_t val, uint8_t* buf);$/;"	p	namespace:folly	signature:(uint64_t val, uint8_t* buf)
folly::encodeZigZag	.\Varint.h	/^inline uint64_t encodeZigZag(int64_t val) {$/;"	f	namespace:folly	signature:(int64_t val)
folly::end	.\Padded.h	/^Iterator<typename Container::const_iterator> end(const Container& c) {$/;"	f	namespace:folly	signature:(const Container& c)
folly::end	.\Padded.h	/^Iterator<typename Container::iterator> end(Container& c) {$/;"	f	namespace:folly	signature:(Container& c)
folly::errnoStr	.\String.cpp	/^fbstring errnoStr(int err) {$/;"	f	namespace:folly	signature:(int err)
folly::estimateSpaceNeeded	.\Conv.h	/^estimateSpaceNeeded(Src value) {$/;"	f	namespace:folly	signature:(Src value)
folly::estimateSpaceNeeded	.\Conv.h	/^estimateSpaceNeeded(T) {$/;"	f	namespace:folly	signature:(T)
folly::estimateTime	.\Benchmark.cpp	/^static double estimateTime(double * begin, double * end) {$/;"	f	namespace:folly	signature:(double * begin, double * end)
folly::exception_tracer	.\experimental\exception_tracer\ExceptionTracer.cpp	/^namespace exception_tracer {$/;"	n	namespace:folly	file:
folly::exception_tracer	.\experimental\exception_tracer\ExceptionTracer.h	/^namespace exception_tracer {$/;"	n	namespace:folly
folly::exception_tracer	.\experimental\exception_tracer\StackTrace.cpp	/^namespace folly { namespace exception_tracer {$/;"	n	namespace:folly	file:
folly::exception_tracer	.\experimental\exception_tracer\StackTrace.h	/^namespace folly { namespace exception_tracer {$/;"	n	namespace:folly
folly::exception_tracer::ExceptionInfo	.\experimental\exception_tracer\ExceptionTracer.h	/^struct ExceptionInfo {$/;"	s	namespace:folly::exception_tracer
folly::exception_tracer::ExceptionInfo::frames	.\experimental\exception_tracer\ExceptionTracer.h	/^  std::vector<uintptr_t> frames;  \/\/ front() is top of stack$/;"	m	struct:folly::exception_tracer::ExceptionInfo	access:public
folly::exception_tracer::ExceptionInfo::type	.\experimental\exception_tracer\ExceptionTracer.h	/^  const std::type_info* type;$/;"	m	struct:folly::exception_tracer::ExceptionInfo	access:public
folly::exception_tracer::StackTrace	.\experimental\exception_tracer\StackTrace.h	/^struct StackTrace {$/;"	s	namespace:folly::exception_tracer
folly::exception_tracer::StackTrace::StackTrace	.\experimental\exception_tracer\StackTrace.h	/^  StackTrace() : frameCount(0) { }$/;"	f	struct:folly::exception_tracer::StackTrace	access:public	signature:()
folly::exception_tracer::StackTrace::addresses	.\experimental\exception_tracer\StackTrace.h	/^  uintptr_t addresses[kMaxFrames];$/;"	m	struct:folly::exception_tracer::StackTrace	access:public
folly::exception_tracer::StackTrace::frameCount	.\experimental\exception_tracer\StackTrace.h	/^  size_t frameCount;$/;"	m	struct:folly::exception_tracer::StackTrace	access:public
folly::exception_tracer::StackTraceStack	.\experimental\exception_tracer\StackTrace.h	/^class StackTraceStack {$/;"	c	namespace:folly::exception_tracer
folly::exception_tracer::StackTraceStack::Node	.\experimental\exception_tracer\StackTrace.cpp	/^class StackTraceStack::Node : public StackTrace {$/;"	c	class:folly::exception_tracer::StackTraceStack	file:	inherits:StackTrace
folly::exception_tracer::StackTraceStack::Node	.\experimental\exception_tracer\StackTrace.h	/^  class Node;$/;"	x
folly::exception_tracer::StackTraceStack::Node::Node	.\experimental\exception_tracer\StackTrace.cpp	/^  Node() : next(nullptr) { }$/;"	f	class:folly::exception_tracer::StackTraceStack::Node	file:	access:private	signature:()
folly::exception_tracer::StackTraceStack::Node::allocate	.\experimental\exception_tracer\StackTrace.cpp	/^  static Node* allocate();$/;"	p	class:folly::exception_tracer::StackTraceStack::Node	file:	access:public	signature:()
folly::exception_tracer::StackTraceStack::Node::deallocate	.\experimental\exception_tracer\StackTrace.cpp	/^  void deallocate();$/;"	p	class:folly::exception_tracer::StackTraceStack::Node	file:	access:public	signature:()
folly::exception_tracer::StackTraceStack::Node::deallocate	.\experimental\exception_tracer\StackTrace.cpp	/^void StackTraceStack::Node::deallocate() {$/;"	f	class:folly::exception_tracer::StackTraceStack::Node	signature:()
folly::exception_tracer::StackTraceStack::Node::next	.\experimental\exception_tracer\StackTrace.cpp	/^  Node* next;$/;"	m	class:folly::exception_tracer::StackTraceStack::Node	file:	access:public
folly::exception_tracer::StackTraceStack::Node::~Node	.\experimental\exception_tracer\StackTrace.cpp	/^  ~Node() { }$/;"	f	class:folly::exception_tracer::StackTraceStack::Node	file:	access:private	signature:()
folly::exception_tracer::StackTraceStack::checkGuard	.\experimental\exception_tracer\StackTrace.h	/^  void checkGuard() const {$/;"	f	class:folly::exception_tracer::StackTraceStack	access:private	signature:() const
folly::exception_tracer::StackTraceStack::clear	.\experimental\exception_tracer\StackTrace.cpp	/^void StackTraceStack::clear() {$/;"	f	class:folly::exception_tracer::StackTraceStack	signature:()
folly::exception_tracer::StackTraceStack::clear	.\experimental\exception_tracer\StackTrace.h	/^  void clear();$/;"	p	class:folly::exception_tracer::StackTraceStack	access:public	signature:()
folly::exception_tracer::StackTraceStack::empty	.\experimental\exception_tracer\StackTrace.h	/^  bool empty() const { return !top_; }$/;"	f	class:folly::exception_tracer::StackTraceStack	access:public	signature:() const
folly::exception_tracer::StackTraceStack::guard1_	.\experimental\exception_tracer\StackTrace.h	/^  uintptr_t guard1_;$/;"	m	class:folly::exception_tracer::StackTraceStack	access:private
folly::exception_tracer::StackTraceStack::guard2_	.\experimental\exception_tracer\StackTrace.h	/^  uintptr_t guard2_;$/;"	m	class:folly::exception_tracer::StackTraceStack	access:private
folly::exception_tracer::StackTraceStack::moveTopFrom	.\experimental\exception_tracer\StackTrace.cpp	/^bool StackTraceStack::moveTopFrom(StackTraceStack& other) {$/;"	f	class:folly::exception_tracer::StackTraceStack	signature:(StackTraceStack& other)
folly::exception_tracer::StackTraceStack::moveTopFrom	.\experimental\exception_tracer\StackTrace.h	/^  bool moveTopFrom(StackTraceStack& other);$/;"	p	class:folly::exception_tracer::StackTraceStack	access:public	signature:(StackTraceStack& other)
folly::exception_tracer::StackTraceStack::next	.\experimental\exception_tracer\StackTrace.cpp	/^StackTrace* StackTraceStack::next(StackTrace* p) {$/;"	f	class:folly::exception_tracer::StackTraceStack	signature:(StackTrace* p)
folly::exception_tracer::StackTraceStack::next	.\experimental\exception_tracer\StackTrace.h	/^  StackTrace* next(StackTrace* p);$/;"	p	class:folly::exception_tracer::StackTraceStack	access:public	signature:(StackTrace* p)
folly::exception_tracer::StackTraceStack::pop	.\experimental\exception_tracer\StackTrace.cpp	/^bool StackTraceStack::pop() {$/;"	f	class:folly::exception_tracer::StackTraceStack	signature:()
folly::exception_tracer::StackTraceStack::pop	.\experimental\exception_tracer\StackTrace.h	/^  bool pop();$/;"	p	class:folly::exception_tracer::StackTraceStack	access:public	signature:()
folly::exception_tracer::StackTraceStack::pushCurrent	.\experimental\exception_tracer\StackTrace.cpp	/^bool StackTraceStack::pushCurrent() {$/;"	f	class:folly::exception_tracer::StackTraceStack	signature:()
folly::exception_tracer::StackTraceStack::pushCurrent	.\experimental\exception_tracer\StackTrace.h	/^  bool pushCurrent();$/;"	p	class:folly::exception_tracer::StackTraceStack	access:public	signature:()
folly::exception_tracer::StackTraceStack::top	.\experimental\exception_tracer\StackTrace.cpp	/^StackTrace* StackTraceStack::top() {$/;"	f	class:folly::exception_tracer::StackTraceStack	signature:()
folly::exception_tracer::StackTraceStack::top	.\experimental\exception_tracer\StackTrace.h	/^  StackTrace* top();$/;"	p	class:folly::exception_tracer::StackTraceStack	access:public	signature:()
folly::exception_tracer::StackTraceStack::top_	.\experimental\exception_tracer\StackTrace.h	/^  Node* top_;$/;"	m	class:folly::exception_tracer::StackTraceStack	access:private
folly::exception_tracer::__anon23::isAbiCppException	.\experimental\exception_tracer\ExceptionTracer.cpp	/^bool isAbiCppException(const __cxa_exception* exc) {$/;"	f	namespace:folly::exception_tracer::__anon23	signature:(const __cxa_exception* exc)
folly::exception_tracer::__anon24::dumpExceptionStack	.\experimental\exception_tracer\ExceptionTracer.cpp	/^void dumpExceptionStack(const char* prefix) {$/;"	f	namespace:folly::exception_tracer::__anon24	signature:(const char* prefix)
folly::exception_tracer::__anon24::origTerminate	.\experimental\exception_tracer\ExceptionTracer.cpp	/^std::terminate_handler origTerminate = abort;$/;"	m	namespace:folly::exception_tracer::__anon24	file:
folly::exception_tracer::__anon24::origUnexpected	.\experimental\exception_tracer\ExceptionTracer.cpp	/^std::unexpected_handler origUnexpected = abort;$/;"	m	namespace:folly::exception_tracer::__anon24	file:
folly::exception_tracer::__anon24::terminateHandler	.\experimental\exception_tracer\ExceptionTracer.cpp	/^void terminateHandler() {$/;"	f	namespace:folly::exception_tracer::__anon24	signature:()
folly::exception_tracer::__anon24::unexpectedHandler	.\experimental\exception_tracer\ExceptionTracer.cpp	/^void unexpectedHandler() {$/;"	f	namespace:folly::exception_tracer::__anon24	signature:()
folly::exception_tracer::getCurrentExceptions	.\experimental\exception_tracer\ExceptionTracer.cpp	/^std::vector<ExceptionInfo> getCurrentExceptions() {$/;"	f	namespace:folly::exception_tracer	signature:()
folly::exception_tracer::getCurrentExceptions	.\experimental\exception_tracer\ExceptionTracer.h	/^std::vector<ExceptionInfo> getCurrentExceptions();$/;"	p	namespace:folly::exception_tracer	signature:()
folly::exception_tracer::installHandlers	.\experimental\exception_tracer\ExceptionTracer.cpp	/^void installHandlers() {$/;"	f	namespace:folly::exception_tracer	signature:()
folly::exception_tracer::installHandlers	.\experimental\exception_tracer\ExceptionTracer.h	/^void installHandlers();$/;"	p	namespace:folly::exception_tracer	signature:()
folly::exception_tracer::kMaxFrames	.\experimental\exception_tracer\StackTrace.h	/^constexpr size_t kMaxFrames = 500;$/;"	m	namespace:folly::exception_tracer
folly::exception_tracer::operator <<	.\experimental\exception_tracer\ExceptionTracer.cpp	/^std::ostream& operator<<(std::ostream& out, const ExceptionInfo& info) {$/;"	f	namespace:folly::exception_tracer	signature:(std::ostream& out, const ExceptionInfo& info)
folly::exception_tracer::operator <<	.\experimental\exception_tracer\ExceptionTracer.h	/^std::ostream& operator<<(std::ostream& out, const ExceptionInfo& info);$/;"	p	namespace:folly::exception_tracer	signature:(std::ostream& out, const ExceptionInfo& info)
folly::exception_wrapper	.\ExceptionWrapper.h	/^class exception_wrapper {$/;"	c	namespace:folly
folly::exception_wrapper::eptr_	.\ExceptionWrapper.h	/^  std::exception_ptr eptr_;$/;"	m	class:folly::exception_wrapper	access:protected
folly::exception_wrapper::estr_	.\ExceptionWrapper.h	/^  std::string estr_;$/;"	m	class:folly::exception_wrapper	access:protected
folly::exception_wrapper::exception_wrapper	.\ExceptionWrapper.h	/^  exception_wrapper() : throwfn_(nullptr) { }$/;"	f	class:folly::exception_wrapper	access:public	signature:()
folly::exception_wrapper::getCopied	.\ExceptionWrapper.h	/^  const std::exception* getCopied() const { return item_.get(); }$/;"	f	class:folly::exception_wrapper	access:public	signature:() const
folly::exception_wrapper::getCopied	.\ExceptionWrapper.h	/^  std::exception* getCopied() { return item_.get(); }$/;"	f	class:folly::exception_wrapper	access:public	signature:()
folly::exception_wrapper::getExceptionPtr	.\ExceptionWrapper.h	/^  std::exception_ptr getExceptionPtr() const {$/;"	f	class:folly::exception_wrapper	access:public	signature:() const
folly::exception_wrapper::is_compatible_with	.\ExceptionWrapper.h	/^  bool is_compatible_with() const {$/;"	f	class:folly::exception_wrapper	access:public	signature:() const
folly::exception_wrapper::item_	.\ExceptionWrapper.h	/^  std::shared_ptr<std::exception> item_;$/;"	m	class:folly::exception_wrapper	access:protected
folly::exception_wrapper::make_exception_wrapper	.\ExceptionWrapper.h	/^  friend exception_wrapper make_exception_wrapper(Args&&... args);$/;"	p	class:folly::exception_wrapper	access:friend	signature:(Args&&.... args)
folly::exception_wrapper::operator !=	.\ExceptionWrapper.h	/^  bool operator!=(const exception_wrapper& a) const {$/;"	f	class:folly::exception_wrapper	access:public	signature:(const exception_wrapper& a) const
folly::exception_wrapper::operator ==	.\ExceptionWrapper.h	/^  bool operator==(const exception_wrapper& a) const {$/;"	f	class:folly::exception_wrapper	access:public	signature:(const exception_wrapper& a) const
folly::exception_wrapper::operator bool	.\ExceptionWrapper.h	/^  explicit operator bool() const {$/;"	f	class:folly::exception_wrapper	access:public	signature:() const
folly::exception_wrapper::throwException	.\ExceptionWrapper.h	/^  void throwException() const {$/;"	f	class:folly::exception_wrapper	access:public	signature:() const
folly::exception_wrapper::throwfn_	.\ExceptionWrapper.h	/^  void (*throwfn_)(std::exception*);$/;"	m	class:folly::exception_wrapper	access:protected
folly::exception_wrapper::what	.\ExceptionWrapper.h	/^  fbstring what() const {$/;"	f	class:folly::exception_wrapper	access:public	signature:() const
folly::exception_wrapper::with_exception	.\ExceptionWrapper.h	/^  bool with_exception(F f) const {$/;"	f	class:folly::exception_wrapper	access:public	signature:(F f) const
folly::exception_wrapper::with_exception	.\ExceptionWrapper.h	/^  bool with_exception(F f) {$/;"	f	class:folly::exception_wrapper	access:public	signature:(F f)
folly::exception_wrapper::with_exception1	.\ExceptionWrapper.h	/^  static bool with_exception1(F f, T* that) {$/;"	f	class:folly::exception_wrapper	access:private	signature:(F f, T* that)
folly::fbvector	.\FBVector.h	/^  class fbvector;$/;"	x
folly::fbvector	.\FBVector.h	/^class fbvector : private boost::totally_ordered<fbvector<T, Allocator>> {$/;"	c	namespace:folly	inherits:boost::totally_ordered
folly::fbvector::A	.\FBVector.h	/^  typedef std::allocator_traits<Allocator> A;$/;"	t	class:folly::fbvector	access:private
folly::fbvector::Impl	.\FBVector.h	/^  struct Impl : public Allocator {$/;"	s	class:folly::fbvector	inherits:Allocator	access:private
folly::fbvector::Impl::D_allocate	.\FBVector.h	/^    T* D_allocate(size_type n) {$/;"	f	struct:folly::fbvector::Impl	access:public	signature:(size_type n)
folly::fbvector::Impl::Impl	.\FBVector.h	/^    Impl() : Allocator(), b_(nullptr), e_(nullptr), z_(nullptr) {}$/;"	f	struct:folly::fbvector::Impl	access:public	signature:()
folly::fbvector::Impl::Impl	.\FBVector.h	/^    \/* implicit *\/ Impl(Allocator&& a)$/;"	f	struct:folly::fbvector::Impl	access:public	signature:(Allocator&& a)
folly::fbvector::Impl::Impl	.\FBVector.h	/^    \/* implicit *\/ Impl(const Allocator& a)$/;"	f	struct:folly::fbvector::Impl	access:public	signature:(const Allocator& a)
folly::fbvector::Impl::Impl	.\FBVector.h	/^    \/* implicit *\/ Impl(size_type n, const Allocator& a = Allocator())$/;"	f	struct:folly::fbvector::Impl	access:public	signature:(size_type n, const Allocator& a = Allocator())
folly::fbvector::Impl::b_	.\FBVector.h	/^        b_(other.b_), e_(other.e_), z_(other.z_)$/;"	p	struct:folly::fbvector::Impl	access:public	signature:(other.b_)
folly::fbvector::Impl::b_	.\FBVector.h	/^    pointer b_, e_, z_;$/;"	m	struct:folly::fbvector::Impl	access:public
folly::fbvector::Impl::e_	.\FBVector.h	/^        b_(other.b_), e_(other.e_), z_(other.z_)$/;"	p	struct:folly::fbvector::Impl	access:public	signature:(other.e_)
folly::fbvector::Impl::e_	.\FBVector.h	/^    pointer b_, e_, z_;$/;"	m	struct:folly::fbvector::Impl	access:public
folly::fbvector::Impl::init	.\FBVector.h	/^    void init(size_type n) {$/;"	f	struct:folly::fbvector::Impl	access:public	signature:(size_type n)
folly::fbvector::Impl::noexcept	.\FBVector.h	/^    Impl(Impl&& other) noexcept$/;"	m	struct:folly::fbvector::Impl	access:public
folly::fbvector::Impl::pointer	.\FBVector.h	/^    typedef typename A::pointer pointer;$/;"	t	struct:folly::fbvector::Impl	access:public
folly::fbvector::Impl::reset	.\FBVector.h	/^    void reset() { \/\/ same as reset(0)$/;"	f	struct:folly::fbvector::Impl	access:public	signature:()
folly::fbvector::Impl::reset	.\FBVector.h	/^    void reset(size_type newCap) {$/;"	f	struct:folly::fbvector::Impl	access:public	signature:(size_type newCap)
folly::fbvector::Impl::set	.\FBVector.h	/^    set(pointer newB, size_type newSize, size_type newCap) {$/;"	f	struct:folly::fbvector::Impl	access:public	signature:(pointer newB, size_type newSize, size_type newCap)
folly::fbvector::Impl::size_type	.\FBVector.h	/^    typedef typename A::size_type size_type;$/;"	t	struct:folly::fbvector::Impl	access:public
folly::fbvector::Impl::swapData	.\FBVector.h	/^    void swapData(Impl& other) {$/;"	f	struct:folly::fbvector::Impl	access:public	signature:(Impl& other)
folly::fbvector::Impl::z_	.\FBVector.h	/^        b_(other.b_), e_(other.e_), z_(other.z_)$/;"	f	struct:folly::fbvector::Impl	access:public	signature:(other.z_)
folly::fbvector::Impl::z_	.\FBVector.h	/^    pointer b_, e_, z_;$/;"	m	struct:folly::fbvector::Impl	access:public
folly::fbvector::Impl::~Impl	.\FBVector.h	/^    ~Impl() {$/;"	f	struct:folly::fbvector::Impl	access:public	signature:()
folly::fbvector::allocator_type	.\FBVector.h	/^  typedef Allocator                                   allocator_type;$/;"	t	class:folly::fbvector	access:public
folly::fbvector::const_iterator	.\FBVector.h	/^  typedef const T*                                    const_iterator;$/;"	t	class:folly::fbvector	access:public
folly::fbvector::const_pointer	.\FBVector.h	/^  typedef typename A::const_pointer                   const_pointer;$/;"	t	class:folly::fbvector	access:public
folly::fbvector::const_reference	.\FBVector.h	/^  typedef const value_type&                           const_reference;$/;"	t	class:folly::fbvector	access:public
folly::fbvector::const_reverse_iterator	.\FBVector.h	/^  typedef std::reverse_iterator<const_iterator>       const_reverse_iterator;$/;"	t	class:folly::fbvector	access:public
folly::fbvector::difference_type	.\FBVector.h	/^  typedef typename std::make_signed<size_type>::type  difference_type;$/;"	t	class:folly::fbvector	access:public
folly::fbvector::impl_	.\FBVector.h	/^  } impl_;$/;"	m	class:folly::fbvector	typeref:struct:folly::fbvector::Impl	access:private
folly::fbvector::iterator	.\FBVector.h	/^  typedef T*                                          iterator;$/;"	t	class:folly::fbvector	access:public
folly::fbvector::pointer	.\FBVector.h	/^  typedef typename A::pointer                         pointer;$/;"	t	class:folly::fbvector	access:public
folly::fbvector::reference	.\FBVector.h	/^  typedef value_type&                                 reference;$/;"	t	class:folly::fbvector	access:public
folly::fbvector::reverse_iterator	.\FBVector.h	/^  typedef std::reverse_iterator<iterator>             reverse_iterator;$/;"	t	class:folly::fbvector	access:public
folly::fbvector::size_type	.\FBVector.h	/^  typedef size_t                                      size_type;$/;"	t	class:folly::fbvector	access:public
folly::fbvector::swap	.\FBVector.h	/^  static void swap(Impl& a, Impl& b) {$/;"	f	class:folly::fbvector	access:private	signature:(Impl& a, Impl& b)
folly::fbvector::value_type	.\FBVector.h	/^  typedef T                                           value_type;$/;"	t	class:folly::fbvector	access:public
folly::fbvector::~T	.\FBVector.h	/^      if (!boost::has_trivial_destructor<T>::value) p->~T();$/;"	t	class:folly::fbvector	access:private
folly::fdatasyncNoInt	.\FileUtil.cpp	/^int fdatasyncNoInt(int fd) {$/;"	f	namespace:folly	signature:(int fd)
folly::fdatasyncNoInt	.\FileUtil.h	/^int fdatasyncNoInt(int fd);$/;"	p	namespace:folly	signature:(int fd)
folly::fileutil_detail	.\detail\FileUtilDetail.h	/^namespace folly { namespace fileutil_detail {$/;"	n	namespace:folly
folly::fileutil_detail::incr	.\detail\FileUtilDetail.h	/^inline void incr(ssize_t n) { }$/;"	f	namespace:folly::fileutil_detail	signature:(ssize_t n)
folly::fileutil_detail::incr	.\detail\FileUtilDetail.h	/^inline void incr(ssize_t n, off_t& offset) { offset += n; }$/;"	f	namespace:folly::fileutil_detail	signature:(ssize_t n, off_t& offset)
folly::fileutil_detail::wrapFull	.\detail\FileUtilDetail.h	/^ssize_t wrapFull(F f, int fd, void* buf, size_t count, Offset... offset) {$/;"	f	namespace:folly::fileutil_detail	signature:(F f, int fd, void* buf, size_t count, Offset... offset)
folly::fileutil_detail::wrapNoInt	.\detail\FileUtilDetail.h	/^ssize_t wrapNoInt(F f, Args... args) {$/;"	f	namespace:folly::fileutil_detail	signature:(F f, Args... args)
folly::fileutil_detail::wrapvFull	.\detail\FileUtilDetail.h	/^ssize_t wrapvFull(F f, int fd, iovec* iov, int count, Offset... offset) {$/;"	f	namespace:folly::fileutil_detail	signature:(F f, int fd, iovec* iov, int count, Offset... offset)
folly::fingerprint128	.\Fingerprint.h	/^inline void fingerprint128(StringPiece str,$/;"	f	namespace:folly	signature:(StringPiece str, uint64_t* msb, uint64_t* lsb)
folly::fingerprint64	.\Fingerprint.h	/^inline uint64_t fingerprint64(StringPiece str) {$/;"	f	namespace:folly	signature:(StringPiece str)
folly::fingerprint96	.\Fingerprint.h	/^inline void fingerprint96(StringPiece str,$/;"	f	namespace:folly	signature:(StringPiece str, uint64_t* msb, uint32_t* lsb)
folly::flockNoInt	.\FileUtil.cpp	/^int flockNoInt(int fd, int operation) {$/;"	f	namespace:folly	signature:(int fd, int operation)
folly::flockNoInt	.\FileUtil.h	/^int flockNoInt(int fd, int operation);$/;"	p	namespace:folly	signature:(int fd, int operation)
folly::foo	.\test\LazyTest.cpp	/^auto const foo = folly::lazy([]() -> std::string {$/;"	m	namespace:folly	file:
folly::format	.\Format.h	/^Formatter<false, Args...> format(StringPiece fmt, Args&&... args);$/;"	p	namespace:folly	signature:(StringPiece fmt, Args&&... args)
folly::format_value	.\Format-inl.h	/^namespace format_value {$/;"	n	namespace:folly
folly::format_value::formatFormatter	.\Format-inl.h	/^void formatFormatter($/;"	f	namespace:folly::format_value	signature:( const BaseFormatter<Derived, containerMode, Args...>& formatter, FormatArg& arg, FormatCallback& cb)
folly::format_value::formatNumber	.\Format-inl.h	/^void formatNumber(StringPiece val, int prefixLen, FormatArg& arg,$/;"	f	namespace:folly::format_value	signature:(StringPiece val, int prefixLen, FormatArg& arg, FormatCallback& cb)
folly::format_value::formatString	.\Format-inl.h	/^void formatString(StringPiece val, FormatArg& arg, FormatCallback& cb) {$/;"	f	namespace:folly::format_value	signature:(StringPiece val, FormatArg& arg, FormatCallback& cb)
folly::freeHeap	.\small_vector.h	/^    void freeHeap() {$/;"	f	namespace:folly	signature:()
folly::fs	.\experimental\io\FsUtil.cpp	/^namespace fs {$/;"	n	namespace:folly	file:
folly::fs	.\experimental\io\FsUtil.h	/^namespace fs {$/;"	n	namespace:folly
folly::fs::__anon29::skipPrefix	.\experimental\io\FsUtil.cpp	/^bool skipPrefix(const path& pth, const path& prefix, path::const_iterator& it) {$/;"	f	namespace:folly::fs::__anon29	signature:(const path& pth, const path& prefix, path::const_iterator& it)
folly::fs::canonical_parent	.\experimental\io\FsUtil.cpp	/^path canonical_parent(const path& pth, const path& base) {$/;"	f	namespace:folly::fs	signature:(const path& pth, const path& base)
folly::fs::canonical_parent	.\experimental\io\FsUtil.h	/^path canonical_parent(const path& p, const path& basePath = current_path());$/;"	p	namespace:folly::fs	signature:(const path& p, const path& basePath = current_path())
folly::fs::remove_prefix	.\experimental\io\FsUtil.cpp	/^path remove_prefix(const path& pth, const path& prefix) {$/;"	f	namespace:folly::fs	signature:(const path& pth, const path& prefix)
folly::fs::remove_prefix	.\experimental\io\FsUtil.h	/^path remove_prefix(const path& p, const path& prefix);$/;"	p	namespace:folly::fs	signature:(const path& p, const path& prefix)
folly::fs::starts_with	.\experimental\io\FsUtil.cpp	/^bool starts_with(const path& pth, const path& prefix) {$/;"	f	namespace:folly::fs	signature:(const path& pth, const path& prefix)
folly::fsyncNoInt	.\FileUtil.cpp	/^int fsyncNoInt(int fd) {$/;"	f	namespace:folly	signature:(int fd)
folly::fsyncNoInt	.\FileUtil.h	/^int fsyncNoInt(int fd);$/;"	p	namespace:folly	signature:(int fd)
folly::ftruncateNoInt	.\FileUtil.cpp	/^int ftruncateNoInt(int fd, off_t len) {$/;"	f	namespace:folly	signature:(int fd, off_t len)
folly::ftruncateNoInt	.\FileUtil.h	/^int ftruncateNoInt(int fd, off_t len);$/;"	p	namespace:folly	signature:(int fd, off_t len)
folly::gen	.\gen\Base-inl.h	/^namespace folly { namespace gen {$/;"	n	namespace:folly
folly::gen	.\gen\Base.h	/^namespace folly { namespace gen {$/;"	n	namespace:folly
folly::gen	.\gen\Combine-inl.h	/^namespace gen {$/;"	n	namespace:folly
folly::gen	.\gen\Combine.h	/^namespace gen {$/;"	n	namespace:folly
folly::gen	.\gen\Core-inl.h	/^namespace folly { namespace gen {$/;"	n	namespace:folly
folly::gen	.\gen\Core.h	/^namespace folly { namespace gen {$/;"	n	namespace:folly
folly::gen	.\gen\File-inl.h	/^namespace gen {$/;"	n	namespace:folly
folly::gen	.\gen\File.h	/^namespace gen {$/;"	n	namespace:folly
folly::gen	.\gen\Parallel-inl.h	/^namespace gen {$/;"	n	namespace:folly
folly::gen	.\gen\Parallel.h	/^namespace folly { namespace gen {$/;"	n	namespace:folly
folly::gen	.\gen\ParallelMap-inl.h	/^namespace folly { namespace gen { namespace detail {$/;"	n	namespace:folly
folly::gen	.\gen\ParallelMap.h	/^namespace folly { namespace gen {$/;"	n	namespace:folly
folly::gen	.\gen\String-inl.h	/^namespace gen {$/;"	n	namespace:folly
folly::gen	.\gen\String.h	/^namespace gen {$/;"	n	namespace:folly
folly::gen::ArgumentReference	.\gen\Base-inl.h	/^struct ArgumentReference$/;"	s	namespace:folly::gen	inherits:std::conditional
folly::gen::Cast	.\gen\Base.h	/^class Cast {$/;"	c	namespace:folly::gen
folly::gen::Cast::operator ()	.\gen\Base.h	/^  Dest operator()(Value&& value) const {$/;"	f	class:folly::gen::Cast	access:public	signature:(Value&& value) const
folly::gen::Const	.\gen\Base.h	/^  Const,$/;"	e	enum:folly::gen::MemberType
folly::gen::ConstMemberFunction	.\gen\Base.h	/^class ConstMemberFunction{$/;"	c	namespace:folly::gen
folly::gen::ConstMemberFunction::ConstMemberFunction	.\gen\Base.h	/^  explicit ConstMemberFunction(MemberPtr member)$/;"	f	class:folly::gen::ConstMemberFunction	access:public	signature:(MemberPtr member)
folly::gen::ConstMemberFunction::member_	.\gen\Base.h	/^  MemberPtr member_;$/;"	m	class:folly::gen::ConstMemberFunction	access:private
folly::gen::ConstMemberFunction::operator ()	.\gen\Base.h	/^  Result operator()(const Class& x) const {$/;"	f	class:folly::gen::ConstMemberFunction	access:public	signature:(const Class& x) const
folly::gen::ConstMemberFunction::operator ()	.\gen\Base.h	/^  Result operator()(const Class* x) const {$/;"	f	class:folly::gen::ConstMemberFunction	access:public	signature:(const Class* x) const
folly::gen::EmptySequence	.\gen\Base.h	/^class EmptySequence : public std::exception {$/;"	c	namespace:folly::gen	inherits:std::exception
folly::gen::ExprIsConst	.\gen\Base.h	/^template <MemberType Constness> struct ExprIsConst {$/;"	s	namespace:folly::gen
folly::gen::ExprIsConst::value	.\gen\Base.h	/^    value = Constness == Const$/;"	e	enum:folly::gen::ExprIsConst::__anon54
folly::gen::ExprIsMutable	.\gen\Base.h	/^template <MemberType Constness> struct ExprIsMutable {$/;"	s	namespace:folly::gen
folly::gen::ExprIsMutable::value	.\gen\Base.h	/^    value = Constness == Mutable$/;"	e	enum:folly::gen::ExprIsMutable::__anon55
folly::gen::FBounded	.\gen\Core-inl.h	/^struct FBounded {$/;"	s	namespace:folly::gen
folly::gen::FBounded::self	.\gen\Core-inl.h	/^  Self& self() {$/;"	f	struct:folly::gen::FBounded	access:public	signature:()
folly::gen::FBounded::self	.\gen\Core-inl.h	/^  const Self& self() const {$/;"	f	struct:folly::gen::FBounded	access:public	signature:() const
folly::gen::Field	.\gen\Base.h	/^class Field {$/;"	c	namespace:folly::gen
folly::gen::Field::Field	.\gen\Base.h	/^  explicit Field(FieldPtr field)$/;"	f	class:folly::gen::Field	access:public	signature:(FieldPtr field)
folly::gen::Field::FieldType	.\gen\Base.h	/^  typedef FieldType (Class::*FieldPtr);$/;"	t	class:folly::gen::Field	access:public
folly::gen::Field::field_	.\gen\Base.h	/^  FieldPtr field_;$/;"	m	class:folly::gen::Field	access:private
folly::gen::Field::operator ()	.\gen\Base.h	/^  FieldType& operator()(Class& x) const {$/;"	f	class:folly::gen::Field	access:public	signature:(Class& x) const
folly::gen::Field::operator ()	.\gen\Base.h	/^  FieldType& operator()(Class* x) const {$/;"	f	class:folly::gen::Field	access:public	signature:(Class* x) const
folly::gen::Field::operator ()	.\gen\Base.h	/^  FieldType&& operator()(Class&& x) const {$/;"	f	class:folly::gen::Field	access:public	signature:(Class&& x) const
folly::gen::Field::operator ()	.\gen\Base.h	/^  const FieldType& operator()(const Class& x) const {$/;"	f	class:folly::gen::Field	access:public	signature:(const Class& x) const
folly::gen::Field::operator ()	.\gen\Base.h	/^  const FieldType& operator()(const Class* x) const {$/;"	f	class:folly::gen::Field	access:public	signature:(const Class* x) const
folly::gen::GenImpl	.\gen\Core-inl.h	/^class GenImpl : public FBounded<Self> {$/;"	c	namespace:folly::gen	inherits:FBounded
folly::gen::GenImpl	.\gen\Core.h	/^class GenImpl;$/;"	x
folly::gen::GenImpl::GenImpl	.\gen\Core-inl.h	/^  GenImpl() = default;$/;"	p	class:folly::gen::GenImpl	access:protected	signature:()
folly::gen::GenImpl::GenImpl	.\gen\Core-inl.h	/^  GenImpl(GenImpl&&) = default;$/;"	p	class:folly::gen::GenImpl	access:protected	signature:(GenImpl&&)
folly::gen::GenImpl::GenImpl	.\gen\Core-inl.h	/^  GenImpl(const GenImpl&) = default;$/;"	p	class:folly::gen::GenImpl	access:protected	signature:(const GenImpl&)
folly::gen::GenImpl::StorageType	.\gen\Core-inl.h	/^  typedef typename std::decay<Value>::type StorageType;$/;"	t	class:folly::gen::GenImpl	access:public
folly::gen::GenImpl::ValueType	.\gen\Core-inl.h	/^  typedef Value ValueType;$/;"	t	class:folly::gen::GenImpl	access:public
folly::gen::GenImpl::apply	.\gen\Core-inl.h	/^  bool apply(Handler&& handler) const;$/;"	p	class:folly::gen::GenImpl	access:public	signature:(Handler&& handler) const
folly::gen::GenImpl::foreach	.\gen\Core-inl.h	/^  void foreach(Body&& body) const {$/;"	f	class:folly::gen::GenImpl	access:public	signature:(Body&& body) const
folly::gen::GenImpl::infinite	.\gen\Core-inl.h	/^  static constexpr bool infinite = false;$/;"	m	class:folly::gen::GenImpl	access:public
folly::gen::GenImpl::operator =	.\gen\Core-inl.h	/^  GenImpl& operator=(GenImpl&&) = default;$/;"	p	class:folly::gen::GenImpl	access:protected	signature:(GenImpl&&)
folly::gen::GenImpl::operator =	.\gen\Core-inl.h	/^  GenImpl& operator=(const GenImpl&) = default;$/;"	p	class:folly::gen::GenImpl	access:protected	signature:(const GenImpl&)
folly::gen::Get	.\gen\Base.h	/^class Get {$/;"	c	namespace:folly::gen
folly::gen::Get::get	.\gen\Base.h	/^  decltype(std::get<n>(std::forward<Value>(value))) {$/;"	f	class:folly::gen::Get	access:public	signature:(std::forward<Value>(
folly::gen::Identity	.\gen\Base.h	/^class Identity {$/;"	c	namespace:folly::gen
folly::gen::Identity::forward	.\gen\Base.h	/^  decltype(std::forward<Value>(value)) {$/;"	f	class:folly::gen::Identity	access:public	signature:(value)
folly::gen::IsCompatibleSignature	.\gen\Core-inl.h	/^class IsCompatibleSignature {$/;"	c	namespace:folly::gen
folly::gen::IsCompatibleSignature	.\gen\Core-inl.h	/^class IsCompatibleSignature<Candidate, ExpectedReturn(ArgTypes...)> {$/;"	c	namespace:folly::gen
folly::gen::IsCompatibleSignature::testArgs	.\gen\Core-inl.h	/^  static constexpr bool testArgs(...) {$/;"	f	class:folly::gen::IsCompatibleSignature	access:private	signature:(....)
folly::gen::IsCompatibleSignature::testArgs	.\gen\Core-inl.h	/^  static constexpr bool testArgs(int* p) {$/;"	f	class:folly::gen::IsCompatibleSignature	access:private	signature:(int* p)
folly::gen::IsCompatibleSignature::value	.\gen\Core-inl.h	/^  static constexpr bool value = false;$/;"	m	class:folly::gen::IsCompatibleSignature	access:private
folly::gen::IsCompatibleSignature::value	.\gen\Core-inl.h	/^  static constexpr bool value = testArgs<Candidate>(nullptr);$/;"	m	class:folly::gen::IsCompatibleSignature	access:public
folly::gen::Less	.\gen\Base.h	/^class Less {$/;"	c	namespace:folly::gen
folly::gen::Less::decltype	.\gen\Base.h	/^  decltype(first < second) {$/;"	f	class:folly::gen::Less	access:public	signature:(first < second) { return first < second; } }; class Greater { public: template<class First, class Second> auto operator()(const First& first, const Second& second) const -> decltype(first > second)
folly::gen::MemberFunction	.\gen\Base.h	/^class MemberFunction {$/;"	c	namespace:folly::gen
folly::gen::MemberFunction::MemberFunction	.\gen\Base.h	/^  explicit MemberFunction(MemberPtr member)$/;"	f	class:folly::gen::MemberFunction	access:public	signature:(MemberPtr member)
folly::gen::MemberFunction::MemberPtr	.\gen\Base.h	/^  typedef Result (Class::*MemberPtr)();$/;"	t	class:folly::gen::MemberFunction	access:public
folly::gen::MemberFunction::member_	.\gen\Base.h	/^  MemberPtr member_;$/;"	m	class:folly::gen::MemberFunction	access:private
folly::gen::MemberFunction::operator ()	.\gen\Base.h	/^  Result operator()(Class& x) const {$/;"	f	class:folly::gen::MemberFunction	access:public	signature:(Class& x) const
folly::gen::MemberFunction::operator ()	.\gen\Base.h	/^  Result operator()(Class&& x) const {$/;"	f	class:folly::gen::MemberFunction	access:public	signature:(Class&& x) const
folly::gen::MemberFunction::operator ()	.\gen\Base.h	/^  Result operator()(Class* x) const {$/;"	f	class:folly::gen::MemberFunction	access:public	signature:(Class* x) const
folly::gen::MemberType	.\gen\Base.h	/^enum MemberType {$/;"	g	namespace:folly::gen
folly::gen::MixedNewlines	.\gen\String.h	/^class MixedNewlines {};$/;"	c	namespace:folly::gen
folly::gen::Move	.\gen\Base.h	/^class Move {$/;"	c	namespace:folly::gen
folly::gen::Move::move	.\gen\Base.h	/^  decltype(std::move(std::forward<Value>(value))) {$/;"	f	class:folly::gen::Move	access:public	signature:(std::forward<Value>(
folly::gen::Mutable	.\gen\Base.h	/^  Mutable$/;"	e	enum:folly::gen::MemberType
folly::gen::Operator	.\gen\Core-inl.h	/^class Operator : public FBounded<Self> {$/;"	c	namespace:folly::gen	inherits:FBounded
folly::gen::Operator	.\gen\Core.h	/^class Operator;$/;"	x
folly::gen::Operator::Operator	.\gen\Core-inl.h	/^  Operator() = default;$/;"	p	class:folly::gen::Operator	access:protected	signature:()
folly::gen::Operator::Operator	.\gen\Core-inl.h	/^  Operator(const Operator&) = default;$/;"	p	class:folly::gen::Operator	access:protected	signature:(const Operator&)
folly::gen::Operator::compose	.\gen\Core-inl.h	/^  ResultGen compose(const GenImpl<Value, Source>& source) const;$/;"	p	class:folly::gen::Operator	access:public	signature:(const GenImpl<Value, Source>& source) const
folly::gen::Operator::noexcept	.\gen\Core-inl.h	/^  Operator& operator=(Operator&&) noexcept = default;$/;"	m	class:folly::gen::Operator	access:protected
folly::gen::Operator::noexcept	.\gen\Core-inl.h	/^  Operator(Operator&&) noexcept = default;$/;"	m	class:folly::gen::Operator	access:protected
folly::gen::Operator::operator =	.\gen\Core-inl.h	/^  Operator& operator=(const Operator&) = default;$/;"	p	class:folly::gen::Operator	access:protected	signature:(const Operator&)
folly::gen::Return	.\gen\Base.h	/^member(Return (Class::*member)() const) {$/;"	f	namespace:folly::gen	signature:(Class::*member) const
folly::gen::Return	.\gen\Base.h	/^member(Return (Class::*member)()) {$/;"	f	namespace:folly::gen	signature:(Class::*member)
folly::gen::StreamSplitter	.\gen\String.h	/^class StreamSplitter {$/;"	c	namespace:folly::gen
folly::gen::StreamSplitter::StreamSplitter	.\gen\String.h	/^  StreamSplitter(char delimiter,$/;"	f	class:folly::gen::StreamSplitter	access:public	signature:(char delimiter, Callback&& pieceCb, uint64_t maxLength = 0, uint64_t initialCapacity = 0)
folly::gen::StreamSplitter::buffer_	.\gen\String.h	/^  IOBuf buffer_;$/;"	m	class:folly::gen::StreamSplitter	access:private
folly::gen::StreamSplitter::delimiter_	.\gen\String.h	/^  char delimiter_;$/;"	m	class:folly::gen::StreamSplitter	access:private
folly::gen::StreamSplitter::flush	.\gen\String-inl.h	/^bool StreamSplitter<Callback>::flush() {$/;"	f	class:folly::gen::StreamSplitter	signature:()
folly::gen::StreamSplitter::flush	.\gen\String.h	/^  bool flush();$/;"	p	class:folly::gen::StreamSplitter	access:public	signature:()
folly::gen::StreamSplitter::maxLength_	.\gen\String.h	/^  uint64_t maxLength_;  \/\/ The callback never gets more chars than this$/;"	m	class:folly::gen::StreamSplitter	access:private
folly::gen::StreamSplitter::operator ()	.\gen\String-inl.h	/^bool StreamSplitter<Callback>::operator()(StringPiece in) {$/;"	f	class:folly::gen::StreamSplitter	signature:(StringPiece in)
folly::gen::StreamSplitter::operator ()	.\gen\String.h	/^  bool operator()(StringPiece in);$/;"	p	class:folly::gen::StreamSplitter	access:public	signature:(StringPiece in)
folly::gen::StreamSplitter::pieceCb_	.\gen\String.h	/^  Callback pieceCb_;$/;"	m	class:folly::gen::StreamSplitter	access:private
folly::gen::To	.\gen\Base.h	/^class To {$/;"	c	namespace:folly::gen
folly::gen::To	.\gen\Base.h	/^class To<StringPiece> {$/;"	c	namespace:folly::gen
folly::gen::To::operator ()	.\gen\Base.h	/^  Dest operator()(Value&& value) const {$/;"	f	class:folly::gen::To	access:public	signature:(Value&& value) const
folly::gen::To::operator ()	.\gen\Base.h	/^  StringPiece operator()(StringPiece src) const {$/;"	f	class:folly::gen::To	access:public	signature:(StringPiece src) const
folly::gen::VirtualGen	.\gen\Base-inl.h	/^class VirtualGen : public GenImpl<Value, VirtualGen<Value>> {$/;"	c	namespace:folly::gen	inherits:GenImpl
folly::gen::VirtualGen	.\gen\Base.h	/^class VirtualGen;$/;"	x
folly::gen::VirtualGen::VirtualGen	.\gen\Base-inl.h	/^  VirtualGen(const VirtualGen& source)$/;"	f	class:folly::gen::VirtualGen	access:public	signature:(const VirtualGen& source)
folly::gen::VirtualGen::VirtualGen	.\gen\Base-inl.h	/^  \/* implicit *\/ VirtualGen(Self source)$/;"	f	class:folly::gen::VirtualGen	access:public	signature:(Self source)
folly::gen::VirtualGen::WrapperBase	.\gen\Base-inl.h	/^  class WrapperBase {$/;"	c	class:folly::gen::VirtualGen	access:private
folly::gen::VirtualGen::WrapperBase::apply	.\gen\Base-inl.h	/^    virtual bool apply(const std::function<bool(Value)>& handler) const = 0;$/;"	p	class:folly::gen::VirtualGen::WrapperBase	access:public	signature:(const std::function<bool(Value)>& handler) const
folly::gen::VirtualGen::WrapperBase::clone	.\gen\Base-inl.h	/^    virtual std::unique_ptr<const WrapperBase> clone() const = 0;$/;"	p	class:folly::gen::VirtualGen::WrapperBase	access:public	signature:() const
folly::gen::VirtualGen::WrapperBase::foreach	.\gen\Base-inl.h	/^    virtual void foreach(const std::function<void(Value)>& body) const = 0;$/;"	p	class:folly::gen::VirtualGen::WrapperBase	access:public	signature:(const std::function<void(Value)>& body) const
folly::gen::VirtualGen::WrapperImpl	.\gen\Base-inl.h	/^  class WrapperImpl : public WrapperBase {$/;"	c	class:folly::gen::VirtualGen	inherits:WrapperBase	access:private
folly::gen::VirtualGen::WrapperImpl::WrapperImpl	.\gen\Base-inl.h	/^    explicit WrapperImpl(Wrapped wrapped)$/;"	f	class:folly::gen::VirtualGen::WrapperImpl	access:public	signature:(Wrapped wrapped)
folly::gen::VirtualGen::WrapperImpl::apply	.\gen\Base-inl.h	/^    virtual bool apply(const std::function<bool(Value)>& handler) const {$/;"	f	class:folly::gen::VirtualGen::WrapperImpl	access:public	signature:(const std::function<bool(Value)>& handler) const
folly::gen::VirtualGen::WrapperImpl::clone	.\gen\Base-inl.h	/^    virtual std::unique_ptr<const WrapperBase> clone() const {$/;"	f	class:folly::gen::VirtualGen::WrapperImpl	access:public	signature:() const
folly::gen::VirtualGen::WrapperImpl::foreach	.\gen\Base-inl.h	/^    virtual void foreach(const std::function<void(Value)>& body) const {$/;"	f	class:folly::gen::VirtualGen::WrapperImpl	access:public	signature:(const std::function<void(Value)>& body) const
folly::gen::VirtualGen::WrapperImpl::wrapped_	.\gen\Base-inl.h	/^    Wrapped wrapped_;$/;"	m	class:folly::gen::VirtualGen::WrapperImpl	access:private
folly::gen::VirtualGen::apply	.\gen\Base-inl.h	/^  bool apply(const std::function<bool(Value)>& handler) const {$/;"	f	class:folly::gen::VirtualGen	access:public	signature:(const std::function<bool(Value)>& handler) const
folly::gen::VirtualGen::foreach	.\gen\Base-inl.h	/^  void foreach(const std::function<void(Value)>& body) const {$/;"	f	class:folly::gen::VirtualGen	access:public	signature:(const std::function<void(Value)>& body) const
folly::gen::VirtualGen::move	.\gen\Base-inl.h	/^      : wrapper_(std::move(source.wrapper_)) {}$/;"	f	class:folly::gen::VirtualGen	access:public	signature:(source.wrapper_)
folly::gen::VirtualGen::operator =	.\gen\Base-inl.h	/^  VirtualGen& operator=(const VirtualGen& source) {$/;"	f	class:folly::gen::VirtualGen	access:public	signature:(const VirtualGen& source)
folly::gen::VirtualGen::wrapper_	.\gen\Base-inl.h	/^  std::unique_ptr<const WrapperBase> wrapper_;$/;"	m	class:folly::gen::VirtualGen	access:private
folly::gen::all	.\gen\Base.h	/^All all(Predicate pred = Predicate()) {$/;"	f	namespace:folly::gen	signature:(Predicate pred = Predicate())
folly::gen::any	.\gen\Base-inl.h	/^static const detail::Any any;$/;"	m	namespace:folly::gen
folly::gen::appendTo	.\gen\Base.h	/^Append appendTo(Collection& collection) {$/;"	f	namespace:folly::gen	signature:(Collection& collection)
folly::gen::as	.\gen\Base.h	/^Collect as() {$/;"	f	namespace:folly::gen	signature:()
folly::gen::assert_type	.\gen\Base.h	/^detail::TypeAssertion<Value> assert_type() {$/;"	f	namespace:folly::gen	signature:()
folly::gen::batch	.\gen\Base-inl.h	/^inline detail::Batch batch(size_t batchSize) {$/;"	f	namespace:folly::gen	signature:(size_t batchSize)
folly::gen::chunked	.\gen\Parallel.h	/^Chunked chunked(Container& container, int chunkSize = 256) {$/;"	f	namespace:folly::gen	signature:(Container& container, int chunkSize = 256)
folly::gen::chunked	.\gen\Parallel.h	/^Chunked chunked(const Container& container, int chunkSize = 256) {$/;"	f	namespace:folly::gen	signature:(const Container& container, int chunkSize = 256)
folly::gen::concat	.\gen\Base-inl.h	/^static const detail::Concat concat;$/;"	m	namespace:folly::gen
folly::gen::contains	.\gen\Base.h	/^Contains contains(Needle&& needle) {$/;"	f	namespace:folly::gen	signature:(Needle&& needle)
folly::gen::count	.\gen\Base-inl.h	/^static const detail::Count count;$/;"	m	namespace:folly::gen
folly::gen::cycle	.\gen\Base-inl.h	/^static const detail::Cycle cycle;$/;"	m	namespace:folly::gen
folly::gen::decltype	.\gen\Core-inl.h	/^decltype(op.self().compose(gen.self())) {$/;"	f	namespace:folly::gen	signature:(op.self().compose(gen.self()))
folly::gen::decltype	.\gen\Core-inl.h	/^decltype(op.self().compose(std::move(gen.self()))) {$/;"	f	namespace:folly::gen	signature:(op.self().compose(std::move(gen.self())))
folly::gen::dereference	.\gen\Base-inl.h	/^static const detail::Dereference dereference;$/;"	m	namespace:folly::gen
folly::gen::detail	.\gen\Base-inl.h	/^namespace detail {$/;"	n	namespace:folly::gen
folly::gen::detail	.\gen\Base.h	/^namespace detail {$/;"	n	namespace:folly::gen
folly::gen::detail	.\gen\Combine-inl.h	/^namespace detail {$/;"	n	namespace:folly::gen
folly::gen::detail	.\gen\Combine.h	/^namespace detail {$/;"	n	namespace:folly::gen
folly::gen::detail	.\gen\Core-inl.h	/^namespace detail {$/;"	n	namespace:folly::gen
folly::gen::detail	.\gen\Core.h	/^namespace detail {$/;"	n	namespace:folly::gen
folly::gen::detail	.\gen\File-inl.h	/^namespace detail {$/;"	n	namespace:folly::gen
folly::gen::detail	.\gen\File.h	/^namespace detail {$/;"	n	namespace:folly::gen
folly::gen::detail	.\gen\Parallel-inl.h	/^namespace detail {$/;"	n	namespace:folly::gen
folly::gen::detail	.\gen\Parallel.h	/^namespace detail {$/;"	n	namespace:folly::gen
folly::gen::detail	.\gen\ParallelMap-inl.h	/^namespace folly { namespace gen { namespace detail {$/;"	n	namespace:folly::gen
folly::gen::detail	.\gen\ParallelMap.h	/^namespace detail {$/;"	n	namespace:folly::gen
folly::gen::detail	.\gen\String-inl.h	/^namespace detail {$/;"	n	namespace:folly::gen
folly::gen::detail	.\gen\String.h	/^namespace detail {$/;"	n	namespace:folly::gen
folly::gen::detail::All	.\gen\Base-inl.h	/^class All : public Operator<All<Predicate>> {$/;"	c	namespace:folly::gen::detail	inherits:Operator
folly::gen::detail::All	.\gen\Base.h	/^class All;$/;"	x
folly::gen::detail::All::All	.\gen\Base-inl.h	/^  All() {}$/;"	f	class:folly::gen::detail::All	access:public	signature:()
folly::gen::detail::All::All	.\gen\Base-inl.h	/^  explicit All(Predicate pred)$/;"	f	class:folly::gen::detail::All	access:public	signature:(Predicate pred)
folly::gen::detail::All::compose	.\gen\Base-inl.h	/^  bool compose(const GenImpl<Value, Source>& source) const {$/;"	f	class:folly::gen::detail::All	access:public	signature:(const GenImpl<Value, Source>& source) const
folly::gen::detail::All::pred_	.\gen\Base-inl.h	/^  Predicate pred_;$/;"	m	class:folly::gen::detail::All	access:private
folly::gen::detail::Any	.\gen\Base-inl.h	/^class Any : public Operator<Any> {$/;"	c	namespace:folly::gen::detail	inherits:Operator
folly::gen::detail::Any	.\gen\Base.h	/^class Any;$/;"	x
folly::gen::detail::Any::Any	.\gen\Base-inl.h	/^  Any() { }$/;"	f	class:folly::gen::detail::Any	access:public	signature:()
folly::gen::detail::Any::compose	.\gen\Base-inl.h	/^  bool compose(const GenImpl<Value, Source>& source) const {$/;"	f	class:folly::gen::detail::Any	access:public	signature:(const GenImpl<Value, Source>& source) const
folly::gen::detail::Any::operator ()	.\gen\Base-inl.h	/^  Composed operator()(Predicate pred) const {$/;"	f	class:folly::gen::detail::Any	access:public	signature:(Predicate pred) const
folly::gen::detail::Append	.\gen\Base-inl.h	/^class Append : public Operator<Append<Collection>> {$/;"	c	namespace:folly::gen::detail	inherits:Operator
folly::gen::detail::Append	.\gen\Base.h	/^class Append;$/;"	x
folly::gen::detail::Append::Append	.\gen\Base-inl.h	/^  explicit Append(Collection* collection)$/;"	f	class:folly::gen::detail::Append	access:public	signature:(Collection* collection)
folly::gen::detail::Append::collection_	.\gen\Base-inl.h	/^  Collection* collection_;$/;"	m	class:folly::gen::detail::Append	access:private
folly::gen::detail::Append::compose	.\gen\Base-inl.h	/^  Collection& compose(const GenImpl<Value, Source>& source) const {$/;"	f	class:folly::gen::detail::Append	access:public	signature:(const GenImpl<Value, Source>& source) const
folly::gen::detail::Batch	.\gen\Base-inl.h	/^class Batch : public Operator<Batch> {$/;"	c	namespace:folly::gen::detail	inherits:Operator
folly::gen::detail::Batch	.\gen\Base.h	/^class Batch;$/;"	x
folly::gen::detail::Batch::Batch	.\gen\Base-inl.h	/^  explicit Batch(size_t batchSize)$/;"	f	class:folly::gen::detail::Batch	access:public	signature:(size_t batchSize)
folly::gen::detail::Batch::Generator	.\gen\Base-inl.h	/^  class Generator :$/;"	c	class:folly::gen::detail::Batch	inherits:GenImpl	access:public
folly::gen::detail::Batch::Generator::Generator	.\gen\Base-inl.h	/^    explicit Generator(Source source, size_t batchSize)$/;"	f	class:folly::gen::detail::Batch::Generator	access:public	signature:(Source source, size_t batchSize)
folly::gen::detail::Batch::Generator::apply	.\gen\Base-inl.h	/^    bool apply(Handler&& handler) const {$/;"	f	class:folly::gen::detail::Batch::Generator	access:public	signature:(Handler&& handler) const
folly::gen::detail::Batch::Generator::batchSize_	.\gen\Base-inl.h	/^    size_t batchSize_;$/;"	m	class:folly::gen::detail::Batch::Generator	access:private
folly::gen::detail::Batch::Generator::infinite	.\gen\Base-inl.h	/^    static constexpr bool infinite = Source::infinite;$/;"	m	class:folly::gen::detail::Batch::Generator	access:public
folly::gen::detail::Batch::Generator::source_	.\gen\Base-inl.h	/^    Source source_;$/;"	m	class:folly::gen::detail::Batch::Generator	access:private
folly::gen::detail::Batch::batchSize_	.\gen\Base-inl.h	/^  size_t batchSize_;$/;"	m	class:folly::gen::detail::Batch	access:private
folly::gen::detail::Batch::compose	.\gen\Base-inl.h	/^  Gen compose(GenImpl<Value, Source>&& source) const {$/;"	f	class:folly::gen::detail::Batch	access:public	signature:(GenImpl<Value, Source>&& source) const
folly::gen::detail::Batch::compose	.\gen\Base-inl.h	/^  Gen compose(const GenImpl<Value, Source>& source) const {$/;"	f	class:folly::gen::detail::Batch	access:public	signature:(const GenImpl<Value, Source>& source) const
folly::gen::detail::Chain	.\gen\Core-inl.h	/^class Chain : public GenImpl<Value,$/;"	c	namespace:folly::gen::detail	inherits:GenImpl
folly::gen::detail::Chain	.\gen\Core.h	/^class Chain;$/;"	x
folly::gen::detail::Chain::Chain	.\gen\Core-inl.h	/^  explicit Chain(First first, Second second)$/;"	f	class:folly::gen::detail::Chain	access:public	signature:(First first, Second second)
folly::gen::detail::Chain::apply	.\gen\Core-inl.h	/^  bool apply(Handler&& handler) const {$/;"	f	class:folly::gen::detail::Chain	access:public	signature:(Handler&& handler) const
folly::gen::detail::Chain::first_	.\gen\Core-inl.h	/^  First first_;$/;"	m	class:folly::gen::detail::Chain	access:private
folly::gen::detail::Chain::foreach	.\gen\Core-inl.h	/^  void foreach(Body&& body) const {$/;"	f	class:folly::gen::detail::Chain	access:public	signature:(Body&& body) const
folly::gen::detail::Chain::infinite	.\gen\Core-inl.h	/^  static constexpr bool infinite = First::infinite || Second::infinite;$/;"	m	class:folly::gen::detail::Chain	access:public
folly::gen::detail::Chain::second_	.\gen\Core-inl.h	/^  Second second_;$/;"	m	class:folly::gen::detail::Chain	access:private
folly::gen::detail::ChunkedRangeSource	.\gen\Parallel-inl.h	/^class ChunkedRangeSource$/;"	c	namespace:folly::gen::detail	inherits:GenImpl
folly::gen::detail::ChunkedRangeSource	.\gen\Parallel.h	/^class ChunkedRangeSource;$/;"	x
folly::gen::detail::ChunkedRangeSource::ChunkedRangeSource	.\gen\Parallel-inl.h	/^  ChunkedRangeSource() {}$/;"	f	class:folly::gen::detail::ChunkedRangeSource	access:public	signature:()
folly::gen::detail::ChunkedRangeSource::ChunkedRangeSource	.\gen\Parallel-inl.h	/^  ChunkedRangeSource(int chunkSize, Range<Iterator> range)$/;"	f	class:folly::gen::detail::ChunkedRangeSource	access:public	signature:(int chunkSize, Range<Iterator> range)
folly::gen::detail::ChunkedRangeSource::apply	.\gen\Parallel-inl.h	/^  bool apply(Handler&& handler) const {$/;"	f	class:folly::gen::detail::ChunkedRangeSource	access:public	signature:(Handler&& handler) const
folly::gen::detail::ChunkedRangeSource::chunkSize_	.\gen\Parallel-inl.h	/^  int chunkSize_;$/;"	m	class:folly::gen::detail::ChunkedRangeSource	access:private
folly::gen::detail::ChunkedRangeSource::range_	.\gen\Parallel-inl.h	/^  Range<Iterator> range_;$/;"	m	class:folly::gen::detail::ChunkedRangeSource	access:private
folly::gen::detail::ClosableMPMCQueue	.\gen\Parallel-inl.h	/^class ClosableMPMCQueue {$/;"	c	namespace:folly::gen::detail
folly::gen::detail::ClosableMPMCQueue::ClosableMPMCQueue	.\gen\Parallel-inl.h	/^  explicit ClosableMPMCQueue(size_t capacity) : queue_(capacity) {}$/;"	f	class:folly::gen::detail::ClosableMPMCQueue	access:public	signature:(size_t capacity)
folly::gen::detail::ClosableMPMCQueue::closeInputProducer	.\gen\Parallel-inl.h	/^  void closeInputProducer() {$/;"	f	class:folly::gen::detail::ClosableMPMCQueue	access:public	signature:()
folly::gen::detail::ClosableMPMCQueue::closeOutputConsumer	.\gen\Parallel-inl.h	/^  void closeOutputConsumer() {$/;"	f	class:folly::gen::detail::ClosableMPMCQueue	access:public	signature:()
folly::gen::detail::ClosableMPMCQueue::consumers	.\gen\Parallel-inl.h	/^  size_t consumers() const {$/;"	f	class:folly::gen::detail::ClosableMPMCQueue	access:public	signature:() const
folly::gen::detail::ClosableMPMCQueue::openConsumer	.\gen\Parallel-inl.h	/^  void openConsumer() { ++consumers_; }$/;"	f	class:folly::gen::detail::ClosableMPMCQueue	access:public	signature:()
folly::gen::detail::ClosableMPMCQueue::openProducer	.\gen\Parallel-inl.h	/^  void openProducer() { ++producers_; }$/;"	f	class:folly::gen::detail::ClosableMPMCQueue	access:public	signature:()
folly::gen::detail::ClosableMPMCQueue::producers	.\gen\Parallel-inl.h	/^  size_t producers() const {$/;"	f	class:folly::gen::detail::ClosableMPMCQueue	access:public	signature:() const
folly::gen::detail::ClosableMPMCQueue::queue_	.\gen\Parallel-inl.h	/^  MPMCQueue<T> queue_;$/;"	m	class:folly::gen::detail::ClosableMPMCQueue	access:private
folly::gen::detail::ClosableMPMCQueue::readUnlessClosed	.\gen\Parallel-inl.h	/^  bool readUnlessClosed(T& out) {$/;"	f	class:folly::gen::detail::ClosableMPMCQueue	access:public	signature:(T& out)
folly::gen::detail::ClosableMPMCQueue::readUnlessEmpty	.\gen\Parallel-inl.h	/^  bool readUnlessEmpty(T& out) {$/;"	f	class:folly::gen::detail::ClosableMPMCQueue	access:public	signature:(T& out)
folly::gen::detail::ClosableMPMCQueue::wakeConsumer_	.\gen\Parallel-inl.h	/^  folly::EventCount wakeConsumer_;$/;"	m	class:folly::gen::detail::ClosableMPMCQueue	access:private
folly::gen::detail::ClosableMPMCQueue::wakeProducer_	.\gen\Parallel-inl.h	/^  folly::EventCount wakeProducer_;$/;"	m	class:folly::gen::detail::ClosableMPMCQueue	access:private
folly::gen::detail::ClosableMPMCQueue::writeUnlessClosed	.\gen\Parallel-inl.h	/^  bool writeUnlessClosed(Args&&... args) {$/;"	f	class:folly::gen::detail::ClosableMPMCQueue	access:public	signature:(Args&&.... args)
folly::gen::detail::ClosableMPMCQueue::~ClosableMPMCQueue	.\gen\Parallel-inl.h	/^  ~ClosableMPMCQueue() {$/;"	f	class:folly::gen::detail::ClosableMPMCQueue	access:public	signature:()
folly::gen::detail::Collect	.\gen\Base-inl.h	/^class Collect : public Operator<Collect<Collection>> {$/;"	c	namespace:folly::gen::detail	inherits:Operator
folly::gen::detail::Collect	.\gen\Base.h	/^class Collect;$/;"	x
folly::gen::detail::Collect::Collect	.\gen\Base-inl.h	/^  Collect() { }$/;"	f	class:folly::gen::detail::Collect	access:public	signature:()
folly::gen::detail::Collect::compose	.\gen\Base-inl.h	/^  Collection compose(const GenImpl<Value, Source>& source) const {$/;"	f	class:folly::gen::detail::Collect	access:public	signature:(const GenImpl<Value, Source>& source) const
folly::gen::detail::CollectTemplate	.\gen\Base-inl.h	/^class CollectTemplate : public Operator<CollectTemplate<Container, Allocator>> {$/;"	c	namespace:folly::gen::detail	inherits:Operator
folly::gen::detail::CollectTemplate	.\gen\Base.h	/^class CollectTemplate;$/;"	x
folly::gen::detail::CollectTemplate::CollectTemplate	.\gen\Base-inl.h	/^  CollectTemplate() { }$/;"	f	class:folly::gen::detail::CollectTemplate	access:public	signature:()
folly::gen::detail::CollectTemplate::compose	.\gen\Base-inl.h	/^  Collection compose(const GenImpl<Value, Source>& source) const {$/;"	f	class:folly::gen::detail::CollectTemplate	access:public	signature:(const GenImpl<Value, Source>& source) const
folly::gen::detail::Composed	.\gen\Core-inl.h	/^class Composed : public Operator<Composed<First, Second>> {$/;"	c	namespace:folly::gen::detail	inherits:Operator
folly::gen::detail::Composed	.\gen\Core.h	/^class Composed;$/;"	x
folly::gen::detail::Composed::Composed	.\gen\Core-inl.h	/^  Composed() {}$/;"	f	class:folly::gen::detail::Composed	access:public	signature:()
folly::gen::detail::Composed::Composed	.\gen\Core-inl.h	/^  Composed(First first, Second second)$/;"	f	class:folly::gen::detail::Composed	access:public	signature:(First first, Second second)
folly::gen::detail::Composed::compose	.\gen\Core-inl.h	/^  SecondRet compose(GenImpl<Value, Source>&& source) const {$/;"	f	class:folly::gen::detail::Composed	access:public	signature:(GenImpl<Value, Source>&& source) const
folly::gen::detail::Composed::compose	.\gen\Core-inl.h	/^  SecondRet compose(const GenImpl<Value, Source>& source) const {$/;"	f	class:folly::gen::detail::Composed	access:public	signature:(const GenImpl<Value, Source>& source) const
folly::gen::detail::Composed::first_	.\gen\Core-inl.h	/^  First first_;$/;"	m	class:folly::gen::detail::Composed	access:private
folly::gen::detail::Composed::second_	.\gen\Core-inl.h	/^  Second second_;$/;"	m	class:folly::gen::detail::Composed	access:private
folly::gen::detail::Composer	.\gen\Base-inl.h	/^class Composer {$/;"	c	namespace:folly::gen::detail
folly::gen::detail::Composer	.\gen\Base.h	/^class Composer;$/;"	x
folly::gen::detail::Composer::Composer	.\gen\Base-inl.h	/^  explicit Composer(Operators op)$/;"	f	class:folly::gen::detail::Composer	access:public	signature:(Operators op)
folly::gen::detail::Composer::op_	.\gen\Base-inl.h	/^  Operators op_;$/;"	m	class:folly::gen::detail::Composer	access:private
folly::gen::detail::Composer::operator ()	.\gen\Base-inl.h	/^  Ret operator()(Source&& source) const {$/;"	f	class:folly::gen::detail::Composer	access:public	signature:(Source&& source) const
folly::gen::detail::Concat	.\gen\Base-inl.h	/^class Concat : public Operator<Concat> {$/;"	c	namespace:folly::gen::detail	inherits:Operator
folly::gen::detail::Concat	.\gen\Base.h	/^class Concat;$/;"	x
folly::gen::detail::Concat::Concat	.\gen\Base-inl.h	/^  Concat() { }$/;"	f	class:folly::gen::detail::Concat	access:public	signature:()
folly::gen::detail::Concat::Generator	.\gen\Base-inl.h	/^  class Generator :$/;"	c	class:folly::gen::detail::Concat	inherits:GenImpl	access:public
folly::gen::detail::Concat::Generator::Generator	.\gen\Base-inl.h	/^    explicit Generator(Source source)$/;"	f	class:folly::gen::detail::Concat::Generator	access:public	signature:(Source source)
folly::gen::detail::Concat::Generator::apply	.\gen\Base-inl.h	/^    bool apply(Handler&& handler) const {$/;"	f	class:folly::gen::detail::Concat::Generator	access:public	signature:(Handler&& handler) const
folly::gen::detail::Concat::Generator::foreach	.\gen\Base-inl.h	/^    void foreach(Body&& body) const {$/;"	f	class:folly::gen::detail::Concat::Generator	access:public	signature:(Body&& body) const
folly::gen::detail::Concat::Generator::infinite	.\gen\Base-inl.h	/^    static constexpr bool infinite = Source::infinite;$/;"	m	class:folly::gen::detail::Concat::Generator	access:public
folly::gen::detail::Concat::Generator::source_	.\gen\Base-inl.h	/^    Source source_;$/;"	m	class:folly::gen::detail::Concat::Generator	access:private
folly::gen::detail::Concat::compose	.\gen\Base-inl.h	/^  Gen compose(GenImpl<Value, Source>&& source) const {$/;"	f	class:folly::gen::detail::Concat	access:public	signature:(GenImpl<Value, Source>&& source) const
folly::gen::detail::Concat::compose	.\gen\Base-inl.h	/^  Gen compose(const GenImpl<Value, Source>& source) const {$/;"	f	class:folly::gen::detail::Concat	access:public	signature:(const GenImpl<Value, Source>& source) const
folly::gen::detail::Contains	.\gen\Base-inl.h	/^class Contains : public Operator<Contains<Needle>> {$/;"	c	namespace:folly::gen::detail	inherits:Operator
folly::gen::detail::Contains	.\gen\Base.h	/^class Contains;$/;"	x
folly::gen::detail::Contains::Contains	.\gen\Base-inl.h	/^  explicit Contains(Needle needle)$/;"	f	class:folly::gen::detail::Contains	access:public	signature:(Needle needle)
folly::gen::detail::Contains::compose	.\gen\Base-inl.h	/^  bool compose(const GenImpl<Value, Source>& source) const {$/;"	f	class:folly::gen::detail::Contains	access:public	signature:(const GenImpl<Value, Source>& source) const
folly::gen::detail::Contains::needle_	.\gen\Base-inl.h	/^  Needle needle_;$/;"	m	class:folly::gen::detail::Contains	access:private
folly::gen::detail::CopiedSource	.\gen\Base-inl.h	/^class CopiedSource :$/;"	c	namespace:folly::gen::detail	inherits:GenImpl
folly::gen::detail::CopiedSource	.\gen\Base.h	/^class CopiedSource;$/;"	x
folly::gen::detail::CopiedSource::ContainerType	.\gen\Base-inl.h	/^  typedef Container ContainerType;$/;"	t	class:folly::gen::detail::CopiedSource	access:public
folly::gen::detail::CopiedSource::CopiedSource	.\gen\Base-inl.h	/^  CopiedSource(const CopiedSource<StorageType, Container>& source)$/;"	f	class:folly::gen::detail::CopiedSource	access:public	signature:(const CopiedSource<StorageType, Container>& source)
folly::gen::detail::CopiedSource::CopiedSource	.\gen\Base-inl.h	/^  explicit CopiedSource(Container&& container) :$/;"	f	class:folly::gen::detail::CopiedSource	access:public	signature:(Container&& container)
folly::gen::detail::CopiedSource::CopiedSource	.\gen\Base-inl.h	/^  explicit CopiedSource(const SourceContainer& container)$/;"	f	class:folly::gen::detail::CopiedSource	access:public	signature:(const SourceContainer& container)
folly::gen::detail::CopiedSource::apply	.\gen\Base-inl.h	/^  bool apply(Handler&& handler) const {$/;"	f	class:folly::gen::detail::CopiedSource	access:public	signature:(Handler&& handler) const
folly::gen::detail::CopiedSource::copy_	.\gen\Base-inl.h	/^  std::shared_ptr<const Container> copy_;$/;"	m	class:folly::gen::detail::CopiedSource	access:public
folly::gen::detail::CopiedSource::foreach	.\gen\Base-inl.h	/^  void foreach(Body&& body) const {$/;"	f	class:folly::gen::detail::CopiedSource	access:public	signature:(Body&& body) const
folly::gen::detail::Count	.\gen\Base-inl.h	/^class Count : public Operator<Count> {$/;"	c	namespace:folly::gen::detail	inherits:Operator
folly::gen::detail::Count::Count	.\gen\Base-inl.h	/^  Count() { }$/;"	f	class:folly::gen::detail::Count	access:public	signature:()
folly::gen::detail::Count::compose	.\gen\Base-inl.h	/^  size_t compose(const GenImpl<Value, Source>& source) const {$/;"	f	class:folly::gen::detail::Count	access:public	signature:(const GenImpl<Value, Source>& source) const
folly::gen::detail::Cycle	.\gen\Base-inl.h	/^class Cycle : public Operator<Cycle> {$/;"	c	namespace:folly::gen::detail	inherits:Operator
folly::gen::detail::Cycle	.\gen\Base.h	/^class Cycle;$/;"	x
folly::gen::detail::Cycle::Cycle	.\gen\Base-inl.h	/^  Cycle()$/;"	f	class:folly::gen::detail::Cycle	access:public	signature:()
folly::gen::detail::Cycle::Cycle	.\gen\Base-inl.h	/^  explicit Cycle(off_t limit)$/;"	f	class:folly::gen::detail::Cycle	access:public	signature:(off_t limit)
folly::gen::detail::Cycle::Generator	.\gen\Base-inl.h	/^  class Generator : public GenImpl<Value, Generator<Value, Source>> {$/;"	c	class:folly::gen::detail::Cycle	inherits:GenImpl	access:public
folly::gen::detail::Cycle::Generator::Generator	.\gen\Base-inl.h	/^    explicit Generator(Source source, off_t limit)$/;"	f	class:folly::gen::detail::Cycle::Generator	access:public	signature:(Source source, off_t limit)
folly::gen::detail::Cycle::Generator::apply	.\gen\Base-inl.h	/^    bool apply(Handler&& handler) const {$/;"	f	class:folly::gen::detail::Cycle::Generator	access:public	signature:(Handler&& handler) const
folly::gen::detail::Cycle::Generator::infinite	.\gen\Base-inl.h	/^    static constexpr bool infinite = Source::infinite;$/;"	m	class:folly::gen::detail::Cycle::Generator	access:public
folly::gen::detail::Cycle::Generator::limit_	.\gen\Base-inl.h	/^    off_t limit_; \/\/ -1 for infinite$/;"	m	class:folly::gen::detail::Cycle::Generator	access:private
folly::gen::detail::Cycle::Generator::source_	.\gen\Base-inl.h	/^    Source source_;$/;"	m	class:folly::gen::detail::Cycle::Generator	access:private
folly::gen::detail::Cycle::compose	.\gen\Base-inl.h	/^  Gen compose(GenImpl<Value, Source>&& source) const {$/;"	f	class:folly::gen::detail::Cycle	access:public	signature:(GenImpl<Value, Source>&& source) const
folly::gen::detail::Cycle::compose	.\gen\Base-inl.h	/^  Gen compose(const GenImpl<Value, Source>& source) const {$/;"	f	class:folly::gen::detail::Cycle	access:public	signature:(const GenImpl<Value, Source>& source) const
folly::gen::detail::Cycle::limit_	.\gen\Base-inl.h	/^  off_t limit_; \/\/ -1 for infinite$/;"	m	class:folly::gen::detail::Cycle	access:private
folly::gen::detail::Cycle::operator ()	.\gen\Base-inl.h	/^  Cycle operator()(off_t limit) const {$/;"	f	class:folly::gen::detail::Cycle	access:public	signature:(off_t limit) const
folly::gen::detail::Dereference	.\gen\Base-inl.h	/^class Dereference : public Operator<Dereference> {$/;"	c	namespace:folly::gen::detail	inherits:Operator
folly::gen::detail::Dereference	.\gen\Base.h	/^class Dereference;$/;"	x
folly::gen::detail::Dereference::Dereference	.\gen\Base-inl.h	/^  Dereference() {}$/;"	f	class:folly::gen::detail::Dereference	access:public	signature:()
folly::gen::detail::Dereference::Generator	.\gen\Base-inl.h	/^  class Generator : public GenImpl<Result, Generator<Value, Source, Result>> {$/;"	c	class:folly::gen::detail::Dereference	inherits:GenImpl	access:public
folly::gen::detail::Dereference::Generator::Generator	.\gen\Base-inl.h	/^    explicit Generator(Source source)$/;"	f	class:folly::gen::detail::Dereference::Generator	access:public	signature:(Source source)
folly::gen::detail::Dereference::Generator::apply	.\gen\Base-inl.h	/^    bool apply(Handler&& handler) const {$/;"	f	class:folly::gen::detail::Dereference::Generator	access:public	signature:(Handler&& handler) const
folly::gen::detail::Dereference::Generator::foreach	.\gen\Base-inl.h	/^    void foreach(Body&& body) const {$/;"	f	class:folly::gen::detail::Dereference::Generator	access:public	signature:(Body&& body) const
folly::gen::detail::Dereference::Generator::infinite	.\gen\Base-inl.h	/^    static constexpr bool infinite = Source::infinite;$/;"	m	class:folly::gen::detail::Dereference::Generator	access:public
folly::gen::detail::Dereference::Generator::source_	.\gen\Base-inl.h	/^    Source source_;$/;"	m	class:folly::gen::detail::Dereference::Generator	access:private
folly::gen::detail::Dereference::compose	.\gen\Base-inl.h	/^  Gen compose(GenImpl<Value, Source>&& source) const {$/;"	f	class:folly::gen::detail::Dereference	access:public	signature:(GenImpl<Value, Source>&& source) const
folly::gen::detail::Dereference::compose	.\gen\Base-inl.h	/^  Gen compose(const GenImpl<Value, Source>& source) const {$/;"	f	class:folly::gen::detail::Dereference	access:public	signature:(const GenImpl<Value, Source>& source) const
folly::gen::detail::Distinct	.\gen\Base-inl.h	/^class Distinct : public Operator<Distinct<Selector>> {$/;"	c	namespace:folly::gen::detail	inherits:Operator
folly::gen::detail::Distinct	.\gen\Base.h	/^class Distinct;$/;"	x
folly::gen::detail::Distinct::Distinct	.\gen\Base-inl.h	/^  Distinct() {}$/;"	f	class:folly::gen::detail::Distinct	access:public	signature:()
folly::gen::detail::Distinct::Distinct	.\gen\Base-inl.h	/^  explicit Distinct(Selector selector)$/;"	f	class:folly::gen::detail::Distinct	access:public	signature:(Selector selector)
folly::gen::detail::Distinct::Generator	.\gen\Base-inl.h	/^  class Generator : public GenImpl<Value, Generator<Value, Source>> {$/;"	c	class:folly::gen::detail::Distinct	inherits:GenImpl	access:public
folly::gen::detail::Distinct::Generator::Generator	.\gen\Base-inl.h	/^    Generator(Source source,$/;"	f	class:folly::gen::detail::Distinct::Generator	access:public	signature:(Source source, Selector selector)
folly::gen::detail::Distinct::Generator::KeyStorageType	.\gen\Base-inl.h	/^    typedef typename std::decay<KeyType>::type KeyStorageType;$/;"	t	class:folly::gen::detail::Distinct::Generator	access:private
folly::gen::detail::Distinct::Generator::KeyType	.\gen\Base-inl.h	/^    typedef typename std::result_of<Selector(ParamType)>::type KeyType;$/;"	t	class:folly::gen::detail::Distinct::Generator	access:private
folly::gen::detail::Distinct::Generator::ParamType	.\gen\Base-inl.h	/^    typedef const StorageType& ParamType;$/;"	t	class:folly::gen::detail::Distinct::Generator	access:private
folly::gen::detail::Distinct::Generator::StorageType	.\gen\Base-inl.h	/^    typedef typename std::decay<Value>::type StorageType;$/;"	t	class:folly::gen::detail::Distinct::Generator	access:private
folly::gen::detail::Distinct::Generator::apply	.\gen\Base-inl.h	/^    bool apply(Handler&& handler) const {$/;"	f	class:folly::gen::detail::Distinct::Generator	access:public	signature:(Handler&& handler) const
folly::gen::detail::Distinct::Generator::foreach	.\gen\Base-inl.h	/^    void foreach(Body&& body) const {$/;"	f	class:folly::gen::detail::Distinct::Generator	access:public	signature:(Body&& body) const
folly::gen::detail::Distinct::Generator::selector_	.\gen\Base-inl.h	/^    Selector selector_;$/;"	m	class:folly::gen::detail::Distinct::Generator	access:private
folly::gen::detail::Distinct::Generator::source_	.\gen\Base-inl.h	/^    Source source_;$/;"	m	class:folly::gen::detail::Distinct::Generator	access:private
folly::gen::detail::Distinct::compose	.\gen\Base-inl.h	/^  Gen compose(GenImpl<Value, Source>&& source) const {$/;"	f	class:folly::gen::detail::Distinct	access:public	signature:(GenImpl<Value, Source>&& source) const
folly::gen::detail::Distinct::compose	.\gen\Base-inl.h	/^  Gen compose(const GenImpl<Value, Source>& source) const {$/;"	f	class:folly::gen::detail::Distinct	access:public	signature:(const GenImpl<Value, Source>& source) const
folly::gen::detail::Distinct::selector_	.\gen\Base-inl.h	/^  Selector selector_;$/;"	m	class:folly::gen::detail::Distinct	access:private
folly::gen::detail::Empty	.\gen\Base-inl.h	/^class Empty : public GenImpl<Value, Empty<Value>> {$/;"	c	namespace:folly::gen::detail	inherits:GenImpl
folly::gen::detail::Empty	.\gen\Base.h	/^class Empty;$/;"	x
folly::gen::detail::Empty::apply	.\gen\Base-inl.h	/^  bool apply(Handler&&) const {$/;"	f	class:folly::gen::detail::Empty	access:public	signature:(Handler&&) const
folly::gen::detail::Empty::foreach	.\gen\Base-inl.h	/^  void foreach(Body&&) const {}$/;"	f	class:folly::gen::detail::Empty	access:public	signature:(Body&&) const
folly::gen::detail::FBounded	.\gen\Base.h	/^struct FBounded;$/;"	x
folly::gen::detail::FBounded	.\gen\Core.h	/^struct FBounded;$/;"	x
folly::gen::detail::FileReader	.\gen\File-inl.h	/^class FileReader : public GenImpl<ByteRange, FileReader> {$/;"	c	namespace:folly::gen::detail	inherits:GenImpl
folly::gen::detail::FileReader	.\gen\File.h	/^class FileReader;$/;"	x
folly::gen::detail::FileReader::FileReader	.\gen\File-inl.h	/^  FileReader(File file, std::unique_ptr<IOBuf> buffer)$/;"	f	class:folly::gen::detail::FileReader	access:public	signature:(File file, std::unique_ptr<IOBuf> buffer)
folly::gen::detail::FileReader::apply	.\gen\File-inl.h	/^  bool apply(Body&& body) const {$/;"	f	class:folly::gen::detail::FileReader	access:public	signature:(Body&& body) const
folly::gen::detail::FileReader::buffer_	.\gen\File-inl.h	/^  std::unique_ptr<IOBuf> buffer_;$/;"	m	class:folly::gen::detail::FileReader	access:private
folly::gen::detail::FileReader::file_	.\gen\File-inl.h	/^  File file_;$/;"	m	class:folly::gen::detail::FileReader	access:private
folly::gen::detail::FileReader::infinite	.\gen\File-inl.h	/^  static constexpr bool infinite = false;$/;"	m	class:folly::gen::detail::FileReader	access:public
folly::gen::detail::FileWriter	.\gen\File-inl.h	/^class FileWriter : public Operator<FileWriter> {$/;"	c	namespace:folly::gen::detail	inherits:Operator
folly::gen::detail::FileWriter	.\gen\File.h	/^class FileWriter;$/;"	x
folly::gen::detail::FileWriter::FileWriter	.\gen\File-inl.h	/^  FileWriter(File file, std::unique_ptr<IOBuf> buffer)$/;"	f	class:folly::gen::detail::FileWriter	access:public	signature:(File file, std::unique_ptr<IOBuf> buffer)
folly::gen::detail::FileWriter::buffer_	.\gen\File-inl.h	/^  std::unique_ptr<IOBuf> buffer_;$/;"	m	class:folly::gen::detail::FileWriter	access:private
folly::gen::detail::FileWriter::compose	.\gen\File-inl.h	/^  void compose(const GenImpl<Value, Source>& source) const {$/;"	f	class:folly::gen::detail::FileWriter	access:public	signature:(const GenImpl<Value, Source>& source) const
folly::gen::detail::FileWriter::file_	.\gen\File-inl.h	/^  mutable File file_;$/;"	m	class:folly::gen::detail::FileWriter	access:private
folly::gen::detail::FileWriter::flushBuffer	.\gen\File-inl.h	/^  void flushBuffer() const {$/;"	f	class:folly::gen::detail::FileWriter	access:private	signature:() const
folly::gen::detail::FileWriter::write	.\gen\File-inl.h	/^  void write(ByteRange v) const {$/;"	f	class:folly::gen::detail::FileWriter	access:private	signature:(ByteRange v) const
folly::gen::detail::Filter	.\gen\Base-inl.h	/^class Filter : public Operator<Filter<Predicate>> {$/;"	c	namespace:folly::gen::detail	inherits:Operator
folly::gen::detail::Filter	.\gen\Base.h	/^class Filter;$/;"	x
folly::gen::detail::Filter::Filter	.\gen\Base-inl.h	/^  Filter() {}$/;"	f	class:folly::gen::detail::Filter	access:public	signature:()
folly::gen::detail::Filter::Filter	.\gen\Base-inl.h	/^  explicit Filter(Predicate pred)$/;"	f	class:folly::gen::detail::Filter	access:public	signature:(Predicate pred)
folly::gen::detail::Filter::Generator	.\gen\Base-inl.h	/^  class Generator : public GenImpl<Value, Generator<Value, Source>> {$/;"	c	class:folly::gen::detail::Filter	inherits:GenImpl	access:public
folly::gen::detail::Filter::Generator::Generator	.\gen\Base-inl.h	/^    explicit Generator(Source source, const Predicate& pred)$/;"	f	class:folly::gen::detail::Filter::Generator	access:public	signature:(Source source, const Predicate& pred)
folly::gen::detail::Filter::Generator::apply	.\gen\Base-inl.h	/^    bool apply(Handler&& handler) const {$/;"	f	class:folly::gen::detail::Filter::Generator	access:public	signature:(Handler&& handler) const
folly::gen::detail::Filter::Generator::foreach	.\gen\Base-inl.h	/^    void foreach(Body&& body) const {$/;"	f	class:folly::gen::detail::Filter::Generator	access:public	signature:(Body&& body) const
folly::gen::detail::Filter::Generator::infinite	.\gen\Base-inl.h	/^    static constexpr bool infinite = Source::infinite;$/;"	m	class:folly::gen::detail::Filter::Generator	access:public
folly::gen::detail::Filter::Generator::pred_	.\gen\Base-inl.h	/^    Predicate pred_;$/;"	m	class:folly::gen::detail::Filter::Generator	access:private
folly::gen::detail::Filter::Generator::source_	.\gen\Base-inl.h	/^    Source source_;$/;"	m	class:folly::gen::detail::Filter::Generator	access:private
folly::gen::detail::Filter::compose	.\gen\Base-inl.h	/^  Gen compose(GenImpl<Value, Source>&& source) const {$/;"	f	class:folly::gen::detail::Filter	access:public	signature:(GenImpl<Value, Source>&& source) const
folly::gen::detail::Filter::compose	.\gen\Base-inl.h	/^  Gen compose(const GenImpl<Value, Source>& source) const {$/;"	f	class:folly::gen::detail::Filter	access:public	signature:(const GenImpl<Value, Source>& source) const
folly::gen::detail::Filter::pred_	.\gen\Base-inl.h	/^  Predicate pred_;$/;"	m	class:folly::gen::detail::Filter	access:private
folly::gen::detail::First	.\gen\Base-inl.h	/^class First : public Operator<First> {$/;"	c	namespace:folly::gen::detail	inherits:Operator
folly::gen::detail::First	.\gen\Base.h	/^class First;$/;"	x
folly::gen::detail::First::First	.\gen\Base-inl.h	/^  First() { }$/;"	f	class:folly::gen::detail::First	access:public	signature:()
folly::gen::detail::First::compose	.\gen\Base-inl.h	/^  StorageType compose(const GenImpl<Value, Source>& source) const {$/;"	f	class:folly::gen::detail::First	access:public	signature:(const GenImpl<Value, Source>& source) const
folly::gen::detail::FoldLeft	.\gen\Base-inl.h	/^class FoldLeft : public Operator<FoldLeft<Seed, Fold>> {$/;"	c	namespace:folly::gen::detail	inherits:Operator
folly::gen::detail::FoldLeft	.\gen\Base.h	/^class FoldLeft;$/;"	x
folly::gen::detail::FoldLeft::FoldLeft	.\gen\Base-inl.h	/^  FoldLeft() {}$/;"	f	class:folly::gen::detail::FoldLeft	access:public	signature:()
folly::gen::detail::FoldLeft::FoldLeft	.\gen\Base-inl.h	/^  FoldLeft(Seed seed,$/;"	f	class:folly::gen::detail::FoldLeft	access:public	signature:(Seed seed, Fold fold)
folly::gen::detail::FoldLeft::compose	.\gen\Base-inl.h	/^  Seed compose(const GenImpl<Value, Source>& source) const {$/;"	f	class:folly::gen::detail::FoldLeft	access:public	signature:(const GenImpl<Value, Source>& source) const
folly::gen::detail::FoldLeft::fold_	.\gen\Base-inl.h	/^  Fold fold_;$/;"	m	class:folly::gen::detail::FoldLeft	access:private
folly::gen::detail::FoldLeft::seed_	.\gen\Base-inl.h	/^  Seed seed_;$/;"	m	class:folly::gen::detail::FoldLeft	access:private
folly::gen::detail::GeneratorBuilder	.\gen\Base-inl.h	/^struct GeneratorBuilder {$/;"	s	namespace:folly::gen::detail
folly::gen::detail::GeneratorBuilder	.\gen\Base.h	/^struct GeneratorBuilder;$/;"	x
folly::gen::detail::GeneratorBuilder::operator +	.\gen\Base-inl.h	/^  Yield operator+(Source&& source) {$/;"	f	struct:folly::gen::detail::GeneratorBuilder	access:public	signature:(Source&& source)
folly::gen::detail::GuardImpl	.\gen\Base-inl.h	/^class GuardImpl : public Operator<GuardImpl<Exception, ErrorHandler>> {$/;"	c	namespace:folly::gen::detail	inherits:Operator
folly::gen::detail::GuardImpl	.\gen\Base.h	/^class GuardImpl;$/;"	x
folly::gen::detail::GuardImpl::Generator	.\gen\Base-inl.h	/^  class Generator : public GenImpl<Value, Generator<Value, Source>> {$/;"	c	class:folly::gen::detail::GuardImpl	inherits:GenImpl	access:public
folly::gen::detail::GuardImpl::Generator::Generator	.\gen\Base-inl.h	/^    explicit Generator(Source source,$/;"	f	class:folly::gen::detail::GuardImpl::Generator	access:public	signature:(Source source, ErrorHandler handler)
folly::gen::detail::GuardImpl::Generator::apply	.\gen\Base-inl.h	/^    bool apply(Handler&& handler) const {$/;"	f	class:folly::gen::detail::GuardImpl::Generator	access:public	signature:(Handler&& handler) const
folly::gen::detail::GuardImpl::Generator::handler_	.\gen\Base-inl.h	/^    ErrorHandler handler_;$/;"	m	class:folly::gen::detail::GuardImpl::Generator	access:private
folly::gen::detail::GuardImpl::Generator::infinite	.\gen\Base-inl.h	/^    static constexpr bool infinite = Source::infinite;$/;"	m	class:folly::gen::detail::GuardImpl::Generator	access:public
folly::gen::detail::GuardImpl::Generator::source_	.\gen\Base-inl.h	/^    Source source_;$/;"	m	class:folly::gen::detail::GuardImpl::Generator	access:private
folly::gen::detail::GuardImpl::GuardImpl	.\gen\Base-inl.h	/^  explicit GuardImpl(ErrorHandler handler) : handler_(std::move(handler)) {}$/;"	f	class:folly::gen::detail::GuardImpl	access:public	signature:(ErrorHandler handler)
folly::gen::detail::GuardImpl::compose	.\gen\Base-inl.h	/^  Gen compose(GenImpl<Value, Source>&& source) const {$/;"	f	class:folly::gen::detail::GuardImpl	access:public	signature:(GenImpl<Value, Source>&& source) const
folly::gen::detail::GuardImpl::compose	.\gen\Base-inl.h	/^  Gen compose(const GenImpl<Value, Source>& source) const {$/;"	f	class:folly::gen::detail::GuardImpl	access:public	signature:(const GenImpl<Value, Source>& source) const
folly::gen::detail::GuardImpl::handler_	.\gen\Base-inl.h	/^  ErrorHandler handler_;$/;"	m	class:folly::gen::detail::GuardImpl	access:private
folly::gen::detail::InfiniteImpl	.\gen\Base-inl.h	/^class InfiniteImpl {$/;"	c	namespace:folly::gen::detail
folly::gen::detail::InfiniteImpl	.\gen\Base.h	/^class InfiniteImpl;$/;"	x
folly::gen::detail::InfiniteImpl::step	.\gen\Base-inl.h	/^  void step(Value& current) const { ++current; }$/;"	f	class:folly::gen::detail::InfiniteImpl	access:public	signature:(Value& current) const
folly::gen::detail::InfiniteImpl::test	.\gen\Base-inl.h	/^  bool test(const Value& current) const { return true; }$/;"	f	class:folly::gen::detail::InfiniteImpl	access:public	signature:(const Value& current) const
folly::gen::detail::Interleave	.\gen\Combine-inl.h	/^class Interleave : public Operator<Interleave<Container>> {$/;"	c	namespace:folly::gen::detail	inherits:Operator
folly::gen::detail::Interleave	.\gen\Combine.h	/^class Interleave;$/;"	x
folly::gen::detail::Interleave::Generator	.\gen\Combine-inl.h	/^  class Generator : public GenImpl<Value, Generator<Value, Source>> {$/;"	c	class:folly::gen::detail::Interleave	inherits:GenImpl	access:public
folly::gen::detail::Interleave::Generator::ConstRefType	.\gen\Combine-inl.h	/^    typedef const typename Container::value_type& ConstRefType;$/;"	t	class:folly::gen::detail::Interleave::Generator	access:private
folly::gen::detail::Interleave::Generator::Generator	.\gen\Combine-inl.h	/^    explicit Generator(Source source,$/;"	f	class:folly::gen::detail::Interleave::Generator	access:public	signature:(Source source, const std::shared_ptr<const Container> container)
folly::gen::detail::Interleave::Generator::apply	.\gen\Combine-inl.h	/^    bool apply(Handler&& handler) const {$/;"	f	class:folly::gen::detail::Interleave::Generator	access:public	signature:(Handler&& handler) const
folly::gen::detail::Interleave::Generator::container_	.\gen\Combine-inl.h	/^    const std::shared_ptr<const Container> container_;$/;"	m	class:folly::gen::detail::Interleave::Generator	access:private
folly::gen::detail::Interleave::Generator::source_	.\gen\Combine-inl.h	/^    Source source_;$/;"	m	class:folly::gen::detail::Interleave::Generator	access:private
folly::gen::detail::Interleave::Generator::static_assert	.\gen\Combine-inl.h	/^    static_assert(std::is_same<const Value&, ConstRefType>::value,$/;"	p	class:folly::gen::detail::Interleave::Generator	access:private	signature:(std::is_same<const Value&, ConstRefType>::value, )
folly::gen::detail::Interleave::Interleave	.\gen\Combine-inl.h	/^  explicit Interleave(Container container)$/;"	f	class:folly::gen::detail::Interleave	access:public	signature:(Container container)
folly::gen::detail::Interleave::compose	.\gen\Combine-inl.h	/^  Gen compose(GenImpl<Value2, Source>&& source) const {$/;"	f	class:folly::gen::detail::Interleave	access:public	signature:(GenImpl<Value2, Source>&& source) const
folly::gen::detail::Interleave::compose	.\gen\Combine-inl.h	/^  Gen compose(const GenImpl<Value2, Source>& source) const {$/;"	f	class:folly::gen::detail::Interleave	access:public	signature:(const GenImpl<Value2, Source>& source) const
folly::gen::detail::Interleave::container_	.\gen\Combine-inl.h	/^  const std::shared_ptr<const Container> container_;$/;"	m	class:folly::gen::detail::Interleave	access:private
folly::gen::detail::Just	.\gen\Base-inl.h	/^class Just : public GenImpl<const Value&, Just<Value>> {$/;"	c	namespace:folly::gen::detail	inherits:GenImpl
folly::gen::detail::Just	.\gen\Base.h	/^class Just;$/;"	x
folly::gen::detail::Just::Just	.\gen\Base-inl.h	/^  explicit Just(Value value) : value_(std::forward<Value>(value)) {}$/;"	f	class:folly::gen::detail::Just	access:public	signature:(Value value)
folly::gen::detail::Just::apply	.\gen\Base-inl.h	/^  bool apply(Handler&& handler) const {$/;"	f	class:folly::gen::detail::Just	access:public	signature:(Handler&& handler) const
folly::gen::detail::Just::foreach	.\gen\Base-inl.h	/^  void foreach(Body&& body) const {$/;"	f	class:folly::gen::detail::Just	access:public	signature:(Body&& body) const
folly::gen::detail::Just::value_	.\gen\Base-inl.h	/^  const Value value_;$/;"	m	class:folly::gen::detail::Just	access:private
folly::gen::detail::Map	.\gen\Base-inl.h	/^class Map : public Operator<Map<Predicate>> {$/;"	c	namespace:folly::gen::detail	inherits:Operator
folly::gen::detail::Map	.\gen\Base.h	/^class Map;$/;"	x
folly::gen::detail::Map::Generator	.\gen\Base-inl.h	/^  class Generator :$/;"	c	class:folly::gen::detail::Map	inherits:GenImpl	access:public
folly::gen::detail::Map::Generator::Generator	.\gen\Base-inl.h	/^    explicit Generator(Source source, const Predicate& pred)$/;"	f	class:folly::gen::detail::Map::Generator	access:public	signature:(Source source, const Predicate& pred)
folly::gen::detail::Map::Generator::apply	.\gen\Base-inl.h	/^    bool apply(Handler&& handler) const {$/;"	f	class:folly::gen::detail::Map::Generator	access:public	signature:(Handler&& handler) const
folly::gen::detail::Map::Generator::foreach	.\gen\Base-inl.h	/^    void foreach(Body&& body) const {$/;"	f	class:folly::gen::detail::Map::Generator	access:public	signature:(Body&& body) const
folly::gen::detail::Map::Generator::infinite	.\gen\Base-inl.h	/^    static constexpr bool infinite = Source::infinite;$/;"	m	class:folly::gen::detail::Map::Generator	access:public
folly::gen::detail::Map::Generator::pred_	.\gen\Base-inl.h	/^    Predicate pred_;$/;"	m	class:folly::gen::detail::Map::Generator	access:private
folly::gen::detail::Map::Generator::source_	.\gen\Base-inl.h	/^    Source source_;$/;"	m	class:folly::gen::detail::Map::Generator	access:private
folly::gen::detail::Map::Map	.\gen\Base-inl.h	/^  Map() {}$/;"	f	class:folly::gen::detail::Map	access:public	signature:()
folly::gen::detail::Map::Map	.\gen\Base-inl.h	/^  explicit Map(Predicate pred)$/;"	f	class:folly::gen::detail::Map	access:public	signature:(Predicate pred)
folly::gen::detail::Map::compose	.\gen\Base-inl.h	/^  Gen compose(GenImpl<Value, Source>&& source) const {$/;"	f	class:folly::gen::detail::Map	access:public	signature:(GenImpl<Value, Source>&& source) const
folly::gen::detail::Map::compose	.\gen\Base-inl.h	/^  Gen compose(const GenImpl<Value, Source>& source) const {$/;"	f	class:folly::gen::detail::Map	access:public	signature:(const GenImpl<Value, Source>& source) const
folly::gen::detail::Map::pred_	.\gen\Base-inl.h	/^  Predicate pred_;$/;"	m	class:folly::gen::detail::Map	access:private
folly::gen::detail::MergeTuples	.\gen\Combine-inl.h	/^class MergeTuples {$/;"	c	namespace:folly::gen::detail
folly::gen::detail::MergeTuples::std::forward	.\gen\Combine-inl.h	/^                        std::get<1>(std::forward<Tuple>(value)))) {$/;"	f	class:folly::gen::detail::MergeTuples::std	access:public	signature:(value)
folly::gen::detail::Min	.\gen\Base-inl.h	/^class Min : public Operator<Min<Selector, Comparer>> {$/;"	c	namespace:folly::gen::detail	inherits:Operator
folly::gen::detail::Min	.\gen\Base.h	/^class Min;$/;"	x
folly::gen::detail::Min::Min	.\gen\Base-inl.h	/^  Min() {}$/;"	f	class:folly::gen::detail::Min	access:public	signature:()
folly::gen::detail::Min::Min	.\gen\Base-inl.h	/^  Min(Selector selector,$/;"	f	class:folly::gen::detail::Min	access:public	signature:(Selector selector, Comparer comparer)
folly::gen::detail::Min::Min	.\gen\Base-inl.h	/^  explicit Min(Selector selector)$/;"	f	class:folly::gen::detail::Min	access:public	signature:(Selector selector)
folly::gen::detail::Min::comparer_	.\gen\Base-inl.h	/^  Comparer comparer_;$/;"	m	class:folly::gen::detail::Min	access:private
folly::gen::detail::Min::compose	.\gen\Base-inl.h	/^  StorageType compose(const GenImpl<Value, Source>& source) const {$/;"	f	class:folly::gen::detail::Min	access:public	signature:(const GenImpl<Value, Source>& source) const
folly::gen::detail::Min::selector_	.\gen\Base-inl.h	/^  Selector selector_;$/;"	m	class:folly::gen::detail::Min	access:private
folly::gen::detail::Order	.\gen\Base-inl.h	/^class Order : public Operator<Order<Selector, Comparer>> {$/;"	c	namespace:folly::gen::detail	inherits:Operator
folly::gen::detail::Order	.\gen\Base.h	/^class Order;$/;"	x
folly::gen::detail::Order::Generator	.\gen\Base-inl.h	/^  class Generator :$/;"	c	class:folly::gen::detail::Order	inherits:GenImpl	access:public
folly::gen::detail::Order::Generator::Generator	.\gen\Base-inl.h	/^    Generator(Source source,$/;"	f	class:folly::gen::detail::Order::Generator	access:public	signature:(Source source, Selector selector, Comparer comparer)
folly::gen::detail::Order::Generator::VectorType	.\gen\Base-inl.h	/^    typedef std::vector<StorageType> VectorType;$/;"	t	class:folly::gen::detail::Order::Generator	access:private
folly::gen::detail::Order::Generator::apply	.\gen\Base-inl.h	/^    bool apply(Handler&& handler) const {$/;"	f	class:folly::gen::detail::Order::Generator	access:public	signature:(Handler&& handler) const
folly::gen::detail::Order::Generator::asVector	.\gen\Base-inl.h	/^    VectorType asVector() const {$/;"	f	class:folly::gen::detail::Order::Generator	access:private	signature:() const
folly::gen::detail::Order::Generator::comparer_	.\gen\Base-inl.h	/^    Comparer comparer_;$/;"	m	class:folly::gen::detail::Order::Generator	access:private
folly::gen::detail::Order::Generator::foreach	.\gen\Base-inl.h	/^    void foreach(Body&& body) const {$/;"	f	class:folly::gen::detail::Order::Generator	access:public	signature:(Body&& body) const
folly::gen::detail::Order::Generator::operator |	.\gen\Base-inl.h	/^    VectorType operator|(const Collect<VectorType>&) const {$/;"	f	class:folly::gen::detail::Order::Generator	access:public	signature:(const Collect<VectorType>&) const
folly::gen::detail::Order::Generator::operator |	.\gen\Base-inl.h	/^    VectorType operator|(const CollectTemplate<std::vector>&) const {$/;"	f	class:folly::gen::detail::Order::Generator	access:public	signature:(const CollectTemplate<std::vector>&) const
folly::gen::detail::Order::Generator::selector_	.\gen\Base-inl.h	/^    Selector selector_;$/;"	m	class:folly::gen::detail::Order::Generator	access:private
folly::gen::detail::Order::Generator::source_	.\gen\Base-inl.h	/^    Source source_;$/;"	m	class:folly::gen::detail::Order::Generator	access:private
folly::gen::detail::Order::Order	.\gen\Base-inl.h	/^  Order() {}$/;"	f	class:folly::gen::detail::Order	access:public	signature:()
folly::gen::detail::Order::Order	.\gen\Base-inl.h	/^  Order(Selector selector,$/;"	f	class:folly::gen::detail::Order	access:public	signature:(Selector selector, Comparer comparer)
folly::gen::detail::Order::Order	.\gen\Base-inl.h	/^  explicit Order(Selector selector)$/;"	f	class:folly::gen::detail::Order	access:public	signature:(Selector selector)
folly::gen::detail::Order::comparer_	.\gen\Base-inl.h	/^  Comparer comparer_;$/;"	m	class:folly::gen::detail::Order	access:private
folly::gen::detail::Order::compose	.\gen\Base-inl.h	/^  Gen compose(GenImpl<Value, Source>&& source) const {$/;"	f	class:folly::gen::detail::Order	access:public	signature:(GenImpl<Value, Source>&& source) const
folly::gen::detail::Order::compose	.\gen\Base-inl.h	/^  Gen compose(const GenImpl<Value, Source>& source) const {$/;"	f	class:folly::gen::detail::Order	access:public	signature:(const GenImpl<Value, Source>& source) const
folly::gen::detail::Order::selector_	.\gen\Base-inl.h	/^  Selector selector_;$/;"	m	class:folly::gen::detail::Order	access:private
folly::gen::detail::PMap	.\gen\ParallelMap-inl.h	/^class PMap : public Operator<PMap<Predicate>> {$/;"	c	namespace:folly::gen::detail	inherits:Operator
folly::gen::detail::PMap	.\gen\ParallelMap.h	/^class PMap;$/;"	x
folly::gen::detail::PMap::Generator	.\gen\ParallelMap-inl.h	/^  class Generator :$/;"	c	class:folly::gen::detail::PMap	inherits:GenImpl	access:public
folly::gen::detail::PMap::Generator::ExecutionPipeline	.\gen\ParallelMap-inl.h	/^    class ExecutionPipeline {$/;"	c	class:folly::gen::detail::PMap::Generator	access:private
folly::gen::detail::PMap::Generator::ExecutionPipeline::ExecutionPipeline	.\gen\ParallelMap-inl.h	/^      ExecutionPipeline(const Predicate& pred, size_t nThreads)$/;"	f	class:folly::gen::detail::PMap::Generator::ExecutionPipeline	access:public	signature:(const Predicate& pred, size_t nThreads)
folly::gen::detail::PMap::Generator::ExecutionPipeline::blockingRead	.\gen\ParallelMap-inl.h	/^      void blockingRead(Output& out) {$/;"	f	class:folly::gen::detail::PMap::Generator::ExecutionPipeline	access:public	signature:(Output& out)
folly::gen::detail::PMap::Generator::ExecutionPipeline::blockingWrite	.\gen\ParallelMap-inl.h	/^      void blockingWrite(Value&& value) {$/;"	f	class:folly::gen::detail::PMap::Generator::ExecutionPipeline	access:public	signature:(Value&& value)
folly::gen::detail::PMap::Generator::ExecutionPipeline::pipeline_	.\gen\ParallelMap-inl.h	/^      MPMCPipeline<Input, Output> pipeline_;$/;"	m	class:folly::gen::detail::PMap::Generator::ExecutionPipeline	access:private
folly::gen::detail::PMap::Generator::ExecutionPipeline::predApplier	.\gen\ParallelMap-inl.h	/^      void predApplier() {$/;"	f	class:folly::gen::detail::PMap::Generator::ExecutionPipeline	access:private	signature:()
folly::gen::detail::PMap::Generator::ExecutionPipeline::pred_	.\gen\ParallelMap-inl.h	/^      const Predicate& pred_;$/;"	m	class:folly::gen::detail::PMap::Generator::ExecutionPipeline	access:private
folly::gen::detail::PMap::Generator::ExecutionPipeline::read	.\gen\ParallelMap-inl.h	/^      bool read(Output& out) {$/;"	f	class:folly::gen::detail::PMap::Generator::ExecutionPipeline	access:public	signature:(Output& out)
folly::gen::detail::PMap::Generator::ExecutionPipeline::stop	.\gen\ParallelMap-inl.h	/^      void stop() {$/;"	f	class:folly::gen::detail::PMap::Generator::ExecutionPipeline	access:public	signature:()
folly::gen::detail::PMap::Generator::ExecutionPipeline::wake_	.\gen\ParallelMap-inl.h	/^      EventCount wake_;$/;"	m	class:folly::gen::detail::PMap::Generator::ExecutionPipeline	access:private
folly::gen::detail::PMap::Generator::ExecutionPipeline::workers_	.\gen\ParallelMap-inl.h	/^      std::vector<std::thread> workers_;$/;"	m	class:folly::gen::detail::PMap::Generator::ExecutionPipeline	access:private
folly::gen::detail::PMap::Generator::ExecutionPipeline::write	.\gen\ParallelMap-inl.h	/^      bool write(Value&& value) {$/;"	f	class:folly::gen::detail::PMap::Generator::ExecutionPipeline	access:public	signature:(Value&& value)
folly::gen::detail::PMap::Generator::ExecutionPipeline::~ExecutionPipeline	.\gen\ParallelMap-inl.h	/^      ~ExecutionPipeline() {$/;"	f	class:folly::gen::detail::PMap::Generator::ExecutionPipeline	access:public	signature:()
folly::gen::detail::PMap::Generator::Generator	.\gen\ParallelMap-inl.h	/^    Generator(Source source, const Predicate& pred, size_t nThreads)$/;"	f	class:folly::gen::detail::PMap::Generator	access:public	signature:(Source source, const Predicate& pred, size_t nThreads)
folly::gen::detail::PMap::Generator::apply	.\gen\ParallelMap-inl.h	/^    bool apply(Handler&& handler) const {$/;"	f	class:folly::gen::detail::PMap::Generator	access:public	signature:(Handler&& handler) const
folly::gen::detail::PMap::Generator::foreach	.\gen\ParallelMap-inl.h	/^    void foreach(Body&& body) const {$/;"	f	class:folly::gen::detail::PMap::Generator	access:public	signature:(Body&& body) const
folly::gen::detail::PMap::Generator::infinite	.\gen\ParallelMap-inl.h	/^    static constexpr bool infinite = Source::infinite;$/;"	m	class:folly::gen::detail::PMap::Generator	access:public
folly::gen::detail::PMap::Generator::nThreads_	.\gen\ParallelMap-inl.h	/^    const size_t nThreads_;$/;"	m	class:folly::gen::detail::PMap::Generator	access:private
folly::gen::detail::PMap::Generator::pred_	.\gen\ParallelMap-inl.h	/^    Predicate pred_;$/;"	m	class:folly::gen::detail::PMap::Generator	access:private
folly::gen::detail::PMap::Generator::source_	.\gen\ParallelMap-inl.h	/^    Source source_;$/;"	m	class:folly::gen::detail::PMap::Generator	access:private
folly::gen::detail::PMap::PMap	.\gen\ParallelMap-inl.h	/^  PMap() {}$/;"	f	class:folly::gen::detail::PMap	access:public	signature:()
folly::gen::detail::PMap::PMap	.\gen\ParallelMap-inl.h	/^  PMap(Predicate pred, size_t nThreads)$/;"	f	class:folly::gen::detail::PMap	access:public	signature:(Predicate pred, size_t nThreads)
folly::gen::detail::PMap::compose	.\gen\ParallelMap-inl.h	/^  Gen compose(GenImpl<Value, Source>&& source) const {$/;"	f	class:folly::gen::detail::PMap	access:public	signature:(GenImpl<Value, Source>&& source) const
folly::gen::detail::PMap::compose	.\gen\ParallelMap-inl.h	/^  Gen compose(const GenImpl<Value, Source>& source) const {$/;"	f	class:folly::gen::detail::PMap	access:public	signature:(const GenImpl<Value, Source>& source) const
folly::gen::detail::PMap::nThreads_	.\gen\ParallelMap-inl.h	/^  size_t nThreads_;$/;"	m	class:folly::gen::detail::PMap	access:private
folly::gen::detail::PMap::pred_	.\gen\ParallelMap-inl.h	/^  Predicate pred_;$/;"	m	class:folly::gen::detail::PMap	access:private
folly::gen::detail::Parallel	.\gen\Parallel-inl.h	/^class Parallel : public Operator<Parallel<Ops>> {$/;"	c	namespace:folly::gen::detail	inherits:Operator
folly::gen::detail::Parallel	.\gen\Parallel.h	/^class Parallel;$/;"	x
folly::gen::detail::Parallel::Generator	.\gen\Parallel-inl.h	/^  class Generator : public GenImpl<OutputDecayed&&,$/;"	c	class:folly::gen::detail::Parallel	inherits:GenImpl	access:public
folly::gen::detail::Parallel::Generator::Executor	.\gen\Parallel-inl.h	/^    class Executor {$/;"	c	class:folly::gen::detail::Parallel::Generator	access:private
folly::gen::detail::Parallel::Generator::Executor::Executor	.\gen\Parallel-inl.h	/^      Executor(size_t threads, const Ops* ops)$/;"	f	class:folly::gen::detail::Parallel::Generator::Executor	access:public	signature:(size_t threads, const Ops* ops)
folly::gen::detail::Parallel::Generator::Executor::closeInputProducer	.\gen\Parallel-inl.h	/^      void closeInputProducer() { inQueue_.closeInputProducer(); }$/;"	f	class:folly::gen::detail::Parallel::Generator::Executor	access:public	signature:()
folly::gen::detail::Parallel::Generator::Executor::closeOutputConsumer	.\gen\Parallel-inl.h	/^      void closeOutputConsumer() { outQueue_.closeOutputConsumer(); }$/;"	f	class:folly::gen::detail::Parallel::Generator::Executor	access:public	signature:()
folly::gen::detail::Parallel::Generator::Executor::inQueue_	.\gen\Parallel-inl.h	/^      InQueue inQueue_;$/;"	m	class:folly::gen::detail::Parallel::Generator::Executor	access:private
folly::gen::detail::Parallel::Generator::Executor::ops_	.\gen\Parallel-inl.h	/^      const Ops* ops_;$/;"	m	class:folly::gen::detail::Parallel::Generator::Executor	access:private
folly::gen::detail::Parallel::Generator::Executor::outQueue_	.\gen\Parallel-inl.h	/^      OutQueue outQueue_;$/;"	m	class:folly::gen::detail::Parallel::Generator::Executor	access:private
folly::gen::detail::Parallel::Generator::Executor::puller_	.\gen\Parallel-inl.h	/^      Puller puller_;$/;"	m	class:folly::gen::detail::Parallel::Generator::Executor	access:private
folly::gen::detail::Parallel::Generator::Executor::pusher_	.\gen\Parallel-inl.h	/^      Pusher<all> pusher_;$/;"	m	class:folly::gen::detail::Parallel::Generator::Executor	access:private
folly::gen::detail::Parallel::Generator::Executor::readUnlessClosed	.\gen\Parallel-inl.h	/^      bool readUnlessClosed(OutputDecayed& output) {$/;"	f	class:folly::gen::detail::Parallel::Generator::Executor	access:public	signature:(OutputDecayed& output)
folly::gen::detail::Parallel::Generator::Executor::readUnlessEmpty	.\gen\Parallel-inl.h	/^      bool readUnlessEmpty(OutputDecayed& output) {$/;"	f	class:folly::gen::detail::Parallel::Generator::Executor	access:public	signature:(OutputDecayed& output)
folly::gen::detail::Parallel::Generator::Executor::work	.\gen\Parallel-inl.h	/^      void work() {$/;"	f	class:folly::gen::detail::Parallel::Generator::Executor	access:private	signature:()
folly::gen::detail::Parallel::Generator::Executor::workers_	.\gen\Parallel-inl.h	/^      std::vector<std::thread> workers_;$/;"	m	class:folly::gen::detail::Parallel::Generator::Executor	access:private
folly::gen::detail::Parallel::Generator::Executor::writeUnlessClosed	.\gen\Parallel-inl.h	/^      bool writeUnlessClosed(Input&& input) {$/;"	f	class:folly::gen::detail::Parallel::Generator::Executor	access:public	signature:(Input&& input)
folly::gen::detail::Parallel::Generator::Executor::writeUnlessFull	.\gen\Parallel-inl.h	/^      bool writeUnlessFull(Input&& input) {$/;"	f	class:folly::gen::detail::Parallel::Generator::Executor	access:public	signature:(Input&& input)
folly::gen::detail::Parallel::Generator::Executor::~Executor	.\gen\Parallel-inl.h	/^      ~Executor() {$/;"	f	class:folly::gen::detail::Parallel::Generator::Executor	access:public	signature:()
folly::gen::detail::Parallel::Generator::Generator	.\gen\Parallel-inl.h	/^    Generator(Source source, Ops ops, size_t threads)$/;"	f	class:folly::gen::detail::Parallel::Generator	access:public	signature:(Source source, Ops ops, size_t threads)
folly::gen::detail::Parallel::Generator::InQueue	.\gen\Parallel-inl.h	/^    typedef ClosableMPMCQueue<InputDecayed> InQueue;$/;"	t	class:folly::gen::detail::Parallel::Generator	access:private
folly::gen::detail::Parallel::Generator::OutQueue	.\gen\Parallel-inl.h	/^    typedef ClosableMPMCQueue<OutputDecayed> OutQueue;$/;"	t	class:folly::gen::detail::Parallel::Generator	access:private
folly::gen::detail::Parallel::Generator::Puller	.\gen\Parallel-inl.h	/^    class Puller : public GenImpl<InputDecayed&&, Puller> {$/;"	c	class:folly::gen::detail::Parallel::Generator	inherits:GenImpl	access:private
folly::gen::detail::Parallel::Generator::Puller::Puller	.\gen\Parallel-inl.h	/^      explicit Puller(InQueue* queue) : queue_(queue) {}$/;"	f	class:folly::gen::detail::Parallel::Generator::Puller	access:public	signature:(InQueue* queue)
folly::gen::detail::Parallel::Generator::Puller::apply	.\gen\Parallel-inl.h	/^      bool apply(Handler&& handler) const {$/;"	f	class:folly::gen::detail::Parallel::Generator::Puller	access:public	signature:(Handler&& handler) const
folly::gen::detail::Parallel::Generator::Puller::foreach	.\gen\Parallel-inl.h	/^      void foreach(Body&& body) const {$/;"	f	class:folly::gen::detail::Parallel::Generator::Puller	access:public	signature:(Body&& body) const
folly::gen::detail::Parallel::Generator::Puller::queue_	.\gen\Parallel-inl.h	/^      InQueue* queue_;$/;"	m	class:folly::gen::detail::Parallel::Generator::Puller	access:private
folly::gen::detail::Parallel::Generator::Pusher	.\gen\Parallel-inl.h	/^    class Pusher : public Operator<Pusher<all>> {$/;"	c	class:folly::gen::detail::Parallel::Generator	inherits:Operator	access:private
folly::gen::detail::Parallel::Generator::Pusher::Pusher	.\gen\Parallel-inl.h	/^      explicit Pusher(OutQueue* queue) : queue_(queue) {}$/;"	f	class:folly::gen::detail::Parallel::Generator::Pusher	access:public	signature:(OutQueue* queue)
folly::gen::detail::Parallel::Generator::Pusher::compose	.\gen\Parallel-inl.h	/^      void compose(const GenImpl<Value, InnerSource>& source) const {$/;"	f	class:folly::gen::detail::Parallel::Generator::Pusher	access:public	signature:(const GenImpl<Value, InnerSource>& source) const
folly::gen::detail::Parallel::Generator::Pusher::queue_	.\gen\Parallel-inl.h	/^      OutQueue* queue_;$/;"	m	class:folly::gen::detail::Parallel::Generator::Pusher	access:private
folly::gen::detail::Parallel::Generator::apply	.\gen\Parallel-inl.h	/^    bool apply(Handler&& handler) const {$/;"	f	class:folly::gen::detail::Parallel::Generator	access:public	signature:(Handler&& handler) const
folly::gen::detail::Parallel::Generator::foreach	.\gen\Parallel-inl.h	/^    void foreach(Body&& body) const {$/;"	f	class:folly::gen::detail::Parallel::Generator	access:public	signature:(Body&& body) const
folly::gen::detail::Parallel::Generator::ops_	.\gen\Parallel-inl.h	/^    const Ops ops_;$/;"	m	class:folly::gen::detail::Parallel::Generator	access:private
folly::gen::detail::Parallel::Generator::source_	.\gen\Parallel-inl.h	/^    const Source source_;$/;"	m	class:folly::gen::detail::Parallel::Generator	access:private
folly::gen::detail::Parallel::Generator::threads_	.\gen\Parallel-inl.h	/^    const size_t threads_;$/;"	m	class:folly::gen::detail::Parallel::Generator	access:private
folly::gen::detail::Parallel::Parallel	.\gen\Parallel-inl.h	/^  Parallel(Ops ops, size_t threads) : ops_(std::move(ops)), threads_(threads) {}$/;"	f	class:folly::gen::detail::Parallel	access:public	signature:(Ops ops, size_t threads)
folly::gen::detail::Parallel::compose	.\gen\Parallel-inl.h	/^  Generator<Value, Source> compose(GenImpl<Value, Source>&& source) const {$/;"	f	class:folly::gen::detail::Parallel	access:public	signature:(GenImpl<Value, Source>&& source) const
folly::gen::detail::Parallel::compose	.\gen\Parallel-inl.h	/^  Generator<Value, Source> compose(const GenImpl<Value, Source>& source) const {$/;"	f	class:folly::gen::detail::Parallel	access:public	signature:(const GenImpl<Value, Source>& source) const
folly::gen::detail::Parallel::ops_	.\gen\Parallel-inl.h	/^  Ops ops_;$/;"	m	class:folly::gen::detail::Parallel	access:private
folly::gen::detail::Parallel::threads_	.\gen\Parallel-inl.h	/^  size_t threads_;$/;"	m	class:folly::gen::detail::Parallel	access:private
folly::gen::detail::RangeConcat	.\gen\Base-inl.h	/^class RangeConcat : public Operator<RangeConcat> {$/;"	c	namespace:folly::gen::detail	inherits:Operator
folly::gen::detail::RangeConcat	.\gen\Base.h	/^class RangeConcat;$/;"	x
folly::gen::detail::RangeConcat::Generator	.\gen\Base-inl.h	/^  class Generator$/;"	c	class:folly::gen::detail::RangeConcat	inherits:GenImpl	access:public
folly::gen::detail::RangeConcat::Generator::Generator	.\gen\Base-inl.h	/^    explicit Generator(Source source)$/;"	f	class:folly::gen::detail::RangeConcat::Generator	access:public	signature:(Source source)
folly::gen::detail::RangeConcat::Generator::apply	.\gen\Base-inl.h	/^    bool apply(Handler&& handler) const {$/;"	f	class:folly::gen::detail::RangeConcat::Generator	access:public	signature:(Handler&& handler) const
folly::gen::detail::RangeConcat::Generator::foreach	.\gen\Base-inl.h	/^    void foreach(Body&& body) const {$/;"	f	class:folly::gen::detail::RangeConcat::Generator	access:public	signature:(Body&& body) const
folly::gen::detail::RangeConcat::Generator::source_	.\gen\Base-inl.h	/^    Source source_;$/;"	m	class:folly::gen::detail::RangeConcat::Generator	access:private
folly::gen::detail::RangeConcat::RangeConcat	.\gen\Base-inl.h	/^  RangeConcat() { }$/;"	f	class:folly::gen::detail::RangeConcat	access:public	signature:()
folly::gen::detail::RangeConcat::compose	.\gen\Base-inl.h	/^  Gen compose(GenImpl<Value, Source>&& source) const {$/;"	f	class:folly::gen::detail::RangeConcat	access:public	signature:(GenImpl<Value, Source>&& source) const
folly::gen::detail::RangeConcat::compose	.\gen\Base-inl.h	/^  Gen compose(const GenImpl<Value, Source>& source) const {$/;"	f	class:folly::gen::detail::RangeConcat	access:public	signature:(const GenImpl<Value, Source>& source) const
folly::gen::detail::RangeImpl	.\gen\Base-inl.h	/^class RangeImpl {$/;"	c	namespace:folly::gen::detail
folly::gen::detail::RangeImpl	.\gen\Base.h	/^class RangeImpl;$/;"	x
folly::gen::detail::RangeImpl::RangeImpl	.\gen\Base-inl.h	/^  explicit RangeImpl(Value end) : end_(std::move(end)) { }$/;"	f	class:folly::gen::detail::RangeImpl	access:public	signature:(Value end)
folly::gen::detail::RangeImpl::end_	.\gen\Base-inl.h	/^  Value end_;$/;"	m	class:folly::gen::detail::RangeImpl	access:private
folly::gen::detail::RangeImpl::step	.\gen\Base-inl.h	/^  void step(Value& current) const { ++current; }$/;"	f	class:folly::gen::detail::RangeImpl	access:public	signature:(Value& current) const
folly::gen::detail::RangeImpl::test	.\gen\Base-inl.h	/^  bool test(const Value& current) const { return current < end_; }$/;"	f	class:folly::gen::detail::RangeImpl	access:public	signature:(const Value& current) const
folly::gen::detail::RangeSource	.\gen\Base-inl.h	/^class RangeSource : public GenImpl<typename Range<Iterator>::reference,$/;"	c	namespace:folly::gen::detail	inherits:GenImpl
folly::gen::detail::RangeSource::RangeSource	.\gen\Base-inl.h	/^  RangeSource() {}$/;"	f	class:folly::gen::detail::RangeSource	access:public	signature:()
folly::gen::detail::RangeSource::RangeSource	.\gen\Base-inl.h	/^  explicit RangeSource(Range<Iterator> range)$/;"	f	class:folly::gen::detail::RangeSource	access:public	signature:(Range<Iterator> range)
folly::gen::detail::RangeSource::apply	.\gen\Base-inl.h	/^  bool apply(Handler&& handler) const {$/;"	f	class:folly::gen::detail::RangeSource	access:public	signature:(Handler&& handler) const
folly::gen::detail::RangeSource::foreach	.\gen\Base-inl.h	/^  void foreach(Body&& body) const {$/;"	f	class:folly::gen::detail::RangeSource	access:public	signature:(Body&& body) const
folly::gen::detail::RangeSource::range_	.\gen\Base-inl.h	/^  Range<Iterator> range_;$/;"	m	class:folly::gen::detail::RangeSource	access:private
folly::gen::detail::RangeWithStepImpl	.\gen\Base-inl.h	/^class RangeWithStepImpl {$/;"	c	namespace:folly::gen::detail
folly::gen::detail::RangeWithStepImpl	.\gen\Base.h	/^class RangeWithStepImpl;$/;"	x
folly::gen::detail::RangeWithStepImpl::RangeWithStepImpl	.\gen\Base-inl.h	/^  explicit RangeWithStepImpl(Value end, Distance step)$/;"	f	class:folly::gen::detail::RangeWithStepImpl	access:public	signature:(Value end, Distance step)
folly::gen::detail::RangeWithStepImpl::end_	.\gen\Base-inl.h	/^  Value end_;$/;"	m	class:folly::gen::detail::RangeWithStepImpl	access:private
folly::gen::detail::RangeWithStepImpl::step	.\gen\Base-inl.h	/^  void step(Value& current) const { current += step_; }$/;"	f	class:folly::gen::detail::RangeWithStepImpl	access:public	signature:(Value& current) const
folly::gen::detail::RangeWithStepImpl::step_	.\gen\Base-inl.h	/^  Distance step_;$/;"	m	class:folly::gen::detail::RangeWithStepImpl	access:private
folly::gen::detail::RangeWithStepImpl::test	.\gen\Base-inl.h	/^  bool test(const Value& current) const { return current < end_; }$/;"	f	class:folly::gen::detail::RangeWithStepImpl	access:public	signature:(const Value& current) const
folly::gen::detail::Reduce	.\gen\Base-inl.h	/^class Reduce : public Operator<Reduce<Reducer>> {$/;"	c	namespace:folly::gen::detail	inherits:Operator
folly::gen::detail::Reduce	.\gen\Base.h	/^class Reduce;$/;"	x
folly::gen::detail::Reduce::Reduce	.\gen\Base-inl.h	/^  Reduce() {}$/;"	f	class:folly::gen::detail::Reduce	access:public	signature:()
folly::gen::detail::Reduce::Reduce	.\gen\Base-inl.h	/^  explicit Reduce(Reducer reducer)$/;"	f	class:folly::gen::detail::Reduce	access:public	signature:(Reducer reducer)
folly::gen::detail::Reduce::compose	.\gen\Base-inl.h	/^  StorageType compose(const GenImpl<Value, Source>& source) const {$/;"	f	class:folly::gen::detail::Reduce	access:public	signature:(const GenImpl<Value, Source>& source) const
folly::gen::detail::Reduce::reducer_	.\gen\Base-inl.h	/^  Reducer reducer_;$/;"	m	class:folly::gen::detail::Reduce	access:private
folly::gen::detail::ReferencedSource	.\gen\Base-inl.h	/^class ReferencedSource :$/;"	c	namespace:folly::gen::detail	inherits:GenImpl
folly::gen::detail::ReferencedSource	.\gen\Base.h	/^class ReferencedSource;$/;"	x
folly::gen::detail::ReferencedSource::ReferencedSource	.\gen\Base-inl.h	/^  explicit ReferencedSource(Container* container)$/;"	f	class:folly::gen::detail::ReferencedSource	access:public	signature:(Container* container)
folly::gen::detail::ReferencedSource::apply	.\gen\Base-inl.h	/^  bool apply(Handler&& handler) const {$/;"	f	class:folly::gen::detail::ReferencedSource	access:public	signature:(Handler&& handler) const
folly::gen::detail::ReferencedSource::container_	.\gen\Base-inl.h	/^  Container* container_;$/;"	m	class:folly::gen::detail::ReferencedSource	access:private
folly::gen::detail::ReferencedSource::foreach	.\gen\Base-inl.h	/^  void foreach(Body&& body) const {$/;"	f	class:folly::gen::detail::ReferencedSource	access:public	signature:(Body&& body) const
folly::gen::detail::Sample	.\gen\Base-inl.h	/^class Sample : public Operator<Sample<Random>> {$/;"	c	namespace:folly::gen::detail	inherits:Operator
folly::gen::detail::Sample	.\gen\Base.h	/^class Sample;$/;"	x
folly::gen::detail::Sample::Generator	.\gen\Base-inl.h	/^  class Generator :$/;"	c	class:folly::gen::detail::Sample	inherits:GenImpl	access:public
folly::gen::detail::Sample::Generator::Generator	.\gen\Base-inl.h	/^    explicit Generator(Source source, size_t count, Random rng)$/;"	f	class:folly::gen::detail::Sample::Generator	access:public	signature:(Source source, size_t count, Random rng)
folly::gen::detail::Sample::Generator::apply	.\gen\Base-inl.h	/^    bool apply(Handler&& handler) const {$/;"	f	class:folly::gen::detail::Sample::Generator	access:public	signature:(Handler&& handler) const
folly::gen::detail::Sample::Generator::count_	.\gen\Base-inl.h	/^    size_t count_;$/;"	m	class:folly::gen::detail::Sample::Generator	access:private
folly::gen::detail::Sample::Generator::max	.\gen\Base-inl.h	/^    static_assert(Random::max() >= std::numeric_limits<int32_t>::max() - 1,$/;"	p	class:folly::gen::detail::Sample::Generator	access:private	signature:()
folly::gen::detail::Sample::Generator::rng_	.\gen\Base-inl.h	/^    mutable Rand rng_;$/;"	m	class:folly::gen::detail::Sample::Generator	access:private
folly::gen::detail::Sample::Generator::source_	.\gen\Base-inl.h	/^    Source source_;$/;"	m	class:folly::gen::detail::Sample::Generator	access:private
folly::gen::detail::Sample::Sample	.\gen\Base-inl.h	/^  explicit Sample(size_t count, Random rng)$/;"	f	class:folly::gen::detail::Sample	access:public	signature:(size_t count, Random rng)
folly::gen::detail::Sample::compose	.\gen\Base-inl.h	/^  Gen compose(GenImpl<Value, Source>&& source) const {$/;"	f	class:folly::gen::detail::Sample	access:public	signature:(GenImpl<Value, Source>&& source) const
folly::gen::detail::Sample::compose	.\gen\Base-inl.h	/^  Gen compose(const GenImpl<Value, Source>& source) const {$/;"	f	class:folly::gen::detail::Sample	access:public	signature:(const GenImpl<Value, Source>& source) const
folly::gen::detail::Sample::count_	.\gen\Base-inl.h	/^  size_t count_;$/;"	m	class:folly::gen::detail::Sample	access:private
folly::gen::detail::Sample::rng_	.\gen\Base-inl.h	/^  Random rng_;$/;"	m	class:folly::gen::detail::Sample	access:private
folly::gen::detail::SeqImpl	.\gen\Base-inl.h	/^class SeqImpl {$/;"	c	namespace:folly::gen::detail
folly::gen::detail::SeqImpl	.\gen\Base.h	/^class SeqImpl;$/;"	x
folly::gen::detail::SeqImpl::SeqImpl	.\gen\Base-inl.h	/^  explicit SeqImpl(Value end) : end_(std::move(end)) { }$/;"	f	class:folly::gen::detail::SeqImpl	access:public	signature:(Value end)
folly::gen::detail::SeqImpl::end_	.\gen\Base-inl.h	/^  Value end_;$/;"	m	class:folly::gen::detail::SeqImpl	access:private
folly::gen::detail::SeqImpl::step	.\gen\Base-inl.h	/^  void step(Value& current) const { ++current; }$/;"	f	class:folly::gen::detail::SeqImpl	access:public	signature:(Value& current) const
folly::gen::detail::SeqImpl::test	.\gen\Base-inl.h	/^  bool test(const Value& current) const { return current <= end_; }$/;"	f	class:folly::gen::detail::SeqImpl	access:public	signature:(const Value& current) const
folly::gen::detail::SeqWithStepImpl	.\gen\Base-inl.h	/^class SeqWithStepImpl {$/;"	c	namespace:folly::gen::detail
folly::gen::detail::SeqWithStepImpl	.\gen\Base.h	/^class SeqWithStepImpl;$/;"	x
folly::gen::detail::SeqWithStepImpl::SeqWithStepImpl	.\gen\Base-inl.h	/^  explicit SeqWithStepImpl(Value end, Distance step)$/;"	f	class:folly::gen::detail::SeqWithStepImpl	access:public	signature:(Value end, Distance step)
folly::gen::detail::SeqWithStepImpl::end_	.\gen\Base-inl.h	/^  Value end_;$/;"	m	class:folly::gen::detail::SeqWithStepImpl	access:private
folly::gen::detail::SeqWithStepImpl::step	.\gen\Base-inl.h	/^  void step(Value& current) const { current += step_; }$/;"	f	class:folly::gen::detail::SeqWithStepImpl	access:public	signature:(Value& current) const
folly::gen::detail::SeqWithStepImpl::step_	.\gen\Base-inl.h	/^  Distance step_;$/;"	m	class:folly::gen::detail::SeqWithStepImpl	access:private
folly::gen::detail::SeqWithStepImpl::test	.\gen\Base-inl.h	/^  bool test(const Value& current) const { return current <= end_; }$/;"	f	class:folly::gen::detail::SeqWithStepImpl	access:public	signature:(const Value& current) const
folly::gen::detail::Sequence	.\gen\Base-inl.h	/^class Sequence : public GenImpl<const Value&, Sequence<Value, SequenceImpl>> {$/;"	c	namespace:folly::gen::detail	inherits:GenImpl
folly::gen::detail::Sequence	.\gen\Base.h	/^class Sequence;$/;"	x
folly::gen::detail::Sequence::Sequence	.\gen\Base-inl.h	/^  explicit Sequence(Value start, SequenceImpl impl)$/;"	f	class:folly::gen::detail::Sequence	access:public	signature:(Value start, SequenceImpl impl)
folly::gen::detail::Sequence::apply	.\gen\Base-inl.h	/^  bool apply(Handler&& handler) const {$/;"	f	class:folly::gen::detail::Sequence	access:public	signature:(Handler&& handler) const
folly::gen::detail::Sequence::foreach	.\gen\Base-inl.h	/^  void foreach(Body&& body) const {$/;"	f	class:folly::gen::detail::Sequence	access:public	signature:(Body&& body) const
folly::gen::detail::Sequence::impl_	.\gen\Base-inl.h	/^  SequenceImpl impl_;$/;"	m	class:folly::gen::detail::Sequence	access:private
folly::gen::detail::Sequence::start_	.\gen\Base-inl.h	/^  Value start_;$/;"	m	class:folly::gen::detail::Sequence	access:private
folly::gen::detail::Skip	.\gen\Base-inl.h	/^class Skip : public Operator<Skip> {$/;"	c	namespace:folly::gen::detail	inherits:Operator
folly::gen::detail::Skip	.\gen\Base.h	/^class Skip;$/;"	x
folly::gen::detail::Skip::Generator	.\gen\Base-inl.h	/^  class Generator :$/;"	c	class:folly::gen::detail::Skip	inherits:GenImpl	access:public
folly::gen::detail::Skip::Generator::Generator	.\gen\Base-inl.h	/^    explicit Generator(Source source, size_t count)$/;"	f	class:folly::gen::detail::Skip::Generator	access:public	signature:(Source source, size_t count)
folly::gen::detail::Skip::Generator::apply	.\gen\Base-inl.h	/^    bool apply(Handler&& handler) const {$/;"	f	class:folly::gen::detail::Skip::Generator	access:public	signature:(Handler&& handler) const
folly::gen::detail::Skip::Generator::count_	.\gen\Base-inl.h	/^    size_t count_;$/;"	m	class:folly::gen::detail::Skip::Generator	access:private
folly::gen::detail::Skip::Generator::foreach	.\gen\Base-inl.h	/^    void foreach(Body&& body) const {$/;"	f	class:folly::gen::detail::Skip::Generator	access:public	signature:(Body&& body) const
folly::gen::detail::Skip::Generator::infinite	.\gen\Base-inl.h	/^    static constexpr bool infinite = Source::infinite;$/;"	m	class:folly::gen::detail::Skip::Generator	access:public
folly::gen::detail::Skip::Generator::source_	.\gen\Base-inl.h	/^    Source source_;$/;"	m	class:folly::gen::detail::Skip::Generator	access:private
folly::gen::detail::Skip::Skip	.\gen\Base-inl.h	/^  explicit Skip(size_t count)$/;"	f	class:folly::gen::detail::Skip	access:public	signature:(size_t count)
folly::gen::detail::Skip::compose	.\gen\Base-inl.h	/^  Gen compose(GenImpl<Value, Source>&& source) const {$/;"	f	class:folly::gen::detail::Skip	access:public	signature:(GenImpl<Value, Source>&& source) const
folly::gen::detail::Skip::compose	.\gen\Base-inl.h	/^  Gen compose(const GenImpl<Value, Source>& source) const {$/;"	f	class:folly::gen::detail::Skip	access:public	signature:(const GenImpl<Value, Source>& source) const
folly::gen::detail::Skip::count_	.\gen\Base-inl.h	/^  size_t count_;$/;"	m	class:folly::gen::detail::Skip	access:private
folly::gen::detail::SplitStringSource	.\gen\String-inl.h	/^class SplitStringSource$/;"	c	namespace:folly::gen::detail	inherits:GenImpl
folly::gen::detail::SplitStringSource	.\gen\String.h	/^class SplitStringSource;$/;"	x
folly::gen::detail::SplitStringSource::SplitStringSource	.\gen\String-inl.h	/^  SplitStringSource(const StringPiece& source,$/;"	f	class:folly::gen::detail::SplitStringSource	access:public	signature:(const StringPiece& source, DelimiterType delimiter)
folly::gen::detail::SplitStringSource::apply	.\gen\String-inl.h	/^  bool apply(Body&& body) const {$/;"	f	class:folly::gen::detail::SplitStringSource	access:public	signature:(Body&& body) const
folly::gen::detail::SplitStringSource::delimiter_	.\gen\String-inl.h	/^  DelimiterType delimiter_;$/;"	m	class:folly::gen::detail::SplitStringSource	access:private
folly::gen::detail::SplitStringSource::source_	.\gen\String-inl.h	/^  StringPiece source_;$/;"	m	class:folly::gen::detail::SplitStringSource	access:private
folly::gen::detail::SplitTo	.\gen\String-inl.h	/^class SplitTo {$/;"	c	namespace:folly::gen::detail
folly::gen::detail::SplitTo	.\gen\String.h	/^class SplitTo;$/;"	x
folly::gen::detail::SplitTo::SplitTo	.\gen\String-inl.h	/^  explicit SplitTo(Delimiter delimiter)$/;"	f	class:folly::gen::detail::SplitTo	access:public	signature:(Delimiter delimiter)
folly::gen::detail::SplitTo::delimiter_	.\gen\String-inl.h	/^  Delimiter delimiter_;$/;"	m	class:folly::gen::detail::SplitTo	access:private
folly::gen::detail::SplitTo::operator ()	.\gen\String-inl.h	/^  TargetContainer operator()(StringPiece line) const {$/;"	f	class:folly::gen::detail::SplitTo	access:public	signature:(StringPiece line) const
folly::gen::detail::Stride	.\gen\Base-inl.h	/^class Stride : public Operator<Stride> {$/;"	c	namespace:folly::gen::detail	inherits:Operator
folly::gen::detail::Stride	.\gen\Base.h	/^class Stride;$/;"	x
folly::gen::detail::Stride::Generator	.\gen\Base-inl.h	/^  class Generator : public GenImpl<Value, Generator<Value, Source>> {$/;"	c	class:folly::gen::detail::Stride	inherits:GenImpl	access:public
folly::gen::detail::Stride::Generator::Generator	.\gen\Base-inl.h	/^   Generator(Source source, size_t stride)$/;"	f	class:folly::gen::detail::Stride::Generator	access:public	signature:(Source source, size_t stride)
folly::gen::detail::Stride::Generator::apply	.\gen\Base-inl.h	/^   bool apply(Handler&& handler) const {$/;"	f	class:folly::gen::detail::Stride::Generator	access:public	signature:(Handler&& handler) const
folly::gen::detail::Stride::Generator::foreach	.\gen\Base-inl.h	/^   void foreach(Body&& body) const {$/;"	f	class:folly::gen::detail::Stride::Generator	access:public	signature:(Body&& body) const
folly::gen::detail::Stride::Generator::source_	.\gen\Base-inl.h	/^    Source source_;$/;"	m	class:folly::gen::detail::Stride::Generator	access:private
folly::gen::detail::Stride::Generator::stride_	.\gen\Base-inl.h	/^    size_t stride_;$/;"	m	class:folly::gen::detail::Stride::Generator	access:private
folly::gen::detail::Stride::Stride	.\gen\Base-inl.h	/^  explicit Stride(size_t stride) : stride_(stride) {$/;"	f	class:folly::gen::detail::Stride	access:public	signature:(size_t stride)
folly::gen::detail::Stride::compose	.\gen\Base-inl.h	/^  Gen compose(GenImpl<Value, Source>&& source) const {$/;"	f	class:folly::gen::detail::Stride	access:public	signature:(GenImpl<Value, Source>&& source) const
folly::gen::detail::Stride::compose	.\gen\Base-inl.h	/^  Gen compose(const GenImpl<Value, Source>& source) const {$/;"	f	class:folly::gen::detail::Stride	access:public	signature:(const GenImpl<Value, Source>& source) const
folly::gen::detail::Stride::stride_	.\gen\Base-inl.h	/^  size_t stride_;$/;"	m	class:folly::gen::detail::Stride	access:private
folly::gen::detail::StringResplitter	.\gen\String-inl.h	/^class StringResplitter : public Operator<StringResplitter> {$/;"	c	namespace:folly::gen::detail	inherits:Operator
folly::gen::detail::StringResplitter	.\gen\String.h	/^class StringResplitter;$/;"	x
folly::gen::detail::StringResplitter::Generator	.\gen\String-inl.h	/^  class Generator : public GenImpl<StringPiece, Generator<Source>> {$/;"	c	class:folly::gen::detail::StringResplitter	inherits:GenImpl	access:public
folly::gen::detail::StringResplitter::Generator::Generator	.\gen\String-inl.h	/^    Generator(Source source, char delimiter)$/;"	f	class:folly::gen::detail::StringResplitter::Generator	access:public	signature:(Source source, char delimiter)
folly::gen::detail::StringResplitter::Generator::apply	.\gen\String-inl.h	/^    bool apply(Body&& body) const {$/;"	f	class:folly::gen::detail::StringResplitter::Generator	access:public	signature:(Body&& body) const
folly::gen::detail::StringResplitter::Generator::delimiter_	.\gen\String-inl.h	/^    char delimiter_;$/;"	m	class:folly::gen::detail::StringResplitter::Generator	access:private
folly::gen::detail::StringResplitter::Generator::infinite	.\gen\String-inl.h	/^    static constexpr bool infinite = Source::infinite;$/;"	m	class:folly::gen::detail::StringResplitter::Generator	access:public
folly::gen::detail::StringResplitter::Generator::source_	.\gen\String-inl.h	/^    Source source_;$/;"	m	class:folly::gen::detail::StringResplitter::Generator	access:private
folly::gen::detail::StringResplitter::StringResplitter	.\gen\String-inl.h	/^  explicit StringResplitter(char delimiter) : delimiter_(delimiter) { }$/;"	f	class:folly::gen::detail::StringResplitter	access:public	signature:(char delimiter)
folly::gen::detail::StringResplitter::compose	.\gen\String-inl.h	/^  Gen compose(GenImpl<Value, Source>&& source) const {$/;"	f	class:folly::gen::detail::StringResplitter	access:public	signature:(GenImpl<Value, Source>&& source) const
folly::gen::detail::StringResplitter::compose	.\gen\String-inl.h	/^  Gen compose(const GenImpl<Value, Source>& source) const {$/;"	f	class:folly::gen::detail::StringResplitter	access:public	signature:(const GenImpl<Value, Source>& source) const
folly::gen::detail::StringResplitter::delimiter_	.\gen\String-inl.h	/^  char delimiter_;$/;"	m	class:folly::gen::detail::StringResplitter	access:private
folly::gen::detail::Sub	.\gen\Parallel-inl.h	/^class Sub : public Operator<Sub<Sink>> {$/;"	c	namespace:folly::gen::detail	inherits:Operator
folly::gen::detail::Sub	.\gen\Parallel.h	/^class Sub;$/;"	x
folly::gen::detail::Sub::Sub	.\gen\Parallel-inl.h	/^  explicit Sub(Sink sink) : sink_(sink) {}$/;"	f	class:folly::gen::detail::Sub	access:public	signature:(Sink sink)
folly::gen::detail::Sub::compose	.\gen\Parallel-inl.h	/^  Just compose(const GenImpl<Value, Source>& source) const {$/;"	f	class:folly::gen::detail::Sub	access:public	signature:(const GenImpl<Value, Source>& source) const
folly::gen::detail::Sub::sink_	.\gen\Parallel-inl.h	/^  Sink sink_;$/;"	m	class:folly::gen::detail::Sub	access:private
folly::gen::detail::Sum	.\gen\Base-inl.h	/^class Sum : public Operator<Sum> {$/;"	c	namespace:folly::gen::detail	inherits:Operator
folly::gen::detail::Sum	.\gen\Base.h	/^class Sum;$/;"	x
folly::gen::detail::Sum::Sum	.\gen\Base-inl.h	/^  Sum() : Operator<Sum>() {}$/;"	f	class:folly::gen::detail::Sum	access:public	signature:()
folly::gen::detail::Sum::compose	.\gen\Base-inl.h	/^  StorageType compose(const GenImpl<Value, Source>& source) const {$/;"	f	class:folly::gen::detail::Sum	access:public	signature:(const GenImpl<Value, Source>& source) const
folly::gen::detail::Take	.\gen\Base-inl.h	/^class Take : public Operator<Take> {$/;"	c	namespace:folly::gen::detail	inherits:Operator
folly::gen::detail::Take	.\gen\Base.h	/^class Take;$/;"	x
folly::gen::detail::Take::Generator	.\gen\Base-inl.h	/^  class Generator :$/;"	c	class:folly::gen::detail::Take	inherits:GenImpl	access:public
folly::gen::detail::Take::Generator::Generator	.\gen\Base-inl.h	/^    explicit Generator(Source source, size_t count)$/;"	f	class:folly::gen::detail::Take::Generator	access:public	signature:(Source source, size_t count)
folly::gen::detail::Take::Generator::apply	.\gen\Base-inl.h	/^    bool apply(Handler&& handler) const {$/;"	f	class:folly::gen::detail::Take::Generator	access:public	signature:(Handler&& handler) const
folly::gen::detail::Take::Generator::count_	.\gen\Base-inl.h	/^    size_t count_;$/;"	m	class:folly::gen::detail::Take::Generator	access:private
folly::gen::detail::Take::Generator::source_	.\gen\Base-inl.h	/^    Source source_;$/;"	m	class:folly::gen::detail::Take::Generator	access:private
folly::gen::detail::Take::Take	.\gen\Base-inl.h	/^  explicit Take(size_t count)$/;"	f	class:folly::gen::detail::Take	access:public	signature:(size_t count)
folly::gen::detail::Take::compose	.\gen\Base-inl.h	/^  Gen compose(GenImpl<Value, Source>&& source) const {$/;"	f	class:folly::gen::detail::Take	access:public	signature:(GenImpl<Value, Source>&& source) const
folly::gen::detail::Take::compose	.\gen\Base-inl.h	/^  Gen compose(const GenImpl<Value, Source>& source) const {$/;"	f	class:folly::gen::detail::Take	access:public	signature:(const GenImpl<Value, Source>& source) const
folly::gen::detail::Take::count_	.\gen\Base-inl.h	/^  size_t count_;$/;"	m	class:folly::gen::detail::Take	access:private
folly::gen::detail::TypeAssertion	.\gen\Base-inl.h	/^class TypeAssertion : public Operator<TypeAssertion<Expected>> {$/;"	c	namespace:folly::gen::detail	inherits:Operator
folly::gen::detail::TypeAssertion	.\gen\Base.h	/^class TypeAssertion;$/;"	x
folly::gen::detail::TypeAssertion::compose	.\gen\Base-inl.h	/^  Source&& compose(GenImpl<Value, Source>&& source) const {$/;"	f	class:folly::gen::detail::TypeAssertion	access:public	signature:(GenImpl<Value, Source>&& source) const
folly::gen::detail::TypeAssertion::compose	.\gen\Base-inl.h	/^  const Source& compose(const GenImpl<Value, Source>& source) const {$/;"	f	class:folly::gen::detail::TypeAssertion	access:public	signature:(const GenImpl<Value, Source>& source) const
folly::gen::detail::Unsplit	.\gen\String-inl.h	/^class Unsplit : public Operator<Unsplit<Delimiter, Output>> {$/;"	c	namespace:folly::gen::detail	inherits:Operator
folly::gen::detail::Unsplit	.\gen\String.h	/^class Unsplit;$/;"	x
folly::gen::detail::Unsplit::Unsplit	.\gen\String-inl.h	/^  explicit Unsplit(const Delimiter& delimiter)$/;"	f	class:folly::gen::detail::Unsplit	access:public	signature:(const Delimiter& delimiter)
folly::gen::detail::Unsplit::compose	.\gen\String-inl.h	/^  Output compose(const GenImpl<Value, Source>& source) const {$/;"	f	class:folly::gen::detail::Unsplit	access:public	signature:(const GenImpl<Value, Source>& source) const
folly::gen::detail::Unsplit::delimiter_	.\gen\String-inl.h	/^  Delimiter delimiter_;$/;"	m	class:folly::gen::detail::Unsplit	access:private
folly::gen::detail::UnsplitBuffer	.\gen\String-inl.h	/^class UnsplitBuffer : public Operator<UnsplitBuffer<Delimiter, OutputBuffer>> {$/;"	c	namespace:folly::gen::detail	inherits:Operator
folly::gen::detail::UnsplitBuffer	.\gen\String.h	/^class UnsplitBuffer;$/;"	x
folly::gen::detail::UnsplitBuffer::UnsplitBuffer	.\gen\String-inl.h	/^  UnsplitBuffer(const Delimiter& delimiter, OutputBuffer* outputBuffer)$/;"	f	class:folly::gen::detail::UnsplitBuffer	access:public	signature:(const Delimiter& delimiter, OutputBuffer* outputBuffer)
folly::gen::detail::UnsplitBuffer::compose	.\gen\String-inl.h	/^  void compose(const GenImpl<Value, Source>& source) const {$/;"	f	class:folly::gen::detail::UnsplitBuffer	access:public	signature:(const GenImpl<Value, Source>& source) const
folly::gen::detail::UnsplitBuffer::delimiter_	.\gen\String-inl.h	/^  Delimiter delimiter_;$/;"	m	class:folly::gen::detail::UnsplitBuffer	access:private
folly::gen::detail::UnsplitBuffer::outputBuffer_	.\gen\String-inl.h	/^  OutputBuffer* outputBuffer_;$/;"	m	class:folly::gen::detail::UnsplitBuffer	access:private
folly::gen::detail::Until	.\gen\Base-inl.h	/^class Until : public Operator<Until<Predicate>> {$/;"	c	namespace:folly::gen::detail	inherits:Operator
folly::gen::detail::Until	.\gen\Base.h	/^class Until;$/;"	x
folly::gen::detail::Until::Generator	.\gen\Base-inl.h	/^  class Generator : public GenImpl<Value, Generator<Value, Source>> {$/;"	c	class:folly::gen::detail::Until	inherits:GenImpl	access:public
folly::gen::detail::Until::Generator::Generator	.\gen\Base-inl.h	/^    explicit Generator(Source source, const Predicate& pred)$/;"	f	class:folly::gen::detail::Until::Generator	access:public	signature:(Source source, const Predicate& pred)
folly::gen::detail::Until::Generator::apply	.\gen\Base-inl.h	/^    bool apply(Handler&& handler) const {$/;"	f	class:folly::gen::detail::Until::Generator	access:public	signature:(Handler&& handler) const
folly::gen::detail::Until::Generator::pred_	.\gen\Base-inl.h	/^    Predicate pred_;$/;"	m	class:folly::gen::detail::Until::Generator	access:private
folly::gen::detail::Until::Generator::source_	.\gen\Base-inl.h	/^    Source source_;$/;"	m	class:folly::gen::detail::Until::Generator	access:private
folly::gen::detail::Until::Until	.\gen\Base-inl.h	/^  Until() {}$/;"	f	class:folly::gen::detail::Until	access:public	signature:()
folly::gen::detail::Until::Until	.\gen\Base-inl.h	/^  explicit Until(Predicate pred)$/;"	f	class:folly::gen::detail::Until	access:public	signature:(Predicate pred)
folly::gen::detail::Until::compose	.\gen\Base-inl.h	/^  Gen compose(GenImpl<Value, Source>&& source) const {$/;"	f	class:folly::gen::detail::Until	access:public	signature:(GenImpl<Value, Source>&& source) const
folly::gen::detail::Until::compose	.\gen\Base-inl.h	/^  Gen compose(const GenImpl<Value, Source>& source) const {$/;"	f	class:folly::gen::detail::Until	access:public	signature:(const GenImpl<Value, Source>& source) const
folly::gen::detail::Until::infinite	.\gen\Base-inl.h	/^  static constexpr bool infinite = false;$/;"	m	class:folly::gen::detail::Until	access:public
folly::gen::detail::Until::pred_	.\gen\Base-inl.h	/^  Predicate pred_;$/;"	m	class:folly::gen::detail::Until	access:private
folly::gen::detail::ValueTypeOfRange	.\gen\Base.h	/^struct ValueTypeOfRange {$/;"	s	namespace:folly::gen::detail
folly::gen::detail::ValueTypeOfRange::RefType	.\gen\Base.h	/^    RefType;$/;"	t	struct:folly::gen::detail::ValueTypeOfRange	access:public
folly::gen::detail::ValueTypeOfRange::StorageType	.\gen\Base.h	/^    StorageType;$/;"	t	struct:folly::gen::detail::ValueTypeOfRange	access:public
folly::gen::detail::ValueTypeOfRange::container_	.\gen\Base.h	/^  static Container container_;$/;"	m	struct:folly::gen::detail::ValueTypeOfRange	access:private
folly::gen::detail::Yield	.\gen\Base-inl.h	/^class Yield : public GenImpl<Value, Yield<Value, Source>> {$/;"	c	namespace:folly::gen::detail	inherits:GenImpl
folly::gen::detail::Yield	.\gen\Base.h	/^class Yield;$/;"	x
folly::gen::detail::Yield::Yield	.\gen\Base-inl.h	/^  explicit Yield(Source source)$/;"	f	class:folly::gen::detail::Yield	access:public	signature:(Source source)
folly::gen::detail::Yield::apply	.\gen\Base-inl.h	/^  bool apply(Handler&& handler) const {$/;"	f	class:folly::gen::detail::Yield	access:public	signature:(Handler&& handler) const
folly::gen::detail::Yield::foreach	.\gen\Base-inl.h	/^  void foreach(Body&& body) const {$/;"	f	class:folly::gen::detail::Yield	access:public	signature:(Body&& body) const
folly::gen::detail::Yield::source_	.\gen\Base-inl.h	/^  Source source_;$/;"	m	class:folly::gen::detail::Yield	access:private
folly::gen::detail::Zip	.\gen\Combine-inl.h	/^class Zip : public Operator<Zip<Container>> {$/;"	c	namespace:folly::gen::detail	inherits:Operator
folly::gen::detail::Zip	.\gen\Combine.h	/^class Zip;$/;"	x
folly::gen::detail::Zip::Generator	.\gen\Combine-inl.h	/^  class Generator : public GenImpl<Result,$/;"	c	class:folly::gen::detail::Zip	inherits:GenImpl	access:public
folly::gen::detail::Zip::Generator::Generator	.\gen\Combine-inl.h	/^    explicit Generator(Source source,$/;"	f	class:folly::gen::detail::Zip::Generator	access:public	signature:(Source source, const std::shared_ptr<const Container> container)
folly::gen::detail::Zip::Generator::apply	.\gen\Combine-inl.h	/^    bool apply(Handler&& handler) const {$/;"	f	class:folly::gen::detail::Zip::Generator	access:public	signature:(Handler&& handler) const
folly::gen::detail::Zip::Generator::container_	.\gen\Combine-inl.h	/^    const std::shared_ptr<const Container> container_;$/;"	m	class:folly::gen::detail::Zip::Generator	access:private
folly::gen::detail::Zip::Generator::source_	.\gen\Combine-inl.h	/^    Source source_;$/;"	m	class:folly::gen::detail::Zip::Generator	access:private
folly::gen::detail::Zip::Zip	.\gen\Combine-inl.h	/^  explicit Zip(Container container)$/;"	f	class:folly::gen::detail::Zip	access:public	signature:(Container container)
folly::gen::detail::Zip::compose	.\gen\Combine-inl.h	/^  Gen compose(GenImpl<Value, Source>&& source) const {$/;"	f	class:folly::gen::detail::Zip	access:public	signature:(GenImpl<Value, Source>&& source) const
folly::gen::detail::Zip::compose	.\gen\Combine-inl.h	/^  Gen compose(const GenImpl<Value, Source>& source) const {$/;"	f	class:folly::gen::detail::Zip	access:public	signature:(const GenImpl<Value, Source>& source) const
folly::gen::detail::Zip::container_	.\gen\Combine-inl.h	/^  const std::shared_ptr<const Container> container_;$/;"	m	class:folly::gen::detail::Zip	access:private
folly::gen::detail::ch	.\gen\String-inl.h	/^inline const char* ch(const unsigned char* p) {$/;"	f	namespace:folly::gen::detail	signature:(const unsigned char* p)
folly::gen::detail::consumeBufferPlus	.\gen\String-inl.h	/^bool consumeBufferPlus(Callback& cb, IOBuf& buf, StringPiece& s, uint64_t n) {$/;"	f	namespace:folly::gen::detail	signature:(Callback& cb, IOBuf& buf, StringPiece& s, uint64_t n)
folly::gen::detail::consumeFixedSizeChunks	.\gen\String-inl.h	/^bool consumeFixedSizeChunks(Callback& cb, StringPiece& s, uint64_t maxLength) {$/;"	f	namespace:folly::gen::detail	signature:(Callback& cb, StringPiece& s, uint64_t maxLength)
folly::gen::detail::passthrough	.\gen\String-inl.h	/^inline Target passthrough(Target target) { return target; }$/;"	f	namespace:folly::gen::detail	signature:(Target target)
folly::gen::detail::splitPrefix	.\gen\String-inl.h	/^inline size_t splitPrefix(StringPiece& in,$/;"	f	namespace:folly::gen::detail	signature:(StringPiece& in, StringPiece& prefix, MixedNewlines)
folly::gen::detail::splitPrefix	.\gen\String-inl.h	/^inline size_t splitPrefix(StringPiece& in,$/;"	f	namespace:folly::gen::detail	signature:(StringPiece& in, StringPiece& prefix, StringPiece delimiter)
folly::gen::detail::splitPrefix	.\gen\String-inl.h	/^inline size_t splitPrefix(StringPiece& in,$/;"	f	namespace:folly::gen::detail	signature:(StringPiece& in, StringPiece& prefix, char delimiter)
folly::gen::detail::std::forward	.\gen\Combine-inl.h	/^                         std::forward<Type2>(t2))) {$/;"	f	class:folly::gen::detail::std	signature:(t2)
folly::gen::detail::std::forward	.\gen\Combine-inl.h	/^                        std::make_tuple(std::forward<Type2>(t2)))) {$/;"	f	class:folly::gen::detail::std	signature:(t2)
folly::gen::detail::std::move	.\gen\Combine-inl.h	/^                        std::move(t2))) {$/;"	f	class:folly::gen::detail::std	signature:(t2)
folly::gen::distinct	.\gen\Base-inl.h	/^static const detail::Distinct<Identity> distinct;$/;"	m	namespace:folly::gen
folly::gen::distinctBy	.\gen\Base.h	/^Distinct distinctBy(Selector selector = Identity()) {$/;"	f	namespace:folly::gen	signature:(Selector selector = Identity())
folly::gen::eachAs	.\gen\Base.h	/^Cast eachAs() {$/;"	f	namespace:folly::gen	signature:()
folly::gen::eachTo	.\gen\Base.h	/^To eachTo() {$/;"	f	namespace:folly::gen	signature:()
folly::gen::eachToPair	.\gen\String.h	/^eachToPair(StringPiece delim) {$/;"	f	namespace:folly::gen	signature:(StringPiece delim)
folly::gen::eachToPair	.\gen\String.h	/^eachToPair(char delim) {$/;"	f	namespace:folly::gen	signature:(char delim)
folly::gen::eachToTuple	.\gen\String.h	/^eachToTuple(StringPiece delim) {$/;"	f	namespace:folly::gen	signature:(StringPiece delim)
folly::gen::eachToTuple	.\gen\String.h	/^eachToTuple(char delim) {$/;"	f	namespace:folly::gen	signature:(char delim)
folly::gen::empty	.\gen\Base.h	/^detail::Empty<Value> empty() {$/;"	f	namespace:folly::gen	signature:()
folly::gen::field	.\gen\Base.h	/^Map field(FieldType Class::*field) {$/;"	f	namespace:folly::gen	signature:(FieldType Class::*field)
folly::gen::filter	.\gen\Base.h	/^Filter filter(Predicate pred = Predicate()) {$/;"	f	namespace:folly::gen	signature:(Predicate pred = Predicate())
folly::gen::first	.\gen\Base-inl.h	/^static const detail::First first;$/;"	m	namespace:folly::gen
folly::gen::foldl	.\gen\Base.h	/^FoldLeft foldl(Seed seed = Seed(),$/;"	f	namespace:folly::gen	signature:(Seed seed = Seed(), Fold fold = Fold())
folly::gen::from	.\gen\Base.h	/^From from(Container& source) {$/;"	f	namespace:folly::gen	signature:(Container& source)
folly::gen::from	.\gen\Base.h	/^From from(Container&& source) {$/;"	f	namespace:folly::gen	signature:(Container&& source)
folly::gen::from	.\gen\Base.h	/^From from(std::initializer_list<Value> source) {$/;"	f	namespace:folly::gen	signature:(std::initializer_list<Value> source)
folly::gen::fromConst	.\gen\Base.h	/^From fromConst(const Container& source) {$/;"	f	namespace:folly::gen	signature:(const Container& source)
folly::gen::fromCopy	.\gen\Base.h	/^CopyOf fromCopy(Container&& source) {$/;"	f	namespace:folly::gen	signature:(Container&& source)
folly::gen::fromFile	.\gen\File.h	/^S fromFile(File file, size_t bufferSize=4096) {$/;"	f	namespace:folly::gen	signature:(File file, size_t bufferSize=4096)
folly::gen::fromFile	.\gen\File.h	/^S fromFile(File file, std::unique_ptr<IOBuf> buffer) {$/;"	f	namespace:folly::gen	signature:(File file, std::unique_ptr<IOBuf> buffer)
folly::gen::generator	.\gen\Base.h	/^Yield generator(Source&& source) {$/;"	f	namespace:folly::gen	signature:(Source&& source)
folly::gen::get	.\gen\Base.h	/^Get get() {$/;"	f	namespace:folly::gen	signature:()
folly::gen::guard	.\gen\Base.h	/^GuardImpl guard(ErrorHandler&& handler) {$/;"	f	namespace:folly::gen	signature:(ErrorHandler&& handler)
folly::gen::interleave	.\gen\Combine.h	/^Interleave interleave(Source2&& source2) {$/;"	f	namespace:folly::gen	signature:(Source2&& source2)
folly::gen::just	.\gen\Base.h	/^detail::Just<Value> just(Value value) {$/;"	f	namespace:folly::gen	signature:(Value value)
folly::gen::lines	.\gen\String.h	/^S lines(StringPiece source) {$/;"	f	namespace:folly::gen	signature:(StringPiece source)
folly::gen::map	.\gen\Base.h	/^Map map(Predicate pred = Predicate()) {$/;"	f	namespace:folly::gen	signature:(Predicate pred = Predicate())
folly::gen::mapOp	.\gen\Base.h	/^Map mapOp(Operator op) {$/;"	f	namespace:folly::gen	signature:(Operator op)
folly::gen::mapped	.\gen\Base.h	/^Map mapped(Predicate pred = Predicate()) {$/;"	f	namespace:folly::gen	signature:(Predicate pred = Predicate())
folly::gen::max	.\gen\Base-inl.h	/^static const detail::Min<Identity, Greater> max;$/;"	m	namespace:folly::gen
folly::gen::maxBy	.\gen\Base.h	/^MaxBy maxBy(Selector selector = Selector()) {$/;"	f	namespace:folly::gen	signature:(Selector selector = Selector())
folly::gen::min	.\gen\Base-inl.h	/^static const detail::Min<Identity, Less> min;$/;"	m	namespace:folly::gen
folly::gen::minBy	.\gen\Base.h	/^Min minBy(Selector selector = Selector()) {$/;"	f	namespace:folly::gen	signature:(Selector selector = Selector())
folly::gen::move	.\gen\Base-inl.h	/^static const detail::Map<Move> move;$/;"	m	namespace:folly::gen
folly::gen::operator +	.\gen\Core-inl.h	/^Chain operator+(GenImpl<LeftValue, Left>&& left,$/;"	f	namespace:folly::gen	signature:(GenImpl<LeftValue, Left>&& left, GenImpl<RightValue, Right>&& right)
folly::gen::operator +	.\gen\Core-inl.h	/^Chain operator+(GenImpl<LeftValue, Left>&& left,$/;"	f	namespace:folly::gen	signature:(GenImpl<LeftValue, Left>&& left, const GenImpl<RightValue, Right>& right)
folly::gen::operator +	.\gen\Core-inl.h	/^Chain operator+(const GenImpl<LeftValue, Left>& left,$/;"	f	namespace:folly::gen	signature:(const GenImpl<LeftValue, Left>& left, GenImpl<RightValue, Right>&& right)
folly::gen::operator +	.\gen\Core-inl.h	/^Chain operator+(const GenImpl<LeftValue, Left>& left,$/;"	f	namespace:folly::gen	signature:(const GenImpl<LeftValue, Left>& left, const GenImpl<RightValue, Right>& right)
folly::gen::operator |	.\gen\Core-inl.h	/^Composed operator|(Operator<Left>&& left,$/;"	f	namespace:folly::gen	signature:(Operator<Left>&& left, Operator<Right>&& right)
folly::gen::operator |	.\gen\Core-inl.h	/^Composed operator|(Operator<Left>&& left,$/;"	f	namespace:folly::gen	signature:(Operator<Left>&& left, const Operator<Right>& right)
folly::gen::operator |	.\gen\Core-inl.h	/^Composed operator|(const Operator<Left>& left,$/;"	f	namespace:folly::gen	signature:(const Operator<Left>& left, Operator<Right>&& right)
folly::gen::operator |	.\gen\Core-inl.h	/^Composed operator|(const Operator<Left>& left,$/;"	f	namespace:folly::gen	signature:(const Operator<Left>& left, const Operator<Right>& right)
folly::gen::operator |	.\gen\Core-inl.h	/^operator|(const GenImpl<Value, Gen>& gen, Handler&& handler) {$/;"	f	namespace:folly::gen	signature:(const GenImpl<Value, Gen>& gen, Handler&& handler)
folly::gen::order	.\gen\Base-inl.h	/^static const detail::Order<Identity> order;$/;"	m	namespace:folly::gen
folly::gen::orderBy	.\gen\Base.h	/^Order orderBy(Selector selector = Identity(),$/;"	f	namespace:folly::gen	signature:(Selector selector = Identity(), Comparer comparer = Comparer())
folly::gen::orderByDescending	.\gen\Base.h	/^Order orderByDescending(Selector selector = Identity()) {$/;"	f	namespace:folly::gen	signature:(Selector selector = Identity())
folly::gen::parallel	.\gen\Parallel.h	/^Parallel parallel(Ops ops, size_t threads = 0) {$/;"	f	namespace:folly::gen	signature:(Ops ops, size_t threads = 0)
folly::gen::pmap	.\gen\ParallelMap.h	/^  PMap pmap(Predicate pred = Predicate(), size_t nThreads = 0) {$/;"	f	namespace:folly::gen	signature:(Predicate pred = Predicate(), size_t nThreads = 0)
folly::gen::range	.\gen\Base.h	/^Gen range(Value begin, Value end) {$/;"	f	namespace:folly::gen	signature:(Value begin, Value end)
folly::gen::range	.\gen\Base.h	/^Gen range(Value begin, Value end, Distance step) {$/;"	f	namespace:folly::gen	signature:(Value begin, Value end, Distance step)
folly::gen::rconcat	.\gen\Base-inl.h	/^static const detail::RangeConcat rconcat;$/;"	m	namespace:folly::gen
folly::gen::reduce	.\gen\Base.h	/^Reduce reduce(Reducer reducer = Reducer()) {$/;"	f	namespace:folly::gen	signature:(Reducer reducer = Reducer())
folly::gen::resplit	.\gen\File-inl.h	/^                | resplit(delim)) {$/;"	f	namespace:folly::gen	signature:(delim)
folly::gen::resplit	.\gen\String.h	/^S resplit(char delimiter) {$/;"	f	namespace:folly::gen	signature:(char delimiter)
folly::gen::sample	.\gen\Base-inl.h	/^inline detail::Sample<Random> sample(size_t count, Random rng = Random()) {$/;"	f	namespace:folly::gen	signature:(size_t count, Random rng = Random())
folly::gen::seq	.\gen\Base.h	/^Gen seq(Value first) {$/;"	f	namespace:folly::gen	signature:(Value first)
folly::gen::seq	.\gen\Base.h	/^Gen seq(Value first, Value last) {$/;"	f	namespace:folly::gen	signature:(Value first, Value last)
folly::gen::seq	.\gen\Base.h	/^Gen seq(Value first, Value last, Distance step) {$/;"	f	namespace:folly::gen	signature:(Value first, Value last, Distance step)
folly::gen::skip	.\gen\Base-inl.h	/^inline detail::Skip skip(size_t count) {$/;"	f	namespace:folly::gen	signature:(size_t count)
folly::gen::split	.\gen\String.h	/^S split(StringPiece source, StringPiece delimiter) {$/;"	f	namespace:folly::gen	signature:(StringPiece source, StringPiece delimiter)
folly::gen::split	.\gen\String.h	/^S split(const StringPiece& source, char delimiter) {$/;"	f	namespace:folly::gen	signature:(const StringPiece& source, char delimiter)
folly::gen::streamSplitter	.\gen\String.h	/^StreamSplitter<Callback> streamSplitter(char delimiter,$/;"	f	namespace:folly::gen	signature:(char delimiter, Callback&& pieceCb, uint64_t capacity = 0)
folly::gen::stride	.\gen\Base-inl.h	/^inline detail::Stride stride(size_t s) {$/;"	f	namespace:folly::gen	signature:(size_t s)
folly::gen::sub	.\gen\Parallel.h	/^Sub sub(Sink sink) {$/;"	f	namespace:folly::gen	signature:(Sink sink)
folly::gen::sum	.\gen\Base-inl.h	/^static const detail::Sum sum;$/;"	m	namespace:folly::gen
folly::gen::take	.\gen\Base-inl.h	/^inline detail::Take take(size_t count) {$/;"	f	namespace:folly::gen	signature:(size_t count)
folly::gen::toFile	.\gen\File.h	/^S toFile(File file, size_t bufferSize=4096) {$/;"	f	namespace:folly::gen	signature:(File file, size_t bufferSize=4096)
folly::gen::toFile	.\gen\File.h	/^S toFile(File file, std::unique_ptr<IOBuf> buffer) {$/;"	f	namespace:folly::gen	signature:(File file, std::unique_ptr<IOBuf> buffer)
folly::gen::tuple_flatten	.\gen\Combine-inl.h	/^static const detail::Map<detail::MergeTuples> tuple_flatten;$/;"	m	namespace:folly::gen
folly::gen::unsplit	.\gen\String.h	/^Unsplit unsplit(const Delimiter& delimiter) {$/;"	f	namespace:folly::gen	signature:(const Delimiter& delimiter)
folly::gen::unsplit	.\gen\String.h	/^Unsplit unsplit(const char* delimiter) {$/;"	f	namespace:folly::gen	signature:(const char* delimiter)
folly::gen::unsplit	.\gen\String.h	/^UnsplitBuffer unsplit(Delimiter delimiter, OutputBuffer* outputBuffer) {$/;"	f	namespace:folly::gen	signature:(Delimiter delimiter, OutputBuffer* outputBuffer)
folly::gen::unsplit	.\gen\String.h	/^UnsplitBuffer unsplit(const char* delimiter, OutputBuffer* outputBuffer) {$/;"	f	namespace:folly::gen	signature:(const char* delimiter, OutputBuffer* outputBuffer)
folly::gen::until	.\gen\Base.h	/^Until until(Predicate pred = Predicate()) {$/;"	f	namespace:folly::gen	signature:(Predicate pred = Predicate())
folly::gen::zip	.\gen\Combine-inl.h	/^Zip zip(Source&& source) {$/;"	f	namespace:folly::gen	signature:(Source&& source)
folly::getCapacity	.\small_vector.h	/^    InternalSizeType* getCapacity() const {$/;"	f	namespace:folly	signature:() const
folly::getCapacity	.\small_vector.h	/^    InternalSizeType* getCapacity() {$/;"	f	namespace:folly	signature:()
folly::getHugePageSize	.\experimental\io\HugePages.cpp	/^const HugePageSize* getHugePageSize(size_t size) {$/;"	f	namespace:folly	signature:(size_t size)
folly::getHugePageSize	.\experimental\io\HugePages.h	/^const HugePageSize* getHugePageSize(size_t size = 0);$/;"	p	namespace:folly	signature:(size_t size = 0)
folly::getHugePageSizeForDevice	.\experimental\io\HugePages.cpp	/^const HugePageSize* getHugePageSizeForDevice(dev_t device) {$/;"	f	namespace:folly	signature:(dev_t device)
folly::getHugePageSizeForDevice	.\experimental\io\HugePages.h	/^const HugePageSize* getHugePageSizeForDevice(dev_t device);$/;"	p	namespace:folly	signature:(dev_t device)
folly::getHugePageSizes	.\experimental\io\HugePages.cpp	/^const HugePageSizeVec& getHugePageSizes() {$/;"	f	namespace:folly	signature:()
folly::getHugePageSizes	.\experimental\io\HugePages.h	/^const HugePageSizeVec& getHugePageSizes();$/;"	p	namespace:folly	signature:()
folly::getTimeDelta	.\io\async\EventBase.cpp	/^getTimeDelta(std::chrono::steady_clock::time_point* prev) {$/;"	f	namespace:folly	signature:(std::chrono::steady_clock::time_point* prev)
folly::get_default	.\MapUtil.h	/^typename Map::mapped_type get_default($/;"	f	namespace:folly	signature:( const Map& map, const typename Map::key_type& key, const typename Map::mapped_type& dflt = typename Map::mapped_type())
folly::get_pointer	.\Optional.h	/^T* get_pointer(Optional<T>& opt) {$/;"	f	namespace:folly	signature:(Optional<T>& opt)
folly::get_pointer	.\Optional.h	/^const T* get_pointer(const Optional<T>& opt) {$/;"	f	namespace:folly	signature:(const Optional<T>& opt)
folly::get_ptr	.\MapUtil.h	/^const typename Map::mapped_type* get_ptr($/;"	f	namespace:folly	signature:( const Map& map, const typename Map::key_type& key)
folly::get_ptr	.\MapUtil.h	/^typename Map::mapped_type* get_ptr($/;"	f	namespace:folly	signature:( Map& map, const typename Map::key_type& key)
folly::get_ref_default	.\MapUtil.h	/^const typename Map::mapped_type& get_ref_default($/;"	f	namespace:folly	signature:( const Map& map, const typename Map::key_type& key, const typename Map::mapped_type& dflt)
folly::globalCount	.\test\LazyTest.cpp	/^auto globalCount = folly::lazy([]{ return 0; });$/;"	m	namespace:folly	file:
folly::globalHead_	.\IndexedMemPool.h	/^  AtomicStruct<TaggedPtr,Atom> FOLLY_ALIGN_TO_AVOID_FALSE_SHARING globalHead_;$/;"	m	namespace:folly
folly::globalPop	.\IndexedMemPool.h	/^  uint32_t globalPop() {$/;"	f	namespace:folly	signature:()
folly::globalPush	.\IndexedMemPool.h	/^  void globalPush(Slot& s, uint32_t localHead) {$/;"	f	namespace:folly	signature:(Slot& s, uint32_t localHead)
folly::greater_than	.\Traits.h	/^bool greater_than(LHS const lhs) {$/;"	f	namespace:folly	signature:(LHS const lhs)
folly::hasCapacity	.\small_vector.h	/^    bool hasCapacity() const {$/;"	f	namespace:folly	signature:() const
folly::hash	.\Hash.h	/^namespace folly { namespace hash {$/;"	n	namespace:folly
folly::hash	.\SpookyHashV1.cpp	/^namespace hash {$/;"	n	namespace:folly	file:
folly::hash	.\SpookyHashV1.h	/^namespace hash {$/;"	n	namespace:folly
folly::hash	.\SpookyHashV2.cpp	/^namespace hash {$/;"	n	namespace:folly	file:
folly::hash	.\SpookyHashV2.h	/^namespace hash {$/;"	n	namespace:folly
folly::hash::FNV_32_HASH_START	.\Hash.h	/^const uint32_t FNV_32_HASH_START = 2166136261UL;$/;"	m	namespace:folly::hash
folly::hash::FNV_64_HASH_START	.\Hash.h	/^const uint64_t FNV_64_HASH_START = 14695981039346656037ULL;$/;"	m	namespace:folly::hash
folly::hash::SpookyHashV1	.\SpookyHashV1.h	/^class SpookyHashV1$/;"	c	namespace:folly::hash
folly::hash::SpookyHashV1::End	.\SpookyHashV1.h	/^    static inline void End($/;"	f	class:folly::hash::SpookyHashV1	access:public	signature:( uint64_t &h0, uint64_t &h1, uint64_t &h2, uint64_t &h3, uint64_t &h4, uint64_t &h5, uint64_t &h6, uint64_t &h7, uint64_t &h8, uint64_t &h9, uint64_t &h10,uint64_t &h11)
folly::hash::SpookyHashV1::EndPartial	.\SpookyHashV1.h	/^    static inline void EndPartial($/;"	f	class:folly::hash::SpookyHashV1	access:public	signature:( uint64_t &h0, uint64_t &h1, uint64_t &h2, uint64_t &h3, uint64_t &h4, uint64_t &h5, uint64_t &h6, uint64_t &h7, uint64_t &h8, uint64_t &h9, uint64_t &h10,uint64_t &h11)
folly::hash::SpookyHashV1::Final	.\SpookyHashV1.cpp	/^void SpookyHashV1::Final(uint64_t *hash1, uint64_t *hash2)$/;"	f	class:folly::hash::SpookyHashV1	signature:(uint64_t *hash1, uint64_t *hash2)
folly::hash::SpookyHashV1::Final	.\SpookyHashV1.h	/^    void Final($/;"	p	class:folly::hash::SpookyHashV1	access:public	signature:( uint64_t *hash1, uint64_t *hash2)
folly::hash::SpookyHashV1::Hash128	.\SpookyHashV1.cpp	/^void SpookyHashV1::Hash128($/;"	f	class:folly::hash::SpookyHashV1	signature:( const void *message, size_t length, uint64_t *hash1, uint64_t *hash2)
folly::hash::SpookyHashV1::Hash128	.\SpookyHashV1.h	/^    static void Hash128($/;"	p	class:folly::hash::SpookyHashV1	access:public	signature:( const void *message, size_t length, uint64_t *hash1, uint64_t *hash2)
folly::hash::SpookyHashV1::Hash32	.\SpookyHashV1.h	/^    static uint32_t Hash32($/;"	f	class:folly::hash::SpookyHashV1	access:public	signature:( const void *message, size_t length, uint32_t seed)
folly::hash::SpookyHashV1::Hash64	.\SpookyHashV1.h	/^    static uint64_t Hash64($/;"	f	class:folly::hash::SpookyHashV1	access:public	signature:( const void *message, size_t length, uint64_t seed)
folly::hash::SpookyHashV1::Init	.\SpookyHashV1.cpp	/^void SpookyHashV1::Init(uint64_t seed1, uint64_t seed2)$/;"	f	class:folly::hash::SpookyHashV1	signature:(uint64_t seed1, uint64_t seed2)
folly::hash::SpookyHashV1::Init	.\SpookyHashV1.h	/^    void Init($/;"	p	class:folly::hash::SpookyHashV1	access:public	signature:( uint64_t seed1, uint64_t seed2)
folly::hash::SpookyHashV1::Mix	.\SpookyHashV1.h	/^    static inline void Mix($/;"	f	class:folly::hash::SpookyHashV1	access:public	signature:( const uint64_t *data, uint64_t &s0, uint64_t &s1, uint64_t &s2, uint64_t &s3, uint64_t &s4, uint64_t &s5, uint64_t &s6, uint64_t &s7, uint64_t &s8, uint64_t &s9, uint64_t &s10,uint64_t &s11)
folly::hash::SpookyHashV1::Rot64	.\SpookyHashV1.h	/^    static inline uint64_t Rot64(uint64_t x, int k)$/;"	f	class:folly::hash::SpookyHashV1	access:public	signature:(uint64_t x, int k)
folly::hash::SpookyHashV1::Short	.\SpookyHashV1.cpp	/^void SpookyHashV1::Short($/;"	f	class:folly::hash::SpookyHashV1	signature:( const void *message, size_t length, uint64_t *hash1, uint64_t *hash2)
folly::hash::SpookyHashV1::Short	.\SpookyHashV1.h	/^    static void Short($/;"	p	class:folly::hash::SpookyHashV1	access:private	signature:( const void *message, size_t length, uint64_t *hash1, uint64_t *hash2)
folly::hash::SpookyHashV1::ShortEnd	.\SpookyHashV1.h	/^    static inline void ShortEnd(uint64_t &h0, uint64_t &h1, uint64_t &h2, uint64_t &h3)$/;"	f	class:folly::hash::SpookyHashV1	access:public	signature:(uint64_t &h0, uint64_t &h1, uint64_t &h2, uint64_t &h3)
folly::hash::SpookyHashV1::ShortMix	.\SpookyHashV1.h	/^    static inline void ShortMix(uint64_t &h0, uint64_t &h1, uint64_t &h2, uint64_t &h3)$/;"	f	class:folly::hash::SpookyHashV1	access:public	signature:(uint64_t &h0, uint64_t &h1, uint64_t &h2, uint64_t &h3)
folly::hash::SpookyHashV1::Update	.\SpookyHashV1.cpp	/^void SpookyHashV1::Update(const void *message, size_t length)$/;"	f	class:folly::hash::SpookyHashV1	signature:(const void *message, size_t length)
folly::hash::SpookyHashV1::Update	.\SpookyHashV1.h	/^    void Update($/;"	p	class:folly::hash::SpookyHashV1	access:public	signature:( const void *message, size_t length)
folly::hash::SpookyHashV1::m_data	.\SpookyHashV1.h	/^    uint64_t m_data[2*sc_numVars];  \/\/ unhashed data, for partial messages$/;"	m	class:folly::hash::SpookyHashV1	access:private
folly::hash::SpookyHashV1::m_length	.\SpookyHashV1.h	/^    size_t m_length;                \/\/ total length of the input so far$/;"	m	class:folly::hash::SpookyHashV1	access:private
folly::hash::SpookyHashV1::m_remainder	.\SpookyHashV1.h	/^    uint8_t  m_remainder;           \/\/ length of unhashed data stashed in m_data$/;"	m	class:folly::hash::SpookyHashV1	access:private
folly::hash::SpookyHashV1::m_state	.\SpookyHashV1.h	/^    uint64_t m_state[sc_numVars];   \/\/ internal state of the hash$/;"	m	class:folly::hash::SpookyHashV1	access:private
folly::hash::SpookyHashV1::sc_blockSize	.\SpookyHashV1.h	/^    static const size_t sc_blockSize = sc_numVars*8;$/;"	m	class:folly::hash::SpookyHashV1	access:private
folly::hash::SpookyHashV1::sc_bufSize	.\SpookyHashV1.h	/^    static const size_t sc_bufSize = 2*sc_blockSize;$/;"	m	class:folly::hash::SpookyHashV1	access:private
folly::hash::SpookyHashV1::sc_const	.\SpookyHashV1.h	/^    static const uint64_t sc_const = 0xdeadbeefdeadbeefLL;$/;"	m	class:folly::hash::SpookyHashV1	access:private
folly::hash::SpookyHashV1::sc_numVars	.\SpookyHashV1.h	/^    static const size_t sc_numVars = 12;$/;"	m	class:folly::hash::SpookyHashV1	access:private
folly::hash::SpookyHashV2	.\SpookyHashV2.h	/^class SpookyHashV2$/;"	c	namespace:folly::hash
folly::hash::SpookyHashV2::End	.\SpookyHashV2.h	/^    static inline void End($/;"	f	class:folly::hash::SpookyHashV2	access:public	signature:( const uint64_t *data, uint64_t &h0, uint64_t &h1, uint64_t &h2, uint64_t &h3, uint64_t &h4, uint64_t &h5, uint64_t &h6, uint64_t &h7, uint64_t &h8, uint64_t &h9, uint64_t &h10,uint64_t &h11)
folly::hash::SpookyHashV2::EndPartial	.\SpookyHashV2.h	/^    static inline void EndPartial($/;"	f	class:folly::hash::SpookyHashV2	access:public	signature:( uint64_t &h0, uint64_t &h1, uint64_t &h2, uint64_t &h3, uint64_t &h4, uint64_t &h5, uint64_t &h6, uint64_t &h7, uint64_t &h8, uint64_t &h9, uint64_t &h10,uint64_t &h11)
folly::hash::SpookyHashV2::Final	.\SpookyHashV2.cpp	/^void SpookyHashV2::Final(uint64_t *hash1, uint64_t *hash2)$/;"	f	class:folly::hash::SpookyHashV2	signature:(uint64_t *hash1, uint64_t *hash2)
folly::hash::SpookyHashV2::Final	.\SpookyHashV2.h	/^    void Final($/;"	p	class:folly::hash::SpookyHashV2	access:public	signature:( uint64_t *hash1, uint64_t *hash2)
folly::hash::SpookyHashV2::Hash128	.\SpookyHashV2.cpp	/^void SpookyHashV2::Hash128($/;"	f	class:folly::hash::SpookyHashV2	signature:( const void *message, size_t length, uint64_t *hash1, uint64_t *hash2)
folly::hash::SpookyHashV2::Hash128	.\SpookyHashV2.h	/^    static void Hash128($/;"	p	class:folly::hash::SpookyHashV2	access:public	signature:( const void *message, size_t length, uint64_t *hash1, uint64_t *hash2)
folly::hash::SpookyHashV2::Hash32	.\SpookyHashV2.h	/^    static uint32_t Hash32($/;"	f	class:folly::hash::SpookyHashV2	access:public	signature:( const void *message, size_t length, uint32_t seed)
folly::hash::SpookyHashV2::Hash64	.\SpookyHashV2.h	/^    static uint64_t Hash64($/;"	f	class:folly::hash::SpookyHashV2	access:public	signature:( const void *message, size_t length, uint64_t seed)
folly::hash::SpookyHashV2::Init	.\SpookyHashV2.cpp	/^void SpookyHashV2::Init(uint64_t seed1, uint64_t seed2)$/;"	f	class:folly::hash::SpookyHashV2	signature:(uint64_t seed1, uint64_t seed2)
folly::hash::SpookyHashV2::Init	.\SpookyHashV2.h	/^    void Init($/;"	p	class:folly::hash::SpookyHashV2	access:public	signature:( uint64_t seed1, uint64_t seed2)
folly::hash::SpookyHashV2::Mix	.\SpookyHashV2.h	/^    static inline void Mix($/;"	f	class:folly::hash::SpookyHashV2	access:public	signature:( const uint64_t *data, uint64_t &s0, uint64_t &s1, uint64_t &s2, uint64_t &s3, uint64_t &s4, uint64_t &s5, uint64_t &s6, uint64_t &s7, uint64_t &s8, uint64_t &s9, uint64_t &s10,uint64_t &s11)
folly::hash::SpookyHashV2::Rot64	.\SpookyHashV2.h	/^    static inline uint64_t Rot64(uint64_t x, int k)$/;"	f	class:folly::hash::SpookyHashV2	access:public	signature:(uint64_t x, int k)
folly::hash::SpookyHashV2::Short	.\SpookyHashV2.cpp	/^void SpookyHashV2::Short($/;"	f	class:folly::hash::SpookyHashV2	signature:( const void *message, size_t length, uint64_t *hash1, uint64_t *hash2)
folly::hash::SpookyHashV2::Short	.\SpookyHashV2.h	/^    static void Short($/;"	p	class:folly::hash::SpookyHashV2	access:private	signature:( const void *message, size_t length, uint64_t *hash1, uint64_t *hash2)
folly::hash::SpookyHashV2::ShortEnd	.\SpookyHashV2.h	/^    static inline void ShortEnd(uint64_t &h0, uint64_t &h1, uint64_t &h2, uint64_t &h3)$/;"	f	class:folly::hash::SpookyHashV2	access:public	signature:(uint64_t &h0, uint64_t &h1, uint64_t &h2, uint64_t &h3)
folly::hash::SpookyHashV2::ShortMix	.\SpookyHashV2.h	/^    static inline void ShortMix(uint64_t &h0, uint64_t &h1, uint64_t &h2, uint64_t &h3)$/;"	f	class:folly::hash::SpookyHashV2	access:public	signature:(uint64_t &h0, uint64_t &h1, uint64_t &h2, uint64_t &h3)
folly::hash::SpookyHashV2::Update	.\SpookyHashV2.cpp	/^void SpookyHashV2::Update(const void *message, size_t length)$/;"	f	class:folly::hash::SpookyHashV2	signature:(const void *message, size_t length)
folly::hash::SpookyHashV2::Update	.\SpookyHashV2.h	/^    void Update($/;"	p	class:folly::hash::SpookyHashV2	access:public	signature:( const void *message, size_t length)
folly::hash::SpookyHashV2::m_data	.\SpookyHashV2.h	/^    uint64_t m_data[2*sc_numVars];   \/\/ unhashed data, for partial messages$/;"	m	class:folly::hash::SpookyHashV2	access:private
folly::hash::SpookyHashV2::m_length	.\SpookyHashV2.h	/^    size_t m_length;             \/\/ total length of the input so far$/;"	m	class:folly::hash::SpookyHashV2	access:private
folly::hash::SpookyHashV2::m_remainder	.\SpookyHashV2.h	/^    uint8_t  m_remainder;          \/\/ length of unhashed data stashed in m_data$/;"	m	class:folly::hash::SpookyHashV2	access:private
folly::hash::SpookyHashV2::m_state	.\SpookyHashV2.h	/^    uint64_t m_state[sc_numVars];  \/\/ internal state of the hash$/;"	m	class:folly::hash::SpookyHashV2	access:private
folly::hash::SpookyHashV2::sc_blockSize	.\SpookyHashV2.h	/^    static const size_t sc_blockSize = sc_numVars*8;$/;"	m	class:folly::hash::SpookyHashV2	access:private
folly::hash::SpookyHashV2::sc_bufSize	.\SpookyHashV2.h	/^    static const size_t sc_bufSize = 2*sc_blockSize;$/;"	m	class:folly::hash::SpookyHashV2	access:private
folly::hash::SpookyHashV2::sc_const	.\SpookyHashV2.h	/^    static const uint64_t sc_const = 0xdeadbeefdeadbeefLL;$/;"	m	class:folly::hash::SpookyHashV2	access:private
folly::hash::SpookyHashV2::sc_numVars	.\SpookyHashV2.h	/^    static const size_t sc_numVars = 12;$/;"	m	class:folly::hash::SpookyHashV2	access:private
folly::hash::StdHasher	.\Hash.h	/^class StdHasher {$/;"	c	namespace:folly::hash
folly::hash::StdHasher::hash	.\Hash.h	/^  static size_t hash(const T& t) {$/;"	f	class:folly::hash::StdHasher	access:public	signature:(const T& t)
folly::hash::fnv32	.\Hash.h	/^inline uint32_t fnv32(const char* s,$/;"	f	namespace:folly::hash	signature:(const char* s, uint32_t hash = FNV_32_HASH_START)
folly::hash::fnv32	.\Hash.h	/^inline uint32_t fnv32(const std::string& str,$/;"	f	namespace:folly::hash	signature:(const std::string& str, uint32_t hash = FNV_32_HASH_START)
folly::hash::fnv32_buf	.\Hash.h	/^inline uint32_t fnv32_buf(const void* buf,$/;"	f	namespace:folly::hash	signature:(const void* buf, int n, uint32_t hash = FNV_32_HASH_START)
folly::hash::fnv64	.\Hash.h	/^inline uint64_t fnv64(const char* s,$/;"	f	namespace:folly::hash	signature:(const char* s, uint64_t hash = FNV_64_HASH_START)
folly::hash::fnv64	.\Hash.h	/^inline uint64_t fnv64(const std::string& str,$/;"	f	namespace:folly::hash	signature:(const std::string& str, uint64_t hash = FNV_64_HASH_START)
folly::hash::fnv64_buf	.\Hash.h	/^inline uint64_t fnv64_buf(const void* buf,$/;"	f	namespace:folly::hash	signature:(const void* buf, int n, uint64_t hash = FNV_64_HASH_START)
folly::hash::hash_128_to_64	.\Hash.h	/^inline size_t hash_128_to_64(const size_t upper, const size_t lower) {$/;"	f	namespace:folly::hash	signature:(const size_t upper, const size_t lower)
folly::hash::hash_combine	.\Hash.h	/^size_t hash_combine(const T& t, const Ts&... ts) {$/;"	f	namespace:folly::hash	signature:(const T& t, const Ts&... ts)
folly::hash::hash_combine_generic	.\Hash.h	/^inline size_t hash_combine_generic() {$/;"	f	namespace:folly::hash	signature:()
folly::hash::hash_combine_generic	.\Hash.h	/^size_t hash_combine_generic(const T& t, const Ts&... ts) {$/;"	f	namespace:folly::hash	signature:(const T& t, const Ts&... ts)
folly::hash::hash_range	.\Hash.h	/^uint64_t hash_range(Iter begin,$/;"	f	namespace:folly::hash	signature:(Iter begin, Iter end, uint64_t hash = 0, Hash hasher = Hash())
folly::hash::hsieh_hash32	.\Hash.h	/^inline uint32_t hsieh_hash32(const char* s) {$/;"	f	namespace:folly::hash	signature:(const char* s)
folly::hash::hsieh_hash32_buf	.\Hash.h	/^inline uint32_t hsieh_hash32_buf(const void* buf, int len) {$/;"	f	namespace:folly::hash	signature:(const void* buf, int len)
folly::hash::hsieh_hash32_str	.\Hash.h	/^inline uint32_t hsieh_hash32_str(const std::string& str) {$/;"	f	namespace:folly::hash	signature:(const std::string& str)
folly::hash::jenkins_rev_mix32	.\Hash.h	/^inline uint32_t jenkins_rev_mix32(uint32_t key) {$/;"	f	namespace:folly::hash	signature:(uint32_t key)
folly::hash::jenkins_rev_unmix32	.\Hash.h	/^inline uint32_t jenkins_rev_unmix32(uint32_t key) {$/;"	f	namespace:folly::hash	signature:(uint32_t key)
folly::hash::twang_32from64	.\Hash.h	/^inline uint32_t twang_32from64(uint64_t key) {$/;"	f	namespace:folly::hash	signature:(uint64_t key)
folly::hash::twang_mix64	.\Hash.h	/^inline uint64_t twang_mix64(uint64_t key) {$/;"	f	namespace:folly::hash	signature:(uint64_t key)
folly::hash::twang_unmix64	.\Hash.h	/^inline uint64_t twang_unmix64(uint64_t key) {$/;"	f	namespace:folly::hash	signature:(uint64_t key)
folly::hash_value	.\IPAddress.cpp	/^size_t hash_value(const IPAddress& addr) {$/;"	f	namespace:folly	signature:(const IPAddress& addr)
folly::hash_value	.\IPAddress.h	/^std::size_t hash_value(const IPAddress& addr);$/;"	p	namespace:folly	signature:(const IPAddress& addr)
folly::hash_value	.\IPAddressV4.cpp	/^size_t hash_value(const IPAddressV4& addr) {$/;"	f	namespace:folly	signature:(const IPAddressV4& addr)
folly::hash_value	.\IPAddressV4.h	/^size_t hash_value(const IPAddressV4& addr);$/;"	p	namespace:folly	signature:(const IPAddressV4& addr)
folly::hash_value	.\IPAddressV6.cpp	/^size_t hash_value(const IPAddressV6& addr) {$/;"	f	namespace:folly	signature:(const IPAddressV6& addr)
folly::hash_value	.\IPAddressV6.h	/^std::size_t hash_value(const IPAddressV6& addr);$/;"	p	namespace:folly	signature:(const IPAddressV6& addr)
folly::hash_value	.\SocketAddress.cpp	/^size_t hash_value(const SocketAddress& address) {$/;"	f	namespace:folly	signature:(const SocketAddress& address)
folly::hash_value	.\SocketAddress.h	/^size_t hash_value(const SocketAddress& address);$/;"	p	namespace:folly	signature:(const SocketAddress& address)
folly::hasher	.\Hash.h	/^struct hasher;$/;"	x
folly::hasher	.\Hash.h	/^template<> struct hasher<int32_t> {$/;"	s	namespace:folly
folly::hasher	.\Hash.h	/^template<> struct hasher<int64_t> {$/;"	s	namespace:folly
folly::hasher	.\Hash.h	/^template<> struct hasher<uint32_t> {$/;"	s	namespace:folly
folly::hasher	.\Hash.h	/^template<> struct hasher<uint64_t> {$/;"	s	namespace:folly
folly::hasher::operator ()	.\Hash.h	/^  size_t operator()(int32_t key) const {$/;"	f	struct:folly::hasher	access:public	signature:(int32_t key) const
folly::hasher::operator ()	.\Hash.h	/^  size_t operator()(int64_t key) const {$/;"	f	struct:folly::hasher	access:public	signature:(int64_t key) const
folly::hasher::operator ()	.\Hash.h	/^  size_t operator()(uint32_t key) const {$/;"	f	struct:folly::hasher	access:public	signature:(uint32_t key) const
folly::hasher::operator ()	.\Hash.h	/^  size_t operator()(uint64_t key) const {$/;"	f	struct:folly::hasher	access:public	signature:(uint64_t key) const
folly::hexDump	.\String-inl.h	/^void hexDump(const void* ptr, size_t size, OutIt out) {$/;"	f	namespace:folly	signature:(const void* ptr, size_t size, OutIt out)
folly::hexDump	.\String.cpp	/^std::string hexDump(const void* ptr, size_t size) {$/;"	f	namespace:folly	signature:(const void* ptr, size_t size)
folly::hexlify	.\String-inl.h	/^bool hexlify(const InputString& input, OutputString& output,$/;"	f	namespace:folly	signature:(const InputString& input, OutputString& output, bool append_output)
folly::humanReadable	.\Benchmark.cpp	/^static string humanReadable(double n, unsigned int decimals,$/;"	f	namespace:folly	signature:(double n, unsigned int decimals, const ScaleInfo* scales)
folly::humanify	.\String-inl.h	/^void humanify(const String1& input, String2& output) {$/;"	f	namespace:folly	signature:(const String1& input, String2& output)
folly::io	.\io\Compression.cpp	/^namespace folly { namespace io {$/;"	n	namespace:folly	file:
folly::io	.\io\Compression.h	/^namespace folly { namespace io {$/;"	n	namespace:folly
folly::io	.\io\Cursor.h	/^namespace folly { namespace io {$/;"	n	namespace:folly
folly::io	.\io\test\CompressionTest.cpp	/^namespace folly { namespace io { namespace test {$/;"	n	namespace:folly	file:
folly::io::Appender	.\io\Cursor.h	/^class Appender : public detail::Writable<Appender> {$/;"	c	namespace:folly::io	inherits:detail::Writable
folly::io::Appender::Appender	.\io\Cursor.h	/^  Appender(IOBuf* buf, uint64_t growth)$/;"	f	class:folly::io::Appender	access:public	signature:(IOBuf* buf, uint64_t growth)
folly::io::Appender::append	.\io\Cursor.h	/^  void append(size_t n) {$/;"	f	class:folly::io::Appender	access:public	signature:(size_t n)
folly::io::Appender::buffer_	.\io\Cursor.h	/^  IOBuf* buffer_;$/;"	m	class:folly::io::Appender	access:private
folly::io::Appender::crtBuf_	.\io\Cursor.h	/^  IOBuf* crtBuf_;$/;"	m	class:folly::io::Appender	access:private
folly::io::Appender::ensure	.\io\Cursor.h	/^  void ensure(uint64_t n) {$/;"	f	class:folly::io::Appender	access:public	signature:(uint64_t n)
folly::io::Appender::growth_	.\io\Cursor.h	/^  uint64_t growth_;$/;"	m	class:folly::io::Appender	access:private
folly::io::Appender::length	.\io\Cursor.h	/^  size_t length() const {$/;"	f	class:folly::io::Appender	access:public	signature:() const
folly::io::Appender::pushAtMost	.\io\Cursor.h	/^  size_t pushAtMost(const uint8_t* buf, size_t len) {$/;"	f	class:folly::io::Appender	access:public	signature:(const uint8_t* buf, size_t len)
folly::io::Appender::tryGrowChain	.\io\Cursor.h	/^  bool tryGrowChain() {$/;"	f	class:folly::io::Appender	access:private	signature:()
folly::io::Appender::writableData	.\io\Cursor.h	/^  uint8_t* writableData() {$/;"	f	class:folly::io::Appender	access:public	signature:()
folly::io::COMPRESSION_LEVEL_BEST	.\io\Compression.h	/^constexpr int COMPRESSION_LEVEL_BEST = -3;$/;"	m	namespace:folly::io
folly::io::COMPRESSION_LEVEL_DEFAULT	.\io\Compression.h	/^constexpr int COMPRESSION_LEVEL_DEFAULT = -2;$/;"	m	namespace:folly::io
folly::io::COMPRESSION_LEVEL_FASTEST	.\io\Compression.h	/^constexpr int COMPRESSION_LEVEL_FASTEST = -1;$/;"	m	namespace:folly::io
folly::io::Codec	.\io\Compression.h	/^class Codec {$/;"	c	namespace:folly::io
folly::io::Codec::Codec	.\io\Compression.cpp	/^Codec::Codec(CodecType type) : type_(type) { }$/;"	f	class:folly::io::Codec	signature:(CodecType type)
folly::io::Codec::Codec	.\io\Compression.h	/^  explicit Codec(CodecType type);$/;"	p	class:folly::io::Codec	access:protected	signature:(CodecType type)
folly::io::Codec::UNKNOWN_UNCOMPRESSED_LENGTH	.\io\Compression.h	/^  static constexpr uint64_t UNKNOWN_UNCOMPRESSED_LENGTH = uint64_t(-1);$/;"	m	class:folly::io::Codec	access:public
folly::io::Codec::UNLIMITED_UNCOMPRESSED_LENGTH	.\io\Compression.h	/^  static constexpr uint64_t UNLIMITED_UNCOMPRESSED_LENGTH = uint64_t(-2);$/;"	m	class:folly::io::Codec	access:public
folly::io::Codec::compress	.\io\Compression.cpp	/^std::unique_ptr<IOBuf> Codec::compress(const IOBuf* data) {$/;"	f	class:folly::io::Codec	signature:(const IOBuf* data)
folly::io::Codec::compress	.\io\Compression.h	/^  std::unique_ptr<IOBuf> compress(const folly::IOBuf* data);$/;"	p	class:folly::io::Codec	access:public	signature:(const folly::IOBuf* data)
folly::io::Codec::doCompress	.\io\Compression.h	/^  virtual std::unique_ptr<IOBuf> doCompress(const folly::IOBuf* data) = 0;$/;"	p	class:folly::io::Codec	access:private	signature:(const folly::IOBuf* data)
folly::io::Codec::doMaxUncompressedLength	.\io\Compression.cpp	/^uint64_t Codec::doMaxUncompressedLength() const {$/;"	f	class:folly::io::Codec	signature:() const
folly::io::Codec::doMaxUncompressedLength	.\io\Compression.h	/^  virtual uint64_t doMaxUncompressedLength() const;$/;"	p	class:folly::io::Codec	access:private	signature:() const
folly::io::Codec::doNeedsUncompressedLength	.\io\Compression.cpp	/^bool Codec::doNeedsUncompressedLength() const {$/;"	f	class:folly::io::Codec	signature:() const
folly::io::Codec::doNeedsUncompressedLength	.\io\Compression.h	/^  virtual bool doNeedsUncompressedLength() const;$/;"	p	class:folly::io::Codec	access:private	signature:() const
folly::io::Codec::doUncompress	.\io\Compression.h	/^  virtual std::unique_ptr<IOBuf> doUncompress(const folly::IOBuf* data,$/;"	p	class:folly::io::Codec	access:private	signature:(const folly::IOBuf* data, uint64_t uncompressedLength)
folly::io::Codec::maxUncompressedLength	.\io\Compression.cpp	/^uint64_t Codec::maxUncompressedLength() const {$/;"	f	class:folly::io::Codec	signature:() const
folly::io::Codec::maxUncompressedLength	.\io\Compression.h	/^  uint64_t maxUncompressedLength() const;$/;"	p	class:folly::io::Codec	access:public	signature:() const
folly::io::Codec::needsUncompressedLength	.\io\Compression.cpp	/^bool Codec::needsUncompressedLength() const {$/;"	f	class:folly::io::Codec	signature:() const
folly::io::Codec::needsUncompressedLength	.\io\Compression.h	/^  bool needsUncompressedLength() const;$/;"	p	class:folly::io::Codec	access:public	signature:() const
folly::io::Codec::type	.\io\Compression.h	/^  CodecType type() const { return type_; }$/;"	f	class:folly::io::Codec	access:public	signature:() const
folly::io::Codec::type_	.\io\Compression.h	/^  CodecType type_;$/;"	m	class:folly::io::Codec	access:private
folly::io::Codec::uncompress	.\io\Compression.cpp	/^std::unique_ptr<IOBuf> Codec::uncompress(const IOBuf* data,$/;"	f	class:folly::io::Codec	signature:(const IOBuf* data, uint64_t uncompressedLength)
folly::io::Codec::uncompress	.\io\Compression.h	/^  std::unique_ptr<IOBuf> uncompress($/;"	p	class:folly::io::Codec	access:public	signature:( const IOBuf* data, uint64_t uncompressedLength = UNKNOWN_UNCOMPRESSED_LENGTH)
folly::io::Codec::~Codec	.\io\Compression.h	/^  virtual ~Codec() { }$/;"	f	class:folly::io::Codec	access:public	signature:()
folly::io::CodecType	.\io\Compression.h	/^enum class CodecType {$/;"	c	namespace:folly::io
folly::io::CodecType::LZ4	.\io\Compression.h	/^  LZ4 = 2,$/;"	m	class:folly::io::CodecType	access:private
folly::io::CodecType::LZ4_VARINT_SIZE	.\io\Compression.h	/^  LZ4_VARINT_SIZE = 5,$/;"	m	class:folly::io::CodecType	access:private
folly::io::CodecType::LZMA2	.\io\Compression.h	/^  LZMA2 = 6,$/;"	m	class:folly::io::CodecType	access:private
folly::io::CodecType::LZMA2_VARINT_SIZE	.\io\Compression.h	/^  LZMA2_VARINT_SIZE = 7,$/;"	m	class:folly::io::CodecType	access:private
folly::io::CodecType::NO_COMPRESSION	.\io\Compression.h	/^  NO_COMPRESSION = 1,$/;"	m	class:folly::io::CodecType	access:private
folly::io::CodecType::NUM_CODEC_TYPES	.\io\Compression.h	/^  NUM_CODEC_TYPES = 8,$/;"	m	class:folly::io::CodecType	access:private
folly::io::CodecType::SNAPPY	.\io\Compression.h	/^  SNAPPY = 3,$/;"	m	class:folly::io::CodecType	access:private
folly::io::CodecType::USER_DEFINED	.\io\Compression.h	/^  USER_DEFINED = 0,$/;"	m	class:folly::io::CodecType	access:private
folly::io::CodecType::ZLIB	.\io\Compression.h	/^  ZLIB = 4,$/;"	m	class:folly::io::CodecType	access:private
folly::io::Cursor	.\io\Cursor.h	/^class Cursor : public detail::CursorBase<Cursor, const IOBuf> {$/;"	c	namespace:folly::io	inherits:detail::CursorBase
folly::io::Cursor::Cursor	.\io\Cursor.h	/^  explicit Cursor(const IOBuf* buf)$/;"	f	class:folly::io::Cursor	access:public	signature:(const IOBuf* buf)
folly::io::Cursor::Cursor	.\io\Cursor.h	/^  explicit Cursor(const detail::CursorBase<OtherDerived, OtherBuf>& cursor)$/;"	f	class:folly::io::Cursor	access:public	signature:(const detail::CursorBase<OtherDerived, OtherBuf>& cursor)
folly::io::CursorAccess	.\io\Cursor.h	/^enum class CursorAccess {$/;"	c	namespace:folly::io
folly::io::CursorAccess::PRIVATE	.\io\Cursor.h	/^  PRIVATE,$/;"	m	class:folly::io::CursorAccess	access:private
folly::io::QueueAppender	.\io\Cursor.h	/^class QueueAppender : public detail::Writable<QueueAppender> {$/;"	c	namespace:folly::io	inherits:detail::Writable
folly::io::QueueAppender::QueueAppender	.\io\Cursor.h	/^  QueueAppender(IOBufQueue* queue, uint64_t growth) {$/;"	f	class:folly::io::QueueAppender	access:public	signature:(IOBufQueue* queue, uint64_t growth)
folly::io::QueueAppender::append	.\io\Cursor.h	/^  void append(size_t n) { queue_->postallocate(n); }$/;"	f	class:folly::io::QueueAppender	access:public	signature:(size_t n)
folly::io::QueueAppender::ensure	.\io\Cursor.h	/^  void ensure(uint64_t n) { queue_->preallocate(n, growth_); }$/;"	f	class:folly::io::QueueAppender	access:public	signature:(uint64_t n)
folly::io::QueueAppender::growth_	.\io\Cursor.h	/^  size_t growth_;$/;"	m	class:folly::io::QueueAppender	access:private
folly::io::QueueAppender::insert	.\io\Cursor.h	/^  void insert(std::unique_ptr<folly::IOBuf> buf) {$/;"	f	class:folly::io::QueueAppender	access:public	signature:(std::unique_ptr<folly::IOBuf> buf)
folly::io::QueueAppender::length	.\io\Cursor.h	/^  size_t length() const { return queue_->tailroom(); }$/;"	f	class:folly::io::QueueAppender	access:public	signature:() const
folly::io::QueueAppender::pushAtMost	.\io\Cursor.h	/^  size_t pushAtMost(const uint8_t* buf, size_t len) {$/;"	f	class:folly::io::QueueAppender	access:public	signature:(const uint8_t* buf, size_t len)
folly::io::QueueAppender::queue_	.\io\Cursor.h	/^  folly::IOBufQueue* queue_;$/;"	m	class:folly::io::QueueAppender	access:private
folly::io::QueueAppender::reset	.\io\Cursor.h	/^  void reset(IOBufQueue* queue, uint64_t growth) {$/;"	f	class:folly::io::QueueAppender	access:public	signature:(IOBufQueue* queue, uint64_t growth)
folly::io::QueueAppender::writableData	.\io\Cursor.h	/^  uint8_t* writableData() {$/;"	f	class:folly::io::QueueAppender	access:public	signature:()
folly::io::QueueAppender::write	.\io\Cursor.h	/^  write(T value) {$/;"	f	class:folly::io::QueueAppender	access:public	signature:(T value)
folly::io::RWCursor	.\io\Cursor.h	/^class RWCursor$/;"	c	namespace:folly::io	inherits:detail::CursorBase,detail::Writable
folly::io::RWCursor::RWCursor	.\io\Cursor.h	/^  explicit RWCursor(IOBuf* buf)$/;"	f	class:folly::io::RWCursor	access:public	signature:(IOBuf* buf)
folly::io::RWCursor::RWCursor	.\io\Cursor.h	/^  explicit RWCursor(const detail::CursorBase<OtherDerived, OtherBuf>& cursor)$/;"	f	class:folly::io::RWCursor	access:public	signature:(const detail::CursorBase<OtherDerived, OtherBuf>& cursor)
folly::io::RWCursor::advanceDone	.\io\Cursor.h	/^  void advanceDone() {$/;"	f	class:folly::io::RWCursor	access:private	signature:()
folly::io::RWCursor::gather	.\io\Cursor.h	/^  void gather(size_t n) {$/;"	f	class:folly::io::RWCursor	access:public	signature:(size_t n)
folly::io::RWCursor::gatherAtMost	.\io\Cursor.h	/^  void gatherAtMost(size_t n) {$/;"	f	class:folly::io::RWCursor	access:public	signature:(size_t n)
folly::io::RWCursor::insert	.\io\Cursor.h	/^  void insert(std::unique_ptr<folly::IOBuf> buf) {$/;"	f	class:folly::io::RWCursor	access:public	signature:(std::unique_ptr<folly::IOBuf> buf)
folly::io::RWCursor::maybeShared_	.\io\Cursor.h	/^  bool maybeShared_;$/;"	m	class:folly::io::RWCursor	access:private
folly::io::RWCursor::maybeUnshare	.\io\Cursor.h	/^  void maybeUnshare() {$/;"	f	class:folly::io::RWCursor	access:private	signature:()
folly::io::RWCursor::pushAtMost	.\io\Cursor.h	/^  size_t pushAtMost(const uint8_t* buf, size_t len) {$/;"	f	class:folly::io::RWCursor	access:public	signature:(const uint8_t* buf, size_t len)
folly::io::RWCursor::writableData	.\io\Cursor.h	/^  uint8_t* writableData() {$/;"	f	class:folly::io::RWCursor	access:public	signature:()
folly::io::RWPrivateCursor	.\io\Cursor.h	/^typedef RWCursor<CursorAccess::PRIVATE> RWPrivateCursor;$/;"	t	namespace:folly::io
folly::io::RWUnshareCursor	.\io\Cursor.h	/^typedef RWCursor<CursorAccess::UNSHARE> RWUnshareCursor;$/;"	t	namespace:folly::io
folly::io::__anon64::FOLLY_FINAL	.\io\Compression.cpp	/^class IOBufSnappySource FOLLY_FINAL : public snappy::Source {$/;"	c	namespace:folly::io::__anon64	file:	inherits:snappy::Source
folly::io::__anon64::FOLLY_FINAL	.\io\Compression.cpp	/^class LZ4Codec FOLLY_FINAL : public Codec {$/;"	c	namespace:folly::io::__anon64	file:	inherits:Codec
folly::io::__anon64::FOLLY_FINAL	.\io\Compression.cpp	/^class LZMA2Codec FOLLY_FINAL : public Codec {$/;"	c	namespace:folly::io::__anon64	file:	inherits:Codec
folly::io::__anon64::FOLLY_FINAL	.\io\Compression.cpp	/^class NoCompressionCodec FOLLY_FINAL : public Codec {$/;"	c	namespace:folly::io::__anon64	file:	inherits:Codec
folly::io::__anon64::FOLLY_FINAL	.\io\Compression.cpp	/^class SnappyCodec FOLLY_FINAL : public Codec {$/;"	c	namespace:folly::io::__anon64	file:	inherits:Codec
folly::io::__anon64::FOLLY_FINAL	.\io\Compression.cpp	/^class ZlibCodec FOLLY_FINAL : public Codec {$/;"	c	namespace:folly::io::__anon64	file:	inherits:Codec
folly::io::__anon64::FOLLY_FINAL::FOLLY_OVERRIDE	.\io\Compression.cpp	/^      uint64_t uncompressedLength) FOLLY_OVERRIDE;$/;"	m	class:folly::io::__anon64::FOLLY_FINAL	file:	access:private
folly::io::__anon64::FOLLY_FINAL::FOLLY_OVERRIDE	.\io\Compression.cpp	/^  bool doNeedsUncompressedLength() const FOLLY_OVERRIDE;$/;"	m	class:folly::io::__anon64::FOLLY_FINAL	file:	access:private
folly::io::__anon64::FOLLY_FINAL::FOLLY_OVERRIDE	.\io\Compression.cpp	/^  const char* Peek(size_t* len) FOLLY_OVERRIDE;$/;"	m	class:folly::io::__anon64::FOLLY_FINAL	file:	access:public
folly::io::__anon64::FOLLY_FINAL::FOLLY_OVERRIDE	.\io\Compression.cpp	/^  size_t Available() const FOLLY_OVERRIDE;$/;"	m	class:folly::io::__anon64::FOLLY_FINAL	file:	access:public
folly::io::__anon64::FOLLY_FINAL::FOLLY_OVERRIDE	.\io\Compression.cpp	/^  std::unique_ptr<IOBuf> doCompress(const IOBuf* data) FOLLY_OVERRIDE;$/;"	m	class:folly::io::__anon64::FOLLY_FINAL	file:	access:private
folly::io::__anon64::FOLLY_FINAL::FOLLY_OVERRIDE	.\io\Compression.cpp	/^  uint64_t doMaxUncompressedLength() const FOLLY_OVERRIDE;$/;"	m	class:folly::io::__anon64::FOLLY_FINAL	file:	access:private
folly::io::__anon64::FOLLY_FINAL::FOLLY_OVERRIDE	.\io\Compression.cpp	/^  void Skip(size_t n) FOLLY_OVERRIDE;$/;"	m	class:folly::io::__anon64::FOLLY_FINAL	file:	access:public
folly::io::__anon64::FOLLY_FINAL::IOBufSnappySource	.\io\Compression.cpp	/^  explicit IOBufSnappySource(const IOBuf* data);$/;"	p	class:folly::io::__anon64::FOLLY_FINAL	file:	access:public	signature:(const IOBuf* data)
folly::io::__anon64::FOLLY_FINAL::LZ4Codec	.\io\Compression.cpp	/^  explicit LZ4Codec(int level, CodecType type);$/;"	p	class:folly::io::__anon64::FOLLY_FINAL	file:	access:public	signature:(int level, CodecType type)
folly::io::__anon64::FOLLY_FINAL::LZMA2Codec	.\io\Compression.cpp	/^  explicit LZMA2Codec(int level, CodecType type);$/;"	p	class:folly::io::__anon64::FOLLY_FINAL	file:	access:public	signature:(int level, CodecType type)
folly::io::__anon64::FOLLY_FINAL::NoCompressionCodec	.\io\Compression.cpp	/^  explicit NoCompressionCodec(int level, CodecType type);$/;"	p	class:folly::io::__anon64::FOLLY_FINAL	file:	access:public	signature:(int level, CodecType type)
folly::io::__anon64::FOLLY_FINAL::SnappyCodec	.\io\Compression.cpp	/^  explicit SnappyCodec(int level, CodecType type);$/;"	p	class:folly::io::__anon64::FOLLY_FINAL	file:	access:public	signature:(int level, CodecType type)
folly::io::__anon64::FOLLY_FINAL::ZlibCodec	.\io\Compression.cpp	/^  explicit ZlibCodec(int level, CodecType type);$/;"	p	class:folly::io::__anon64::FOLLY_FINAL	file:	access:public	signature:(int level, CodecType type)
folly::io::__anon64::FOLLY_FINAL::addOutputBuffer	.\io\Compression.cpp	/^  std::unique_ptr<IOBuf> addOutputBuffer(lzma_stream* stream, size_t length);$/;"	p	class:folly::io::__anon64::FOLLY_FINAL	file:	access:private	signature:(lzma_stream* stream, size_t length)
folly::io::__anon64::FOLLY_FINAL::addOutputBuffer	.\io\Compression.cpp	/^  std::unique_ptr<IOBuf> addOutputBuffer(z_stream* stream, uint32_t length);$/;"	p	class:folly::io::__anon64::FOLLY_FINAL	file:	access:private	signature:(z_stream* stream, uint32_t length)
folly::io::__anon64::FOLLY_FINAL::available_	.\io\Compression.cpp	/^  size_t available_;$/;"	m	class:folly::io::__anon64::FOLLY_FINAL	file:	access:private
folly::io::__anon64::FOLLY_FINAL::create	.\io\Compression.cpp	/^  static std::unique_ptr<Codec> create(int level, CodecType type);$/;"	p	class:folly::io::__anon64::FOLLY_FINAL	file:	access:public	signature:(int level, CodecType type)
folly::io::__anon64::FOLLY_FINAL::cursor_	.\io\Compression.cpp	/^  io::Cursor cursor_;$/;"	m	class:folly::io::__anon64::FOLLY_FINAL	file:	access:private
folly::io::__anon64::FOLLY_FINAL::doInflate	.\io\Compression.cpp	/^  bool doInflate(lzma_stream* stream, IOBuf* head, size_t bufferLength);$/;"	p	class:folly::io::__anon64::FOLLY_FINAL	file:	access:private	signature:(lzma_stream* stream, IOBuf* head, size_t bufferLength)
folly::io::__anon64::FOLLY_FINAL::doInflate	.\io\Compression.cpp	/^  bool doInflate(z_stream* stream, IOBuf* head, uint32_t bufferLength);$/;"	p	class:folly::io::__anon64::FOLLY_FINAL	file:	access:private	signature:(z_stream* stream, IOBuf* head, uint32_t bufferLength)
folly::io::__anon64::FOLLY_FINAL::encodeSize	.\io\Compression.cpp	/^  bool encodeSize() const { return type() == CodecType::LZ4_VARINT_SIZE; }$/;"	f	class:folly::io::__anon64::FOLLY_FINAL	file:	access:private	signature:() const
folly::io::__anon64::FOLLY_FINAL::encodeSize	.\io\Compression.cpp	/^  bool encodeSize() const { return type() == CodecType::LZMA2_VARINT_SIZE; }$/;"	f	class:folly::io::__anon64::FOLLY_FINAL	file:	access:private	signature:() const
folly::io::__anon64::FOLLY_FINAL::highCompression_	.\io\Compression.cpp	/^  bool highCompression_;$/;"	m	class:folly::io::__anon64::FOLLY_FINAL	file:	access:private
folly::io::__anon64::FOLLY_FINAL::level_	.\io\Compression.cpp	/^  int level_;$/;"	m	class:folly::io::__anon64::FOLLY_FINAL	file:	access:private
folly::io::__anon64::IOBufSnappySource::Available	.\io\Compression.cpp	/^size_t IOBufSnappySource::Available() const {$/;"	f	class:folly::io::__anon64::IOBufSnappySource	signature:() const
folly::io::__anon64::IOBufSnappySource::IOBufSnappySource	.\io\Compression.cpp	/^IOBufSnappySource::IOBufSnappySource(const IOBuf* data)$/;"	f	class:folly::io::__anon64::IOBufSnappySource	signature:(const IOBuf* data)
folly::io::__anon64::IOBufSnappySource::Peek	.\io\Compression.cpp	/^const char* IOBufSnappySource::Peek(size_t* len) {$/;"	f	class:folly::io::__anon64::IOBufSnappySource	signature:(size_t* len)
folly::io::__anon64::IOBufSnappySource::Skip	.\io\Compression.cpp	/^void IOBufSnappySource::Skip(size_t n) {$/;"	f	class:folly::io::__anon64::IOBufSnappySource	signature:(size_t n)
folly::io::__anon64::LZ4Codec::LZ4Codec	.\io\Compression.cpp	/^LZ4Codec::LZ4Codec(int level, CodecType type) : Codec(type) {$/;"	f	class:folly::io::__anon64::LZ4Codec	signature:(int level, CodecType type)
folly::io::__anon64::LZ4Codec::create	.\io\Compression.cpp	/^std::unique_ptr<Codec> LZ4Codec::create(int level, CodecType type) {$/;"	f	class:folly::io::__anon64::LZ4Codec	signature:(int level, CodecType type)
folly::io::__anon64::LZ4Codec::doCompress	.\io\Compression.cpp	/^std::unique_ptr<IOBuf> LZ4Codec::doCompress(const IOBuf* data) {$/;"	f	class:folly::io::__anon64::LZ4Codec	signature:(const IOBuf* data)
folly::io::__anon64::LZ4Codec::doMaxUncompressedLength	.\io\Compression.cpp	/^uint64_t LZ4Codec::doMaxUncompressedLength() const {$/;"	f	class:folly::io::__anon64::LZ4Codec	signature:() const
folly::io::__anon64::LZ4Codec::doNeedsUncompressedLength	.\io\Compression.cpp	/^bool LZ4Codec::doNeedsUncompressedLength() const {$/;"	f	class:folly::io::__anon64::LZ4Codec	signature:() const
folly::io::__anon64::LZ4Codec::doUncompress	.\io\Compression.cpp	/^std::unique_ptr<IOBuf> LZ4Codec::doUncompress($/;"	f	class:folly::io::__anon64::LZ4Codec	signature:( const IOBuf* data, uint64_t uncompressedLength)
folly::io::__anon64::LZMA2Codec::LZMA2Codec	.\io\Compression.cpp	/^LZMA2Codec::LZMA2Codec(int level, CodecType type) : Codec(type) {$/;"	f	class:folly::io::__anon64::LZMA2Codec	signature:(int level, CodecType type)
folly::io::__anon64::LZMA2Codec::addOutputBuffer	.\io\Compression.cpp	/^std::unique_ptr<IOBuf> LZMA2Codec::addOutputBuffer($/;"	f	class:folly::io::__anon64::LZMA2Codec	signature:( lzma_stream* stream, size_t length)
folly::io::__anon64::LZMA2Codec::create	.\io\Compression.cpp	/^std::unique_ptr<Codec> LZMA2Codec::create(int level, CodecType type) {$/;"	f	class:folly::io::__anon64::LZMA2Codec	signature:(int level, CodecType type)
folly::io::__anon64::LZMA2Codec::doCompress	.\io\Compression.cpp	/^std::unique_ptr<IOBuf> LZMA2Codec::doCompress(const IOBuf* data) {$/;"	f	class:folly::io::__anon64::LZMA2Codec	signature:(const IOBuf* data)
folly::io::__anon64::LZMA2Codec::doInflate	.\io\Compression.cpp	/^bool LZMA2Codec::doInflate(lzma_stream* stream,$/;"	f	class:folly::io::__anon64::LZMA2Codec	signature:(lzma_stream* stream, IOBuf* head, size_t bufferLength)
folly::io::__anon64::LZMA2Codec::doMaxUncompressedLength	.\io\Compression.cpp	/^uint64_t LZMA2Codec::doMaxUncompressedLength() const {$/;"	f	class:folly::io::__anon64::LZMA2Codec	signature:() const
folly::io::__anon64::LZMA2Codec::doNeedsUncompressedLength	.\io\Compression.cpp	/^bool LZMA2Codec::doNeedsUncompressedLength() const {$/;"	f	class:folly::io::__anon64::LZMA2Codec	signature:() const
folly::io::__anon64::LZMA2Codec::doUncompress	.\io\Compression.cpp	/^std::unique_ptr<IOBuf> LZMA2Codec::doUncompress(const IOBuf* data,$/;"	f	class:folly::io::__anon64::LZMA2Codec	signature:(const IOBuf* data, uint64_t uncompressedLength)
folly::io::__anon64::NoCompressionCodec::NoCompressionCodec	.\io\Compression.cpp	/^NoCompressionCodec::NoCompressionCodec(int level, CodecType type)$/;"	f	class:folly::io::__anon64::NoCompressionCodec	signature:(int level, CodecType type)
folly::io::__anon64::NoCompressionCodec::create	.\io\Compression.cpp	/^std::unique_ptr<Codec> NoCompressionCodec::create(int level, CodecType type) {$/;"	f	class:folly::io::__anon64::NoCompressionCodec	signature:(int level, CodecType type)
folly::io::__anon64::NoCompressionCodec::doCompress	.\io\Compression.cpp	/^std::unique_ptr<IOBuf> NoCompressionCodec::doCompress($/;"	f	class:folly::io::__anon64::NoCompressionCodec	signature:( const IOBuf* data)
folly::io::__anon64::NoCompressionCodec::doUncompress	.\io\Compression.cpp	/^std::unique_ptr<IOBuf> NoCompressionCodec::doUncompress($/;"	f	class:folly::io::__anon64::NoCompressionCodec	signature:( const IOBuf* data, uint64_t uncompressedLength)
folly::io::__anon64::SnappyCodec::SnappyCodec	.\io\Compression.cpp	/^SnappyCodec::SnappyCodec(int level, CodecType type) : Codec(type) {$/;"	f	class:folly::io::__anon64::SnappyCodec	signature:(int level, CodecType type)
folly::io::__anon64::SnappyCodec::create	.\io\Compression.cpp	/^std::unique_ptr<Codec> SnappyCodec::create(int level, CodecType type) {$/;"	f	class:folly::io::__anon64::SnappyCodec	signature:(int level, CodecType type)
folly::io::__anon64::SnappyCodec::doCompress	.\io\Compression.cpp	/^std::unique_ptr<IOBuf> SnappyCodec::doCompress(const IOBuf* data) {$/;"	f	class:folly::io::__anon64::SnappyCodec	signature:(const IOBuf* data)
folly::io::__anon64::SnappyCodec::doMaxUncompressedLength	.\io\Compression.cpp	/^uint64_t SnappyCodec::doMaxUncompressedLength() const {$/;"	f	class:folly::io::__anon64::SnappyCodec	signature:() const
folly::io::__anon64::SnappyCodec::doUncompress	.\io\Compression.cpp	/^std::unique_ptr<IOBuf> SnappyCodec::doUncompress(const IOBuf* data,$/;"	f	class:folly::io::__anon64::SnappyCodec	signature:(const IOBuf* data, uint64_t uncompressedLength)
folly::io::__anon64::ZlibCodec::ZlibCodec	.\io\Compression.cpp	/^ZlibCodec::ZlibCodec(int level, CodecType type) : Codec(type) {$/;"	f	class:folly::io::__anon64::ZlibCodec	signature:(int level, CodecType type)
folly::io::__anon64::ZlibCodec::addOutputBuffer	.\io\Compression.cpp	/^std::unique_ptr<IOBuf> ZlibCodec::addOutputBuffer(z_stream* stream,$/;"	f	class:folly::io::__anon64::ZlibCodec	signature:(z_stream* stream, uint32_t length)
folly::io::__anon64::ZlibCodec::create	.\io\Compression.cpp	/^std::unique_ptr<Codec> ZlibCodec::create(int level, CodecType type) {$/;"	f	class:folly::io::__anon64::ZlibCodec	signature:(int level, CodecType type)
folly::io::__anon64::ZlibCodec::doCompress	.\io\Compression.cpp	/^std::unique_ptr<IOBuf> ZlibCodec::doCompress(const IOBuf* data) {$/;"	f	class:folly::io::__anon64::ZlibCodec	signature:(const IOBuf* data)
folly::io::__anon64::ZlibCodec::doInflate	.\io\Compression.cpp	/^bool ZlibCodec::doInflate(z_stream* stream,$/;"	f	class:folly::io::__anon64::ZlibCodec	signature:(z_stream* stream, IOBuf* head, uint32_t bufferLength)
folly::io::__anon64::ZlibCodec::doUncompress	.\io\Compression.cpp	/^std::unique_ptr<IOBuf> ZlibCodec::doUncompress(const IOBuf* data,$/;"	f	class:folly::io::__anon64::ZlibCodec	signature:(const IOBuf* data, uint64_t uncompressedLength)
folly::io::__anon64::__anon65::decodeVarintFromCursor	.\io\Compression.cpp	/^uint64_t decodeVarintFromCursor(folly::io::Cursor& cursor) {$/;"	f	namespace:folly::io::__anon64::__anon65	signature:(folly::io::Cursor& cursor)
folly::io::__anon64::__anon65::encodeVarintToIOBuf	.\io\Compression.cpp	/^void encodeVarintToIOBuf(uint64_t val, folly::IOBuf* out) {$/;"	f	namespace:folly::io::__anon64::__anon65	signature:(uint64_t val, folly::IOBuf* out)
folly::io::__anon64::gCodecFactories	.\io\Compression.cpp	/^CodecFactory gCodecFactories[$/;"	m	namespace:folly::io::__anon64	file:
folly::io::__anon64::std::CodecFactory	.\io\Compression.cpp	/^typedef std::unique_ptr<Codec> (*CodecFactory)(int, CodecType);$/;"	t	class:folly::io::__anon64::std	file:
folly::io::detail	.\io\Cursor.h	/^namespace detail {$/;"	n	namespace:folly::io
folly::io::detail::CursorBase	.\io\Cursor.h	/^class CursorBase {$/;"	c	namespace:folly::io::detail
folly::io::detail::CursorBase::CursorBase	.\io\Cursor.h	/^  explicit CursorBase(BufType* buf)$/;"	f	class:folly::io::detail::CursorBase	access:public	signature:(BufType* buf)
folly::io::detail::CursorBase::CursorBase	.\io\Cursor.h	/^  explicit CursorBase(const CursorBase<OtherDerived, OtherBuf>& cursor)$/;"	f	class:folly::io::detail::CursorBase	access:public	signature:(const CursorBase<OtherDerived, OtherBuf>& cursor)
folly::io::detail::CursorBase::CursorBase	.\io\Cursor.h	/^  template <class D, typename B> friend class CursorBase;$/;"	x
folly::io::detail::CursorBase::advanceDone	.\io\Cursor.h	/^  void advanceDone() {$/;"	f	class:folly::io::detail::CursorBase	access:private	signature:()
folly::io::detail::CursorBase::buffer_	.\io\Cursor.h	/^  BufType* buffer_;$/;"	m	class:folly::io::detail::CursorBase	access:private
folly::io::detail::CursorBase::clone	.\io\Cursor.h	/^  void clone(folly::IOBuf& buf, size_t len) {$/;"	f	class:folly::io::detail::CursorBase	access:public	signature:(folly::IOBuf& buf, size_t len)
folly::io::detail::CursorBase::clone	.\io\Cursor.h	/^  void clone(std::unique_ptr<folly::IOBuf>& buf, size_t len) {$/;"	f	class:folly::io::detail::CursorBase	access:public	signature:(std::unique_ptr<folly::IOBuf>& buf, size_t len)
folly::io::detail::CursorBase::cloneAtMost	.\io\Cursor.h	/^  size_t cloneAtMost(folly::IOBuf& buf, size_t len) {$/;"	f	class:folly::io::detail::CursorBase	access:public	signature:(folly::IOBuf& buf, size_t len)
folly::io::detail::CursorBase::cloneAtMost	.\io\Cursor.h	/^  size_t cloneAtMost(std::unique_ptr<folly::IOBuf>& buf, size_t len) {$/;"	f	class:folly::io::detail::CursorBase	access:public	signature:(std::unique_ptr<folly::IOBuf>& buf, size_t len)
folly::io::detail::CursorBase::crtBuf_	.\io\Cursor.h	/^  BufType* crtBuf_;$/;"	m	class:folly::io::detail::CursorBase	access:protected
folly::io::detail::CursorBase::data	.\io\Cursor.h	/^  const uint8_t* data() const {$/;"	f	class:folly::io::detail::CursorBase	access:public	signature:() const
folly::io::detail::CursorBase::head	.\io\Cursor.h	/^  BufType* head() {$/;"	f	class:folly::io::detail::CursorBase	access:protected	signature:()
folly::io::detail::CursorBase::length	.\io\Cursor.h	/^  size_t length() const {$/;"	f	class:folly::io::detail::CursorBase	access:public	signature:() const
folly::io::detail::CursorBase::offset_	.\io\Cursor.h	/^  size_t offset_;$/;"	m	class:folly::io::detail::CursorBase	access:protected
folly::io::detail::CursorBase::operator !=	.\io\Cursor.h	/^  bool operator!=(const Derived& other) const {$/;"	f	class:folly::io::detail::CursorBase	access:public	signature:(const Derived& other) const
folly::io::detail::CursorBase::operator +	.\io\Cursor.h	/^  Derived operator+(size_t offset) const {$/;"	f	class:folly::io::detail::CursorBase	access:public	signature:(size_t offset) const
folly::io::detail::CursorBase::operator +=	.\io\Cursor.h	/^  Derived& operator+=(size_t offset) {$/;"	f	class:folly::io::detail::CursorBase	access:public	signature:(size_t offset)
folly::io::detail::CursorBase::operator -	.\io\Cursor.h	/^  size_t operator-(const BufType* buf) const {$/;"	f	class:folly::io::detail::CursorBase	access:public	signature:(const BufType* buf) const
folly::io::detail::CursorBase::operator -	.\io\Cursor.h	/^  size_t operator-(const CursorBase& other) const {$/;"	f	class:folly::io::detail::CursorBase	access:public	signature:(const CursorBase& other) const
folly::io::detail::CursorBase::operator ==	.\io\Cursor.h	/^  bool operator==(const Derived& other) const {$/;"	f	class:folly::io::detail::CursorBase	access:public	signature:(const Derived& other) const
folly::io::detail::CursorBase::peek	.\io\Cursor.h	/^  std::pair<const uint8_t*, size_t> peek() {$/;"	f	class:folly::io::detail::CursorBase	access:public	signature:()
folly::io::detail::CursorBase::pull	.\io\Cursor.h	/^  void pull(void* buf, size_t len) {$/;"	f	class:folly::io::detail::CursorBase	access:public	signature:(void* buf, size_t len)
folly::io::detail::CursorBase::pullAtMost	.\io\Cursor.h	/^  size_t pullAtMost(void* buf, size_t len) {$/;"	f	class:folly::io::detail::CursorBase	access:public	signature:(void* buf, size_t len)
folly::io::detail::CursorBase::read	.\io\Cursor.h	/^  read() {$/;"	f	class:folly::io::detail::CursorBase	access:public	signature:()
folly::io::detail::CursorBase::readBE	.\io\Cursor.h	/^  T readBE() {$/;"	f	class:folly::io::detail::CursorBase	access:public	signature:()
folly::io::detail::CursorBase::readFixedString	.\io\Cursor.h	/^  std::string readFixedString(size_t len) {$/;"	f	class:folly::io::detail::CursorBase	access:public	signature:(size_t len)
folly::io::detail::CursorBase::readLE	.\io\Cursor.h	/^  T readLE() {$/;"	f	class:folly::io::detail::CursorBase	access:public	signature:()
folly::io::detail::CursorBase::readTerminatedString	.\io\Cursor.h	/^  std::string readTerminatedString($/;"	f	class:folly::io::detail::CursorBase	access:public	signature:( char termChar = , size_t maxLength = std::numeric_limits<size_t>::max())
folly::io::detail::CursorBase::reset	.\io\Cursor.h	/^  void reset(BufType* buf) {$/;"	f	class:folly::io::detail::CursorBase	access:public	signature:(BufType* buf)
folly::io::detail::CursorBase::skip	.\io\Cursor.h	/^  void skip(size_t len) {$/;"	f	class:folly::io::detail::CursorBase	access:public	signature:(size_t len)
folly::io::detail::CursorBase::skipAtMost	.\io\Cursor.h	/^  size_t skipAtMost(size_t len) {$/;"	f	class:folly::io::detail::CursorBase	access:public	signature:(size_t len)
folly::io::detail::CursorBase::totalLength	.\io\Cursor.h	/^  size_t totalLength() const {$/;"	f	class:folly::io::detail::CursorBase	access:public	signature:() const
folly::io::detail::CursorBase::tryAdvanceBuffer	.\io\Cursor.h	/^  bool tryAdvanceBuffer() {$/;"	f	class:folly::io::detail::CursorBase	access:protected	signature:()
folly::io::detail::CursorBase::~CursorBase	.\io\Cursor.h	/^  ~CursorBase(){}$/;"	f	class:folly::io::detail::CursorBase	access:protected	signature:()
folly::io::detail::Writable	.\io\Cursor.h	/^class Writable {$/;"	c	namespace:folly::io::detail
folly::io::detail::Writable::push	.\io\Cursor.h	/^  void push(const uint8_t* buf, size_t len) {$/;"	f	class:folly::io::detail::Writable	access:public	signature:(const uint8_t* buf, size_t len)
folly::io::detail::Writable::write	.\io\Cursor.h	/^  write(T value) {$/;"	f	class:folly::io::detail::Writable	access:public	signature:(T value)
folly::io::detail::Writable::writeBE	.\io\Cursor.h	/^  void writeBE(T value) {$/;"	f	class:folly::io::detail::Writable	access:public	signature:(T value)
folly::io::detail::Writable::writeLE	.\io\Cursor.h	/^  void writeLE(T value) {$/;"	f	class:folly::io::detail::Writable	access:public	signature:(T value)
folly::io::getCodec	.\io\Compression.cpp	/^std::unique_ptr<Codec> getCodec(CodecType type, int level) {$/;"	f	namespace:folly::io	signature:(CodecType type, int level)
folly::io::getCodec	.\io\Compression.h	/^std::unique_ptr<Codec> getCodec(CodecType type,$/;"	p	namespace:folly::io	signature:(CodecType type, int level = COMPRESSION_LEVEL_DEFAULT)
folly::io::test	.\io\test\CompressionTest.cpp	/^namespace folly { namespace io { namespace test {$/;"	n	namespace:folly::io	file:
folly::io::test::CompressionCorruptionTest	.\io\test\CompressionTest.cpp	/^class CompressionCorruptionTest : public testing::TestWithParam<CodecType> {$/;"	c	namespace:folly::io::test	file:	inherits:testing::TestWithParam
folly::io::test::CompressionCorruptionTest::SetUp	.\io\test\CompressionTest.cpp	/^  void SetUp() {$/;"	f	class:folly::io::test::CompressionCorruptionTest	access:protected	signature:()
folly::io::test::CompressionCorruptionTest::codec_	.\io\test\CompressionTest.cpp	/^  std::unique_ptr<Codec> codec_;$/;"	m	class:folly::io::test::CompressionCorruptionTest	file:	access:protected
folly::io::test::CompressionCorruptionTest::runSimpleTest	.\io\test\CompressionTest.cpp	/^  void runSimpleTest(const DataHolder& dh);$/;"	p	class:folly::io::test::CompressionCorruptionTest	file:	access:protected	signature:(const DataHolder& dh)
folly::io::test::CompressionCorruptionTest::runSimpleTest	.\io\test\CompressionTest.cpp	/^void CompressionCorruptionTest::runSimpleTest(const DataHolder& dh) {$/;"	f	class:folly::io::test::CompressionCorruptionTest	signature:(const DataHolder& dh)
folly::io::test::CompressionTest	.\io\test\CompressionTest.cpp	/^class CompressionTest : public testing::TestWithParam<$/;"	c	namespace:folly::io::test	file:	inherits:testing::TestWithParam
folly::io::test::CompressionTest::SetUp	.\io\test\CompressionTest.cpp	/^   void SetUp() {$/;"	f	class:folly::io::test::CompressionTest	access:protected	signature:()
folly::io::test::CompressionTest::codec_	.\io\test\CompressionTest.cpp	/^   std::unique_ptr<Codec> codec_;$/;"	m	class:folly::io::test::CompressionTest	file:	access:protected
folly::io::test::CompressionTest::runSimpleTest	.\io\test\CompressionTest.cpp	/^   void runSimpleTest(const DataHolder& dh);$/;"	p	class:folly::io::test::CompressionTest	file:	access:protected	signature:(const DataHolder& dh)
folly::io::test::CompressionTest::runSimpleTest	.\io\test\CompressionTest.cpp	/^void CompressionTest::runSimpleTest(const DataHolder& dh) {$/;"	f	class:folly::io::test::CompressionTest	signature:(const DataHolder& dh)
folly::io::test::CompressionTest::uncompressedLength_	.\io\test\CompressionTest.cpp	/^   uint64_t uncompressedLength_;$/;"	m	class:folly::io::test::CompressionTest	file:	access:protected
folly::io::test::ConstantDataHolder	.\io\test\CompressionTest.cpp	/^class ConstantDataHolder : public DataHolder {$/;"	c	namespace:folly::io::test	file:	inherits:DataHolder
folly::io::test::ConstantDataHolder::ConstantDataHolder	.\io\test\CompressionTest.cpp	/^  explicit ConstantDataHolder(size_t sizeLog2);$/;"	p	class:folly::io::test::ConstantDataHolder	file:	access:public	signature:(size_t sizeLog2)
folly::io::test::ConstantDataHolder::ConstantDataHolder	.\io\test\CompressionTest.cpp	/^ConstantDataHolder::ConstantDataHolder(size_t sizeLog2)$/;"	f	class:folly::io::test::ConstantDataHolder	signature:(size_t sizeLog2)
folly::io::test::DataHolder	.\io\test\CompressionTest.cpp	/^class DataHolder : private boost::noncopyable {$/;"	c	namespace:folly::io::test	file:	inherits:boost::noncopyable
folly::io::test::DataHolder::DataHolder	.\io\test\CompressionTest.cpp	/^  explicit DataHolder(size_t sizeLog2);$/;"	p	class:folly::io::test::DataHolder	file:	access:protected	signature:(size_t sizeLog2)
folly::io::test::DataHolder::DataHolder	.\io\test\CompressionTest.cpp	/^DataHolder::DataHolder(size_t sizeLog2)$/;"	f	class:folly::io::test::DataHolder	signature:(size_t sizeLog2)
folly::io::test::DataHolder::data	.\io\test\CompressionTest.cpp	/^  ByteRange data(size_t size) const;$/;"	p	class:folly::io::test::DataHolder	file:	access:public	signature:(size_t size) const
folly::io::test::DataHolder::data	.\io\test\CompressionTest.cpp	/^ByteRange DataHolder::data(size_t size) const {$/;"	f	class:folly::io::test::DataHolder	signature:(size_t size) const
folly::io::test::DataHolder::data_	.\io\test\CompressionTest.cpp	/^  std::unique_ptr<uint8_t[]> data_;$/;"	m	class:folly::io::test::DataHolder	file:	access:protected
folly::io::test::DataHolder::hash	.\io\test\CompressionTest.cpp	/^  uint64_t hash(size_t size) const;$/;"	p	class:folly::io::test::DataHolder	file:	access:public	signature:(size_t size) const
folly::io::test::DataHolder::hash	.\io\test\CompressionTest.cpp	/^uint64_t DataHolder::hash(size_t size) const {$/;"	f	class:folly::io::test::DataHolder	signature:(size_t size) const
folly::io::test::DataHolder::hashCache_	.\io\test\CompressionTest.cpp	/^  mutable std::unordered_map<uint64_t, uint64_t> hashCache_;$/;"	m	class:folly::io::test::DataHolder	file:	access:protected
folly::io::test::DataHolder::size_	.\io\test\CompressionTest.cpp	/^  const size_t size_;$/;"	m	class:folly::io::test::DataHolder	file:	access:protected
folly::io::test::INSTANTIATE_TEST_CASE_P	.\io\test\CompressionTest.cpp	/^INSTANTIATE_TEST_CASE_P($/;"	p	namespace:folly::io::test	file:	signature:( CompressionCorruptionTest, CompressionCorruptionTest, testing::Values( CodecType::SNAPPY, CodecType::ZLIB))
folly::io::test::INSTANTIATE_TEST_CASE_P	.\io\test\CompressionTest.cpp	/^INSTANTIATE_TEST_CASE_P($/;"	p	namespace:folly::io::test	file:	signature:( CompressionTest, CompressionTest, testing::Combine( testing::Values(0, 1, 12, 22, 25, 27), testing::Values(CodecType::NO_COMPRESSION, CodecType::LZ4, CodecType::SNAPPY, CodecType::ZLIB, CodecType::LZ4_VARINT_SIZE, CodecType::LZMA2, CodecType::LZMA2_VARINT_SIZE)))
folly::io::test::RandomDataHolder	.\io\test\CompressionTest.cpp	/^class RandomDataHolder : public DataHolder {$/;"	c	namespace:folly::io::test	file:	inherits:DataHolder
folly::io::test::RandomDataHolder::RandomDataHolder	.\io\test\CompressionTest.cpp	/^  explicit RandomDataHolder(size_t sizeLog2);$/;"	p	class:folly::io::test::RandomDataHolder	file:	access:public	signature:(size_t sizeLog2)
folly::io::test::RandomDataHolder::RandomDataHolder	.\io\test\CompressionTest.cpp	/^RandomDataHolder::RandomDataHolder(size_t sizeLog2)$/;"	f	class:folly::io::test::RandomDataHolder	signature:(size_t sizeLog2)
folly::io::test::TEST	.\io\test\CompressionTest.cpp	/^TEST(CompressionTestNeedsUncompressedLength, Simple) {$/;"	f	namespace:folly::io::test	signature:(CompressionTestNeedsUncompressedLength, Simple)
folly::io::test::TEST_P	.\io\test\CompressionTest.cpp	/^TEST_P(CompressionCorruptionTest, ConstantData) {$/;"	f	namespace:folly::io::test	signature:(CompressionCorruptionTest, ConstantData)
folly::io::test::TEST_P	.\io\test\CompressionTest.cpp	/^TEST_P(CompressionCorruptionTest, RandomData) {$/;"	f	namespace:folly::io::test	signature:(CompressionCorruptionTest, RandomData)
folly::io::test::TEST_P	.\io\test\CompressionTest.cpp	/^TEST_P(CompressionTest, ConstantData) {$/;"	f	namespace:folly::io::test	signature:(CompressionTest, ConstantData)
folly::io::test::TEST_P	.\io\test\CompressionTest.cpp	/^TEST_P(CompressionTest, RandomData) {$/;"	f	namespace:folly::io::test	signature:(CompressionTest, RandomData)
folly::io::test::constantDataHolder	.\io\test\CompressionTest.cpp	/^ConstantDataHolder constantDataHolder(dataSizeLog2);$/;"	p	namespace:folly::io::test	file:	signature:(dataSizeLog2)
folly::io::test::dataSizeLog2	.\io\test\CompressionTest.cpp	/^constexpr size_t dataSizeLog2 = 27;  \/\/ 128MiB$/;"	m	namespace:folly::io::test	file:
folly::io::test::hashIOBuf	.\io\test\CompressionTest.cpp	/^uint64_t hashIOBuf(const IOBuf* buf) {$/;"	f	namespace:folly::io::test	signature:(const IOBuf* buf)
folly::io::test::randomDataHolder	.\io\test\CompressionTest.cpp	/^RandomDataHolder randomDataHolder(dataSizeLog2);$/;"	p	namespace:folly::io::test	file:	signature:(dataSizeLog2)
folly::is_complete	.\Traits.h	/^class is_complete {$/;"	c	namespace:folly
folly::is_complete::sfinae	.\Traits.h	/^  template <unsigned long long> struct sfinae {};$/;"	s	class:folly::is_complete	access:private
folly::is_complete::test	.\Traits.h	/^  constexpr static bool test(sfinae<sizeof(U)>*) { return true; }$/;"	f	class:folly::is_complete	access:private	signature:(sfinae<sizeof(U)>*)
folly::is_complete::test	.\Traits.h	/^  template <typename> constexpr static bool test(...) { return false; }$/;"	f	class:folly::is_complete	access:private	signature:(....)
folly::is_complete::value	.\Traits.h	/^  constexpr static bool value = test<T>(nullptr);$/;"	m	class:folly::is_complete	access:public
folly::is_negative	.\Traits.h	/^constexpr bool is_negative(T x) {$/;"	f	namespace:folly	signature:(T x)
folly::is_non_negative	.\Traits.h	/^constexpr bool is_non_negative(T x) {$/;"	f	namespace:folly	signature:(T x)
folly::is_non_positive	.\Traits.h	/^constexpr bool is_non_positive(T x) { return !x || folly::is_negative(x); }$/;"	f	namespace:folly	signature:(T x)
folly::is_positive	.\Traits.h	/^constexpr bool is_positive(T x) { return !is_non_positive(x); }$/;"	f	namespace:folly	signature:(T x)
folly::is_simple_allocator	.\Memory.h	/^class is_simple_allocator {$/;"	c	namespace:folly
folly::is_simple_allocator::FOLLY_CREATE_HAS_MEMBER_FN_TRAITS	.\Memory.h	/^  FOLLY_CREATE_HAS_MEMBER_FN_TRAITS(has_destroy, destroy);$/;"	p	class:folly::is_simple_allocator	access:private	signature:(has_destroy, destroy)
folly::is_simple_allocator::allocator	.\Memory.h	/^  >::type allocator;$/;"	t	class:folly::is_simple_allocator	access:private
folly::is_simple_allocator::pointer	.\Memory.h	/^  typedef value_type* pointer;$/;"	t	class:folly::is_simple_allocator	access:private
folly::is_simple_allocator::value	.\Memory.h	/^  constexpr static bool value = !has_destroy<allocator, void(pointer)>::value$/;"	m	class:folly::is_simple_allocator	access:public
folly::is_simple_allocator::value_type	.\Memory.h	/^  typedef typename std::remove_reference<T>::type value_type;$/;"	t	class:folly::is_simple_allocator	access:private
folly::join	.\String-inl.h	/^void join(const Delim& delimiter,$/;"	f	namespace:folly	signature:(const Delim& delimiter, Iterator begin, Iterator end, String& output)
folly::json	.\json.cpp	/^namespace json {$/;"	n	namespace:folly	file:
folly::json	.\json.h	/^namespace json {$/;"	n	namespace:folly
folly::json::ParseError	.\json.h	/^  struct ParseError : std::runtime_error {$/;"	s	namespace:folly::json	inherits:std::runtime_error
folly::json::ParseError::ParseError	.\json.h	/^    explicit ParseError(int line)$/;"	f	struct:folly::json::ParseError	access:public	signature:(int line)
folly::json::ParseError::ParseError	.\json.h	/^    explicit ParseError(int line, std::string const& context,$/;"	f	struct:folly::json::ParseError	access:public	signature:(int line, std::string const& context, std::string const& expected)
folly::json::ParseError::ParseError	.\json.h	/^    explicit ParseError(std::string const& msg)$/;"	f	struct:folly::json::ParseError	access:public	signature:(std::string const& msg)
folly::json::__anon75::Input	.\json.cpp	/^struct Input {$/;"	s	namespace:folly::json::__anon75	file:
folly::json::__anon75::Input::Input	.\json.cpp	/^  Input(Input const&) = delete;$/;"	p	struct:folly::json::__anon75::Input	file:	access:public	signature:(Input const&)
folly::json::__anon75::Input::Input	.\json.cpp	/^  explicit Input(StringPiece range, json::serialization_opts const* opts)$/;"	f	struct:folly::json::__anon75::Input	access:public	signature:(StringPiece range, json::serialization_opts const* opts)
folly::json::__anon75::Input::begin	.\json.cpp	/^  char const* begin() const { return range_.begin(); }$/;"	f	struct:folly::json::__anon75::Input	access:public	signature:() const
folly::json::__anon75::Input::consume	.\json.cpp	/^  bool consume(StringPiece str) {$/;"	f	struct:folly::json::__anon75::Input	access:public	signature:(StringPiece str)
folly::json::__anon75::Input::context	.\json.cpp	/^  std::string context() const {$/;"	f	struct:folly::json::__anon75::Input	access:public	signature:() const
folly::json::__anon75::Input::current_	.\json.cpp	/^  int current_;$/;"	m	struct:folly::json::__anon75::Input	file:	access:private
folly::json::__anon75::Input::error	.\json.cpp	/^  dynamic error(char const* what) const {$/;"	f	struct:folly::json::__anon75::Input	access:public	signature:(char const* what) const
folly::json::__anon75::Input::expect	.\json.cpp	/^  void expect(char c) {$/;"	f	struct:folly::json::__anon75::Input	access:public	signature:(char c)
folly::json::__anon75::Input::extract	.\json.cpp	/^  T extract() {$/;"	f	struct:folly::json::__anon75::Input	access:public	signature:()
folly::json::__anon75::Input::json::getOpts	.\json.cpp	/^  json::serialization_opts const& getOpts() {$/;"	f	class:folly::json::__anon75::Input::json	access:public	signature:()
folly::json::__anon75::Input::json::opts_	.\json.cpp	/^  json::serialization_opts const& opts_;$/;"	m	class:folly::json::__anon75::Input::json	file:	access:private
folly::json::__anon75::Input::lineNum_	.\json.cpp	/^  unsigned lineNum_;$/;"	m	struct:folly::json::__anon75::Input	file:	access:private
folly::json::__anon75::Input::operator *	.\json.cpp	/^  int operator*() const {$/;"	f	struct:folly::json::__anon75::Input	access:public	signature:() const
folly::json::__anon75::Input::operator ++	.\json.cpp	/^  void operator++() {$/;"	f	struct:folly::json::__anon75::Input	access:public	signature:()
folly::json::__anon75::Input::operator =	.\json.cpp	/^  Input& operator=(Input const&) = delete;$/;"	p	struct:folly::json::__anon75::Input	file:	access:public	signature:(Input const&)
folly::json::__anon75::Input::range_	.\json.cpp	/^  StringPiece range_;$/;"	m	struct:folly::json::__anon75::Input	file:	access:private
folly::json::__anon75::Input::size	.\json.cpp	/^  std::size_t size() const {$/;"	f	struct:folly::json::__anon75::Input	access:public	signature:() const
folly::json::__anon75::Input::skipDigits	.\json.cpp	/^  StringPiece skipDigits() {$/;"	f	struct:folly::json::__anon75::Input	access:public	signature:()
folly::json::__anon75::Input::skipMinusAndDigits	.\json.cpp	/^  StringPiece skipMinusAndDigits() {$/;"	f	struct:folly::json::__anon75::Input	access:public	signature:()
folly::json::__anon75::Input::skipWhile	.\json.cpp	/^  StringPiece skipWhile(const Predicate& p) {$/;"	f	struct:folly::json::__anon75::Input	access:public	signature:(const Predicate& p)
folly::json::__anon75::Input::skipWhitespace	.\json.cpp	/^  void skipWhitespace() {$/;"	f	struct:folly::json::__anon75::Input	access:public	signature:()
folly::json::__anon75::Input::storeCurrent	.\json.cpp	/^  void storeCurrent() {$/;"	f	struct:folly::json::__anon75::Input	file:	access:private	signature:()
folly::json::__anon75::Printer	.\json.cpp	/^struct Printer {$/;"	s	namespace:folly::json::__anon75	file:
folly::json::__anon75::Printer::Printer	.\json.cpp	/^  explicit Printer(fbstring& out,$/;"	f	struct:folly::json::__anon75::Printer	access:public	signature:(fbstring& out, unsigned* indentLevel, serialization_opts const* opts)
folly::json::__anon75::Printer::indent	.\json.cpp	/^  void indent() const {$/;"	f	struct:folly::json::__anon75::Printer	file:	access:private	signature:() const
folly::json::__anon75::Printer::indentLevel_	.\json.cpp	/^  unsigned* const indentLevel_;$/;"	m	struct:folly::json::__anon75::Printer	file:	access:private
folly::json::__anon75::Printer::mapColon	.\json.cpp	/^  void mapColon() const {$/;"	f	struct:folly::json::__anon75::Printer	file:	access:private	signature:() const
folly::json::__anon75::Printer::newline	.\json.cpp	/^  void newline() const {$/;"	f	struct:folly::json::__anon75::Printer	file:	access:private	signature:() const
folly::json::__anon75::Printer::operator ()	.\json.cpp	/^  void operator()(dynamic const& v) const {$/;"	f	struct:folly::json::__anon75::Printer	access:public	signature:(dynamic const& v) const
folly::json::__anon75::Printer::opts_	.\json.cpp	/^  serialization_opts const& opts_;$/;"	m	struct:folly::json::__anon75::Printer	file:	access:private
folly::json::__anon75::Printer::out_	.\json.cpp	/^  fbstring& out_;$/;"	m	struct:folly::json::__anon75::Printer	file:	access:private
folly::json::__anon75::Printer::outdent	.\json.cpp	/^  void outdent() const {$/;"	f	struct:folly::json::__anon75::Printer	file:	access:private	signature:() const
folly::json::__anon75::Printer::printArray	.\json.cpp	/^  void printArray(dynamic const& a) const {$/;"	f	struct:folly::json::__anon75::Printer	file:	access:private	signature:(dynamic const& a) const
folly::json::__anon75::Printer::printKV	.\json.cpp	/^  void printKV(const std::pair<const dynamic, dynamic>& p) const {$/;"	f	struct:folly::json::__anon75::Printer	file:	access:private	signature:(const std::pair<const dynamic, dynamic>& p) const
folly::json::__anon75::Printer::printKVPairs	.\json.cpp	/^  void printKVPairs(Iterator begin, Iterator end) const {$/;"	f	struct:folly::json::__anon75::Printer	file:	access:private	signature:(Iterator begin, Iterator end) const
folly::json::__anon75::Printer::printObject	.\json.cpp	/^  void printObject(dynamic const& o) const {$/;"	f	struct:folly::json::__anon75::Printer	file:	access:private	signature:(dynamic const& o) const
folly::json::__anon75::decodeUnicodeEscape	.\json.cpp	/^fbstring decodeUnicodeEscape(Input& in) {$/;"	f	namespace:folly::json::__anon75	signature:(Input& in)
folly::json::__anon75::decodeUtf8	.\json.cpp	/^char32_t decodeUtf8($/;"	f	namespace:folly::json::__anon75	signature:( const unsigned char*& p, const unsigned char* const e, bool skipOnError)
folly::json::__anon75::parseArray	.\json.cpp	/^dynamic parseArray(Input& in) {$/;"	f	namespace:folly::json::__anon75	signature:(Input& in)
folly::json::__anon75::parseNumber	.\json.cpp	/^dynamic parseNumber(Input& in) {$/;"	f	namespace:folly::json::__anon75	signature:(Input& in)
folly::json::__anon75::parseNumber	.\json.cpp	/^dynamic parseNumber(Input& in);$/;"	p	namespace:folly::json::__anon75	file:	signature:(Input& in)
folly::json::__anon75::parseObject	.\json.cpp	/^dynamic parseObject(Input& in) {$/;"	f	namespace:folly::json::__anon75	signature:(Input& in)
folly::json::__anon75::parseString	.\json.cpp	/^fbstring parseString(Input& in) {$/;"	f	namespace:folly::json::__anon75	signature:(Input& in)
folly::json::__anon75::parseString	.\json.cpp	/^fbstring parseString(Input& in);$/;"	p	namespace:folly::json::__anon75	file:	signature:(Input& in)
folly::json::__anon75::parseValue	.\json.cpp	/^dynamic parseValue(Input& in) {$/;"	f	namespace:folly::json::__anon75	signature:(Input& in)
folly::json::__anon75::parseValue	.\json.cpp	/^dynamic parseValue(Input& in);$/;"	p	namespace:folly::json::__anon75	file:	signature:(Input& in)
folly::json::escapeString	.\json.cpp	/^void escapeString(StringPiece input,$/;"	f	namespace:folly::json	signature:(StringPiece input, fbstring& out, const serialization_opts& opts)
folly::json::escapeString	.\json.h	/^  void escapeString(StringPiece input,$/;"	p	namespace:folly::json	signature:(StringPiece input, fbstring& out, const serialization_opts& opts)
folly::json::serialization_opts	.\json.h	/^  struct serialization_opts {$/;"	s	namespace:folly::json
folly::json::serialization_opts::allow_nan_inf	.\json.h	/^    bool allow_nan_inf;$/;"	m	struct:folly::json::serialization_opts	access:public
folly::json::serialization_opts::allow_non_string_keys	.\json.h	/^    bool allow_non_string_keys;$/;"	m	struct:folly::json::serialization_opts	access:public
folly::json::serialization_opts::allow_trailing_comma	.\json.h	/^    bool allow_trailing_comma;$/;"	m	struct:folly::json::serialization_opts	access:public
folly::json::serialization_opts::double_mode	.\json.h	/^    double_conversion::DoubleToStringConverter::DtoaMode double_mode;$/;"	m	struct:folly::json::serialization_opts	access:public
folly::json::serialization_opts::double_num_digits	.\json.h	/^    unsigned int double_num_digits;$/;"	m	struct:folly::json::serialization_opts	access:public
folly::json::serialization_opts::encode_non_ascii	.\json.h	/^    bool encode_non_ascii;$/;"	m	struct:folly::json::serialization_opts	access:public
folly::json::serialization_opts::javascript_safe	.\json.h	/^    bool javascript_safe;$/;"	m	struct:folly::json::serialization_opts	access:public
folly::json::serialization_opts::pretty_formatting	.\json.h	/^    bool pretty_formatting;$/;"	m	struct:folly::json::serialization_opts	access:public
folly::json::serialization_opts::serialization_opts	.\json.h	/^    explicit serialization_opts()$/;"	f	struct:folly::json::serialization_opts	access:public	signature:()
folly::json::serialization_opts::skip_invalid_utf8	.\json.h	/^    bool skip_invalid_utf8;$/;"	m	struct:folly::json::serialization_opts	access:public
folly::json::serialization_opts::sort_keys	.\json.h	/^    bool sort_keys;$/;"	m	struct:folly::json::serialization_opts	access:public
folly::json::serialization_opts::validate_utf8	.\json.h	/^    bool validate_utf8;$/;"	m	struct:folly::json::serialization_opts	access:public
folly::json::serialize	.\json.cpp	/^fbstring serialize(dynamic const& dyn, serialization_opts const& opts) {$/;"	f	namespace:folly::json	signature:(dynamic const& dyn, serialization_opts const& opts)
folly::json::serialize	.\json.h	/^  fbstring serialize(dynamic const&, serialization_opts const&);$/;"	p	namespace:folly::json	signature:(dynamic const&, serialization_opts const&)
folly::json::stripComments	.\json.cpp	/^fbstring stripComments(StringPiece jsonC) {$/;"	f	namespace:folly::json	signature:(StringPiece jsonC)
folly::json::stripComments	.\json.h	/^  fbstring stripComments(StringPiece jsonC);$/;"	p	namespace:folly::json	signature:(StringPiece jsonC)
folly::kMaxVarintLength32	.\Varint.h	/^constexpr size_t kMaxVarintLength32 = 5;$/;"	m	namespace:folly
folly::kMaxVarintLength64	.\Varint.h	/^constexpr size_t kMaxVarintLength64 = 10;$/;"	m	namespace:folly
folly::kNoFD	.\io\async\EventBase.cpp	/^const int kNoFD = -1;$/;"	m	namespace:folly	file:
folly::lazy	.\Lazy.h	/^lazy(Func&& fun) {$/;"	f	namespace:folly	signature:(Func&& fun)
folly::less_than	.\Traits.h	/^bool less_than(LHS const lhs) {$/;"	f	namespace:folly	signature:(LHS const lhs)
folly::localHead	.\IndexedMemPool.h	/^  AtomicStruct<TaggedPtr,Atom>& localHead() {$/;"	f	namespace:folly	signature:()
folly::localPop	.\IndexedMemPool.h	/^  uint32_t localPop(AtomicStruct<TaggedPtr,Atom>& head) {$/;"	f	namespace:folly	signature:(AtomicStruct<TaggedPtr,Atom>& head)
folly::localPush	.\IndexedMemPool.h	/^  void localPush(AtomicStruct<TaggedPtr,Atom>& head, uint32_t idx) {$/;"	f	namespace:folly	signature:(AtomicStruct<TaggedPtr,Atom>& head, uint32_t idx)
folly::local_	.\IndexedMemPool.h	/^  LocalList local_[NumLocalLists];$/;"	m	namespace:folly
folly::lockInOrder	.\Synchronized.h	/^void lockInOrder(P1& p1, P2& p2) {$/;"	f	namespace:folly	signature:(P1& p1, P2& p2)
folly::makeGuard	.\ScopeGuard.h	/^makeGuard(FunctionType&& fn) {$/;"	f	namespace:folly	signature:(FunctionType&& fn)
folly::makeMoveWrapper	.\MoveWrapper.h	/^MoveWrapper<T> makeMoveWrapper(T&& t) {$/;"	f	namespace:folly	signature:(T&& t)
folly::make_exception_wrapper	.\ExceptionWrapper.h	/^exception_wrapper make_exception_wrapper(Args&&... args) {$/;"	f	namespace:folly	signature:(Args&&.... args)
folly::make_optional	.\Optional.h	/^Opt make_optional(T&& v) {$/;"	f	namespace:folly	signature:(T&& v)
folly::make_stl_allocator	.\Memory.h	/^>::type make_stl_allocator(Allocator&& allocator) {$/;"	f	namespace:folly	signature:(Allocator&& allocator)
folly::make_unique	.\Memory.h	/^make_unique(Args&&... args) {$/;"	f	namespace:folly	signature:(Args&&.... args)
folly::make_unique	.\Memory.h	/^make_unique(Args&&...) = delete;$/;"	p	namespace:folly	signature:(Args&&....)
folly::make_unique	.\Memory.h	/^make_unique(const size_t n) {$/;"	f	namespace:folly	signature:(const size_t n)
folly::meanVariance	.\Benchmark.cpp	/^meanVariance(const double * begin, const double *const end) {$/;"	f	namespace:folly	signature:(const double * begin, const double *const end)
folly::merge	.\Merge.h	/^OutputIt merge(InputIt1 first1, InputIt1 last1,$/;"	f	namespace:folly	signature:(InputIt1 first1, InputIt1 last1, InputIt2 first2, InputIt2 last2, OutputIt d_first)
folly::merge	.\Merge.h	/^OutputIt merge(InputIt1 first1, InputIt1 last1,$/;"	f	namespace:folly	signature:(InputIt1 first1, InputIt1 last1, InputIt2 first2, InputIt2 last2, OutputIt d_first, Compare comp)
folly::metricReadable	.\Benchmark.cpp	/^static string metricReadable(double n, unsigned int decimals) {$/;"	f	namespace:folly	signature:(double n, unsigned int decimals)
folly::mmapFileCopy	.\MemoryMapping.cpp	/^void mmapFileCopy(const char* src, const char* dest, mode_t mode) {$/;"	f	namespace:folly	signature:(const char* src, const char* dest, mode_t mode)
folly::mmapFileCopy	.\MemoryMapping.h	/^void mmapFileCopy(const char* src, const char* dest, mode_t mode = 0666);$/;"	p	namespace:folly	signature:(const char* src, const char* dest, mode_t mode = 0666)
folly::mmapLength_	.\IndexedMemPool.h	/^  size_t mmapLength_;$/;"	m	namespace:folly
folly::mode	.\Benchmark.cpp	/^static double mode(const double * begin, const double *const end) {$/;"	f	namespace:folly	signature:(const double * begin, const double *const end)
folly::none	.\Optional.h	/^const None none = nullptr;$/;"	m	namespace:folly
folly::openNoInt	.\FileUtil.cpp	/^int openNoInt(const char* name, int flags, mode_t mode) {$/;"	f	namespace:folly	signature:(const char* name, int flags, mode_t mode)
folly::openNoInt	.\FileUtil.h	/^int openNoInt(const char* name, int flags, mode_t mode = 0666);$/;"	p	namespace:folly	signature:(const char* name, int flags, mode_t mode = 0666)
folly::operator !=	.\Optional.h	/^bool operator!=(const Optional<V>& a, const Optional<V>& b) {$/;"	f	namespace:folly	signature:(const Optional<V>& a, const Optional<V>& b)
folly::operator !=	.\Optional.h	/^template<class V> bool operator!=(const Optional<V>&, const V& other) = delete;$/;"	p	namespace:folly	signature:(const Optional<V>&, const V& other)
folly::operator !=	.\Optional.h	/^template<class V> bool operator!=(const V& other, const Optional<V>&) = delete;$/;"	p	namespace:folly	signature:(const V& other, const Optional<V>&)
folly::operator <	.\IPAddress.cpp	/^bool operator<(const IPAddress& addr1, const IPAddress& addr2) {$/;"	f	namespace:folly	signature:(const IPAddress& addr1, const IPAddress& addr2)
folly::operator <	.\IPAddress.h	/^bool operator<(const IPAddress& addr1, const IPAddress& addr2);$/;"	p	namespace:folly	signature:(const IPAddress& addr1, const IPAddress& addr2)
folly::operator <	.\IPAddressV4.h	/^inline bool operator<(const IPAddressV4& addr1, const IPAddressV4& addr2) {$/;"	f	namespace:folly	signature:(const IPAddressV4& addr1, const IPAddressV4& addr2)
folly::operator <	.\IPAddressV6.h	/^inline bool operator<(const IPAddressV6& addr1, const IPAddressV6& addr2) {$/;"	f	namespace:folly	signature:(const IPAddressV6& addr1, const IPAddressV6& addr2)
folly::operator <	.\Optional.h	/^bool operator< (const Optional<V>& a, const Optional<V>& b) {$/;"	f	namespace:folly	signature:(const Optional<V>& a, const Optional<V>& b)
folly::operator <	.\Optional.h	/^template<class V> bool operator< (const Optional<V>&, const V& other) = delete;$/;"	p	namespace:folly	signature:(const Optional<V>&, const V& other)
folly::operator <	.\Optional.h	/^template<class V> bool operator< (const V& other, const Optional<V>&) = delete;$/;"	p	namespace:folly	signature:(const V& other, const Optional<V>&)
folly::operator <	.\Range.h	/^inline bool operator<(const Range<T>& lhs, const Range<T>& rhs) {$/;"	f	namespace:folly	signature:(const Range<T>& lhs, const Range<T>& rhs)
folly::operator <	.\Range.h	/^operator<(const T& lhs, const U& rhs) {$/;"	f	namespace:folly	signature:(const T& lhs, const U& rhs)
folly::operator <	.\experimental\io\HugePages.h	/^inline bool operator<(const HugePageSize& a, const HugePageSize& b) {$/;"	f	namespace:folly	signature:(const HugePageSize& a, const HugePageSize& b)
folly::operator <<	.\IPAddress.cpp	/^ostream& operator<<(ostream& os, const IPAddress& addr) {$/;"	f	namespace:folly	signature:(ostream& os, const IPAddress& addr)
folly::operator <<	.\IPAddress.h	/^std::ostream& operator<<(std::ostream& os, const IPAddress& addr);$/;"	p	namespace:folly	signature:(std::ostream& os, const IPAddress& addr)
folly::operator <<	.\IPAddressV4.cpp	/^ostream& operator<<(ostream& os, const IPAddressV4& addr) {$/;"	f	namespace:folly	signature:(ostream& os, const IPAddressV4& addr)
folly::operator <<	.\IPAddressV4.h	/^std::ostream& operator<<(std::ostream& os, const IPAddressV4& addr);$/;"	p	namespace:folly	signature:(std::ostream& os, const IPAddressV4& addr)
folly::operator <<	.\IPAddressV6.cpp	/^ostream& operator<<(ostream& os, const IPAddressV6& addr) {$/;"	f	namespace:folly	signature:(ostream& os, const IPAddressV6& addr)
folly::operator <<	.\IPAddressV6.h	/^std::ostream& operator<<(std::ostream& os, const IPAddressV6& addr);$/;"	p	namespace:folly	signature:(std::ostream& os, const IPAddressV6& addr)
folly::operator <<	.\MacAddress.cpp	/^std::ostream& operator<<(std::ostream& os, MacAddress address) {$/;"	f	namespace:folly	signature:(std::ostream& os, MacAddress address)
folly::operator <<	.\MacAddress.h	/^std::ostream& operator<<(std::ostream& os, MacAddress address);$/;"	p	namespace:folly	signature:(std::ostream& os, MacAddress address)
folly::operator <<	.\Range.cpp	/^std::ostream& operator<<(std::ostream& os, const MutableStringPiece& piece) {$/;"	f	namespace:folly	signature:(std::ostream& os, const MutableStringPiece& piece)
folly::operator <<	.\Range.cpp	/^std::ostream& operator<<(std::ostream& os, const StringPiece& piece) {$/;"	f	namespace:folly	signature:(std::ostream& os, const StringPiece& piece)
folly::operator <<	.\Range.h	/^std::ostream& operator<<(std::ostream& os, const MutableStringPiece& piece);$/;"	p	namespace:folly	signature:(std::ostream& os, const MutableStringPiece& piece)
folly::operator <<	.\Range.h	/^std::ostream& operator<<(std::ostream& os, const StringPiece& piece);$/;"	p	namespace:folly	signature:(std::ostream& os, const StringPiece& piece)
folly::operator <<	.\SocketAddress.cpp	/^std::ostream& operator<<(std::ostream& os, const SocketAddress& addr) {$/;"	f	namespace:folly	signature:(std::ostream& os, const SocketAddress& addr)
folly::operator <<	.\SocketAddress.h	/^std::ostream& operator<<(std::ostream& os, const SocketAddress& addr);$/;"	p	namespace:folly	signature:(std::ostream& os, const SocketAddress& addr)
folly::operator <<	.\dynamic-inl.h	/^inline std::ostream& operator<<(std::ostream& out, dynamic const& d) {$/;"	f	namespace:folly	signature:(std::ostream& out, dynamic const& d)
folly::operator <<	.\experimental\io\AsyncIO.cpp	/^std::ostream& operator<<(std::ostream& os, AsyncIOOp::State state) {$/;"	f	namespace:folly	signature:(std::ostream& os, AsyncIOOp::State state)
folly::operator <<	.\experimental\io\AsyncIO.cpp	/^std::ostream& operator<<(std::ostream& os, const AsyncIOOp& op) {$/;"	f	namespace:folly	signature:(std::ostream& os, const AsyncIOOp& op)
folly::operator <<	.\experimental\io\AsyncIO.h	/^std::ostream& operator<<(std::ostream& stream, AsyncIOOp::State state);$/;"	p	namespace:folly	signature:(std::ostream& stream, AsyncIOOp::State state)
folly::operator <<	.\experimental\io\AsyncIO.h	/^std::ostream& operator<<(std::ostream& stream, const AsyncIOOp& o);$/;"	p	namespace:folly	signature:(std::ostream& stream, const AsyncIOOp& o)
folly::operator <<	.\test\OptionalTest.cpp	/^std::ostream& operator<<(std::ostream& os, const Optional<V>& v) {$/;"	f	namespace:folly	signature:(std::ostream& os, const Optional<V>& v)
folly::operator <=	.\Optional.h	/^bool operator<=(const Optional<V>& a, const Optional<V>& b) {$/;"	f	namespace:folly	signature:(const Optional<V>& a, const Optional<V>& b)
folly::operator <=	.\Optional.h	/^template<class V> bool operator<=(const Optional<V>&, const V& other) = delete;$/;"	p	namespace:folly	signature:(const Optional<V>&, const V& other)
folly::operator <=	.\Optional.h	/^template<class V> bool operator<=(const V& other, const Optional<V>&) = delete;$/;"	p	namespace:folly	signature:(const V& other, const Optional<V>&)
folly::operator <=	.\Range.h	/^operator<=(const T& lhs, const U& rhs) {$/;"	f	namespace:folly	signature:(const T& lhs, const U& rhs)
folly::operator ==	.\IPAddress.cpp	/^bool operator==(const IPAddress& addr1, const IPAddress& addr2) {$/;"	f	namespace:folly	signature:(const IPAddress& addr1, const IPAddress& addr2)
folly::operator ==	.\IPAddress.h	/^bool operator==(const IPAddress& addr1, const IPAddress& addr2);$/;"	p	namespace:folly	signature:(const IPAddress& addr1, const IPAddress& addr2)
folly::operator ==	.\IPAddressV4.h	/^inline bool operator==(const IPAddressV4& addr1, const IPAddressV4& addr2) {$/;"	f	namespace:folly	signature:(const IPAddressV4& addr1, const IPAddressV4& addr2)
folly::operator ==	.\IPAddressV6.h	/^inline bool operator==(const IPAddressV6& addr1, const IPAddressV6& addr2) {$/;"	f	namespace:folly	signature:(const IPAddressV6& addr1, const IPAddressV6& addr2)
folly::operator ==	.\Optional.h	/^bool operator==(const Optional<V>& a, const Optional<V>& b) {$/;"	f	namespace:folly	signature:(const Optional<V>& a, const Optional<V>& b)
folly::operator ==	.\Optional.h	/^template<class V> bool operator==(const Optional<V>&, const V& other) = delete;$/;"	p	namespace:folly	signature:(const Optional<V>&, const V& other)
folly::operator ==	.\Optional.h	/^template<class V> bool operator==(const V& other, const Optional<V>&) = delete;$/;"	p	namespace:folly	signature:(const V& other, const Optional<V>&)
folly::operator ==	.\Range.h	/^inline bool operator==(const Range<T>& lhs, const Range<T>& rhs) {$/;"	f	namespace:folly	signature:(const Range<T>& lhs, const Range<T>& rhs)
folly::operator ==	.\Range.h	/^operator==(const T& lhs, const U& rhs) {$/;"	f	namespace:folly	signature:(const T& lhs, const U& rhs)
folly::operator ==	.\experimental\io\HugePages.h	/^inline bool operator==(const HugePageSize& a, const HugePageSize& b) {$/;"	f	namespace:folly	signature:(const HugePageSize& a, const HugePageSize& b)
folly::operator ==	.\test\OptionalTest.cpp	/^bool operator==(const MoveTester& o1, const MoveTester& o2) {$/;"	f	namespace:folly	signature:(const MoveTester& o1, const MoveTester& o2)
folly::operator ==	.\test\RangeTest.cpp	/^bool operator==(MutableStringPiece mp, StringPiece sp) {$/;"	f	namespace:folly	signature:(MutableStringPiece mp, StringPiece sp)
folly::operator ==	.\test\RangeTest.cpp	/^bool operator==(StringPiece sp, MutableStringPiece mp) {$/;"	f	namespace:folly	signature:(StringPiece sp, MutableStringPiece mp)
folly::operator >	.\Optional.h	/^bool operator> (const Optional<V>& a, const Optional<V>& b) {$/;"	f	namespace:folly	signature:(const Optional<V>& a, const Optional<V>& b)
folly::operator >	.\Optional.h	/^template<class V> bool operator> (const Optional<V>&, const V& other) = delete;$/;"	p	namespace:folly	signature:(const Optional<V>&, const V& other)
folly::operator >	.\Optional.h	/^template<class V> bool operator> (const V& other, const Optional<V>&) = delete;$/;"	p	namespace:folly	signature:(const V& other, const Optional<V>&)
folly::operator >	.\Range.h	/^operator>(const T& lhs, const U& rhs) {$/;"	f	namespace:folly	signature:(const T& lhs, const U& rhs)
folly::operator >=	.\Optional.h	/^bool operator>=(const Optional<V>& a, const Optional<V>& b) {$/;"	f	namespace:folly	signature:(const Optional<V>& a, const Optional<V>& b)
folly::operator >=	.\Optional.h	/^template<class V> bool operator>=(const Optional<V>&, const V& other) = delete;$/;"	p	namespace:folly	signature:(const Optional<V>&, const V& other)
folly::operator >=	.\Optional.h	/^template<class V> bool operator>=(const V& other, const Optional<V>&) = delete;$/;"	p	namespace:folly	signature:(const V& other, const Optional<V>&)
folly::operator >=	.\Range.h	/^operator>=(const T& lhs, const U& rhs) {$/;"	f	namespace:folly	signature:(const T& lhs, const U& rhs)
folly::padded	.\Padded.h	/^namespace padded {$/;"	n	namespace:folly
folly::padded::Node	.\Padded.h	/^class Node;$/;"	x
folly::padded::advance	.\Padded.h	/^  void advance(typename Super::difference_type n) {$/;"	f	namespace:folly::padded	access:private	signature:(typename Super::difference_type n)
folly::padded::decrement	.\Padded.h	/^  void decrement() {$/;"	f	namespace:folly::padded	access:private	signature:()
folly::padded::dereference	.\Padded.h	/^  typename Super::reference dereference() const {$/;"	f	namespace:folly::padded	access:private	signature:() const
folly::padded::detail	.\Padded.h	/^namespace detail {$/;"	n	namespace:folly::padded
folly::padded::detail::NodeValid	.\Padded.h	/^template <class T, size_t NS, class Enable=void> struct NodeValid;$/;"	x
folly::padded::detail::base_reference	.\Padded.h	/^  const Node& node() const { return *this->base_reference(); }$/;"	p	namespace:folly::padded::detail	signature:()
folly::padded::distance_to	.\Padded.h	/^  typename Super::difference_type distance_to(const Iterator& other) const {$/;"	f	namespace:folly::padded	access:private	signature:(const Iterator& other) const
folly::padded::equal	.\Padded.h	/^  bool equal(const Iterator& other) const {$/;"	f	namespace:folly::padded	access:private	signature:(const Iterator& other) const
folly::padded::increment	.\Padded.h	/^  void increment() {$/;"	f	namespace:folly::padded	access:private	signature:()
folly::padded::pos	.\Padded.h	/^  size_t pos() const { return pos_; }$/;"	f	namespace:folly::padded	signature:() const
folly::padded::pos_	.\Padded.h	/^  ssize_t pos_;  \/\/ signed for easier advance() implementation$/;"	m	namespace:folly::padded	access:private
folly::parseJson	.\json.cpp	/^dynamic parseJson($/;"	f	namespace:folly	signature:( StringPiece range, json::serialization_opts const& opts)
folly::parseJson	.\json.cpp	/^dynamic parseJson(StringPiece range) {$/;"	f	namespace:folly	signature:(StringPiece range)
folly::parseJson	.\json.h	/^dynamic parseJson(StringPiece);$/;"	p	namespace:folly	signature:(StringPiece)
folly::preadFull	.\FileUtil.cpp	/^ssize_t preadFull(int fd, void* buf, size_t count, off_t offset) {$/;"	f	namespace:folly	signature:(int fd, void* buf, size_t count, off_t offset)
folly::preadFull	.\FileUtil.h	/^ssize_t preadFull(int fd, void* buf, size_t n, off_t offset);$/;"	p	namespace:folly	signature:(int fd, void* buf, size_t n, off_t offset)
folly::preadNoInt	.\FileUtil.cpp	/^ssize_t preadNoInt(int fd, void* buf, size_t count, off_t offset) {$/;"	f	namespace:folly	signature:(int fd, void* buf, size_t count, off_t offset)
folly::preadNoInt	.\FileUtil.h	/^ssize_t preadNoInt(int fd, void* buf, size_t n, off_t offset);$/;"	p	namespace:folly	signature:(int fd, void* buf, size_t n, off_t offset)
folly::preadvFull	.\FileUtil.cpp	/^ssize_t preadvFull(int fd, iovec* iov, int count, off_t offset) {$/;"	f	namespace:folly	signature:(int fd, iovec* iov, int count, off_t offset)
folly::preadvFull	.\FileUtil.h	/^ssize_t preadvFull(int fd, iovec* iov, int count, off_t offset);$/;"	p	namespace:folly	signature:(int fd, iovec* iov, int count, off_t offset)
folly::prettyPrint	.\String.cpp	/^std::string prettyPrint(double val, PrettyType type, bool addSpace) {$/;"	f	namespace:folly	signature:(double val, PrettyType type, bool addSpace)
folly::prettyToDouble	.\String.cpp	/^double prettyToDouble(folly::StringPiece *const prettyString,$/;"	f	namespace:folly	signature:(folly::StringPiece *const prettyString, const PrettyType type)
folly::prettyToDouble	.\String.cpp	/^double prettyToDouble(folly::StringPiece prettyString, const PrettyType type){$/;"	f	namespace:folly	signature:(folly::StringPiece prettyString, const PrettyType type)
folly::printBenchmarkResults	.\Benchmark.cpp	/^static void printBenchmarkResults($/;"	f	namespace:folly	signature:( const vector<tuple<const char*, const char*, double> >& data)
folly::printBenchmarkResultsAsJson	.\Benchmark.cpp	/^static void printBenchmarkResultsAsJson($/;"	f	namespace:folly	signature:( const vector<tuple<const char*, const char*, double> >& data)
folly::printBenchmarkResultsAsTable	.\Benchmark.cpp	/^static void printBenchmarkResultsAsTable($/;"	f	namespace:folly	signature:( const vector<tuple<const char*, const char*, double> >& data)
folly::pwriteFull	.\FileUtil.cpp	/^ssize_t pwriteFull(int fd, const void* buf, size_t count, off_t offset) {$/;"	f	namespace:folly	signature:(int fd, const void* buf, size_t count, off_t offset)
folly::pwriteFull	.\FileUtil.h	/^ssize_t pwriteFull(int fd, const void* buf, size_t n, off_t offset);$/;"	p	namespace:folly	signature:(int fd, const void* buf, size_t n, off_t offset)
folly::pwriteNoInt	.\FileUtil.cpp	/^ssize_t pwriteNoInt(int fd, const void* buf, size_t count, off_t offset) {$/;"	f	namespace:folly	signature:(int fd, const void* buf, size_t count, off_t offset)
folly::pwriteNoInt	.\FileUtil.h	/^ssize_t pwriteNoInt(int fd, const void* buf, size_t n, off_t offset);$/;"	p	namespace:folly	signature:(int fd, const void* buf, size_t n, off_t offset)
folly::pwritevFull	.\FileUtil.cpp	/^ssize_t pwritevFull(int fd, iovec* iov, int count, off_t offset) {$/;"	f	namespace:folly	signature:(int fd, iovec* iov, int count, off_t offset)
folly::pwritevFull	.\FileUtil.h	/^ssize_t pwritevFull(int fd, iovec* iov, int count, off_t offset);$/;"	p	namespace:folly	signature:(int fd, iovec* iov, int count, off_t offset)
folly::qfind	.\Range.h	/^inline size_t qfind(const Range<T> & haystack,$/;"	p	namespace:folly	signature:(const Range<T> & haystack, const Range<T> & needle, Comp eq = Comp())
folly::qfind	.\Range.h	/^inline size_t qfind(const Range<const char*>& haystack, const char& needle) {$/;"	f	namespace:folly	signature:(const Range<const char*>& haystack, const char& needle)
folly::qfind	.\Range.h	/^inline size_t qfind(const Range<const unsigned char*>& haystack,$/;"	f	namespace:folly	signature:(const Range<const unsigned char*>& haystack, const unsigned char& needle)
folly::qfind	.\Range.h	/^size_t qfind(const Range<T> & haystack,$/;"	p	namespace:folly	signature:(const Range<T> & haystack, const typename Range<T>::value_type& needle)
folly::qfind	.\Range.h	/^size_t qfind(const Range<T>& haystack,$/;"	f	namespace:folly	signature:(const Range<T>& haystack, const Range<T>& needle, Comp eq)
folly::qfind	.\Range.h	/^size_t qfind(const Range<T>& haystack,$/;"	f	namespace:folly	signature:(const Range<T>& haystack, const typename Range<T>::value_type& needle)
folly::qfind_first_of	.\Range.h	/^inline size_t qfind_first_of(const Range<T> & haystack,$/;"	p	namespace:folly	signature:(const Range<T> & haystack, const Range<T> & needle)
folly::qfind_first_of	.\Range.h	/^inline size_t qfind_first_of(const Range<const char*>& haystack,$/;"	f	namespace:folly	signature:(const Range<const char*>& haystack, const Range<const char*>& needles)
folly::qfind_first_of	.\Range.h	/^inline size_t qfind_first_of(const Range<const unsigned char*>& haystack,$/;"	f	namespace:folly	signature:(const Range<const unsigned char*>& haystack, const Range<const unsigned char*>& needles)
folly::qfind_first_of	.\Range.h	/^size_t qfind_first_of(const Range<T> & haystack,$/;"	f	namespace:folly	signature:(const Range<T> & haystack, const Range<T> & needles, Comp eq)
folly::qfind_first_of	.\Range.h	/^size_t qfind_first_of(const Range<T>& haystack,$/;"	f	namespace:folly	signature:(const Range<T>& haystack, const Range<T>& needles)
folly::randomNumberSeed	.\Random.h	/^inline uint32_t randomNumberSeed() {$/;"	f	namespace:folly	signature:()
folly::range	.\Range.h	/^Range<Iter> range(Iter first, Iter last) {$/;"	f	namespace:folly	signature:(Iter first, Iter last)
folly::range	.\Range.h	/^Range<T*> range(Collection&& v) {$/;"	f	namespace:folly	signature:(Collection&& v)
folly::readFile	.\FileUtil.h	/^bool readFile(const char* file_name, Container& out,$/;"	f	namespace:folly	signature:(const char* file_name, Container& out, size_t num_bytes = std::numeric_limits<size_t>::max())
folly::readFull	.\FileUtil.cpp	/^ssize_t readFull(int fd, void* buf, size_t count) {$/;"	f	namespace:folly	signature:(int fd, void* buf, size_t count)
folly::readFull	.\FileUtil.h	/^ssize_t readFull(int fd, void* buf, size_t n);$/;"	p	namespace:folly	signature:(int fd, void* buf, size_t n)
folly::readNoInt	.\FileUtil.cpp	/^ssize_t readNoInt(int fd, void* buf, size_t count) {$/;"	f	namespace:folly	signature:(int fd, void* buf, size_t count)
folly::readNoInt	.\FileUtil.h	/^ssize_t readNoInt(int fd, void* buf, size_t n);$/;"	p	namespace:folly	signature:(int fd, void* buf, size_t n)
folly::readableTime	.\Benchmark.cpp	/^static string readableTime(double n, unsigned int decimals) {$/;"	f	namespace:folly	signature:(double n, unsigned int decimals)
folly::readvFull	.\FileUtil.cpp	/^ssize_t readvFull(int fd, iovec* iov, int count) {$/;"	f	namespace:folly	signature:(int fd, iovec* iov, int count)
folly::readvFull	.\FileUtil.h	/^ssize_t readvFull(int fd, iovec* iov, int count);$/;"	p	namespace:folly	signature:(int fd, iovec* iov, int count)
folly::readvNoInt	.\FileUtil.cpp	/^ssize_t readvNoInt(int fd, const iovec* iov, int count) {$/;"	f	namespace:folly	signature:(int fd, const iovec* iov, int count)
folly::readvNoInt	.\FileUtil.h	/^ssize_t readvNoInt(int fd, const iovec* iov, int count);$/;"	p	namespace:folly	signature:(int fd, const iovec* iov, int count)
folly::rebind_allocator	.\Memory.h	/^typename Allocator::template rebind<T>::other rebind_allocator($/;"	f	namespace:folly	signature:( Allocator const& allocator )
folly::recordio_helpers	.\io\RecordIO-inl.h	/^namespace recordio_helpers {$/;"	n	namespace:folly
folly::recordio_helpers	.\io\RecordIO.cpp	/^namespace recordio_helpers {$/;"	n	namespace:folly	file:
folly::recordio_helpers	.\io\RecordIO.h	/^namespace recordio_helpers {$/;"	n	namespace:folly
folly::recordio_helpers::RecordInfo	.\io\RecordIO.h	/^struct RecordInfo {$/;"	s	namespace:folly::recordio_helpers
folly::recordio_helpers::RecordInfo::fileId	.\io\RecordIO.h	/^  uint32_t fileId;$/;"	m	struct:folly::recordio_helpers::RecordInfo	access:public
folly::recordio_helpers::RecordInfo::record	.\io\RecordIO.h	/^  ByteRange record;$/;"	m	struct:folly::recordio_helpers::RecordInfo	access:public
folly::recordio_helpers::__anon68::dataHash	.\io\RecordIO.cpp	/^uint64_t dataHash(ByteRange range) {$/;"	f	namespace:folly::recordio_helpers::__anon68	signature:(ByteRange range)
folly::recordio_helpers::__anon68::dataLengthAndHash	.\io\RecordIO.cpp	/^std::pair<size_t, uint64_t> dataLengthAndHash(const IOBuf* buf) {$/;"	f	namespace:folly::recordio_helpers::__anon68	signature:(const IOBuf* buf)
folly::recordio_helpers::__anon68::headerHash	.\io\RecordIO.cpp	/^uint32_t headerHash(const Header& header) {$/;"	f	namespace:folly::recordio_helpers::__anon68	signature:(const Header& header)
folly::recordio_helpers::__anon68::kHashSeed	.\io\RecordIO.cpp	/^constexpr uint32_t kHashSeed = 0xdeadbeef;  \/\/ for mcurtiss$/;"	m	namespace:folly::recordio_helpers::__anon68	file:
folly::recordio_helpers::detail	.\io\RecordIO-inl.h	/^namespace detail {$/;"	n	namespace:folly::recordio_helpers
folly::recordio_helpers::detail::FOLLY_PACK_ATTR	.\io\RecordIO-inl.h	/^} FOLLY_PACK_ATTR;$/;"	m	namespace:folly::recordio_helpers::detail	typeref:struct:folly::recordio_helpers::detail::Header
folly::recordio_helpers::detail::Header	.\io\RecordIO-inl.h	/^struct Header {$/;"	s	namespace:folly::recordio_helpers::detail
folly::recordio_helpers::detail::Header::dataHash	.\io\RecordIO-inl.h	/^  uint64_t dataHash;$/;"	m	struct:folly::recordio_helpers::detail::Header	access:public
folly::recordio_helpers::detail::Header::dataLength	.\io\RecordIO-inl.h	/^  uint32_t dataLength;$/;"	m	struct:folly::recordio_helpers::detail::Header	access:public
folly::recordio_helpers::detail::Header::fileId	.\io\RecordIO-inl.h	/^  uint32_t fileId;        \/\/ unique file ID$/;"	m	struct:folly::recordio_helpers::detail::Header	access:public
folly::recordio_helpers::detail::Header::flags	.\io\RecordIO-inl.h	/^  uint16_t flags;         \/\/ reserved (must be 0)$/;"	m	struct:folly::recordio_helpers::detail::Header	access:public
folly::recordio_helpers::detail::Header::hashFunction	.\io\RecordIO-inl.h	/^  uint8_t  hashFunction;  \/\/ 0 = SpookyHashV2$/;"	m	struct:folly::recordio_helpers::detail::Header	access:public
folly::recordio_helpers::detail::Header::headerHash	.\io\RecordIO-inl.h	/^  uint32_t headerHash;  \/\/ must be last$/;"	m	struct:folly::recordio_helpers::detail::Header	access:public
folly::recordio_helpers::detail::Header::kMagic	.\io\RecordIO-inl.h	/^  static constexpr uint32_t kMagic = 0xeac313a1;$/;"	m	struct:folly::recordio_helpers::detail::Header	access:public
folly::recordio_helpers::detail::Header::magic	.\io\RecordIO-inl.h	/^  uint32_t magic;$/;"	m	struct:folly::recordio_helpers::detail::Header	access:public
folly::recordio_helpers::detail::Header::version	.\io\RecordIO-inl.h	/^  uint8_t  version;       \/\/ backwards incompatible version, currently 0$/;"	m	struct:folly::recordio_helpers::detail::Header	access:public
folly::recordio_helpers::detail::sizeof	.\io\RecordIO-inl.h	/^              sizeof(Header), "invalid header layout");$/;"	p	namespace:folly::recordio_helpers::detail	signature:(Header)
folly::recordio_helpers::findRecord	.\io\RecordIO-inl.h	/^inline RecordInfo findRecord(ByteRange range, uint32_t fileId) {$/;"	f	namespace:folly::recordio_helpers	signature:(ByteRange range, uint32_t fileId)
folly::recordio_helpers::findRecord	.\io\RecordIO.cpp	/^RecordInfo findRecord(ByteRange searchRange,$/;"	f	namespace:folly::recordio_helpers	signature:(ByteRange searchRange, ByteRange wholeRange, uint32_t fileId)
folly::recordio_helpers::findRecord	.\io\RecordIO.h	/^RecordInfo findRecord(ByteRange range, uint32_t fileId);$/;"	p	namespace:folly::recordio_helpers	signature:(ByteRange range, uint32_t fileId)
folly::recordio_helpers::findRecord	.\io\RecordIO.h	/^RecordInfo findRecord(ByteRange searchRange,$/;"	p	namespace:folly::recordio_helpers	signature:(ByteRange searchRange, ByteRange wholeRange, uint32_t fileId)
folly::recordio_helpers::headerSize	.\io\RecordIO-inl.h	/^constexpr size_t headerSize() { return sizeof(detail::Header); }$/;"	f	namespace:folly::recordio_helpers	signature:()
folly::recordio_helpers::headerSize	.\io\RecordIO.h	/^constexpr size_t headerSize();  \/\/ defined in RecordIO-inl.h$/;"	p	namespace:folly::recordio_helpers	signature:()
folly::recordio_helpers::prependHeader	.\io\RecordIO.cpp	/^size_t prependHeader(std::unique_ptr<IOBuf>& buf, uint32_t fileId) {$/;"	f	namespace:folly::recordio_helpers	signature:(std::unique_ptr<IOBuf>& buf, uint32_t fileId)
folly::recordio_helpers::prependHeader	.\io\RecordIO.h	/^size_t prependHeader(std::unique_ptr<IOBuf>& buf, uint32_t fileId = 1);$/;"	p	namespace:folly::recordio_helpers	signature:(std::unique_ptr<IOBuf>& buf, uint32_t fileId = 1)
folly::recordio_helpers::validateRecord	.\io\RecordIO.cpp	/^RecordInfo validateRecord(ByteRange range, uint32_t fileId) {$/;"	f	namespace:folly::recordio_helpers	signature:(ByteRange range, uint32_t fileId)
folly::recordio_helpers::validateRecord	.\io\RecordIO.h	/^RecordInfo validateRecord(ByteRange range, uint32_t fileId);$/;"	p	namespace:folly::recordio_helpers	signature:(ByteRange range, uint32_t fileId)
folly::rfind	.\Range.h	/^inline size_t rfind(const Range<const char*>& haystack, const char& needle) {$/;"	f	namespace:folly	signature:(const Range<const char*>& haystack, const char& needle)
folly::rfind	.\Range.h	/^inline size_t rfind(const Range<const unsigned char*>& haystack,$/;"	f	namespace:folly	signature:(const Range<const unsigned char*>& haystack, const unsigned char& needle)
folly::rfind	.\Range.h	/^size_t rfind(const Range<T> & haystack,$/;"	p	namespace:folly	signature:(const Range<T> & haystack, const typename Range<T>::value_type& needle)
folly::rfind	.\Range.h	/^size_t rfind(const Range<T>& haystack,$/;"	f	namespace:folly	signature:(const Range<T>& haystack, const typename Range<T>::value_type& needle)
folly::runBenchmarkGetNSPerIteration	.\Benchmark.cpp	/^static double runBenchmarkGetNSPerIteration(const BenchmarkFun& fun,$/;"	f	namespace:folly	signature:(const BenchmarkFun& fun, const double globalBaseline)
folly::runBenchmarks	.\Benchmark.cpp	/^void runBenchmarks() {$/;"	f	namespace:folly	signature:()
folly::runBenchmarks	.\Benchmark.h	/^void runBenchmarks();$/;"	p	namespace:folly	signature:()
folly::runBenchmarksOnFlag	.\Benchmark.h	/^inline bool runBenchmarksOnFlag() {$/;"	f	namespace:folly	signature:()
folly::setThreadName	.\ThreadName.h	/^inline bool setThreadName(StringPiece name) {$/;"	f	namespace:folly	signature:(StringPiece name)
folly::setThreadName	.\ThreadName.h	/^inline bool setThreadName(pthread_t id, StringPiece name) {$/;"	f	namespace:folly	signature:(pthread_t id, StringPiece name)
folly::shutdownNoInt	.\FileUtil.cpp	/^int shutdownNoInt(int fd, int how) {$/;"	f	namespace:folly	signature:(int fd, int how)
folly::shutdownNoInt	.\FileUtil.h	/^int shutdownNoInt(int fd, int how);$/;"	p	namespace:folly	signature:(int fd, int how)
folly::size_	.\IndexedMemPool.h	/^  std::atomic<uint32_t> size_;$/;"	m	namespace:folly
folly::sizeof	.\PackedSyncPtr.h	/^static_assert(sizeof(PackedSyncPtr<void>) == 8,$/;"	p	namespace:folly	signature:(PackedSyncPtr<void>)
folly::sizeof	.\test\OptionalTest.cpp	/^static_assert(sizeof(Optional<NoDefault>) == 4, "");$/;"	p	namespace:folly	file:	signature:(Optional<NoDefault>)
folly::sizeof	.\test\OptionalTest.cpp	/^static_assert(sizeof(Optional<char>) == 2, "");$/;"	p	namespace:folly	file:	signature:(Optional<char>)
folly::sizeof	.\test\OptionalTest.cpp	/^static_assert(sizeof(Optional<char>) == sizeof(boost::optional<char>), "");$/;"	m	namespace:folly	file:
folly::sizeof	.\test\OptionalTest.cpp	/^static_assert(sizeof(Optional<double>) == sizeof(boost::optional<double>), "");$/;"	m	namespace:folly	file:
folly::sizeof	.\test\OptionalTest.cpp	/^static_assert(sizeof(Optional<int>) == 8, "");$/;"	p	namespace:folly	file:	signature:(Optional<int>)
folly::sizeof	.\test\OptionalTest.cpp	/^static_assert(sizeof(Optional<int>) == sizeof(boost::optional<int>), "");$/;"	m	namespace:folly	file:
folly::sizeof	.\test\OptionalTest.cpp	/^static_assert(sizeof(Optional<short>) == sizeof(boost::optional<short>), "");$/;"	m	namespace:folly	file:
folly::skipWhitespace	.\String.cpp	/^StringPiece skipWhitespace(StringPiece sp) {$/;"	f	namespace:folly	signature:(StringPiece sp)
folly::slot	.\IndexedMemPool.h	/^  Slot& slot(uint32_t idx) {$/;"	f	namespace:folly	signature:(uint32_t idx)
folly::slot	.\IndexedMemPool.h	/^  const Slot& slot(uint32_t idx) const {$/;"	f	namespace:folly	signature:(uint32_t idx) const
folly::slotIndex	.\IndexedMemPool.h	/^  size_t slotIndex(uint32_t idx) const {$/;"	f	namespace:folly	signature:(uint32_t idx) const
folly::slots_	.\IndexedMemPool.h	/^  Slot* FOLLY_ALIGN_TO_AVOID_FALSE_SHARING slots_;$/;"	m	namespace:folly
folly::small_vector	.\small_vector.h	/^class small_vector$/;"	c	namespace:folly	inherits:detail::small_vector_base::type
folly::small_vector	.\small_vector.h	/^class small_vector;$/;"	x
folly::small_vector::BaseType	.\small_vector.h	/^  >::type BaseType;$/;"	t	class:folly::small_vector	access:private
folly::small_vector::FB_PACK_ATTR	.\small_vector.h	/^  } FB_PACK_ATTR;$/;"	m	class:folly::small_vector	typeref:struct:folly::small_vector::HeapPtr	access:private
folly::small_vector::FB_PACK_ATTR	.\small_vector.h	/^  } FB_PACK_ATTR;$/;"	m	class:folly::small_vector	typeref:struct:folly::small_vector::HeapPtrWithCapacity	access:private
folly::small_vector::HeapPtr	.\small_vector.h	/^  struct HeapPtr {$/;"	s	class:folly::small_vector	access:private
folly::small_vector::HeapPtr::getCapacity	.\small_vector.h	/^    InternalSizeType* getCapacity() {$/;"	f	struct:folly::small_vector::HeapPtr	access:public	signature:()
folly::small_vector::HeapPtr::heap_	.\small_vector.h	/^    void* heap_;$/;"	m	struct:folly::small_vector::HeapPtr	access:public
folly::small_vector::HeapPtrWithCapacity	.\small_vector.h	/^  struct HeapPtrWithCapacity {$/;"	s	class:folly::small_vector	access:private
folly::small_vector::HeapPtrWithCapacity::capacity_	.\small_vector.h	/^    InternalSizeType capacity_;$/;"	m	struct:folly::small_vector::HeapPtrWithCapacity	access:public
folly::small_vector::HeapPtrWithCapacity::getCapacity	.\small_vector.h	/^    InternalSizeType* getCapacity() {$/;"	f	struct:folly::small_vector::HeapPtrWithCapacity	access:public	signature:()
folly::small_vector::HeapPtrWithCapacity::heap_	.\small_vector.h	/^    void* heap_;$/;"	m	struct:folly::small_vector::HeapPtrWithCapacity	access:public
folly::small_vector::InlineStorageType	.\small_vector.h	/^  >::type InlineStorageType;$/;"	t	class:folly::small_vector	access:private
folly::small_vector::InlineStorageType	.\small_vector.h	/^  typedef unsigned char InlineStorageType[sizeof(value_type) * MaxInline];$/;"	t	class:folly::small_vector	access:private
folly::small_vector::InternalSizeType	.\small_vector.h	/^  typedef typename BaseType::InternalSizeType InternalSizeType;$/;"	t	class:folly::small_vector	access:private
folly::small_vector::MaxInline	.\small_vector.h	/^    MaxInline = boost::mpl::max<$/;"	e	enum:folly::small_vector::__anon89
folly::small_vector::assign	.\small_vector.h	/^  void assign(Arg first, Arg last) {$/;"	f	class:folly::small_vector	access:public	signature:(Arg first, Arg last)
folly::small_vector::assign	.\small_vector.h	/^  void assign(size_type n, const value_type& t) {$/;"	f	class:folly::small_vector	access:public	signature:(size_type n, const value_type& t)
folly::small_vector::assign	.\small_vector.h	/^  void assign(std::initializer_list<value_type> il) {$/;"	f	class:folly::small_vector	access:public	signature:(std::initializer_list<value_type> il)
folly::small_vector::at	.\small_vector.h	/^  const_reference at(size_type i) const {$/;"	f	class:folly::small_vector	access:public	signature:(size_type i) const
folly::small_vector::at	.\small_vector.h	/^  reference at(size_type i) {$/;"	f	class:folly::small_vector	access:public	signature:(size_type i)
folly::small_vector::back	.\small_vector.h	/^  const_reference back() const  { assert(!empty()); return *(end() - 1); }$/;"	f	class:folly::small_vector	access:public	signature:() const
folly::small_vector::back	.\small_vector.h	/^  reference back()              { assert(!empty()); return *(end() - 1); }$/;"	f	class:folly::small_vector	access:public	signature:()
folly::small_vector::begin	.\small_vector.h	/^  const_iterator begin()   const { return data(); }$/;"	f	class:folly::small_vector	access:public	signature:() const
folly::small_vector::begin	.\small_vector.h	/^  iterator       begin()         { return data(); }$/;"	f	class:folly::small_vector	access:public	signature:()
folly::small_vector::capacity	.\small_vector.h	/^  size_type capacity() const {$/;"	f	class:folly::small_vector	access:public	signature:() const
folly::small_vector::cbegin	.\small_vector.h	/^  const_iterator cbegin()  const { return begin(); }$/;"	f	class:folly::small_vector	access:public	signature:() const
folly::small_vector::cend	.\small_vector.h	/^  const_iterator cend()    const { return end(); }$/;"	f	class:folly::small_vector	access:public	signature:() const
folly::small_vector::clear	.\small_vector.h	/^  void clear() {$/;"	f	class:folly::small_vector	access:public	signature:()
folly::small_vector::const_iterator	.\small_vector.h	/^  typedef value_type const*  const_iterator;$/;"	t	class:folly::small_vector	access:public
folly::small_vector::const_reference	.\small_vector.h	/^  typedef value_type const&  const_reference;$/;"	t	class:folly::small_vector	access:public
folly::small_vector::const_reverse_iterator	.\small_vector.h	/^  typedef std::reverse_iterator<const_iterator> const_reverse_iterator;$/;"	t	class:folly::small_vector	access:public
folly::small_vector::constructImpl	.\small_vector.h	/^  void constructImpl(It first, It last, std::false_type) {$/;"	f	class:folly::small_vector	access:private	signature:(It first, It last, std::false_type)
folly::small_vector::constructImpl	.\small_vector.h	/^  void constructImpl(size_type n, value_type const& val, std::true_type) {$/;"	f	class:folly::small_vector	access:private	signature:(size_type n, value_type const& val, std::true_type)
folly::small_vector::crbegin	.\small_vector.h	/^  const_reverse_iterator crbegin() const { return rbegin(); }$/;"	f	class:folly::small_vector	access:public	signature:() const
folly::small_vector::crend	.\small_vector.h	/^  const_reverse_iterator crend()   const { return rend(); }$/;"	f	class:folly::small_vector	access:public	signature:() const
folly::small_vector::difference_type	.\small_vector.h	/^  typedef std::ptrdiff_t     difference_type;$/;"	t	class:folly::small_vector	access:public
folly::small_vector::doConstruct	.\small_vector.h	/^  void doConstruct(size_type n, value_type const& val) {$/;"	f	class:folly::small_vector	access:private	signature:(size_type n, value_type const& val)
folly::small_vector::emplace	.\small_vector.h	/^  iterator emplace(const_iterator p, Args&&... args) {$/;"	f	class:folly::small_vector	access:public	signature:(const_iterator p, Args&&... args)
folly::small_vector::emplaceBack	.\small_vector.h	/^  void emplaceBack(Args&&... args) {$/;"	f	class:folly::small_vector	access:private	signature:(Args&&.... args)
folly::small_vector::emplaceBack	.\small_vector.h	/^  void emplaceBack(value_type&& t) {$/;"	f	class:folly::small_vector	access:private	signature:(value_type&& t)
folly::small_vector::emplace_back	.\small_vector.h	/^  void emplace_back(Args&&... args) {$/;"	f	class:folly::small_vector	access:public	signature:(Args&&.... args)
folly::small_vector::empty	.\small_vector.h	/^  bool      empty()        const { return !size(); }$/;"	f	class:folly::small_vector	access:public	signature:() const
folly::small_vector::end	.\small_vector.h	/^  const_iterator end()     const { return data() + size(); }$/;"	f	class:folly::small_vector	access:public	signature:() const
folly::small_vector::end	.\small_vector.h	/^  iterator       end()           { return data() + size(); }$/;"	f	class:folly::small_vector	access:public	signature:()
folly::small_vector::erase	.\small_vector.h	/^  iterator erase(const_iterator q) {$/;"	f	class:folly::small_vector	access:public	signature:(const_iterator q)
folly::small_vector::erase	.\small_vector.h	/^  iterator erase(const_iterator q1, const_iterator q2) {$/;"	f	class:folly::small_vector	access:public	signature:(const_iterator q1, const_iterator q2)
folly::small_vector::front	.\small_vector.h	/^  const_reference front() const { assert(!empty()); return *begin(); }$/;"	f	class:folly::small_vector	access:public	signature:() const
folly::small_vector::front	.\small_vector.h	/^  reference front()             { assert(!empty()); return *begin(); }$/;"	f	class:folly::small_vector	access:public	signature:()
folly::small_vector::insert	.\small_vector.h	/^  iterator insert(const_iterator constp, value_type&& t) {$/;"	f	class:folly::small_vector	access:public	signature:(const_iterator constp, value_type&& t)
folly::small_vector::insert	.\small_vector.h	/^  iterator insert(const_iterator p, Arg arg1, Arg arg2) {$/;"	f	class:folly::small_vector	access:public	signature:(const_iterator p, Arg arg1, Arg arg2)
folly::small_vector::insert	.\small_vector.h	/^  iterator insert(const_iterator p, std::initializer_list<value_type> il) {$/;"	f	class:folly::small_vector	access:public	signature:(const_iterator p, std::initializer_list<value_type> il)
folly::small_vector::insert	.\small_vector.h	/^  iterator insert(const_iterator p, value_type const& t) {$/;"	f	class:folly::small_vector	access:public	signature:(const_iterator p, value_type const& t)
folly::small_vector::insert	.\small_vector.h	/^  iterator insert(const_iterator pos, size_type n, value_type const& val) {$/;"	f	class:folly::small_vector	access:public	signature:(const_iterator pos, size_type n, value_type const& val)
folly::small_vector::insertImpl	.\small_vector.h	/^  iterator insertImpl(iterator pos, It first, It last, std::false_type) {$/;"	f	class:folly::small_vector	access:private	signature:(iterator pos, It first, It last, std::false_type)
folly::small_vector::insertImpl	.\small_vector.h	/^  iterator insertImpl(iterator pos, size_type n, const value_type& val,$/;"	f	class:folly::small_vector	access:private	signature:(iterator pos, size_type n, const value_type& val, std::true_type)
folly::small_vector::iterator	.\small_vector.h	/^  typedef value_type*        iterator;$/;"	t	class:folly::small_vector	access:public
folly::small_vector::kHasInlineCapacity	.\small_vector.h	/^  static bool const kHasInlineCapacity =$/;"	m	class:folly::small_vector	access:private
folly::small_vector::makeSize	.\small_vector.h	/^  void makeSize(size_type size, value_type* v = nullptr) {$/;"	f	class:folly::small_vector	access:private	signature:(size_type size, value_type* v = nullptr)
folly::small_vector::makeSize	.\small_vector.h	/^  void makeSize(size_type size, value_type* v, size_type pos) {$/;"	f	class:folly::small_vector	access:private	signature:(size_type size, value_type* v, size_type pos)
folly::small_vector::max_size	.\small_vector.h	/^  static constexpr size_type max_size() {$/;"	f	class:folly::small_vector	access:public	signature:()
folly::small_vector::operator <	.\small_vector.h	/^  bool operator<(small_vector const& o) const {$/;"	f	class:folly::small_vector	access:public	signature:(small_vector const& o) const
folly::small_vector::operator =	.\small_vector.h	/^  small_vector& operator=(small_vector const& o) {$/;"	f	class:folly::small_vector	access:public	signature:(small_vector const& o)
folly::small_vector::operator =	.\small_vector.h	/^  small_vector& operator=(small_vector&& o) {$/;"	f	class:folly::small_vector	access:public	signature:(small_vector&& o)
folly::small_vector::operator ==	.\small_vector.h	/^  bool operator==(small_vector const& o) const {$/;"	f	class:folly::small_vector	access:public	signature:(small_vector const& o) const
folly::small_vector::operator []	.\small_vector.h	/^  const_reference operator[](size_type i) const {$/;"	f	class:folly::small_vector	access:public	signature:(size_type i) const
folly::small_vector::operator []	.\small_vector.h	/^  reference operator[](size_type i) {$/;"	f	class:folly::small_vector	access:public	signature:(size_type i)
folly::small_vector::pop_back	.\small_vector.h	/^  void pop_back() {$/;"	f	class:folly::small_vector	access:public	signature:()
folly::small_vector::push_back	.\small_vector.h	/^  void push_back(value_type const& t) {$/;"	f	class:folly::small_vector	access:public	signature:(value_type const& t)
folly::small_vector::push_back	.\small_vector.h	/^  void push_back(value_type&& t) {$/;"	f	class:folly::small_vector	access:public	signature:(value_type&& t)
folly::small_vector::rbegin	.\small_vector.h	/^  const_reverse_iterator rbegin() const {$/;"	f	class:folly::small_vector	access:public	signature:() const
folly::small_vector::rbegin	.\small_vector.h	/^  reverse_iterator       rbegin()        { return reverse_iterator(end()); }$/;"	f	class:folly::small_vector	access:public	signature:()
folly::small_vector::reference	.\small_vector.h	/^  typedef value_type&        reference;$/;"	t	class:folly::small_vector	access:public
folly::small_vector::rend	.\small_vector.h	/^  const_reverse_iterator rend() const {$/;"	f	class:folly::small_vector	access:public	signature:() const
folly::small_vector::rend	.\small_vector.h	/^  reverse_iterator       rend()          { return reverse_iterator(begin()); }$/;"	f	class:folly::small_vector	access:public	signature:()
folly::small_vector::reserve	.\small_vector.h	/^  void reserve(size_type sz) {$/;"	f	class:folly::small_vector	access:public	signature:(size_type sz)
folly::small_vector::resize	.\small_vector.h	/^  void resize(size_type sz) {$/;"	f	class:folly::small_vector	access:public	signature:(size_type sz)
folly::small_vector::resize	.\small_vector.h	/^  void resize(size_type sz, value_type const& v) {$/;"	f	class:folly::small_vector	access:public	signature:(size_type sz, value_type const& v)
folly::small_vector::reverse_iterator	.\small_vector.h	/^  typedef std::reverse_iterator<iterator>       reverse_iterator;$/;"	t	class:folly::small_vector	access:public
folly::small_vector::setCapacity	.\small_vector.h	/^  void setCapacity(size_type newCapacity) {$/;"	f	class:folly::small_vector	access:private	signature:(size_type newCapacity)
folly::small_vector::shrink_to_fit	.\small_vector.h	/^  void shrink_to_fit() {$/;"	f	class:folly::small_vector	access:public	signature:()
folly::small_vector::size	.\small_vector.h	/^  size_type size()         const { return this->doSize(); }$/;"	f	class:folly::small_vector	access:public	signature:() const
folly::small_vector::size_type	.\small_vector.h	/^  typedef std::size_t        size_type;$/;"	t	class:folly::small_vector	access:public
folly::small_vector::small_vector	.\small_vector.h	/^  explicit small_vector() {}$/;"	f	class:folly::small_vector	access:public	signature:()
folly::small_vector::small_vector	.\small_vector.h	/^  explicit small_vector(Arg arg1, Arg arg2)  {$/;"	f	class:folly::small_vector	access:public	signature:(Arg arg1, Arg arg2)
folly::small_vector::small_vector	.\small_vector.h	/^  explicit small_vector(size_type n, value_type const& t = value_type()) {$/;"	f	class:folly::small_vector	access:public	signature:(size_type n, value_type const& t = value_type())
folly::small_vector::small_vector	.\small_vector.h	/^  small_vector(small_vector const& o) {$/;"	f	class:folly::small_vector	access:public	signature:(small_vector const& o)
folly::small_vector::small_vector	.\small_vector.h	/^  small_vector(small_vector&& o) {$/;"	f	class:folly::small_vector	access:public	signature:(small_vector&& o)
folly::small_vector::small_vector	.\small_vector.h	/^  small_vector(std::initializer_list<value_type> il) {$/;"	f	class:folly::small_vector	access:public	signature:(std::initializer_list<value_type> il)
folly::small_vector::swap	.\small_vector.h	/^  void swap(small_vector& o) {$/;"	f	class:folly::small_vector	access:public	signature:(small_vector& o)
folly::small_vector::unconst	.\small_vector.h	/^  static iterator unconst(const_iterator it) {$/;"	f	class:folly::small_vector	access:private	signature:(const_iterator it)
folly::small_vector::unpackHack	.\small_vector.h	/^  template<class T> static T& unpackHack(T* p) {$/;"	f	class:folly::small_vector	access:private	signature:(T* p)
folly::small_vector::value_type	.\small_vector.h	/^  typedef Value              value_type;$/;"	t	class:folly::small_vector	access:public
folly::small_vector::~small_vector	.\small_vector.h	/^  ~small_vector() {$/;"	f	class:folly::small_vector	access:public	signature:()
folly::small_vector_policy	.\small_vector.h	/^namespace small_vector_policy {$/;"	n	namespace:folly
folly::small_vector_policy::NoHeap	.\small_vector.h	/^struct NoHeap;$/;"	x
folly::sorted_vector_map	.\sorted_vector_types.h	/^class sorted_vector_map$/;"	c	namespace:folly	inherits:boost::totally_ordered1
folly::sorted_vector_map::ContainerT	.\sorted_vector_types.h	/^  typedef std::vector<std::pair<Key,Value>,Allocator> ContainerT;$/;"	t	class:folly::sorted_vector_map	access:private
folly::sorted_vector_map::EBO	.\sorted_vector_types.h	/^  struct EBO : value_compare {$/;"	s	class:folly::sorted_vector_map	inherits:value_compare	access:private
folly::sorted_vector_map::EBO::EBO	.\sorted_vector_types.h	/^    explicit EBO(const value_compare& c, const Allocator& alloc)$/;"	f	struct:folly::sorted_vector_map::EBO	access:public	signature:(const value_compare& c, const Allocator& alloc)
folly::sorted_vector_map::EBO::cont_	.\sorted_vector_types.h	/^    ContainerT cont_;$/;"	m	struct:folly::sorted_vector_map::EBO	access:public
folly::sorted_vector_map::begin	.\sorted_vector_types.h	/^  const_iterator begin() const          { return m_.cont_.begin();  }$/;"	f	class:folly::sorted_vector_map	access:public	signature:() const
folly::sorted_vector_map::begin	.\sorted_vector_types.h	/^  iterator begin()                      { return m_.cont_.begin();  }$/;"	f	class:folly::sorted_vector_map	access:public	signature:()
folly::sorted_vector_map::capacity	.\sorted_vector_types.h	/^  size_type capacity() const    { return m_.cont_.capacity(); }$/;"	f	class:folly::sorted_vector_map	access:public	signature:() const
folly::sorted_vector_map::clear	.\sorted_vector_types.h	/^  void clear()                  { return m_.cont_.clear();    }$/;"	f	class:folly::sorted_vector_map	access:public	signature:()
folly::sorted_vector_map::const_iterator	.\sorted_vector_types.h	/^  typedef typename ContainerT::const_iterator         const_iterator;$/;"	t	class:folly::sorted_vector_map	access:public
folly::sorted_vector_map::const_reference	.\sorted_vector_types.h	/^  typedef typename ContainerT::const_reference        const_reference;$/;"	t	class:folly::sorted_vector_map	access:public
folly::sorted_vector_map::const_reverse_iterator	.\sorted_vector_types.h	/^  typedef typename ContainerT::const_reverse_iterator const_reverse_iterator;$/;"	t	class:folly::sorted_vector_map	access:public
folly::sorted_vector_map::count	.\sorted_vector_types.h	/^  size_type count(const key_type& key) const {$/;"	f	class:folly::sorted_vector_map	access:public	signature:(const key_type& key) const
folly::sorted_vector_map::difference_type	.\sorted_vector_types.h	/^  typedef typename ContainerT::difference_type        difference_type;$/;"	t	class:folly::sorted_vector_map	access:public
folly::sorted_vector_map::empty	.\sorted_vector_types.h	/^  bool empty() const            { return m_.cont_.empty();    }$/;"	f	class:folly::sorted_vector_map	access:public	signature:() const
folly::sorted_vector_map::end	.\sorted_vector_types.h	/^  const_iterator end() const            { return m_.cont_.end();    }$/;"	f	class:folly::sorted_vector_map	access:public	signature:() const
folly::sorted_vector_map::end	.\sorted_vector_types.h	/^  iterator end()                        { return m_.cont_.end();    }$/;"	f	class:folly::sorted_vector_map	access:public	signature:()
folly::sorted_vector_map::equal_range	.\sorted_vector_types.h	/^  equal_range(const key_type& key) const {$/;"	f	class:folly::sorted_vector_map	access:public	signature:(const key_type& key) const
folly::sorted_vector_map::equal_range	.\sorted_vector_types.h	/^  std::pair<iterator,iterator> equal_range(const key_type& key) {$/;"	f	class:folly::sorted_vector_map	access:public	signature:(const key_type& key)
folly::sorted_vector_map::erase	.\sorted_vector_types.h	/^  size_type erase(const key_type& key) {$/;"	f	class:folly::sorted_vector_map	access:public	signature:(const key_type& key)
folly::sorted_vector_map::erase	.\sorted_vector_types.h	/^  void erase(iterator first, iterator last) {$/;"	f	class:folly::sorted_vector_map	access:public	signature:(iterator first, iterator last)
folly::sorted_vector_map::erase	.\sorted_vector_types.h	/^  void erase(iterator it) {$/;"	f	class:folly::sorted_vector_map	access:public	signature:(iterator it)
folly::sorted_vector_map::find	.\sorted_vector_types.h	/^  const_iterator find(const key_type& key) const {$/;"	f	class:folly::sorted_vector_map	access:public	signature:(const key_type& key) const
folly::sorted_vector_map::find	.\sorted_vector_types.h	/^  iterator find(const key_type& key) {$/;"	f	class:folly::sorted_vector_map	access:public	signature:(const key_type& key)
folly::sorted_vector_map::get_growth_policy	.\sorted_vector_types.h	/^  get_growth_policy() { return *this; }$/;"	f	class:folly::sorted_vector_map	access:private	signature:()
folly::sorted_vector_map::insert	.\sorted_vector_types.h	/^  iterator insert(iterator hint, const value_type& value) {$/;"	f	class:folly::sorted_vector_map	access:public	signature:(iterator hint, const value_type& value)
folly::sorted_vector_map::insert	.\sorted_vector_types.h	/^  iterator insert(iterator hint, value_type&& value) {$/;"	f	class:folly::sorted_vector_map	access:public	signature:(iterator hint, value_type&& value)
folly::sorted_vector_map::insert	.\sorted_vector_types.h	/^  std::pair<iterator,bool> insert(const value_type& value) {$/;"	f	class:folly::sorted_vector_map	access:public	signature:(const value_type& value)
folly::sorted_vector_map::insert	.\sorted_vector_types.h	/^  std::pair<iterator,bool> insert(value_type&& value) {$/;"	f	class:folly::sorted_vector_map	access:public	signature:(value_type&& value)
folly::sorted_vector_map::insert	.\sorted_vector_types.h	/^  void insert(InputIterator first, InputIterator last) {$/;"	f	class:folly::sorted_vector_map	access:public	signature:(InputIterator first, InputIterator last)
folly::sorted_vector_map::iterator	.\sorted_vector_types.h	/^  typedef typename ContainerT::iterator               iterator;$/;"	t	class:folly::sorted_vector_map	access:public
folly::sorted_vector_map::key_comp	.\sorted_vector_types.h	/^  key_compare key_comp() const { return m_; }$/;"	f	class:folly::sorted_vector_map	access:public	signature:() const
folly::sorted_vector_map::key_compare	.\sorted_vector_types.h	/^  typedef Compare                                   key_compare;$/;"	t	class:folly::sorted_vector_map	access:public
folly::sorted_vector_map::key_type	.\sorted_vector_types.h	/^  typedef Key                                       key_type;$/;"	t	class:folly::sorted_vector_map	access:public
folly::sorted_vector_map::lower_bound	.\sorted_vector_types.h	/^  const_iterator lower_bound(const key_type& key) const {$/;"	f	class:folly::sorted_vector_map	access:public	signature:(const key_type& key) const
folly::sorted_vector_map::lower_bound	.\sorted_vector_types.h	/^  iterator lower_bound(const key_type& key) {$/;"	f	class:folly::sorted_vector_map	access:public	signature:(const key_type& key)
folly::sorted_vector_map::m_	.\sorted_vector_types.h	/^  } m_;$/;"	m	class:folly::sorted_vector_map	typeref:struct:folly::sorted_vector_map::EBO	access:private
folly::sorted_vector_map::mapped_type	.\sorted_vector_types.h	/^  typedef Value                                     mapped_type;$/;"	t	class:folly::sorted_vector_map	access:public
folly::sorted_vector_map::max_size	.\sorted_vector_types.h	/^  size_type max_size() const    { return m_.cont_.max_size(); }$/;"	f	class:folly::sorted_vector_map	access:public	signature:() const
folly::sorted_vector_map::operator <	.\sorted_vector_types.h	/^  bool operator<(const sorted_vector_map& other) const {$/;"	f	class:folly::sorted_vector_map	access:public	signature:(const sorted_vector_map& other) const
folly::sorted_vector_map::operator ==	.\sorted_vector_types.h	/^  bool operator==(const sorted_vector_map& other) const {$/;"	f	class:folly::sorted_vector_map	access:public	signature:(const sorted_vector_map& other) const
folly::sorted_vector_map::operator []	.\sorted_vector_types.h	/^  mapped_type& operator[](const key_type& key) {$/;"	f	class:folly::sorted_vector_map	access:public	signature:(const key_type& key)
folly::sorted_vector_map::pointer	.\sorted_vector_types.h	/^  typedef typename ContainerT::pointer                pointer;$/;"	t	class:folly::sorted_vector_map	access:public
folly::sorted_vector_map::rbegin	.\sorted_vector_types.h	/^  const_reverse_iterator rbegin() const { return m_.cont_.rbegin(); }$/;"	f	class:folly::sorted_vector_map	access:public	signature:() const
folly::sorted_vector_map::rbegin	.\sorted_vector_types.h	/^  reverse_iterator rbegin()             { return m_.cont_.rbegin(); }$/;"	f	class:folly::sorted_vector_map	access:public	signature:()
folly::sorted_vector_map::reference	.\sorted_vector_types.h	/^  typedef typename ContainerT::reference              reference;$/;"	t	class:folly::sorted_vector_map	access:public
folly::sorted_vector_map::rend	.\sorted_vector_types.h	/^  const_reverse_iterator rend() const   { return m_.cont_.rend();   }$/;"	f	class:folly::sorted_vector_map	access:public	signature:() const
folly::sorted_vector_map::rend	.\sorted_vector_types.h	/^  reverse_iterator rend()               { return m_.cont_.rend();   }$/;"	f	class:folly::sorted_vector_map	access:public	signature:()
folly::sorted_vector_map::reserve	.\sorted_vector_types.h	/^  void reserve(size_type s)     { return m_.cont_.reserve(s); }$/;"	f	class:folly::sorted_vector_map	access:public	signature:(size_type s)
folly::sorted_vector_map::reverse_iterator	.\sorted_vector_types.h	/^  typedef typename ContainerT::reverse_iterator       reverse_iterator;$/;"	t	class:folly::sorted_vector_map	access:public
folly::sorted_vector_map::shrink_to_fit	.\sorted_vector_types.h	/^  void shrink_to_fit()          { m_.cont_.shrink_to_fit();   }$/;"	f	class:folly::sorted_vector_map	access:public	signature:()
folly::sorted_vector_map::size	.\sorted_vector_types.h	/^  size_type size() const        { return m_.cont_.size();     }$/;"	f	class:folly::sorted_vector_map	access:public	signature:() const
folly::sorted_vector_map::size_type	.\sorted_vector_types.h	/^  typedef typename ContainerT::size_type              size_type;$/;"	t	class:folly::sorted_vector_map	access:public
folly::sorted_vector_map::sorted_vector_map	.\sorted_vector_types.h	/^  explicit sorted_vector_map($/;"	f	class:folly::sorted_vector_map	access:public	signature:( InputIterator first, InputIterator last, const Compare& comp = Compare(), const Allocator& alloc = Allocator())
folly::sorted_vector_map::sorted_vector_map	.\sorted_vector_types.h	/^  explicit sorted_vector_map($/;"	f	class:folly::sorted_vector_map	access:public	signature:( std::initializer_list<value_type> list, const Compare& comp = Compare(), const Allocator& alloc = Allocator())
folly::sorted_vector_map::sorted_vector_map	.\sorted_vector_types.h	/^  explicit sorted_vector_map(const Compare& comp = Compare(),$/;"	f	class:folly::sorted_vector_map	access:public	signature:(const Compare& comp = Compare(), const Allocator& alloc = Allocator())
folly::sorted_vector_map::swap	.\sorted_vector_types.h	/^  void swap(sorted_vector_map& o) {$/;"	f	class:folly::sorted_vector_map	access:public	signature:(sorted_vector_map& o)
folly::sorted_vector_map::upper_bound	.\sorted_vector_types.h	/^  const_iterator upper_bound(const key_type& key) const {$/;"	f	class:folly::sorted_vector_map	access:public	signature:(const key_type& key) const
folly::sorted_vector_map::upper_bound	.\sorted_vector_types.h	/^  iterator upper_bound(const key_type& key) {$/;"	f	class:folly::sorted_vector_map	access:public	signature:(const key_type& key)
folly::sorted_vector_map::value_comp	.\sorted_vector_types.h	/^  value_compare value_comp() const { return m_; }$/;"	f	class:folly::sorted_vector_map	access:public	signature:() const
folly::sorted_vector_map::value_compare	.\sorted_vector_types.h	/^  struct value_compare$/;"	s	class:folly::sorted_vector_map	inherits:std::binary_function,Compare	access:public
folly::sorted_vector_map::value_compare::operator ()	.\sorted_vector_types.h	/^    bool operator()(const value_type& a, const value_type& b) const {$/;"	f	struct:folly::sorted_vector_map::value_compare	access:public	signature:(const value_type& a, const value_type& b) const
folly::sorted_vector_map::value_compare::sorted_vector_map	.\sorted_vector_types.h	/^    friend class sorted_vector_map;$/;"	x
folly::sorted_vector_map::value_compare::value_compare	.\sorted_vector_types.h	/^    explicit value_compare(const Compare& c) : Compare(c) {}$/;"	f	struct:folly::sorted_vector_map::value_compare	access:protected	signature:(const Compare& c)
folly::sorted_vector_map::value_type	.\sorted_vector_types.h	/^  typedef std::pair<key_type,mapped_type>           value_type;$/;"	t	class:folly::sorted_vector_map	access:public
folly::sorted_vector_set	.\sorted_vector_types.h	/^class sorted_vector_set$/;"	c	namespace:folly	inherits:boost::totally_ordered1
folly::sorted_vector_set::ContainerT	.\sorted_vector_types.h	/^  typedef std::vector<T,Allocator> ContainerT;$/;"	t	class:folly::sorted_vector_set	access:private
folly::sorted_vector_set::EBO	.\sorted_vector_types.h	/^  struct EBO : Compare {$/;"	s	class:folly::sorted_vector_set	inherits:Compare	access:private
folly::sorted_vector_set::EBO::EBO	.\sorted_vector_types.h	/^    explicit EBO(const Compare& c, const Allocator& alloc)$/;"	f	struct:folly::sorted_vector_set::EBO	access:public	signature:(const Compare& c, const Allocator& alloc)
folly::sorted_vector_set::EBO::cont_	.\sorted_vector_types.h	/^    ContainerT cont_;$/;"	m	struct:folly::sorted_vector_set::EBO	access:public
folly::sorted_vector_set::begin	.\sorted_vector_types.h	/^  const_iterator begin() const          { return m_.cont_.begin();  }$/;"	f	class:folly::sorted_vector_set	access:public	signature:() const
folly::sorted_vector_set::begin	.\sorted_vector_types.h	/^  iterator begin()                      { return m_.cont_.begin();  }$/;"	f	class:folly::sorted_vector_set	access:public	signature:()
folly::sorted_vector_set::capacity	.\sorted_vector_types.h	/^  size_type capacity() const    { return m_.cont_.capacity(); }$/;"	f	class:folly::sorted_vector_set	access:public	signature:() const
folly::sorted_vector_set::clear	.\sorted_vector_types.h	/^  void clear()                  { return m_.cont_.clear();    }$/;"	f	class:folly::sorted_vector_set	access:public	signature:()
folly::sorted_vector_set::const_iterator	.\sorted_vector_types.h	/^  typedef typename ContainerT::const_iterator         const_iterator;$/;"	t	class:folly::sorted_vector_set	access:public
folly::sorted_vector_set::const_reference	.\sorted_vector_types.h	/^  typedef typename ContainerT::const_reference        const_reference;$/;"	t	class:folly::sorted_vector_set	access:public
folly::sorted_vector_set::const_reverse_iterator	.\sorted_vector_types.h	/^  typedef typename ContainerT::const_reverse_iterator const_reverse_iterator;$/;"	t	class:folly::sorted_vector_set	access:public
folly::sorted_vector_set::count	.\sorted_vector_types.h	/^  size_type count(const key_type& key) const {$/;"	f	class:folly::sorted_vector_set	access:public	signature:(const key_type& key) const
folly::sorted_vector_set::difference_type	.\sorted_vector_types.h	/^  typedef typename ContainerT::difference_type        difference_type;$/;"	t	class:folly::sorted_vector_set	access:public
folly::sorted_vector_set::empty	.\sorted_vector_types.h	/^  bool empty() const            { return m_.cont_.empty();    }$/;"	f	class:folly::sorted_vector_set	access:public	signature:() const
folly::sorted_vector_set::end	.\sorted_vector_types.h	/^  const_iterator end() const            { return m_.cont_.end();    }$/;"	f	class:folly::sorted_vector_set	access:public	signature:() const
folly::sorted_vector_set::end	.\sorted_vector_types.h	/^  iterator end()                        { return m_.cont_.end();    }$/;"	f	class:folly::sorted_vector_set	access:public	signature:()
folly::sorted_vector_set::equal_range	.\sorted_vector_types.h	/^  equal_range(const key_type& key) const {$/;"	f	class:folly::sorted_vector_set	access:public	signature:(const key_type& key) const
folly::sorted_vector_set::equal_range	.\sorted_vector_types.h	/^  std::pair<iterator,iterator> equal_range(const key_type& key) {$/;"	f	class:folly::sorted_vector_set	access:public	signature:(const key_type& key)
folly::sorted_vector_set::erase	.\sorted_vector_types.h	/^  size_type erase(const key_type& key) {$/;"	f	class:folly::sorted_vector_set	access:public	signature:(const key_type& key)
folly::sorted_vector_set::erase	.\sorted_vector_types.h	/^  void erase(iterator first, iterator last) {$/;"	f	class:folly::sorted_vector_set	access:public	signature:(iterator first, iterator last)
folly::sorted_vector_set::erase	.\sorted_vector_types.h	/^  void erase(iterator it) {$/;"	f	class:folly::sorted_vector_set	access:public	signature:(iterator it)
folly::sorted_vector_set::find	.\sorted_vector_types.h	/^  const_iterator find(const key_type& key) const {$/;"	f	class:folly::sorted_vector_set	access:public	signature:(const key_type& key) const
folly::sorted_vector_set::find	.\sorted_vector_types.h	/^  iterator find(const key_type& key) {$/;"	f	class:folly::sorted_vector_set	access:public	signature:(const key_type& key)
folly::sorted_vector_set::get_growth_policy	.\sorted_vector_types.h	/^  get_growth_policy() { return *this; }$/;"	f	class:folly::sorted_vector_set	access:private	signature:()
folly::sorted_vector_set::insert	.\sorted_vector_types.h	/^  iterator insert(iterator hint, const value_type& value) {$/;"	f	class:folly::sorted_vector_set	access:public	signature:(iterator hint, const value_type& value)
folly::sorted_vector_set::insert	.\sorted_vector_types.h	/^  iterator insert(iterator hint, value_type&& value) {$/;"	f	class:folly::sorted_vector_set	access:public	signature:(iterator hint, value_type&& value)
folly::sorted_vector_set::insert	.\sorted_vector_types.h	/^  std::pair<iterator,bool> insert(const value_type& value) {$/;"	f	class:folly::sorted_vector_set	access:public	signature:(const value_type& value)
folly::sorted_vector_set::insert	.\sorted_vector_types.h	/^  std::pair<iterator,bool> insert(value_type&& value) {$/;"	f	class:folly::sorted_vector_set	access:public	signature:(value_type&& value)
folly::sorted_vector_set::insert	.\sorted_vector_types.h	/^  void insert(InputIterator first, InputIterator last) {$/;"	f	class:folly::sorted_vector_set	access:public	signature:(InputIterator first, InputIterator last)
folly::sorted_vector_set::iterator	.\sorted_vector_types.h	/^  typedef typename ContainerT::iterator               iterator;$/;"	t	class:folly::sorted_vector_set	access:public
folly::sorted_vector_set::key_comp	.\sorted_vector_types.h	/^  key_compare key_comp() const { return m_; }$/;"	f	class:folly::sorted_vector_set	access:public	signature:() const
folly::sorted_vector_set::key_compare	.\sorted_vector_types.h	/^  typedef Compare key_compare;$/;"	t	class:folly::sorted_vector_set	access:public
folly::sorted_vector_set::key_type	.\sorted_vector_types.h	/^  typedef T       key_type;$/;"	t	class:folly::sorted_vector_set	access:public
folly::sorted_vector_set::lower_bound	.\sorted_vector_types.h	/^  const_iterator lower_bound(const key_type& key) const {$/;"	f	class:folly::sorted_vector_set	access:public	signature:(const key_type& key) const
folly::sorted_vector_set::lower_bound	.\sorted_vector_types.h	/^  iterator lower_bound(const key_type& key) {$/;"	f	class:folly::sorted_vector_set	access:public	signature:(const key_type& key)
folly::sorted_vector_set::m_	.\sorted_vector_types.h	/^  } m_;$/;"	m	class:folly::sorted_vector_set	typeref:struct:folly::sorted_vector_set::EBO	access:private
folly::sorted_vector_set::max_size	.\sorted_vector_types.h	/^  size_type max_size() const    { return m_.cont_.max_size(); }$/;"	f	class:folly::sorted_vector_set	access:public	signature:() const
folly::sorted_vector_set::operator <	.\sorted_vector_types.h	/^  bool operator<(const sorted_vector_set& other) const {$/;"	f	class:folly::sorted_vector_set	access:public	signature:(const sorted_vector_set& other) const
folly::sorted_vector_set::operator ==	.\sorted_vector_types.h	/^  bool operator==(const sorted_vector_set& other) const {$/;"	f	class:folly::sorted_vector_set	access:public	signature:(const sorted_vector_set& other) const
folly::sorted_vector_set::pointer	.\sorted_vector_types.h	/^  typedef typename ContainerT::pointer                pointer;$/;"	t	class:folly::sorted_vector_set	access:public
folly::sorted_vector_set::rbegin	.\sorted_vector_types.h	/^  const_reverse_iterator rbegin() const { return m_.cont_.rbegin(); }$/;"	f	class:folly::sorted_vector_set	access:public	signature:() const
folly::sorted_vector_set::rbegin	.\sorted_vector_types.h	/^  reverse_iterator rbegin()             { return m_.cont_.rbegin(); }$/;"	f	class:folly::sorted_vector_set	access:public	signature:()
folly::sorted_vector_set::reference	.\sorted_vector_types.h	/^  typedef typename ContainerT::reference              reference;$/;"	t	class:folly::sorted_vector_set	access:public
folly::sorted_vector_set::rend	.\sorted_vector_types.h	/^  const_reverse_iterator rend() const   { return m_.cont_.rend();   }$/;"	f	class:folly::sorted_vector_set	access:public	signature:() const
folly::sorted_vector_set::rend	.\sorted_vector_types.h	/^  reverse_iterator rend()               { return m_.cont_.rend();   }$/;"	f	class:folly::sorted_vector_set	access:public	signature:()
folly::sorted_vector_set::reserve	.\sorted_vector_types.h	/^  void reserve(size_type s)     { return m_.cont_.reserve(s); }$/;"	f	class:folly::sorted_vector_set	access:public	signature:(size_type s)
folly::sorted_vector_set::reverse_iterator	.\sorted_vector_types.h	/^  typedef typename ContainerT::reverse_iterator       reverse_iterator;$/;"	t	class:folly::sorted_vector_set	access:public
folly::sorted_vector_set::shrink_to_fit	.\sorted_vector_types.h	/^  void shrink_to_fit()          { m_.cont_.shrink_to_fit();   }$/;"	f	class:folly::sorted_vector_set	access:public	signature:()
folly::sorted_vector_set::size	.\sorted_vector_types.h	/^  size_type size() const        { return m_.cont_.size();     }$/;"	f	class:folly::sorted_vector_set	access:public	signature:() const
folly::sorted_vector_set::size_type	.\sorted_vector_types.h	/^  typedef typename ContainerT::size_type              size_type;$/;"	t	class:folly::sorted_vector_set	access:public
folly::sorted_vector_set::sorted_vector_set	.\sorted_vector_types.h	/^  explicit sorted_vector_set($/;"	f	class:folly::sorted_vector_set	access:public	signature:( InputIterator first, InputIterator last, const Compare& comp = Compare(), const Allocator& alloc = Allocator())
folly::sorted_vector_set::sorted_vector_set	.\sorted_vector_types.h	/^  explicit sorted_vector_set($/;"	f	class:folly::sorted_vector_set	access:public	signature:( std::initializer_list<value_type> list, const Compare& comp = Compare(), const Allocator& alloc = Allocator())
folly::sorted_vector_set::sorted_vector_set	.\sorted_vector_types.h	/^  explicit sorted_vector_set(const Compare& comp = Compare(),$/;"	f	class:folly::sorted_vector_set	access:public	signature:(const Compare& comp = Compare(), const Allocator& alloc = Allocator())
folly::sorted_vector_set::swap	.\sorted_vector_types.h	/^  void swap(sorted_vector_set& o) {$/;"	f	class:folly::sorted_vector_set	access:public	signature:(sorted_vector_set& o)
folly::sorted_vector_set::upper_bound	.\sorted_vector_types.h	/^  const_iterator upper_bound(const key_type& key) const {$/;"	f	class:folly::sorted_vector_set	access:public	signature:(const key_type& key) const
folly::sorted_vector_set::upper_bound	.\sorted_vector_types.h	/^  iterator upper_bound(const key_type& key) {$/;"	f	class:folly::sorted_vector_set	access:public	signature:(const key_type& key)
folly::sorted_vector_set::value_comp	.\sorted_vector_types.h	/^  value_compare value_comp() const { return m_; }$/;"	f	class:folly::sorted_vector_set	access:public	signature:() const
folly::sorted_vector_set::value_compare	.\sorted_vector_types.h	/^  typedef Compare value_compare;$/;"	t	class:folly::sorted_vector_set	access:public
folly::sorted_vector_set::value_type	.\sorted_vector_types.h	/^  typedef T       value_type;$/;"	t	class:folly::sorted_vector_set	access:public
folly::split	.\String-inl.h	/^split(const Delim& delimiter,$/;"	f	namespace:folly	signature:(const Delim& delimiter, StringPiece input, OutputType& outHead, OutputTypes&... outTail)
folly::split	.\String-inl.h	/^void split(const Delim& delimiter,$/;"	f	namespace:folly	signature:(const Delim& delimiter, const String& input, fbvector<OutputType>& out, bool ignoreEmpty)
folly::split	.\String-inl.h	/^void split(const Delim& delimiter,$/;"	f	namespace:folly	signature:(const Delim& delimiter, const String& input, std::vector<OutputType>& out, bool ignoreEmpty)
folly::splitTo	.\String-inl.h	/^void splitTo(const Delim& delimiter,$/;"	f	namespace:folly	signature:(const Delim& delimiter, const String& input, OutputIterator out, bool ignoreEmpty)
folly::stringAppendf	.\String.cpp	/^std::string& stringAppendf(std::string* output, const char* format, ...) {$/;"	f	namespace:folly	signature:(std::string* output, const char* format, ...)
folly::stringPrintf	.\String.cpp	/^std::string stringPrintf(const char* format, ...) {$/;"	f	namespace:folly	signature:(const char* format, ...)
folly::stringPrintf	.\String.cpp	/^void stringPrintf(std::string* output, const char* format, ...) {$/;"	f	namespace:folly	signature:(std::string* output, const char* format, ...)
folly::swap	.\File.cpp	/^void swap(File& a, File& b) {$/;"	f	namespace:folly	signature:(File& a, File& b)
folly::swap	.\File.h	/^void swap(File& a, File& b);$/;"	p	namespace:folly	signature:(File& a, File& b)
folly::swap	.\MemoryMapping.cpp	/^void swap(MemoryMapping& a, MemoryMapping& b) { a.swap(b); }$/;"	f	namespace:folly	signature:(MemoryMapping& a, MemoryMapping& b)
folly::swap	.\MemoryMapping.h	/^void swap(MemoryMapping&, MemoryMapping&);$/;"	p	namespace:folly	signature:(MemoryMapping&, MemoryMapping&)
folly::swap	.\Optional.h	/^void swap(Optional<T>& a, Optional<T>& b) {$/;"	f	namespace:folly	signature:(Optional<T>& a, Optional<T>& b)
folly::swap	.\Range.h	/^void swap(Range<T>& lhs, Range<T>& rhs) {$/;"	f	namespace:folly	signature:(Range<T>& lhs, Range<T>& rhs)
folly::swap	.\Synchronized.h	/^void swap(Synchronized<T, M>& lhs, Synchronized<T, M>& rhs) {$/;"	f	namespace:folly	signature:(Synchronized<T, M>& lhs, Synchronized<T, M>& rhs)
folly::swap	.\sorted_vector_types.h	/^inline void swap(sorted_vector_map<K,V,C,A,G>& a,$/;"	f	namespace:folly	signature:(sorted_vector_map<K,V,C,A,G>& a, sorted_vector_map<K,V,C,A,G>& b)
folly::swap	.\sorted_vector_types.h	/^inline void swap(sorted_vector_set<T,C,A,G>& a,$/;"	f	namespace:folly	signature:(sorted_vector_set<T,C,A,G>& a, sorted_vector_set<T,C,A,G>& b)
folly::symbolizer	.\experimental\symbolizer\Dwarf.cpp	/^namespace symbolizer {$/;"	n	namespace:folly	file:
folly::symbolizer	.\experimental\symbolizer\Dwarf.h	/^namespace symbolizer {$/;"	n	namespace:folly
folly::symbolizer	.\experimental\symbolizer\Elf-inl.h	/^namespace symbolizer {$/;"	n	namespace:folly
folly::symbolizer	.\experimental\symbolizer\Elf.cpp	/^namespace symbolizer {$/;"	n	namespace:folly	file:
folly::symbolizer	.\experimental\symbolizer\Elf.h	/^namespace symbolizer {$/;"	n	namespace:folly
folly::symbolizer	.\experimental\symbolizer\ElfCache.cpp	/^namespace folly { namespace symbolizer {$/;"	n	namespace:folly	file:
folly::symbolizer	.\experimental\symbolizer\ElfCache.h	/^namespace folly { namespace symbolizer {$/;"	n	namespace:folly
folly::symbolizer	.\experimental\symbolizer\LineReader.cpp	/^namespace folly { namespace symbolizer {$/;"	n	namespace:folly	file:
folly::symbolizer	.\experimental\symbolizer\LineReader.h	/^namespace folly { namespace symbolizer {$/;"	n	namespace:folly
folly::symbolizer	.\experimental\symbolizer\SignalHandler.cpp	/^namespace folly { namespace symbolizer {$/;"	n	namespace:folly	file:
folly::symbolizer	.\experimental\symbolizer\SignalHandler.h	/^namespace folly { namespace symbolizer {$/;"	n	namespace:folly
folly::symbolizer	.\experimental\symbolizer\StackTrace.cpp	/^namespace folly { namespace symbolizer {$/;"	n	namespace:folly	file:
folly::symbolizer	.\experimental\symbolizer\StackTrace.h	/^namespace folly { namespace symbolizer {$/;"	n	namespace:folly
folly::symbolizer	.\experimental\symbolizer\Symbolizer.cpp	/^namespace symbolizer {$/;"	n	namespace:folly	file:
folly::symbolizer	.\experimental\symbolizer\Symbolizer.h	/^namespace symbolizer {$/;"	n	namespace:folly
folly::symbolizer	.\experimental\symbolizer\test\LineReaderTest.cpp	/^namespace folly { namespace symbolizer { namespace test {$/;"	n	namespace:folly	file:
folly::symbolizer	.\experimental\symbolizer\test\SignalHandlerTest.cpp	/^namespace folly { namespace symbolizer { namespace test {$/;"	n	namespace:folly	file:
folly::symbolizer	.\experimental\symbolizer\test\SignalHandlerTest.h	/^namespace folly { namespace symbolizer { namespace test {$/;"	n	namespace:folly
folly::symbolizer	.\experimental\symbolizer\test\SymbolizerTest.cpp	/^namespace folly { namespace symbolizer { namespace test {$/;"	n	namespace:folly	file:
folly::symbolizer::AddressFormatter	.\experimental\symbolizer\Symbolizer.h	/^class AddressFormatter {$/;"	c	namespace:folly::symbolizer
folly::symbolizer::AddressFormatter::AddressFormatter	.\experimental\symbolizer\Symbolizer.cpp	/^AddressFormatter::AddressFormatter() {$/;"	f	class:folly::symbolizer::AddressFormatter	signature:()
folly::symbolizer::AddressFormatter::AddressFormatter	.\experimental\symbolizer\Symbolizer.h	/^  AddressFormatter();$/;"	p	class:folly::symbolizer::AddressFormatter	access:public	signature:()
folly::symbolizer::AddressFormatter::bufTemplate	.\experimental\symbolizer\Symbolizer.cpp	/^constexpr char AddressFormatter::bufTemplate[];$/;"	m	class:folly::symbolizer::AddressFormatter	file:
folly::symbolizer::AddressFormatter::bufTemplate	.\experimental\symbolizer\Symbolizer.h	/^  static constexpr char bufTemplate[] = "    @ 0000000000000000";$/;"	m	class:folly::symbolizer::AddressFormatter	access:private
folly::symbolizer::AddressFormatter::buf_	.\experimental\symbolizer\Symbolizer.h	/^  char buf_[sizeof(bufTemplate)];$/;"	m	class:folly::symbolizer::AddressFormatter	access:private
folly::symbolizer::AddressFormatter::format	.\experimental\symbolizer\Symbolizer.cpp	/^folly::StringPiece AddressFormatter::format(uintptr_t address) {$/;"	f	class:folly::symbolizer::AddressFormatter	signature:(uintptr_t address)
folly::symbolizer::AddressFormatter::format	.\experimental\symbolizer\Symbolizer.h	/^  StringPiece format(uintptr_t address);$/;"	p	class:folly::symbolizer::AddressFormatter	access:public	signature:(uintptr_t address)
folly::symbolizer::Dwarf	.\experimental\symbolizer\Dwarf.h	/^class Dwarf {$/;"	c	namespace:folly::symbolizer
folly::symbolizer::Dwarf::AttributeValue	.\experimental\symbolizer\Dwarf.h	/^  typedef boost::variant<uint64_t, folly::StringPiece> AttributeValue;$/;"	t	class:folly::symbolizer::Dwarf	access:private
folly::symbolizer::Dwarf::DIEAbbreviation	.\experimental\symbolizer\Dwarf.h	/^  struct DIEAbbreviation {$/;"	s	class:folly::symbolizer::Dwarf	access:private
folly::symbolizer::Dwarf::DIEAbbreviation::Attribute	.\experimental\symbolizer\Dwarf.h	/^    struct Attribute {$/;"	s	struct:folly::symbolizer::Dwarf::DIEAbbreviation	access:public
folly::symbolizer::Dwarf::DIEAbbreviation::Attribute::form	.\experimental\symbolizer\Dwarf.h	/^      uint64_t form;$/;"	m	struct:folly::symbolizer::Dwarf::DIEAbbreviation::Attribute	access:public
folly::symbolizer::Dwarf::DIEAbbreviation::Attribute::name	.\experimental\symbolizer\Dwarf.h	/^      uint64_t name;$/;"	m	struct:folly::symbolizer::Dwarf::DIEAbbreviation::Attribute	access:public
folly::symbolizer::Dwarf::DIEAbbreviation::attributes	.\experimental\symbolizer\Dwarf.h	/^    folly::StringPiece attributes;$/;"	m	struct:folly::symbolizer::Dwarf::DIEAbbreviation	access:public
folly::symbolizer::Dwarf::DIEAbbreviation::code	.\experimental\symbolizer\Dwarf.h	/^    uint64_t code;$/;"	m	struct:folly::symbolizer::Dwarf::DIEAbbreviation	access:public
folly::symbolizer::Dwarf::DIEAbbreviation::hasChildren	.\experimental\symbolizer\Dwarf.h	/^    bool hasChildren;$/;"	m	struct:folly::symbolizer::Dwarf::DIEAbbreviation	access:public
folly::symbolizer::Dwarf::DIEAbbreviation::tag	.\experimental\symbolizer\Dwarf.h	/^    uint64_t tag;$/;"	m	struct:folly::symbolizer::Dwarf::DIEAbbreviation	access:public
folly::symbolizer::Dwarf::Dwarf	.\experimental\symbolizer\Dwarf.cpp	/^Dwarf::Dwarf(const ElfFile* elf) : elf_(elf) {$/;"	f	class:folly::symbolizer::Dwarf	signature:(const ElfFile* elf)
folly::symbolizer::Dwarf::Dwarf	.\experimental\symbolizer\Dwarf.h	/^  explicit Dwarf(const ElfFile* elf);$/;"	p	class:folly::symbolizer::Dwarf	access:public	signature:(const ElfFile* elf)
folly::symbolizer::Dwarf::LineNumberVM	.\experimental\symbolizer\Dwarf.h	/^  class LineNumberVM {$/;"	c	class:folly::symbolizer::Dwarf	access:private
folly::symbolizer::Dwarf::LineNumberVM::COMMIT	.\experimental\symbolizer\Dwarf.h	/^      COMMIT,    \/\/ Commit new <address, file, line> tuple$/;"	e	enum:folly::symbolizer::Dwarf::LineNumberVM::StepResult
folly::symbolizer::Dwarf::LineNumberVM::CONTINUE	.\experimental\symbolizer\Dwarf.h	/^      CONTINUE,  \/\/ Continue feeding opcodes$/;"	e	enum:folly::symbolizer::Dwarf::LineNumberVM::StepResult
folly::symbolizer::Dwarf::LineNumberVM::END	.\experimental\symbolizer\Dwarf.h	/^      END,       \/\/ End of sequence$/;"	e	enum:folly::symbolizer::Dwarf::LineNumberVM::StepResult
folly::symbolizer::Dwarf::LineNumberVM::FileName	.\experimental\symbolizer\Dwarf.h	/^    struct FileName {$/;"	s	class:folly::symbolizer::Dwarf::LineNumberVM	access:private
folly::symbolizer::Dwarf::LineNumberVM::FileName::directoryIndex	.\experimental\symbolizer\Dwarf.h	/^      uint64_t directoryIndex;$/;"	m	struct:folly::symbolizer::Dwarf::LineNumberVM::FileName	access:public
folly::symbolizer::Dwarf::LineNumberVM::FileName::relativeName	.\experimental\symbolizer\Dwarf.h	/^      folly::StringPiece relativeName;$/;"	m	struct:folly::symbolizer::Dwarf::LineNumberVM::FileName	access:public
folly::symbolizer::Dwarf::LineNumberVM::LineNumberVM	.\experimental\symbolizer\Dwarf.cpp	/^Dwarf::LineNumberVM::LineNumberVM(folly::StringPiece data,$/;"	f	class:folly::symbolizer::Dwarf::LineNumberVM	signature:(folly::StringPiece data, folly::StringPiece compilationDirectory)
folly::symbolizer::Dwarf::LineNumberVM::LineNumberVM	.\experimental\symbolizer\Dwarf.h	/^    LineNumberVM(folly::StringPiece data,$/;"	p	class:folly::symbolizer::Dwarf::LineNumberVM	access:public	signature:(folly::StringPiece data, folly::StringPiece compilationDirectory)
folly::symbolizer::Dwarf::LineNumberVM::StepResult	.\experimental\symbolizer\Dwarf.h	/^    enum StepResult {$/;"	g	class:folly::symbolizer::Dwarf::LineNumberVM	access:private
folly::symbolizer::Dwarf::LineNumberVM::address_	.\experimental\symbolizer\Dwarf.h	/^    uint64_t address_;$/;"	m	class:folly::symbolizer::Dwarf::LineNumberVM	access:private
folly::symbolizer::Dwarf::LineNumberVM::basicBlock_	.\experimental\symbolizer\Dwarf.h	/^    bool basicBlock_;$/;"	m	class:folly::symbolizer::Dwarf::LineNumberVM	access:private
folly::symbolizer::Dwarf::LineNumberVM::column_	.\experimental\symbolizer\Dwarf.h	/^    uint64_t column_;$/;"	m	class:folly::symbolizer::Dwarf::LineNumberVM	access:private
folly::symbolizer::Dwarf::LineNumberVM::compilationDirectory_	.\experimental\symbolizer\Dwarf.h	/^    folly::StringPiece compilationDirectory_;$/;"	m	class:folly::symbolizer::Dwarf::LineNumberVM	access:private
folly::symbolizer::Dwarf::LineNumberVM::data_	.\experimental\symbolizer\Dwarf.h	/^    folly::StringPiece data_;$/;"	m	class:folly::symbolizer::Dwarf::LineNumberVM	access:private
folly::symbolizer::Dwarf::LineNumberVM::defaultIsStmt_	.\experimental\symbolizer\Dwarf.h	/^    bool defaultIsStmt_;$/;"	m	class:folly::symbolizer::Dwarf::LineNumberVM	access:private
folly::symbolizer::Dwarf::LineNumberVM::discriminator_	.\experimental\symbolizer\Dwarf.h	/^    uint64_t discriminator_;$/;"	m	class:folly::symbolizer::Dwarf::LineNumberVM	access:private
folly::symbolizer::Dwarf::LineNumberVM::endSequence_	.\experimental\symbolizer\Dwarf.h	/^    bool endSequence_;$/;"	m	class:folly::symbolizer::Dwarf::LineNumberVM	access:private
folly::symbolizer::Dwarf::LineNumberVM::epilogueBegin_	.\experimental\symbolizer\Dwarf.h	/^    bool epilogueBegin_;$/;"	m	class:folly::symbolizer::Dwarf::LineNumberVM	access:private
folly::symbolizer::Dwarf::LineNumberVM::fileNameCount_	.\experimental\symbolizer\Dwarf.h	/^    size_t fileNameCount_;$/;"	m	class:folly::symbolizer::Dwarf::LineNumberVM	access:private
folly::symbolizer::Dwarf::LineNumberVM::fileNames_	.\experimental\symbolizer\Dwarf.h	/^    folly::StringPiece fileNames_;$/;"	m	class:folly::symbolizer::Dwarf::LineNumberVM	access:private
folly::symbolizer::Dwarf::LineNumberVM::file_	.\experimental\symbolizer\Dwarf.h	/^    uint64_t file_;$/;"	m	class:folly::symbolizer::Dwarf::LineNumberVM	access:private
folly::symbolizer::Dwarf::LineNumberVM::findAddress	.\experimental\symbolizer\Dwarf.cpp	/^bool Dwarf::LineNumberVM::findAddress(uintptr_t target, Path& file,$/;"	f	class:folly::symbolizer::Dwarf::LineNumberVM	signature:(uintptr_t target, Path& file, uint64_t& line)
folly::symbolizer::Dwarf::LineNumberVM::findAddress	.\experimental\symbolizer\Dwarf.h	/^    bool findAddress(uintptr_t address, Path& file, uint64_t& line);$/;"	p	class:folly::symbolizer::Dwarf::LineNumberVM	access:public	signature:(uintptr_t address, Path& file, uint64_t& line)
folly::symbolizer::Dwarf::LineNumberVM::getFileName	.\experimental\symbolizer\Dwarf.cpp	/^Dwarf::LineNumberVM::FileName Dwarf::LineNumberVM::getFileName(uint64_t index)$/;"	f	class:folly::symbolizer::Dwarf::LineNumberVM	signature:(uint64_t index) const
folly::symbolizer::Dwarf::LineNumberVM::getFileName	.\experimental\symbolizer\Dwarf.h	/^    FileName getFileName(uint64_t index) const;$/;"	p	class:folly::symbolizer::Dwarf::LineNumberVM	access:private	signature:(uint64_t index) const
folly::symbolizer::Dwarf::LineNumberVM::getIncludeDirectory	.\experimental\symbolizer\Dwarf.cpp	/^folly::StringPiece Dwarf::LineNumberVM::getIncludeDirectory(uint64_t index)$/;"	f	class:folly::symbolizer::Dwarf::LineNumberVM	signature:(uint64_t index) const
folly::symbolizer::Dwarf::LineNumberVM::getIncludeDirectory	.\experimental\symbolizer\Dwarf.h	/^    folly::StringPiece getIncludeDirectory(uint64_t index) const;$/;"	p	class:folly::symbolizer::Dwarf::LineNumberVM	access:private	signature:(uint64_t index) const
folly::symbolizer::Dwarf::LineNumberVM::includeDirectories_	.\experimental\symbolizer\Dwarf.h	/^    folly::StringPiece includeDirectories_;$/;"	m	class:folly::symbolizer::Dwarf::LineNumberVM	access:private
folly::symbolizer::Dwarf::LineNumberVM::includeDirectoryCount_	.\experimental\symbolizer\Dwarf.h	/^    size_t includeDirectoryCount_;$/;"	m	class:folly::symbolizer::Dwarf::LineNumberVM	access:private
folly::symbolizer::Dwarf::LineNumberVM::init	.\experimental\symbolizer\Dwarf.cpp	/^void Dwarf::LineNumberVM::init() {$/;"	f	class:folly::symbolizer::Dwarf::LineNumberVM	signature:()
folly::symbolizer::Dwarf::LineNumberVM::init	.\experimental\symbolizer\Dwarf.h	/^    void init();$/;"	p	class:folly::symbolizer::Dwarf::LineNumberVM	access:private	signature:()
folly::symbolizer::Dwarf::LineNumberVM::is64Bit_	.\experimental\symbolizer\Dwarf.h	/^    bool is64Bit_;$/;"	m	class:folly::symbolizer::Dwarf::LineNumberVM	access:private
folly::symbolizer::Dwarf::LineNumberVM::isStmt_	.\experimental\symbolizer\Dwarf.h	/^    bool isStmt_;$/;"	m	class:folly::symbolizer::Dwarf::LineNumberVM	access:private
folly::symbolizer::Dwarf::LineNumberVM::isa_	.\experimental\symbolizer\Dwarf.h	/^    uint64_t isa_;$/;"	m	class:folly::symbolizer::Dwarf::LineNumberVM	access:private
folly::symbolizer::Dwarf::LineNumberVM::lineBase_	.\experimental\symbolizer\Dwarf.h	/^    int8_t lineBase_;$/;"	m	class:folly::symbolizer::Dwarf::LineNumberVM	access:private
folly::symbolizer::Dwarf::LineNumberVM::lineRange_	.\experimental\symbolizer\Dwarf.h	/^    uint8_t lineRange_;$/;"	m	class:folly::symbolizer::Dwarf::LineNumberVM	access:private
folly::symbolizer::Dwarf::LineNumberVM::line_	.\experimental\symbolizer\Dwarf.h	/^    uint64_t line_;$/;"	m	class:folly::symbolizer::Dwarf::LineNumberVM	access:private
folly::symbolizer::Dwarf::LineNumberVM::minLength_	.\experimental\symbolizer\Dwarf.h	/^    uint8_t minLength_;$/;"	m	class:folly::symbolizer::Dwarf::LineNumberVM	access:private
folly::symbolizer::Dwarf::LineNumberVM::next	.\experimental\symbolizer\Dwarf.cpp	/^bool Dwarf::LineNumberVM::next(folly::StringPiece& program) {$/;"	f	class:folly::symbolizer::Dwarf::LineNumberVM	signature:(folly::StringPiece& program)
folly::symbolizer::Dwarf::LineNumberVM::next	.\experimental\symbolizer\Dwarf.h	/^    bool next(folly::StringPiece& program);$/;"	p	class:folly::symbolizer::Dwarf::LineNumberVM	access:private	signature:(folly::StringPiece& program)
folly::symbolizer::Dwarf::LineNumberVM::nextDefineFile	.\experimental\symbolizer\Dwarf.cpp	/^bool Dwarf::LineNumberVM::nextDefineFile(folly::StringPiece& program,$/;"	f	class:folly::symbolizer::Dwarf::LineNumberVM	signature:(folly::StringPiece& program, FileName& fn) const
folly::symbolizer::Dwarf::LineNumberVM::nextDefineFile	.\experimental\symbolizer\Dwarf.h	/^    bool nextDefineFile(folly::StringPiece& program, FileName& fn) const;$/;"	p	class:folly::symbolizer::Dwarf::LineNumberVM	access:private	signature:(folly::StringPiece& program, FileName& fn) const
folly::symbolizer::Dwarf::LineNumberVM::opcodeBase_	.\experimental\symbolizer\Dwarf.h	/^    uint8_t opcodeBase_;$/;"	m	class:folly::symbolizer::Dwarf::LineNumberVM	access:private
folly::symbolizer::Dwarf::LineNumberVM::prologueEnd_	.\experimental\symbolizer\Dwarf.h	/^    bool prologueEnd_;$/;"	m	class:folly::symbolizer::Dwarf::LineNumberVM	access:private
folly::symbolizer::Dwarf::LineNumberVM::readFileName	.\experimental\symbolizer\Dwarf.cpp	/^bool Dwarf::LineNumberVM::readFileName(folly::StringPiece& program,$/;"	f	class:folly::symbolizer::Dwarf::LineNumberVM	signature:(folly::StringPiece& program, FileName& fn)
folly::symbolizer::Dwarf::LineNumberVM::readFileName	.\experimental\symbolizer\Dwarf.h	/^    static bool readFileName(folly::StringPiece& sp, FileName& fn);$/;"	p	class:folly::symbolizer::Dwarf::LineNumberVM	access:private	signature:(folly::StringPiece& sp, FileName& fn)
folly::symbolizer::Dwarf::LineNumberVM::reset	.\experimental\symbolizer\Dwarf.cpp	/^void Dwarf::LineNumberVM::reset() {$/;"	f	class:folly::symbolizer::Dwarf::LineNumberVM	signature:()
folly::symbolizer::Dwarf::LineNumberVM::reset	.\experimental\symbolizer\Dwarf.h	/^    void reset();$/;"	p	class:folly::symbolizer::Dwarf::LineNumberVM	access:private	signature:()
folly::symbolizer::Dwarf::LineNumberVM::standardOpcodeLengths_	.\experimental\symbolizer\Dwarf.h	/^    const uint8_t* standardOpcodeLengths_;$/;"	m	class:folly::symbolizer::Dwarf::LineNumberVM	access:private
folly::symbolizer::Dwarf::LineNumberVM::step	.\experimental\symbolizer\Dwarf.cpp	/^Dwarf::LineNumberVM::StepResult Dwarf::LineNumberVM::step($/;"	f	class:folly::symbolizer::Dwarf::LineNumberVM	signature:( folly::StringPiece& program)
folly::symbolizer::Dwarf::LineNumberVM::step	.\experimental\symbolizer\Dwarf.h	/^    StepResult step(folly::StringPiece& program);$/;"	p	class:folly::symbolizer::Dwarf::LineNumberVM	access:private	signature:(folly::StringPiece& program)
folly::symbolizer::Dwarf::LineNumberVM::version_	.\experimental\symbolizer\Dwarf.h	/^    uint16_t version_;$/;"	m	class:folly::symbolizer::Dwarf::LineNumberVM	access:private
folly::symbolizer::Dwarf::LocationInfo	.\experimental\symbolizer\Dwarf.h	/^  struct LocationInfo {$/;"	s	class:folly::symbolizer::Dwarf	access:public
folly::symbolizer::Dwarf::LocationInfo::LocationInfo	.\experimental\symbolizer\Dwarf.h	/^    LocationInfo() : hasMainFile(false), hasFileAndLine(false), line(0) { }$/;"	f	struct:folly::symbolizer::Dwarf::LocationInfo	access:public	signature:()
folly::symbolizer::Dwarf::LocationInfo::file	.\experimental\symbolizer\Dwarf.h	/^    Path file;$/;"	m	struct:folly::symbolizer::Dwarf::LocationInfo	access:public
folly::symbolizer::Dwarf::LocationInfo::hasFileAndLine	.\experimental\symbolizer\Dwarf.h	/^    bool hasFileAndLine;$/;"	m	struct:folly::symbolizer::Dwarf::LocationInfo	access:public
folly::symbolizer::Dwarf::LocationInfo::hasMainFile	.\experimental\symbolizer\Dwarf.h	/^    bool hasMainFile;$/;"	m	struct:folly::symbolizer::Dwarf::LocationInfo	access:public
folly::symbolizer::Dwarf::LocationInfo::line	.\experimental\symbolizer\Dwarf.h	/^    uint64_t line;$/;"	m	struct:folly::symbolizer::Dwarf::LocationInfo	access:public
folly::symbolizer::Dwarf::LocationInfo::mainFile	.\experimental\symbolizer\Dwarf.h	/^    Path mainFile;$/;"	m	struct:folly::symbolizer::Dwarf::LocationInfo	access:public
folly::symbolizer::Dwarf::Path	.\experimental\symbolizer\Dwarf.h	/^  class Path {$/;"	c	class:folly::symbolizer::Dwarf	access:public
folly::symbolizer::Dwarf::Path::Path	.\experimental\symbolizer\Dwarf.cpp	/^Dwarf::Path::Path(folly::StringPiece baseDir, folly::StringPiece subDir,$/;"	f	class:folly::symbolizer::Dwarf::Path	signature:(folly::StringPiece baseDir, folly::StringPiece subDir, folly::StringPiece file)
folly::symbolizer::Dwarf::Path::Path	.\experimental\symbolizer\Dwarf.h	/^    Path() { }$/;"	f	class:folly::symbolizer::Dwarf::Path	access:public	signature:()
folly::symbolizer::Dwarf::Path::Path	.\experimental\symbolizer\Dwarf.h	/^    Path(folly::StringPiece baseDir, folly::StringPiece subDir,$/;"	p	class:folly::symbolizer::Dwarf::Path	access:public	signature:(folly::StringPiece baseDir, folly::StringPiece subDir, folly::StringPiece file)
folly::symbolizer::Dwarf::Path::baseDir	.\experimental\symbolizer\Dwarf.h	/^    folly::StringPiece baseDir() const { return baseDir_; };$/;"	f	class:folly::symbolizer::Dwarf::Path	access:public	signature:() const
folly::symbolizer::Dwarf::Path::baseDir_	.\experimental\symbolizer\Dwarf.h	/^    folly::StringPiece baseDir_;$/;"	m	class:folly::symbolizer::Dwarf::Path	access:private
folly::symbolizer::Dwarf::Path::file	.\experimental\symbolizer\Dwarf.h	/^    folly::StringPiece file() const { return file_; }$/;"	f	class:folly::symbolizer::Dwarf::Path	access:public	signature:() const
folly::symbolizer::Dwarf::Path::file_	.\experimental\symbolizer\Dwarf.h	/^    folly::StringPiece file_;$/;"	m	class:folly::symbolizer::Dwarf::Path	access:private
folly::symbolizer::Dwarf::Path::size	.\experimental\symbolizer\Dwarf.cpp	/^size_t Dwarf::Path::size() const {$/;"	f	class:folly::symbolizer::Dwarf::Path	signature:() const
folly::symbolizer::Dwarf::Path::size	.\experimental\symbolizer\Dwarf.h	/^    size_t size() const;$/;"	p	class:folly::symbolizer::Dwarf::Path	access:public	signature:() const
folly::symbolizer::Dwarf::Path::subDir	.\experimental\symbolizer\Dwarf.h	/^    folly::StringPiece subDir() const { return subDir_; }$/;"	f	class:folly::symbolizer::Dwarf::Path	access:public	signature:() const
folly::symbolizer::Dwarf::Path::subDir_	.\experimental\symbolizer\Dwarf.h	/^    folly::StringPiece subDir_;$/;"	m	class:folly::symbolizer::Dwarf::Path	access:private
folly::symbolizer::Dwarf::Path::toBuffer	.\experimental\symbolizer\Dwarf.cpp	/^size_t Dwarf::Path::toBuffer(char* buf, size_t bufSize) const {$/;"	f	class:folly::symbolizer::Dwarf::Path	signature:(char* buf, size_t bufSize) const
folly::symbolizer::Dwarf::Path::toBuffer	.\experimental\symbolizer\Dwarf.h	/^    size_t toBuffer(char* buf, size_t bufSize) const;$/;"	p	class:folly::symbolizer::Dwarf::Path	access:public	signature:(char* buf, size_t bufSize) const
folly::symbolizer::Dwarf::Path::toString	.\experimental\symbolizer\Dwarf.cpp	/^void Dwarf::Path::toString(std::string& dest) const {$/;"	f	class:folly::symbolizer::Dwarf::Path	signature:(std::string& dest) const
folly::symbolizer::Dwarf::Path::toString	.\experimental\symbolizer\Dwarf.h	/^    std::string toString() const {$/;"	f	class:folly::symbolizer::Dwarf::Path	access:public	signature:() const
folly::symbolizer::Dwarf::Path::toString	.\experimental\symbolizer\Dwarf.h	/^    void toString(std::string& dest) const;$/;"	p	class:folly::symbolizer::Dwarf::Path	access:public	signature:(std::string& dest) const
folly::symbolizer::Dwarf::Section	.\experimental\symbolizer\Dwarf.h	/^  class Section {$/;"	c	class:folly::symbolizer::Dwarf	access:private
folly::symbolizer::Dwarf::Section::Section	.\experimental\symbolizer\Dwarf.cpp	/^Dwarf::Section::Section(folly::StringPiece d) : is64Bit_(false), data_(d) {$/;"	f	class:folly::symbolizer::Dwarf::Section	signature:(folly::StringPiece d)
folly::symbolizer::Dwarf::Section::Section	.\experimental\symbolizer\Dwarf.h	/^    Section() : is64Bit_(false) { }$/;"	f	class:folly::symbolizer::Dwarf::Section	access:public	signature:()
folly::symbolizer::Dwarf::Section::Section	.\experimental\symbolizer\Dwarf.h	/^    explicit Section(folly::StringPiece d);$/;"	p	class:folly::symbolizer::Dwarf::Section	access:public	signature:(folly::StringPiece d)
folly::symbolizer::Dwarf::Section::data_	.\experimental\symbolizer\Dwarf.h	/^    folly::StringPiece data_;$/;"	m	class:folly::symbolizer::Dwarf::Section	access:private
folly::symbolizer::Dwarf::Section::is64Bit	.\experimental\symbolizer\Dwarf.h	/^    bool is64Bit() const { return is64Bit_; }$/;"	f	class:folly::symbolizer::Dwarf::Section	access:public	signature:() const
folly::symbolizer::Dwarf::Section::is64Bit_	.\experimental\symbolizer\Dwarf.h	/^    bool is64Bit_;$/;"	m	class:folly::symbolizer::Dwarf::Section	access:private
folly::symbolizer::Dwarf::Section::next	.\experimental\symbolizer\Dwarf.cpp	/^bool Dwarf::Section::next(folly::StringPiece& chunk) {$/;"	f	class:folly::symbolizer::Dwarf::Section	signature:(folly::StringPiece& chunk)
folly::symbolizer::Dwarf::Section::next	.\experimental\symbolizer\Dwarf.h	/^    bool next(folly::StringPiece& chunk);$/;"	p	class:folly::symbolizer::Dwarf::Section	access:public	signature:(folly::StringPiece& chunk)
folly::symbolizer::Dwarf::abbrev_	.\experimental\symbolizer\Dwarf.h	/^  folly::StringPiece abbrev_;     \/\/ .debug_abbrev$/;"	m	class:folly::symbolizer::Dwarf	access:private
folly::symbolizer::Dwarf::aranges_	.\experimental\symbolizer\Dwarf.h	/^  folly::StringPiece aranges_;    \/\/ .debug_aranges$/;"	m	class:folly::symbolizer::Dwarf	access:private
folly::symbolizer::Dwarf::elf_	.\experimental\symbolizer\Dwarf.h	/^  const ElfFile* elf_;$/;"	m	class:folly::symbolizer::Dwarf	access:private
folly::symbolizer::Dwarf::findAddress	.\experimental\symbolizer\Dwarf.cpp	/^bool Dwarf::findAddress(uintptr_t address, LocationInfo& locationInfo) const {$/;"	f	class:folly::symbolizer::Dwarf	signature:(uintptr_t address, LocationInfo& locationInfo) const
folly::symbolizer::Dwarf::findAddress	.\experimental\symbolizer\Dwarf.h	/^  bool findAddress(uintptr_t address, LocationInfo& info) const;$/;"	p	class:folly::symbolizer::Dwarf	access:public	signature:(uintptr_t address, LocationInfo& info) const
folly::symbolizer::Dwarf::getAbbreviation	.\experimental\symbolizer\Dwarf.cpp	/^Dwarf::DIEAbbreviation Dwarf::getAbbreviation(uint64_t code, uint64_t offset)$/;"	f	class:folly::symbolizer::Dwarf	signature:(uint64_t code, uint64_t offset) const
folly::symbolizer::Dwarf::getAbbreviation	.\experimental\symbolizer\Dwarf.h	/^  DIEAbbreviation getAbbreviation(uint64_t code, uint64_t offset) const;$/;"	p	class:folly::symbolizer::Dwarf	access:private	signature:(uint64_t code, uint64_t offset) const
folly::symbolizer::Dwarf::getSection	.\experimental\symbolizer\Dwarf.cpp	/^bool Dwarf::getSection(const char* name, folly::StringPiece* section) const {$/;"	f	class:folly::symbolizer::Dwarf	signature:(const char* name, folly::StringPiece* section) const
folly::symbolizer::Dwarf::getSection	.\experimental\symbolizer\Dwarf.h	/^  bool getSection(const char* name, folly::StringPiece* section) const;$/;"	p	class:folly::symbolizer::Dwarf	access:private	signature:(const char* name, folly::StringPiece* section) const
folly::symbolizer::Dwarf::getStringFromStringSection	.\experimental\symbolizer\Dwarf.cpp	/^folly::StringPiece Dwarf::getStringFromStringSection(uint64_t offset) const {$/;"	f	class:folly::symbolizer::Dwarf	signature:(uint64_t offset) const
folly::symbolizer::Dwarf::getStringFromStringSection	.\experimental\symbolizer\Dwarf.h	/^  folly::StringPiece getStringFromStringSection(uint64_t offset) const;$/;"	p	class:folly::symbolizer::Dwarf	access:private	signature:(uint64_t offset) const
folly::symbolizer::Dwarf::info_	.\experimental\symbolizer\Dwarf.h	/^  folly::StringPiece info_;       \/\/ .debug_info$/;"	m	class:folly::symbolizer::Dwarf	access:private
folly::symbolizer::Dwarf::init	.\experimental\symbolizer\Dwarf.cpp	/^void Dwarf::init() {$/;"	f	class:folly::symbolizer::Dwarf	signature:()
folly::symbolizer::Dwarf::init	.\experimental\symbolizer\Dwarf.h	/^  void init();$/;"	p	class:folly::symbolizer::Dwarf	access:private	signature:()
folly::symbolizer::Dwarf::line_	.\experimental\symbolizer\Dwarf.h	/^  folly::StringPiece line_;       \/\/ .debug_line$/;"	m	class:folly::symbolizer::Dwarf	access:private
folly::symbolizer::Dwarf::readAbbreviation	.\experimental\symbolizer\Dwarf.cpp	/^bool Dwarf::readAbbreviation(folly::StringPiece& section,$/;"	f	class:folly::symbolizer::Dwarf	signature:(folly::StringPiece& section, DIEAbbreviation& abbr)
folly::symbolizer::Dwarf::readAbbreviation	.\experimental\symbolizer\Dwarf.h	/^  static bool readAbbreviation(folly::StringPiece& sp, DIEAbbreviation& abbr);$/;"	p	class:folly::symbolizer::Dwarf	access:private	signature:(folly::StringPiece& sp, DIEAbbreviation& abbr)
folly::symbolizer::Dwarf::readAttribute	.\experimental\symbolizer\Dwarf.cpp	/^Dwarf::DIEAbbreviation::Attribute Dwarf::readAttribute($/;"	f	class:folly::symbolizer::Dwarf	signature:( folly::StringPiece& sp)
folly::symbolizer::Dwarf::readAttribute	.\experimental\symbolizer\Dwarf.h	/^  static DIEAbbreviation::Attribute readAttribute(folly::StringPiece& sp);$/;"	p	class:folly::symbolizer::Dwarf	access:private	signature:(folly::StringPiece& sp)
folly::symbolizer::Dwarf::readAttributeValue	.\experimental\symbolizer\Dwarf.cpp	/^Dwarf::AttributeValue Dwarf::readAttributeValue($/;"	f	class:folly::symbolizer::Dwarf	signature:( folly::StringPiece& sp, uint64_t form, bool is64Bit) const
folly::symbolizer::Dwarf::readAttributeValue	.\experimental\symbolizer\Dwarf.h	/^  AttributeValue readAttributeValue($/;"	p	class:folly::symbolizer::Dwarf	access:private	signature:( folly::StringPiece& sp, uint64_t form, bool is64Bit) const
folly::symbolizer::Dwarf::strings_	.\experimental\symbolizer\Dwarf.h	/^  folly::StringPiece strings_;    \/\/ .debug_str$/;"	m	class:folly::symbolizer::Dwarf	access:private
folly::symbolizer::ElfCache	.\experimental\symbolizer\ElfCache.h	/^class ElfCache : public ElfCacheBase {$/;"	c	namespace:folly::symbolizer	inherits:ElfCacheBase
folly::symbolizer::ElfCache::ElfCache	.\experimental\symbolizer\ElfCache.cpp	/^ElfCache::ElfCache(size_t capacity) : capacity_(capacity) { }$/;"	f	class:folly::symbolizer::ElfCache	signature:(size_t capacity)
folly::symbolizer::ElfCache::ElfCache	.\experimental\symbolizer\ElfCache.h	/^  explicit ElfCache(size_t capacity);$/;"	p	class:folly::symbolizer::ElfCache	access:public	signature:(size_t capacity)
folly::symbolizer::ElfCache::Entry	.\experimental\symbolizer\ElfCache.h	/^  struct Entry {$/;"	s	class:folly::symbolizer::ElfCache	access:private
folly::symbolizer::ElfCache::Entry::file	.\experimental\symbolizer\ElfCache.h	/^    ElfFile file;$/;"	m	struct:folly::symbolizer::ElfCache::Entry	access:public
folly::symbolizer::ElfCache::Entry::lruLink	.\experimental\symbolizer\ElfCache.h	/^    LruLink lruLink;$/;"	m	struct:folly::symbolizer::ElfCache::Entry	access:public
folly::symbolizer::ElfCache::Entry::path	.\experimental\symbolizer\ElfCache.h	/^    std::string path;$/;"	m	struct:folly::symbolizer::ElfCache::Entry	access:public
folly::symbolizer::ElfCache::LruLink	.\experimental\symbolizer\ElfCache.h	/^  typedef boost::intrusive::list_member_hook<> LruLink;$/;"	t	class:folly::symbolizer::ElfCache	access:private
folly::symbolizer::ElfCache::LruList	.\experimental\symbolizer\ElfCache.h	/^      boost::intrusive::constant_time_size<false>> LruList;$/;"	t	class:folly::symbolizer::ElfCache	access:private
folly::symbolizer::ElfCache::capacity_	.\experimental\symbolizer\ElfCache.h	/^  size_t capacity_;$/;"	m	class:folly::symbolizer::ElfCache	access:private
folly::symbolizer::ElfCache::filePtr	.\experimental\symbolizer\ElfCache.cpp	/^std::shared_ptr<ElfFile> ElfCache::filePtr(const std::shared_ptr<Entry>& e) {$/;"	f	class:folly::symbolizer::ElfCache	signature:(const std::shared_ptr<Entry>& e)
folly::symbolizer::ElfCache::filePtr	.\experimental\symbolizer\ElfCache.h	/^  static std::shared_ptr<ElfFile> filePtr(const std::shared_ptr<Entry>& e);$/;"	p	class:folly::symbolizer::ElfCache	access:private	signature:(const std::shared_ptr<Entry>& e)
folly::symbolizer::ElfCache::files_	.\experimental\symbolizer\ElfCache.h	/^    StringPieceHash> files_;$/;"	m	class:folly::symbolizer::ElfCache	access:private
folly::symbolizer::ElfCache::getFile	.\experimental\symbolizer\ElfCache.cpp	/^std::shared_ptr<ElfFile> ElfCache::getFile(StringPiece p) {$/;"	f	class:folly::symbolizer::ElfCache	signature:(StringPiece p)
folly::symbolizer::ElfCache::lruList_	.\experimental\symbolizer\ElfCache.h	/^  LruList lruList_;$/;"	m	class:folly::symbolizer::ElfCache	access:private
folly::symbolizer::ElfCache::mutex_	.\experimental\symbolizer\ElfCache.h	/^  std::mutex mutex_;$/;"	m	class:folly::symbolizer::ElfCache	access:private
folly::symbolizer::ElfCache::override	.\experimental\symbolizer\ElfCache.h	/^  std::shared_ptr<ElfFile> getFile(StringPiece path) override;$/;"	m	class:folly::symbolizer::ElfCache	access:public
folly::symbolizer::ElfCacheBase	.\experimental\symbolizer\ElfCache.h	/^class ElfCacheBase {$/;"	c	namespace:folly::symbolizer
folly::symbolizer::ElfCacheBase::getFile	.\experimental\symbolizer\ElfCache.h	/^  virtual std::shared_ptr<ElfFile> getFile(StringPiece path) = 0;$/;"	p	class:folly::symbolizer::ElfCacheBase	access:public	signature:(StringPiece path)
folly::symbolizer::ElfCacheBase::~ElfCacheBase	.\experimental\symbolizer\ElfCache.h	/^  virtual ~ElfCacheBase() { }$/;"	f	class:folly::symbolizer::ElfCacheBase	access:public	signature:()
folly::symbolizer::ElfFile	.\experimental\symbolizer\Elf.h	/^class ElfFile {$/;"	c	namespace:folly::symbolizer
folly::symbolizer::ElfFile::ElfFile	.\experimental\symbolizer\Elf.cpp	/^ElfFile::ElfFile(const char* name, bool readOnly)$/;"	f	class:folly::symbolizer::ElfFile	signature:(const char* name, bool readOnly)
folly::symbolizer::ElfFile::ElfFile	.\experimental\symbolizer\Elf.h	/^  ElfFile(const ElfFile&) = delete;$/;"	p	class:folly::symbolizer::ElfFile	access:private	signature:(const ElfFile&)
folly::symbolizer::ElfFile::ElfFile	.\experimental\symbolizer\Elf.h	/^  explicit ElfFile(const char* name, bool readOnly=true);$/;"	p	class:folly::symbolizer::ElfFile	access:public	signature:(const char* name, bool readOnly=true)
folly::symbolizer::ElfFile::Symbol	.\experimental\symbolizer\Elf.h	/^  typedef std::pair<const ElfW(Shdr)*, const ElfW(Sym)*> Symbol;$/;"	t	class:folly::symbolizer::ElfFile	access:public
folly::symbolizer::ElfFile::baseAddress_	.\experimental\symbolizer\Elf.h	/^  uintptr_t baseAddress_;$/;"	m	class:folly::symbolizer::ElfFile	access:private
folly::symbolizer::ElfFile::destroy	.\experimental\symbolizer\Elf.cpp	/^void ElfFile::destroy() {$/;"	f	class:folly::symbolizer::ElfFile	signature:()
folly::symbolizer::ElfFile::destroy	.\experimental\symbolizer\Elf.h	/^  void destroy();$/;"	p	class:folly::symbolizer::ElfFile	access:private	signature:()
folly::symbolizer::ElfFile::elfHeader	.\experimental\symbolizer\Elf.h	/^  const ElfW(Ehdr)& elfHeader() const {$/;"	f	class:folly::symbolizer::ElfFile	access:public	signature:() const
folly::symbolizer::ElfFile::fd_	.\experimental\symbolizer\Elf.h	/^  int fd_;$/;"	m	class:folly::symbolizer::ElfFile	access:private
folly::symbolizer::ElfFile::file_	.\experimental\symbolizer\Elf.h	/^  char* file_;     \/\/ mmap() location$/;"	m	class:folly::symbolizer::ElfFile	access:private
folly::symbolizer::ElfFile::getBaseAddress	.\experimental\symbolizer\Elf.h	/^  uintptr_t getBaseAddress() const {$/;"	f	class:folly::symbolizer::ElfFile	access:public	signature:() const
folly::symbolizer::ElfFile::getDefinitionByAddress	.\experimental\symbolizer\Elf.cpp	/^ElfFile::Symbol ElfFile::getDefinitionByAddress(uintptr_t address) const {$/;"	f	class:folly::symbolizer::ElfFile	signature:(uintptr_t address) const
folly::symbolizer::ElfFile::getDefinitionByAddress	.\experimental\symbolizer\Elf.h	/^  Symbol getDefinitionByAddress(uintptr_t address) const;$/;"	p	class:folly::symbolizer::ElfFile	access:public	signature:(uintptr_t address) const
folly::symbolizer::ElfFile::getSectionByIndex	.\experimental\symbolizer\Elf.cpp	/^const ElfW(Shdr)* ElfFile::getSectionByIndex(size_t idx) const {$/;"	f	class:folly::symbolizer::ElfFile	signature:(size_t idx) const
folly::symbolizer::ElfFile::getSectionByIndex	.\experimental\symbolizer\Elf.h	/^  const ElfW(Shdr)* getSectionByIndex(size_t idx) const;$/;"	p	class:folly::symbolizer::ElfFile	access:public	signature:(size_t idx) const
folly::symbolizer::ElfFile::getSectionByName	.\experimental\symbolizer\Elf.cpp	/^const ElfW(Shdr)* ElfFile::getSectionByName(const char* name) const {$/;"	f	class:folly::symbolizer::ElfFile	signature:(const char* name) const
folly::symbolizer::ElfFile::getSectionByName	.\experimental\symbolizer\Elf.h	/^  const ElfW(Shdr)* getSectionByName(const char* name) const;$/;"	p	class:folly::symbolizer::ElfFile	access:public	signature:(const char* name) const
folly::symbolizer::ElfFile::getSymbolByName	.\experimental\symbolizer\Elf.cpp	/^ElfFile::Symbol ElfFile::getSymbolByName(const char* name) const {$/;"	f	class:folly::symbolizer::ElfFile	signature:(const char* name) const
folly::symbolizer::ElfFile::getSymbolByName	.\experimental\symbolizer\Elf.h	/^  Symbol getSymbolByName(const char* name) const;$/;"	p	class:folly::symbolizer::ElfFile	access:public	signature:(const char* name) const
folly::symbolizer::ElfFile::getSymbolName	.\experimental\symbolizer\Elf.cpp	/^const char* ElfFile::getSymbolName(Symbol symbol) const {$/;"	f	class:folly::symbolizer::ElfFile	signature:(Symbol symbol) const
folly::symbolizer::ElfFile::getSymbolName	.\experimental\symbolizer\Elf.h	/^  const char* getSymbolName(Symbol symbol) const;$/;"	p	class:folly::symbolizer::ElfFile	access:public	signature:(Symbol symbol) const
folly::symbolizer::ElfFile::init	.\experimental\symbolizer\Elf.cpp	/^bool ElfFile::init(const char** msg) {$/;"	f	class:folly::symbolizer::ElfFile	signature:(const char** msg)
folly::symbolizer::ElfFile::init	.\experimental\symbolizer\Elf.h	/^  bool init(const char** msg);$/;"	p	class:folly::symbolizer::ElfFile	access:private	signature:(const char** msg)
folly::symbolizer::ElfFile::iterateSections	.\experimental\symbolizer\Elf-inl.h	/^const ElfW(Shdr)* ElfFile::iterateSections(Fn fn) const {$/;"	f	class:folly::symbolizer::ElfFile	signature:(Fn fn) const
folly::symbolizer::ElfFile::iterateSections	.\experimental\symbolizer\Elf.h	/^  const ElfW(Shdr)* iterateSections(Fn fn) const;$/;"	p	class:folly::symbolizer::ElfFile	access:public	signature:(Fn fn) const
folly::symbolizer::ElfFile::iterateSectionsWithType	.\experimental\symbolizer\Elf-inl.h	/^const ElfW(Shdr)* ElfFile::iterateSectionsWithType(uint32_t type, Fn fn)$/;"	f	class:folly::symbolizer::ElfFile	signature:(uint32_t type, Fn fn) const
folly::symbolizer::ElfFile::iterateSectionsWithType	.\experimental\symbolizer\Elf.h	/^  const ElfW(Shdr)* iterateSectionsWithType(uint32_t type, Fn fn) const;$/;"	p	class:folly::symbolizer::ElfFile	access:public	signature:(uint32_t type, Fn fn) const
folly::symbolizer::ElfFile::kInvalidElfFile	.\experimental\symbolizer\Elf.h	/^    kInvalidElfFile = -2,$/;"	e	enum:folly::symbolizer::ElfFile::__anon35
folly::symbolizer::ElfFile::kSuccess	.\experimental\symbolizer\Elf.h	/^    kSuccess = 0,$/;"	e	enum:folly::symbolizer::ElfFile::__anon35
folly::symbolizer::ElfFile::kSystemError	.\experimental\symbolizer\Elf.h	/^    kSystemError = -1,$/;"	e	enum:folly::symbolizer::ElfFile::__anon35
folly::symbolizer::ElfFile::length_	.\experimental\symbolizer\Elf.h	/^  size_t length_;  \/\/ mmap() length$/;"	m	class:folly::symbolizer::ElfFile	access:private
folly::symbolizer::ElfFile::noexcept	.\experimental\symbolizer\Elf.h	/^                  const char** msg=nullptr) noexcept;$/;"	m	class:folly::symbolizer::ElfFile	access:public
folly::symbolizer::ElfFile::noexcept	.\experimental\symbolizer\Elf.h	/^  ElfFile() noexcept;$/;"	m	class:folly::symbolizer::ElfFile	access:public
folly::symbolizer::ElfFile::noexcept	.\experimental\symbolizer\Elf.h	/^  ElfFile(ElfFile&& other) noexcept;$/;"	m	class:folly::symbolizer::ElfFile	access:public
folly::symbolizer::ElfFile::open	.\experimental\symbolizer\Elf.cpp	/^void ElfFile::open(const char* name, bool readOnly) {$/;"	f	class:folly::symbolizer::ElfFile	signature:(const char* name, bool readOnly)
folly::symbolizer::ElfFile::open	.\experimental\symbolizer\Elf.h	/^  void open(const char* name, bool readOnly=true);$/;"	p	class:folly::symbolizer::ElfFile	access:public	signature:(const char* name, bool readOnly=true)
folly::symbolizer::ElfFile::operator =	.\experimental\symbolizer\Elf.cpp	/^ElfFile& ElfFile::operator=(ElfFile&& other) {$/;"	f	class:folly::symbolizer::ElfFile	signature:(ElfFile&& other)
folly::symbolizer::ElfFile::operator =	.\experimental\symbolizer\Elf.h	/^  ElfFile& operator=(ElfFile&& other);$/;"	p	class:folly::symbolizer::ElfFile	access:public	signature:(ElfFile&& other)
folly::symbolizer::ElfFile::operator =	.\experimental\symbolizer\Elf.h	/^  ElfFile& operator=(const ElfFile&) = delete;$/;"	p	class:folly::symbolizer::ElfFile	access:private	signature:(const ElfFile&)
folly::symbolizer::ElfFile::section	.\experimental\symbolizer\Elf.h	/^  const ElfW(Sym)* iterateSymbols(const ElfW(Shdr)& section, Fn fn) const;$/;"	m	class:folly::symbolizer::ElfFile	access:public
folly::symbolizer::ElfFile::section	.\experimental\symbolizer\Elf.h	/^  const ElfW(Sym)* iterateSymbolsWithType(const ElfW(Shdr)& section,$/;"	m	class:folly::symbolizer::ElfFile	access:public
folly::symbolizer::ElfFile::section	.\experimental\symbolizer\Elf.h	/^  const T& valueAt(const ElfW(Shdr)& section, const ElfW(Addr) addr) const {$/;"	m	class:folly::symbolizer::ElfFile	access:private
folly::symbolizer::ElfFile::stringTable	.\experimental\symbolizer\Elf.h	/^  const char* getString(const ElfW(Shdr)& stringTable, size_t offset) const;$/;"	m	class:folly::symbolizer::ElfFile	access:public
folly::symbolizer::ElfFile::stringTable	.\experimental\symbolizer\Elf.h	/^  const char* iterateStrings(const ElfW(Shdr)& stringTable, Fn fn) const;$/;"	m	class:folly::symbolizer::ElfFile	access:public
folly::symbolizer::ElfFile::type	.\experimental\symbolizer\Elf.h	/^                                          uint32_t type, Fn fn) const;$/;"	m	class:folly::symbolizer::ElfFile	access:public
folly::symbolizer::ElfFile::~ElfFile	.\experimental\symbolizer\Elf.cpp	/^ElfFile::~ElfFile() {$/;"	f	class:folly::symbolizer::ElfFile	signature:()
folly::symbolizer::ElfFile::~ElfFile	.\experimental\symbolizer\Elf.h	/^  ~ElfFile();$/;"	p	class:folly::symbolizer::ElfFile	access:public	signature:()
folly::symbolizer::FDSymbolizePrinter	.\experimental\symbolizer\Symbolizer.h	/^class FDSymbolizePrinter : public SymbolizePrinter {$/;"	c	namespace:folly::symbolizer	inherits:SymbolizePrinter
folly::symbolizer::FDSymbolizePrinter::FDSymbolizePrinter	.\experimental\symbolizer\Symbolizer.cpp	/^FDSymbolizePrinter::FDSymbolizePrinter(int fd, int options, size_t bufferSize)$/;"	f	class:folly::symbolizer::FDSymbolizePrinter	signature:(int fd, int options, size_t bufferSize)
folly::symbolizer::FDSymbolizePrinter::FDSymbolizePrinter	.\experimental\symbolizer\Symbolizer.h	/^  explicit FDSymbolizePrinter(int fd, int options=0,$/;"	p	class:folly::symbolizer::FDSymbolizePrinter	access:public	signature:(int fd, int options=0, size_t bufferSize=0)
folly::symbolizer::FDSymbolizePrinter::buffer_	.\experimental\symbolizer\Symbolizer.h	/^  std::unique_ptr<IOBuf> buffer_;$/;"	m	class:folly::symbolizer::FDSymbolizePrinter	access:private
folly::symbolizer::FDSymbolizePrinter::doPrint	.\experimental\symbolizer\Symbolizer.cpp	/^void FDSymbolizePrinter::doPrint(StringPiece sp) {$/;"	f	class:folly::symbolizer::FDSymbolizePrinter	signature:(StringPiece sp)
folly::symbolizer::FDSymbolizePrinter::fd_	.\experimental\symbolizer\Symbolizer.h	/^  int fd_;$/;"	m	class:folly::symbolizer::FDSymbolizePrinter	access:private
folly::symbolizer::FDSymbolizePrinter::flush	.\experimental\symbolizer\Symbolizer.cpp	/^void FDSymbolizePrinter::flush() {$/;"	f	class:folly::symbolizer::FDSymbolizePrinter	signature:()
folly::symbolizer::FDSymbolizePrinter::flush	.\experimental\symbolizer\Symbolizer.h	/^  void flush();$/;"	p	class:folly::symbolizer::FDSymbolizePrinter	access:public	signature:()
folly::symbolizer::FDSymbolizePrinter::override	.\experimental\symbolizer\Symbolizer.h	/^  void doPrint(StringPiece sp) override;$/;"	m	class:folly::symbolizer::FDSymbolizePrinter	access:private
folly::symbolizer::FDSymbolizePrinter::~FDSymbolizePrinter	.\experimental\symbolizer\Symbolizer.cpp	/^FDSymbolizePrinter::~FDSymbolizePrinter() {$/;"	f	class:folly::symbolizer::FDSymbolizePrinter	signature:()
folly::symbolizer::FDSymbolizePrinter::~FDSymbolizePrinter	.\experimental\symbolizer\Symbolizer.h	/^  ~FDSymbolizePrinter();$/;"	p	class:folly::symbolizer::FDSymbolizePrinter	access:public	signature:()
folly::symbolizer::FILESymbolizePrinter	.\experimental\symbolizer\Symbolizer.h	/^class FILESymbolizePrinter : public SymbolizePrinter {$/;"	c	namespace:folly::symbolizer	inherits:SymbolizePrinter
folly::symbolizer::FILESymbolizePrinter::FILESymbolizePrinter	.\experimental\symbolizer\Symbolizer.cpp	/^FILESymbolizePrinter::FILESymbolizePrinter(FILE* file, int options)$/;"	f	class:folly::symbolizer::FILESymbolizePrinter	signature:(FILE* file, int options)
folly::symbolizer::FILESymbolizePrinter::FILESymbolizePrinter	.\experimental\symbolizer\Symbolizer.h	/^  explicit FILESymbolizePrinter(FILE* file, int options=0);$/;"	p	class:folly::symbolizer::FILESymbolizePrinter	access:public	signature:(FILE* file, int options=0)
folly::symbolizer::FILESymbolizePrinter::doPrint	.\experimental\symbolizer\Symbolizer.cpp	/^void FILESymbolizePrinter::doPrint(StringPiece sp) {$/;"	f	class:folly::symbolizer::FILESymbolizePrinter	signature:(StringPiece sp)
folly::symbolizer::FILESymbolizePrinter::file_	.\experimental\symbolizer\Symbolizer.h	/^  FILE* file_;$/;"	m	class:folly::symbolizer::FILESymbolizePrinter	access:private
folly::symbolizer::FILESymbolizePrinter::override	.\experimental\symbolizer\Symbolizer.h	/^  void doPrint(StringPiece sp) override;$/;"	m	class:folly::symbolizer::FILESymbolizePrinter	access:private
folly::symbolizer::FrameArray	.\experimental\symbolizer\Symbolizer.h	/^struct FrameArray {$/;"	s	namespace:folly::symbolizer
folly::symbolizer::FrameArray::FrameArray	.\experimental\symbolizer\Symbolizer.h	/^  FrameArray() : frameCount(0) { }$/;"	f	struct:folly::symbolizer::FrameArray	access:public	signature:()
folly::symbolizer::FrameArray::addresses	.\experimental\symbolizer\Symbolizer.h	/^  uintptr_t addresses[N];$/;"	m	struct:folly::symbolizer::FrameArray	access:public
folly::symbolizer::FrameArray::frameCount	.\experimental\symbolizer\Symbolizer.h	/^  size_t frameCount;$/;"	m	struct:folly::symbolizer::FrameArray	access:public
folly::symbolizer::FrameArray::frames	.\experimental\symbolizer\Symbolizer.h	/^  SymbolizedFrame frames[N];$/;"	m	struct:folly::symbolizer::FrameArray	access:public
folly::symbolizer::LineReader	.\experimental\symbolizer\LineReader.h	/^class LineReader : private boost::noncopyable {$/;"	c	namespace:folly::symbolizer	inherits:boost::noncopyable
folly::symbolizer::LineReader::LineReader	.\experimental\symbolizer\LineReader.cpp	/^LineReader::LineReader(int fd, char* buf, size_t bufSize)$/;"	f	class:folly::symbolizer::LineReader	signature:(int fd, char* buf, size_t bufSize)
folly::symbolizer::LineReader::LineReader	.\experimental\symbolizer\LineReader.h	/^  LineReader(int fd, char* buf, size_t bufSize);$/;"	p	class:folly::symbolizer::LineReader	access:public	signature:(int fd, char* buf, size_t bufSize)
folly::symbolizer::LineReader::State	.\experimental\symbolizer\LineReader.h	/^  enum State {$/;"	g	class:folly::symbolizer::LineReader	access:public
folly::symbolizer::LineReader::bol_	.\experimental\symbolizer\LineReader.h	/^  char* bol_;$/;"	m	class:folly::symbolizer::LineReader	access:private
folly::symbolizer::LineReader::bufEnd_	.\experimental\symbolizer\LineReader.h	/^  char* const bufEnd_;$/;"	m	class:folly::symbolizer::LineReader	access:private
folly::symbolizer::LineReader::buf_	.\experimental\symbolizer\LineReader.h	/^  char* const buf_;$/;"	m	class:folly::symbolizer::LineReader	access:private
folly::symbolizer::LineReader::end_	.\experimental\symbolizer\LineReader.h	/^  char* end_;$/;"	m	class:folly::symbolizer::LineReader	access:private
folly::symbolizer::LineReader::eol_	.\experimental\symbolizer\LineReader.h	/^  char* eol_;$/;"	m	class:folly::symbolizer::LineReader	access:private
folly::symbolizer::LineReader::fd_	.\experimental\symbolizer\LineReader.h	/^  int const fd_;$/;"	m	class:folly::symbolizer::LineReader	access:private
folly::symbolizer::LineReader::kEof	.\experimental\symbolizer\LineReader.h	/^    kEof,$/;"	e	enum:folly::symbolizer::LineReader::State
folly::symbolizer::LineReader::kError	.\experimental\symbolizer\LineReader.h	/^    kError$/;"	e	enum:folly::symbolizer::LineReader::State
folly::symbolizer::LineReader::kReading	.\experimental\symbolizer\LineReader.h	/^    kReading,$/;"	e	enum:folly::symbolizer::LineReader::State
folly::symbolizer::LineReader::readLine	.\experimental\symbolizer\LineReader.cpp	/^LineReader::State LineReader::readLine(StringPiece& line) {$/;"	f	class:folly::symbolizer::LineReader	signature:(StringPiece& line)
folly::symbolizer::LineReader::readLine	.\experimental\symbolizer\LineReader.h	/^  State readLine(StringPiece& line);$/;"	p	class:folly::symbolizer::LineReader	access:public	signature:(StringPiece& line)
folly::symbolizer::LineReader::state_	.\experimental\symbolizer\LineReader.h	/^  State state_;$/;"	m	class:folly::symbolizer::LineReader	access:private
folly::symbolizer::OStreamSymbolizePrinter	.\experimental\symbolizer\Symbolizer.h	/^class OStreamSymbolizePrinter : public SymbolizePrinter {$/;"	c	namespace:folly::symbolizer	inherits:SymbolizePrinter
folly::symbolizer::OStreamSymbolizePrinter::OStreamSymbolizePrinter	.\experimental\symbolizer\Symbolizer.cpp	/^OStreamSymbolizePrinter::OStreamSymbolizePrinter(std::ostream& out, int options)$/;"	f	class:folly::symbolizer::OStreamSymbolizePrinter	signature:(std::ostream& out, int options)
folly::symbolizer::OStreamSymbolizePrinter::OStreamSymbolizePrinter	.\experimental\symbolizer\Symbolizer.h	/^  explicit OStreamSymbolizePrinter(std::ostream& out, int options=0);$/;"	p	class:folly::symbolizer::OStreamSymbolizePrinter	access:public	signature:(std::ostream& out, int options=0)
folly::symbolizer::OStreamSymbolizePrinter::doPrint	.\experimental\symbolizer\Symbolizer.cpp	/^void OStreamSymbolizePrinter::doPrint(StringPiece sp) {$/;"	f	class:folly::symbolizer::OStreamSymbolizePrinter	signature:(StringPiece sp)
folly::symbolizer::OStreamSymbolizePrinter::out_	.\experimental\symbolizer\Symbolizer.h	/^  std::ostream& out_;$/;"	m	class:folly::symbolizer::OStreamSymbolizePrinter	access:private
folly::symbolizer::OStreamSymbolizePrinter::override	.\experimental\symbolizer\Symbolizer.h	/^  void doPrint(StringPiece sp) override;$/;"	m	class:folly::symbolizer::OStreamSymbolizePrinter	access:private
folly::symbolizer::SignalCallback	.\experimental\symbolizer\SignalHandler.h	/^typedef void (*SignalCallback)(void);$/;"	t	namespace:folly::symbolizer
folly::symbolizer::SignalSafeElfCache	.\experimental\symbolizer\ElfCache.h	/^class SignalSafeElfCache : public ElfCacheBase {$/;"	c	namespace:folly::symbolizer	inherits:ElfCacheBase
folly::symbolizer::SignalSafeElfCache::Path	.\experimental\symbolizer\ElfCache.h	/^  class Path : private boost::totally_ordered<Path> {$/;"	c	class:folly::symbolizer::SignalSafeElfCache	inherits:boost::totally_ordered	access:private
folly::symbolizer::SignalSafeElfCache::Path::Path	.\experimental\symbolizer\ElfCache.h	/^    explicit Path(StringPiece s) {$/;"	f	class:folly::symbolizer::SignalSafeElfCache::Path	access:public	signature:(StringPiece s)
folly::symbolizer::SignalSafeElfCache::Path::data	.\experimental\symbolizer\ElfCache.h	/^    const char* data() const {$/;"	f	class:folly::symbolizer::SignalSafeElfCache::Path	access:public	signature:() const
folly::symbolizer::SignalSafeElfCache::Path::data_	.\experimental\symbolizer\ElfCache.h	/^    char data_[kMaxSize + 1];$/;"	m	class:folly::symbolizer::SignalSafeElfCache::Path	access:private
folly::symbolizer::SignalSafeElfCache::Path::kMaxSize	.\experimental\symbolizer\ElfCache.h	/^    static constexpr size_t kMaxSize = PATH_MAX - 1;$/;"	m	class:folly::symbolizer::SignalSafeElfCache::Path	access:public
folly::symbolizer::SignalSafeElfCache::Path::operator <	.\experimental\symbolizer\ElfCache.h	/^    bool operator<(const Path& other) const {$/;"	f	class:folly::symbolizer::SignalSafeElfCache::Path	access:public	signature:(const Path& other) const
folly::symbolizer::SignalSafeElfCache::Path::operator ==	.\experimental\symbolizer\ElfCache.h	/^    bool operator==(const Path& other) const {$/;"	f	class:folly::symbolizer::SignalSafeElfCache::Path	access:public	signature:(const Path& other) const
folly::symbolizer::SignalSafeElfCache::SignalSafeElfCache	.\experimental\symbolizer\ElfCache.cpp	/^SignalSafeElfCache::SignalSafeElfCache(size_t capacity) {$/;"	f	class:folly::symbolizer::SignalSafeElfCache	signature:(size_t capacity)
folly::symbolizer::SignalSafeElfCache::SignalSafeElfCache	.\experimental\symbolizer\ElfCache.h	/^  explicit SignalSafeElfCache(size_t capacity);$/;"	p	class:folly::symbolizer::SignalSafeElfCache	access:public	signature:(size_t capacity)
folly::symbolizer::SignalSafeElfCache::getFile	.\experimental\symbolizer\ElfCache.cpp	/^std::shared_ptr<ElfFile> SignalSafeElfCache::getFile(StringPiece p) {$/;"	f	class:folly::symbolizer::SignalSafeElfCache	signature:(StringPiece p)
folly::symbolizer::SignalSafeElfCache::map_	.\experimental\symbolizer\ElfCache.h	/^  boost::container::flat_map<Path, int> map_;$/;"	m	class:folly::symbolizer::SignalSafeElfCache	access:private
folly::symbolizer::SignalSafeElfCache::override	.\experimental\symbolizer\ElfCache.h	/^  std::shared_ptr<ElfFile> getFile(StringPiece path) override;$/;"	m	class:folly::symbolizer::SignalSafeElfCache	access:public
folly::symbolizer::SignalSafeElfCache::slots_	.\experimental\symbolizer\ElfCache.h	/^  std::vector<std::shared_ptr<ElfFile>> slots_;$/;"	m	class:folly::symbolizer::SignalSafeElfCache	access:private
folly::symbolizer::StringSymbolizePrinter	.\experimental\symbolizer\Symbolizer.h	/^class StringSymbolizePrinter : public SymbolizePrinter {$/;"	c	namespace:folly::symbolizer	inherits:SymbolizePrinter
folly::symbolizer::StringSymbolizePrinter::StringSymbolizePrinter	.\experimental\symbolizer\Symbolizer.h	/^  explicit StringSymbolizePrinter(int options=0) : SymbolizePrinter(options) { }$/;"	f	class:folly::symbolizer::StringSymbolizePrinter	access:public	signature:(int options=0)
folly::symbolizer::StringSymbolizePrinter::buf_	.\experimental\symbolizer\Symbolizer.h	/^  fbstring buf_;$/;"	m	class:folly::symbolizer::StringSymbolizePrinter	access:private
folly::symbolizer::StringSymbolizePrinter::doPrint	.\experimental\symbolizer\Symbolizer.cpp	/^void StringSymbolizePrinter::doPrint(StringPiece sp) {$/;"	f	class:folly::symbolizer::StringSymbolizePrinter	signature:(StringPiece sp)
folly::symbolizer::StringSymbolizePrinter::fbstr	.\experimental\symbolizer\Symbolizer.h	/^  const fbstring& fbstr() const { return buf_; }$/;"	f	class:folly::symbolizer::StringSymbolizePrinter	access:public	signature:() const
folly::symbolizer::StringSymbolizePrinter::moveFbString	.\experimental\symbolizer\Symbolizer.h	/^  fbstring moveFbString() { return std::move(buf_); }$/;"	f	class:folly::symbolizer::StringSymbolizePrinter	access:public	signature:()
folly::symbolizer::StringSymbolizePrinter::override	.\experimental\symbolizer\Symbolizer.h	/^  void doPrint(StringPiece sp) override;$/;"	m	class:folly::symbolizer::StringSymbolizePrinter	access:private
folly::symbolizer::StringSymbolizePrinter::str	.\experimental\symbolizer\Symbolizer.h	/^  std::string str() const { return buf_.toStdString(); }$/;"	f	class:folly::symbolizer::StringSymbolizePrinter	access:public	signature:() const
folly::symbolizer::SymbolizePrinter	.\experimental\symbolizer\Symbolizer.h	/^class SymbolizePrinter {$/;"	c	namespace:folly::symbolizer
folly::symbolizer::SymbolizePrinter::BLUE	.\experimental\symbolizer\Symbolizer.h	/^  enum Color { DEFAULT, RED, GREEN, YELLOW, BLUE, CYAN, WHITE, PURPLE };$/;"	e	enum:folly::symbolizer::SymbolizePrinter::Color
folly::symbolizer::SymbolizePrinter::COLOR	.\experimental\symbolizer\Symbolizer.h	/^    COLOR = 1 << 2,$/;"	e	enum:folly::symbolizer::SymbolizePrinter::Options
folly::symbolizer::SymbolizePrinter::COLOR_IF_TTY	.\experimental\symbolizer\Symbolizer.h	/^    COLOR_IF_TTY = 1 << 3,$/;"	e	enum:folly::symbolizer::SymbolizePrinter::Options
folly::symbolizer::SymbolizePrinter::CYAN	.\experimental\symbolizer\Symbolizer.h	/^  enum Color { DEFAULT, RED, GREEN, YELLOW, BLUE, CYAN, WHITE, PURPLE };$/;"	e	enum:folly::symbolizer::SymbolizePrinter::Color
folly::symbolizer::SymbolizePrinter::Color	.\experimental\symbolizer\Symbolizer.h	/^  enum Color { DEFAULT, RED, GREEN, YELLOW, BLUE, CYAN, WHITE, PURPLE };$/;"	g	class:folly::symbolizer::SymbolizePrinter	access:public
folly::symbolizer::SymbolizePrinter::DEFAULT	.\experimental\symbolizer\Symbolizer.h	/^  enum Color { DEFAULT, RED, GREEN, YELLOW, BLUE, CYAN, WHITE, PURPLE };$/;"	e	enum:folly::symbolizer::SymbolizePrinter::Color
folly::symbolizer::SymbolizePrinter::GREEN	.\experimental\symbolizer\Symbolizer.h	/^  enum Color { DEFAULT, RED, GREEN, YELLOW, BLUE, CYAN, WHITE, PURPLE };$/;"	e	enum:folly::symbolizer::SymbolizePrinter::Color
folly::symbolizer::SymbolizePrinter::NO_FILE_AND_LINE	.\experimental\symbolizer\Symbolizer.h	/^    NO_FILE_AND_LINE = 1 << 0,$/;"	e	enum:folly::symbolizer::SymbolizePrinter::Options
folly::symbolizer::SymbolizePrinter::Options	.\experimental\symbolizer\Symbolizer.h	/^  enum Options {$/;"	g	class:folly::symbolizer::SymbolizePrinter	access:public
folly::symbolizer::SymbolizePrinter::PURPLE	.\experimental\symbolizer\Symbolizer.h	/^  enum Color { DEFAULT, RED, GREEN, YELLOW, BLUE, CYAN, WHITE, PURPLE };$/;"	e	enum:folly::symbolizer::SymbolizePrinter::Color
folly::symbolizer::SymbolizePrinter::RED	.\experimental\symbolizer\Symbolizer.h	/^  enum Color { DEFAULT, RED, GREEN, YELLOW, BLUE, CYAN, WHITE, PURPLE };$/;"	e	enum:folly::symbolizer::SymbolizePrinter::Color
folly::symbolizer::SymbolizePrinter::SymbolizePrinter	.\experimental\symbolizer\Symbolizer.h	/^  explicit SymbolizePrinter(int options, bool isTty = false)$/;"	f	class:folly::symbolizer::SymbolizePrinter	access:protected	signature:(int options, bool isTty = false)
folly::symbolizer::SymbolizePrinter::TERSE	.\experimental\symbolizer\Symbolizer.h	/^    TERSE = 1 << 1,$/;"	e	enum:folly::symbolizer::SymbolizePrinter::Options
folly::symbolizer::SymbolizePrinter::WHITE	.\experimental\symbolizer\Symbolizer.h	/^  enum Color { DEFAULT, RED, GREEN, YELLOW, BLUE, CYAN, WHITE, PURPLE };$/;"	e	enum:folly::symbolizer::SymbolizePrinter::Color
folly::symbolizer::SymbolizePrinter::YELLOW	.\experimental\symbolizer\Symbolizer.h	/^  enum Color { DEFAULT, RED, GREEN, YELLOW, BLUE, CYAN, WHITE, PURPLE };$/;"	e	enum:folly::symbolizer::SymbolizePrinter::Color
folly::symbolizer::SymbolizePrinter::color	.\experimental\symbolizer\Symbolizer.cpp	/^void SymbolizePrinter::color(SymbolizePrinter::Color color) {$/;"	f	class:folly::symbolizer::SymbolizePrinter	signature:(SymbolizePrinter::Color color)
folly::symbolizer::SymbolizePrinter::color	.\experimental\symbolizer\Symbolizer.h	/^  void color(Color c);$/;"	p	class:folly::symbolizer::SymbolizePrinter	access:public	signature:(Color c)
folly::symbolizer::SymbolizePrinter::doPrint	.\experimental\symbolizer\Symbolizer.h	/^  virtual void doPrint(StringPiece sp) = 0;$/;"	p	class:folly::symbolizer::SymbolizePrinter	access:private	signature:(StringPiece sp)
folly::symbolizer::SymbolizePrinter::isTty_	.\experimental\symbolizer\Symbolizer.h	/^  const bool isTty_;$/;"	m	class:folly::symbolizer::SymbolizePrinter	access:protected
folly::symbolizer::SymbolizePrinter::options_	.\experimental\symbolizer\Symbolizer.h	/^  const int options_;$/;"	m	class:folly::symbolizer::SymbolizePrinter	access:protected
folly::symbolizer::SymbolizePrinter::print	.\experimental\symbolizer\Symbolizer.cpp	/^void SymbolizePrinter::print(uintptr_t address, const SymbolizedFrame& frame) {$/;"	f	class:folly::symbolizer::SymbolizePrinter	signature:(uintptr_t address, const SymbolizedFrame& frame)
folly::symbolizer::SymbolizePrinter::print	.\experimental\symbolizer\Symbolizer.h	/^  void print(StringPiece sp) { doPrint(sp); }$/;"	f	class:folly::symbolizer::SymbolizePrinter	access:public	signature:(StringPiece sp)
folly::symbolizer::SymbolizePrinter::print	.\experimental\symbolizer\Symbolizer.h	/^  void print(uintptr_t address, const SymbolizedFrame& frame);$/;"	p	class:folly::symbolizer::SymbolizePrinter	access:public	signature:(uintptr_t address, const SymbolizedFrame& frame)
folly::symbolizer::SymbolizePrinter::printTerse	.\experimental\symbolizer\Symbolizer.cpp	/^void SymbolizePrinter::printTerse(uintptr_t address,$/;"	f	class:folly::symbolizer::SymbolizePrinter	signature:(uintptr_t address, const SymbolizedFrame& frame)
folly::symbolizer::SymbolizePrinter::printTerse	.\experimental\symbolizer\Symbolizer.h	/^  void printTerse(uintptr_t address, const SymbolizedFrame& frame);$/;"	p	class:folly::symbolizer::SymbolizePrinter	access:private	signature:(uintptr_t address, const SymbolizedFrame& frame)
folly::symbolizer::SymbolizePrinter::println	.\experimental\symbolizer\Symbolizer.cpp	/^void SymbolizePrinter::println(const uintptr_t* addresses,$/;"	f	class:folly::symbolizer::SymbolizePrinter	signature:(const uintptr_t* addresses, const SymbolizedFrame* frames, size_t frameCount)
folly::symbolizer::SymbolizePrinter::println	.\experimental\symbolizer\Symbolizer.cpp	/^void SymbolizePrinter::println(uintptr_t address,$/;"	f	class:folly::symbolizer::SymbolizePrinter	signature:(uintptr_t address, const SymbolizedFrame& frame)
folly::symbolizer::SymbolizePrinter::println	.\experimental\symbolizer\Symbolizer.h	/^  void println(const FrameArray<N>& fa, size_t skip=0) {$/;"	f	class:folly::symbolizer::SymbolizePrinter	access:public	signature:(const FrameArray<N>& fa, size_t skip=0)
folly::symbolizer::SymbolizePrinter::println	.\experimental\symbolizer\Symbolizer.h	/^  void println(const uintptr_t* addresses,$/;"	p	class:folly::symbolizer::SymbolizePrinter	access:public	signature:(const uintptr_t* addresses, const SymbolizedFrame* frames, size_t frameCount)
folly::symbolizer::SymbolizePrinter::println	.\experimental\symbolizer\Symbolizer.h	/^  void println(uintptr_t address, const SymbolizedFrame& frame);$/;"	p	class:folly::symbolizer::SymbolizePrinter	access:public	signature:(uintptr_t address, const SymbolizedFrame& frame)
folly::symbolizer::SymbolizePrinter::~SymbolizePrinter	.\experimental\symbolizer\Symbolizer.h	/^  virtual ~SymbolizePrinter() { }$/;"	f	class:folly::symbolizer::SymbolizePrinter	access:public	signature:()
folly::symbolizer::SymbolizedFrame	.\experimental\symbolizer\Symbolizer.h	/^struct SymbolizedFrame {$/;"	s	namespace:folly::symbolizer
folly::symbolizer::SymbolizedFrame::SymbolizedFrame	.\experimental\symbolizer\Symbolizer.h	/^  SymbolizedFrame() : found(false), name(nullptr) { }$/;"	f	struct:folly::symbolizer::SymbolizedFrame	access:public	signature:()
folly::symbolizer::SymbolizedFrame::clear	.\experimental\symbolizer\Symbolizer.h	/^  void clear() { *this = SymbolizedFrame(); }$/;"	f	struct:folly::symbolizer::SymbolizedFrame	access:public	signature:()
folly::symbolizer::SymbolizedFrame::demangledName	.\experimental\symbolizer\Symbolizer.h	/^  fbstring demangledName() const {$/;"	f	struct:folly::symbolizer::SymbolizedFrame	access:public	signature:() const
folly::symbolizer::SymbolizedFrame::file_	.\experimental\symbolizer\Symbolizer.h	/^  std::shared_ptr<ElfFile> file_;$/;"	m	struct:folly::symbolizer::SymbolizedFrame	access:private
folly::symbolizer::SymbolizedFrame::found	.\experimental\symbolizer\Symbolizer.h	/^  bool found;$/;"	m	struct:folly::symbolizer::SymbolizedFrame	access:public
folly::symbolizer::SymbolizedFrame::isSignalFrame	.\experimental\symbolizer\Symbolizer.h	/^  bool isSignalFrame;$/;"	m	struct:folly::symbolizer::SymbolizedFrame	access:public
folly::symbolizer::SymbolizedFrame::location	.\experimental\symbolizer\Symbolizer.h	/^  Dwarf::LocationInfo location;$/;"	m	struct:folly::symbolizer::SymbolizedFrame	access:public
folly::symbolizer::SymbolizedFrame::name	.\experimental\symbolizer\Symbolizer.h	/^  const char* name;$/;"	m	struct:folly::symbolizer::SymbolizedFrame	access:public
folly::symbolizer::SymbolizedFrame::set	.\experimental\symbolizer\Symbolizer.cpp	/^void SymbolizedFrame::set(const std::shared_ptr<ElfFile>& file,$/;"	f	class:folly::symbolizer::SymbolizedFrame	signature:(const std::shared_ptr<ElfFile>& file, uintptr_t address)
folly::symbolizer::SymbolizedFrame::set	.\experimental\symbolizer\Symbolizer.h	/^  void set(const std::shared_ptr<ElfFile>& file, uintptr_t address);$/;"	p	struct:folly::symbolizer::SymbolizedFrame	access:public	signature:(const std::shared_ptr<ElfFile>& file, uintptr_t address)
folly::symbolizer::Symbolizer	.\experimental\symbolizer\Symbolizer.h	/^class Symbolizer {$/;"	c	namespace:folly::symbolizer
folly::symbolizer::Symbolizer	.\experimental\symbolizer\Symbolizer.h	/^class Symbolizer;$/;"	x
folly::symbolizer::Symbolizer::Symbolizer	.\experimental\symbolizer\Symbolizer.cpp	/^Symbolizer::Symbolizer(ElfCacheBase* cache)$/;"	f	class:folly::symbolizer::Symbolizer	signature:(ElfCacheBase* cache)
folly::symbolizer::Symbolizer::Symbolizer	.\experimental\symbolizer\Symbolizer.h	/^  explicit Symbolizer(ElfCacheBase* cache = nullptr);$/;"	p	class:folly::symbolizer::Symbolizer	access:public	signature:(ElfCacheBase* cache = nullptr)
folly::symbolizer::Symbolizer::cache_	.\experimental\symbolizer\Symbolizer.h	/^  ElfCacheBase* cache_;$/;"	m	class:folly::symbolizer::Symbolizer	access:private
folly::symbolizer::Symbolizer::symbolize	.\experimental\symbolizer\Symbolizer.cpp	/^void Symbolizer::symbolize(const uintptr_t* addresses,$/;"	f	class:folly::symbolizer::Symbolizer	signature:(const uintptr_t* addresses, SymbolizedFrame* frames, size_t addressCount)
folly::symbolizer::Symbolizer::symbolize	.\experimental\symbolizer\Symbolizer.h	/^  bool symbolize(uintptr_t address, SymbolizedFrame& frame) {$/;"	f	class:folly::symbolizer::Symbolizer	access:public	signature:(uintptr_t address, SymbolizedFrame& frame)
folly::symbolizer::Symbolizer::symbolize	.\experimental\symbolizer\Symbolizer.h	/^  void symbolize(FrameArray<N>& fa) {$/;"	f	class:folly::symbolizer::Symbolizer	access:public	signature:(FrameArray<N>& fa)
folly::symbolizer::Symbolizer::symbolize	.\experimental\symbolizer\Symbolizer.h	/^  void symbolize(const uintptr_t* addresses,$/;"	p	class:folly::symbolizer::Symbolizer	access:public	signature:(const uintptr_t* addresses, SymbolizedFrame* frames, size_t frameCount)
folly::symbolizer::__anon34::read	.\experimental\symbolizer\Dwarf.cpp	/^read(folly::StringPiece& sp) {$/;"	f	namespace:folly::symbolizer::__anon34	signature:(folly::StringPiece& sp)
folly::symbolizer::__anon34::readBytes	.\experimental\symbolizer\Dwarf.cpp	/^folly::StringPiece readBytes(folly::StringPiece& sp, uint64_t len) {$/;"	f	namespace:folly::symbolizer::__anon34	signature:(folly::StringPiece& sp, uint64_t len)
folly::symbolizer::__anon34::readNullTerminated	.\experimental\symbolizer\Dwarf.cpp	/^folly::StringPiece readNullTerminated(folly::StringPiece& sp) {$/;"	f	namespace:folly::symbolizer::__anon34	signature:(folly::StringPiece& sp)
folly::symbolizer::__anon34::readOffset	.\experimental\symbolizer\Dwarf.cpp	/^uint64_t readOffset(folly::StringPiece& sp, bool is64Bit) {$/;"	f	namespace:folly::symbolizer::__anon34	signature:(folly::StringPiece& sp, bool is64Bit)
folly::symbolizer::__anon34::readSLEB	.\experimental\symbolizer\Dwarf.cpp	/^int64_t readSLEB(folly::StringPiece& sp) {$/;"	f	namespace:folly::symbolizer::__anon34	signature:(folly::StringPiece& sp)
folly::symbolizer::__anon34::readULEB	.\experimental\symbolizer\Dwarf.cpp	/^uint64_t readULEB(folly::StringPiece& sp) {$/;"	f	namespace:folly::symbolizer::__anon34	signature:(folly::StringPiece& sp)
folly::symbolizer::__anon34::readULEB	.\experimental\symbolizer\Dwarf.cpp	/^uint64_t readULEB(folly::StringPiece& sp, uint8_t& shift, uint8_t& val) {$/;"	f	namespace:folly::symbolizer::__anon34	signature:(folly::StringPiece& sp, uint8_t& shift, uint8_t& val)
folly::symbolizer::__anon34::simplifyPath	.\experimental\symbolizer\Dwarf.cpp	/^void simplifyPath(folly::StringPiece& sp) {$/;"	f	namespace:folly::symbolizer::__anon34	signature:(folly::StringPiece& sp)
folly::symbolizer::__anon34::skipPadding	.\experimental\symbolizer\Dwarf.cpp	/^void skipPadding(folly::StringPiece& sp, const char* start, size_t alignment) {$/;"	f	namespace:folly::symbolizer::__anon34	signature:(folly::StringPiece& sp, const char* start, size_t alignment)
folly::symbolizer::__anon36::FatalSignalCallbackRegistry	.\experimental\symbolizer\SignalHandler.cpp	/^class FatalSignalCallbackRegistry {$/;"	c	namespace:folly::symbolizer::__anon36	file:
folly::symbolizer::__anon36::FatalSignalCallbackRegistry::FatalSignalCallbackRegistry	.\experimental\symbolizer\SignalHandler.cpp	/^  FatalSignalCallbackRegistry();$/;"	p	class:folly::symbolizer::__anon36::FatalSignalCallbackRegistry	file:	access:public	signature:()
folly::symbolizer::__anon36::FatalSignalCallbackRegistry::FatalSignalCallbackRegistry	.\experimental\symbolizer\SignalHandler.cpp	/^FatalSignalCallbackRegistry::FatalSignalCallbackRegistry()$/;"	f	class:folly::symbolizer::__anon36::FatalSignalCallbackRegistry	signature:()
folly::symbolizer::__anon36::FatalSignalCallbackRegistry::add	.\experimental\symbolizer\SignalHandler.cpp	/^  void add(SignalCallback func);$/;"	p	class:folly::symbolizer::__anon36::FatalSignalCallbackRegistry	file:	access:public	signature:(SignalCallback func)
folly::symbolizer::__anon36::FatalSignalCallbackRegistry::add	.\experimental\symbolizer\SignalHandler.cpp	/^void FatalSignalCallbackRegistry::add(SignalCallback func) {$/;"	f	class:folly::symbolizer::__anon36::FatalSignalCallbackRegistry	signature:(SignalCallback func)
folly::symbolizer::__anon36::FatalSignalCallbackRegistry::handlers_	.\experimental\symbolizer\SignalHandler.cpp	/^  std::vector<SignalCallback> handlers_;$/;"	m	class:folly::symbolizer::__anon36::FatalSignalCallbackRegistry	file:	access:private
folly::symbolizer::__anon36::FatalSignalCallbackRegistry::installed_	.\experimental\symbolizer\SignalHandler.cpp	/^  std::atomic<bool> installed_;$/;"	m	class:folly::symbolizer::__anon36::FatalSignalCallbackRegistry	file:	access:private
folly::symbolizer::__anon36::FatalSignalCallbackRegistry::markInstalled	.\experimental\symbolizer\SignalHandler.cpp	/^  void markInstalled();$/;"	p	class:folly::symbolizer::__anon36::FatalSignalCallbackRegistry	file:	access:public	signature:()
folly::symbolizer::__anon36::FatalSignalCallbackRegistry::markInstalled	.\experimental\symbolizer\SignalHandler.cpp	/^void FatalSignalCallbackRegistry::markInstalled() {$/;"	f	class:folly::symbolizer::__anon36::FatalSignalCallbackRegistry	signature:()
folly::symbolizer::__anon36::FatalSignalCallbackRegistry::mutex_	.\experimental\symbolizer\SignalHandler.cpp	/^  std::mutex mutex_;$/;"	m	class:folly::symbolizer::__anon36::FatalSignalCallbackRegistry	file:	access:private
folly::symbolizer::__anon36::FatalSignalCallbackRegistry::run	.\experimental\symbolizer\SignalHandler.cpp	/^  void run();$/;"	p	class:folly::symbolizer::__anon36::FatalSignalCallbackRegistry	file:	access:public	signature:()
folly::symbolizer::__anon36::FatalSignalCallbackRegistry::run	.\experimental\symbolizer\SignalHandler.cpp	/^void FatalSignalCallbackRegistry::run() {$/;"	f	class:folly::symbolizer::__anon36::FatalSignalCallbackRegistry	signature:()
folly::symbolizer::__anon36::__anon37::name	.\experimental\symbolizer\SignalHandler.cpp	/^  const char* name;$/;"	m	struct:folly::symbolizer::__anon36::__anon37	file:	access:public
folly::symbolizer::__anon36::__anon37::number	.\experimental\symbolizer\SignalHandler.cpp	/^  int number;$/;"	m	struct:folly::symbolizer::__anon36::__anon37	file:	access:public
folly::symbolizer::__anon36::__anon37::oldAction	.\experimental\symbolizer\SignalHandler.cpp	/^  struct sigaction oldAction;$/;"	m	struct:folly::symbolizer::__anon36::__anon37	typeref:struct:folly::symbolizer::__anon36::__anon37::sigaction	file:	access:public
folly::symbolizer::__anon36::callPreviousSignalHandler	.\experimental\symbolizer\SignalHandler.cpp	/^void callPreviousSignalHandler(int signum) {$/;"	f	namespace:folly::symbolizer::__anon36	signature:(int signum)
folly::symbolizer::__anon36::dumpSignalInfo	.\experimental\symbolizer\SignalHandler.cpp	/^void dumpSignalInfo(int signum, siginfo_t* siginfo) {$/;"	f	namespace:folly::symbolizer::__anon36	signature:(int signum, siginfo_t* siginfo)
folly::symbolizer::__anon36::dumpStackTrace	.\experimental\symbolizer\SignalHandler.cpp	/^FOLLY_NOINLINE void dumpStackTrace(bool symbolize);$/;"	p	namespace:folly::symbolizer::__anon36	file:	signature:(bool symbolize)
folly::symbolizer::__anon36::dumpStackTrace	.\experimental\symbolizer\SignalHandler.cpp	/^void dumpStackTrace(bool symbolize) {$/;"	f	namespace:folly::symbolizer::__anon36	signature:(bool symbolize)
folly::symbolizer::__anon36::dumpTimeInfo	.\experimental\symbolizer\SignalHandler.cpp	/^void dumpTimeInfo() {$/;"	f	namespace:folly::symbolizer::__anon36	signature:()
folly::symbolizer::__anon36::flush	.\experimental\symbolizer\SignalHandler.cpp	/^void flush() {$/;"	f	namespace:folly::symbolizer::__anon36	signature:()
folly::symbolizer::__anon36::gFatalSignalCallbackRegistry	.\experimental\symbolizer\SignalHandler.cpp	/^FatalSignalCallbackRegistry* gFatalSignalCallbackRegistry =$/;"	m	namespace:folly::symbolizer::__anon36	file:
folly::symbolizer::__anon36::gInRecursiveSignalHandler	.\experimental\symbolizer\SignalHandler.cpp	/^std::atomic<bool> gInRecursiveSignalHandler(false);$/;"	p	namespace:folly::symbolizer::__anon36	file:	signature:(false)
folly::symbolizer::__anon36::gPrinter	.\experimental\symbolizer\SignalHandler.cpp	/^auto gPrinter = new FDSymbolizePrinter(STDERR_FILENO,$/;"	m	namespace:folly::symbolizer::__anon36	file:
folly::symbolizer::__anon36::gSignalSafeElfCache	.\experimental\symbolizer\SignalHandler.cpp	/^auto gSignalSafeElfCache = new SignalSafeElfCache(kDefaultCapacity);$/;"	m	namespace:folly::symbolizer::__anon36	file:
folly::symbolizer::__anon36::gSignalThread	.\experimental\symbolizer\SignalHandler.cpp	/^std::atomic<pthread_t> gSignalThread(kInvalidThreadId);$/;"	p	namespace:folly::symbolizer::__anon36	file:	signature:(kInvalidThreadId)
folly::symbolizer::__anon36::innerSignalHandler	.\experimental\symbolizer\SignalHandler.cpp	/^void innerSignalHandler(int signum, siginfo_t* info, void* uctx) {$/;"	f	namespace:folly::symbolizer::__anon36	signature:(int signum, siginfo_t* info, void* uctx)
folly::symbolizer::__anon36::kDefaultCapacity	.\experimental\symbolizer\SignalHandler.cpp	/^constexpr size_t kDefaultCapacity = 500;$/;"	m	namespace:folly::symbolizer::__anon36	file:
folly::symbolizer::__anon36::kFatalSignals	.\experimental\symbolizer\SignalHandler.cpp	/^} kFatalSignals[] = {$/;"	m	namespace:folly::symbolizer::__anon36	typeref:struct:folly::symbolizer::__anon36::__anon37	file:
folly::symbolizer::__anon36::kHexChars	.\experimental\symbolizer\SignalHandler.cpp	/^const char kHexChars[] = "0123456789abcdef";$/;"	m	namespace:folly::symbolizer::__anon36	file:
folly::symbolizer::__anon36::kInvalidThreadId	.\experimental\symbolizer\SignalHandler.cpp	/^constexpr pthread_t kInvalidThreadId = 0;$/;"	m	namespace:folly::symbolizer::__anon36	file:
folly::symbolizer::__anon36::print	.\experimental\symbolizer\SignalHandler.cpp	/^void print(StringPiece sp) {$/;"	f	namespace:folly::symbolizer::__anon36	signature:(StringPiece sp)
folly::symbolizer::__anon36::printDec	.\experimental\symbolizer\SignalHandler.cpp	/^void printDec(uint64_t val) {$/;"	f	namespace:folly::symbolizer::__anon36	signature:(uint64_t val)
folly::symbolizer::__anon36::printHex	.\experimental\symbolizer\SignalHandler.cpp	/^void printHex(uint64_t val) {$/;"	f	namespace:folly::symbolizer::__anon36	signature:(uint64_t val)
folly::symbolizer::__anon36::signalHandler	.\experimental\symbolizer\SignalHandler.cpp	/^void signalHandler(int signum, siginfo_t* info, void* uctx) {$/;"	f	namespace:folly::symbolizer::__anon36	signature:(int signum, siginfo_t* info, void* uctx)
folly::symbolizer::__anon38::gAlreadyInstalled	.\experimental\symbolizer\SignalHandler.cpp	/^std::atomic<bool> gAlreadyInstalled;$/;"	m	namespace:folly::symbolizer::__anon38	file:
folly::symbolizer::__anon39::getFrameInfo	.\experimental\symbolizer\StackTrace.cpp	/^inline bool getFrameInfo(unw_cursor_t* cursor, uintptr_t& ip) {$/;"	f	namespace:folly::symbolizer::__anon39	signature:(unw_cursor_t* cursor, uintptr_t& ip)
folly::symbolizer::__anon40::defaultElfCache	.\experimental\symbolizer\Symbolizer.cpp	/^ElfCache* defaultElfCache() {$/;"	f	namespace:folly::symbolizer::__anon40	signature:()
folly::symbolizer::__anon40::parseProcMapsLine	.\experimental\symbolizer\Symbolizer.cpp	/^bool parseProcMapsLine(StringPiece line,$/;"	f	namespace:folly::symbolizer::__anon40	signature:(StringPiece line, uintptr_t& from, uintptr_t& to, StringPiece& fileName)
folly::symbolizer::__anon40::readHex	.\experimental\symbolizer\Symbolizer.cpp	/^uintptr_t readHex(StringPiece& sp) {$/;"	f	namespace:folly::symbolizer::__anon40	signature:(StringPiece& sp)
folly::symbolizer::__anon40::skipNS	.\experimental\symbolizer\Symbolizer.cpp	/^void skipNS(StringPiece& sp) {$/;"	f	namespace:folly::symbolizer::__anon40	signature:(StringPiece& sp)
folly::symbolizer::__anon40::skipWS	.\experimental\symbolizer\Symbolizer.cpp	/^void skipWS(StringPiece& sp) {$/;"	f	namespace:folly::symbolizer::__anon40	signature:(StringPiece& sp)
folly::symbolizer::__anon41::kAddressColor	.\experimental\symbolizer\Symbolizer.cpp	/^const SymbolizePrinter::Color kAddressColor = SymbolizePrinter::Color::BLUE;$/;"	m	namespace:folly::symbolizer::__anon41	file:
folly::symbolizer::__anon41::kFileColor	.\experimental\symbolizer\Symbolizer.cpp	/^const SymbolizePrinter::Color kFileColor = SymbolizePrinter::Color::DEFAULT;$/;"	m	namespace:folly::symbolizer::__anon41	file:
folly::symbolizer::__anon41::kFunctionColor	.\experimental\symbolizer\Symbolizer.cpp	/^const SymbolizePrinter::Color kFunctionColor = SymbolizePrinter::Color::PURPLE;$/;"	m	namespace:folly::symbolizer::__anon41	file:
folly::symbolizer::__anon41::kHexChars	.\experimental\symbolizer\Symbolizer.cpp	/^const char kHexChars[] = "0123456789abcdef";$/;"	m	namespace:folly::symbolizer::__anon41	file:
folly::symbolizer::__anon42::kColorMap	.\experimental\symbolizer\Symbolizer.cpp	/^const std::map<SymbolizePrinter::Color, std::string> kColorMap = {$/;"	m	namespace:folly::symbolizer::__anon42	file:
folly::symbolizer::__anon43::getFD	.\experimental\symbolizer\Symbolizer.cpp	/^int getFD(const std::ios& stream) {$/;"	f	namespace:folly::symbolizer::__anon43	signature:(const std::ios& stream)
folly::symbolizer::__anon43::isTty	.\experimental\symbolizer\Symbolizer.cpp	/^bool isTty(int options, int fd) {$/;"	f	namespace:folly::symbolizer::__anon43	signature:(int options, int fd)
folly::symbolizer::addFatalSignalCallback	.\experimental\symbolizer\SignalHandler.cpp	/^void addFatalSignalCallback(SignalCallback cb) {$/;"	f	namespace:folly::symbolizer	signature:(SignalCallback cb)
folly::symbolizer::addFatalSignalCallback	.\experimental\symbolizer\SignalHandler.h	/^void addFatalSignalCallback(SignalCallback callback);$/;"	p	namespace:folly::symbolizer	signature:(SignalCallback callback)
folly::symbolizer::baseAddress_	.\experimental\symbolizer\Elf.cpp	/^    baseAddress_(other.baseAddress_) {$/;"	f	namespace:folly::symbolizer	signature:(other.baseAddress_)
folly::symbolizer::detail	.\experimental\symbolizer\Symbolizer.h	/^namespace detail {$/;"	n	namespace:folly::symbolizer
folly::symbolizer::detail::fixFrameArray	.\experimental\symbolizer\Symbolizer.h	/^bool fixFrameArray(FrameArray<N>& fa, ssize_t n) {$/;"	f	namespace:folly::symbolizer::detail	signature:(FrameArray<N>& fa, ssize_t n)
folly::symbolizer::fd_	.\experimental\symbolizer\Elf.cpp	/^  : fd_(other.fd_),$/;"	p	namespace:folly::symbolizer	file:	signature:(other.fd_)
folly::symbolizer::file_	.\experimental\symbolizer\Elf.cpp	/^    file_(other.file_),$/;"	p	namespace:folly::symbolizer	file:	signature:(other.file_)
folly::symbolizer::getStackTrace	.\experimental\symbolizer\StackTrace.cpp	/^ssize_t getStackTrace(uintptr_t* addresses, size_t maxAddresses) {$/;"	f	namespace:folly::symbolizer	signature:(uintptr_t* addresses, size_t maxAddresses)
folly::symbolizer::getStackTrace	.\experimental\symbolizer\StackTrace.h	/^ssize_t getStackTrace(uintptr_t* addresses, size_t maxAddresses);$/;"	p	namespace:folly::symbolizer	signature:(uintptr_t* addresses, size_t maxAddresses)
folly::symbolizer::getStackTrace	.\experimental\symbolizer\Symbolizer.h	/^inline bool getStackTrace(FrameArray<N>& fa) {$/;"	f	namespace:folly::symbolizer	signature:(FrameArray<N>& fa)
folly::symbolizer::getStackTraceSafe	.\experimental\symbolizer\StackTrace.cpp	/^ssize_t getStackTraceSafe(uintptr_t* addresses, size_t maxAddresses) {$/;"	f	namespace:folly::symbolizer	signature:(uintptr_t* addresses, size_t maxAddresses)
folly::symbolizer::getStackTraceSafe	.\experimental\symbolizer\StackTrace.h	/^ssize_t getStackTraceSafe(uintptr_t* addresses, size_t maxAddresses);$/;"	p	namespace:folly::symbolizer	signature:(uintptr_t* addresses, size_t maxAddresses)
folly::symbolizer::getStackTraceSafe	.\experimental\symbolizer\Symbolizer.h	/^FOLLY_ALWAYS_INLINE bool getStackTraceSafe(FrameArray<N>& fa);$/;"	p	namespace:folly::symbolizer	signature:(FrameArray<N>& fa)
folly::symbolizer::getStackTraceSafe	.\experimental\symbolizer\Symbolizer.h	/^inline bool getStackTraceSafe(FrameArray<N>& fa) {$/;"	f	namespace:folly::symbolizer	signature:(FrameArray<N>& fa)
folly::symbolizer::installFatalSignalCallbacks	.\experimental\symbolizer\SignalHandler.cpp	/^void installFatalSignalCallbacks() {$/;"	f	namespace:folly::symbolizer	signature:()
folly::symbolizer::installFatalSignalCallbacks	.\experimental\symbolizer\SignalHandler.h	/^void installFatalSignalCallbacks();$/;"	p	namespace:folly::symbolizer	signature:()
folly::symbolizer::installFatalSignalHandler	.\experimental\symbolizer\SignalHandler.cpp	/^void installFatalSignalHandler() {$/;"	f	namespace:folly::symbolizer	signature:()
folly::symbolizer::installFatalSignalHandler	.\experimental\symbolizer\SignalHandler.h	/^void installFatalSignalHandler();$/;"	p	namespace:folly::symbolizer	signature:()
folly::symbolizer::length_	.\experimental\symbolizer\Elf.cpp	/^    length_(other.length_),$/;"	p	namespace:folly::symbolizer	file:	signature:(other.length_)
folly::symbolizer::operator <<	.\experimental\symbolizer\Dwarf.h	/^inline std::ostream& operator<<(std::ostream& out, const Dwarf::Path& path) {$/;"	f	namespace:folly::symbolizer	signature:(std::ostream& out, const Dwarf::Path& path)
folly::symbolizer::section	.\experimental\symbolizer\Elf-inl.h	/^const ElfW(Sym)* ElfFile::iterateSymbols(const ElfW(Shdr)& section, Fn fn)$/;"	m	namespace:folly::symbolizer
folly::symbolizer::section	.\experimental\symbolizer\Elf-inl.h	/^const ElfW(Sym)* ElfFile::iterateSymbolsWithType(const ElfW(Shdr)& section,$/;"	m	namespace:folly::symbolizer
folly::symbolizer::stringTable	.\experimental\symbolizer\Elf-inl.h	/^const char* ElfFile::iterateStrings(const ElfW(Shdr)& stringTable, Fn fn)$/;"	m	namespace:folly::symbolizer
folly::symbolizer::stringTable	.\experimental\symbolizer\Elf.cpp	/^const char* ElfFile::getString(const ElfW(Shdr)& stringTable, size_t offset)$/;"	m	namespace:folly::symbolizer	file:
folly::symbolizer::test	.\experimental\symbolizer\test\LineReaderTest.cpp	/^namespace folly { namespace symbolizer { namespace test {$/;"	n	namespace:folly::symbolizer	file:
folly::symbolizer::test	.\experimental\symbolizer\test\SignalHandlerTest.cpp	/^namespace folly { namespace symbolizer { namespace test {$/;"	n	namespace:folly::symbolizer	file:
folly::symbolizer::test	.\experimental\symbolizer\test\SignalHandlerTest.h	/^namespace folly { namespace symbolizer { namespace test {$/;"	n	namespace:folly::symbolizer
folly::symbolizer::test	.\experimental\symbolizer\test\SymbolizerTest.cpp	/^namespace folly { namespace symbolizer { namespace test {$/;"	n	namespace:folly::symbolizer	file:
folly::symbolizer::test::ElfCacheTest	.\experimental\symbolizer\test\SymbolizerTest.cpp	/^class ElfCacheTest : public testing::Test {$/;"	c	namespace:folly::symbolizer::test	file:	inherits:testing::Test
folly::symbolizer::test::ElfCacheTest::SetUp	.\experimental\symbolizer\test\SymbolizerTest.cpp	/^  void SetUp();$/;"	p	class:folly::symbolizer::test::ElfCacheTest	file:	access:protected	signature:()
folly::symbolizer::test::ElfCacheTest::SetUp	.\experimental\symbolizer\test\SymbolizerTest.cpp	/^void ElfCacheTest::SetUp() {$/;"	f	class:folly::symbolizer::test::ElfCacheTest	signature:()
folly::symbolizer::test::TEST	.\experimental\symbolizer\test\LineReaderTest.cpp	/^TEST(LineReader, Simple) {$/;"	f	namespace:folly::symbolizer::test	signature:(LineReader, Simple)
folly::symbolizer::test::TEST	.\experimental\symbolizer\test\SignalHandlerTest.cpp	/^TEST(SignalHandler, Simple) {$/;"	f	namespace:folly::symbolizer::test	signature:(SignalHandler, Simple)
folly::symbolizer::test::TEST	.\experimental\symbolizer\test\SymbolizerTest.cpp	/^TEST(Symbolizer, Single) {$/;"	f	namespace:folly::symbolizer::test	signature:(Symbolizer, Single)
folly::symbolizer::test::TEST_F	.\experimental\symbolizer\test\SymbolizerTest.cpp	/^TEST_F(ElfCacheTest, SignalSafeElfCache) {$/;"	f	namespace:folly::symbolizer::test	signature:(ElfCacheTest, SignalSafeElfCache)
folly::symbolizer::test::TEST_F	.\experimental\symbolizer\test\SymbolizerTest.cpp	/^TEST_F(ElfCacheTest, TinyElfCache) {$/;"	f	namespace:folly::symbolizer::test	signature:(ElfCacheTest, TinyElfCache)
folly::symbolizer::test::__anon44::callback1	.\experimental\symbolizer\test\SignalHandlerTest.cpp	/^void callback1() {$/;"	f	namespace:folly::symbolizer::test::__anon44	signature:()
folly::symbolizer::test::__anon44::callback2	.\experimental\symbolizer\test\SignalHandlerTest.cpp	/^void callback2() {$/;"	f	namespace:folly::symbolizer::test::__anon44	signature:()
folly::symbolizer::test::__anon44::print	.\experimental\symbolizer\test\SignalHandlerTest.cpp	/^void print(StringPiece sp) {$/;"	f	namespace:folly::symbolizer::test::__anon44	signature:(StringPiece sp)
folly::symbolizer::test::bar	.\experimental\symbolizer\test\SymbolizerTest.cpp	/^FOLLY_NOINLINE void bar();$/;"	p	namespace:folly::symbolizer::test	file:	signature:()
folly::symbolizer::test::bar	.\experimental\symbolizer\test\SymbolizerTest.cpp	/^void bar() {$/;"	f	namespace:folly::symbolizer::test	signature:()
folly::symbolizer::test::comparator	.\experimental\symbolizer\test\SymbolizerTest.cpp	/^int comparator(const void* ap, const void* bp) {$/;"	f	namespace:folly::symbolizer::test	signature:(const void* ap, const void* bp)
folly::symbolizer::test::expect	.\experimental\symbolizer\test\LineReaderTest.cpp	/^void expect(LineReader& lr, const char* expected) {$/;"	f	namespace:folly::symbolizer::test	signature:(LineReader& lr, const char* expected)
folly::symbolizer::test::failHard	.\experimental\symbolizer\test\SignalHandlerTest.h	/^inline void failHard() {$/;"	f	namespace:folly::symbolizer::test	signature:()
folly::symbolizer::test::foo	.\experimental\symbolizer\test\SymbolizerTest.cpp	/^void foo() {$/;"	f	namespace:folly::symbolizer::test	signature:()
folly::symbolizer::test::goldenFrames	.\experimental\symbolizer\test\SymbolizerTest.cpp	/^FrameArray<100> goldenFrames;$/;"	m	namespace:folly::symbolizer::test	file:
folly::symbolizer::test::runElfCacheTest	.\experimental\symbolizer\test\SymbolizerTest.cpp	/^void runElfCacheTest(Symbolizer& symbolizer) {$/;"	f	namespace:folly::symbolizer::test	signature:(Symbolizer& symbolizer)
folly::symbolizer::test::writeAll	.\experimental\symbolizer\test\LineReaderTest.cpp	/^void writeAll(int fd, const char* str) {$/;"	f	namespace:folly::symbolizer::test	signature:(int fd, const char* str)
folly::symbolizer::type	.\experimental\symbolizer\Elf-inl.h	/^                                                 uint32_t type, Fn fn) const {$/;"	m	namespace:folly::symbolizer
folly::test	.\experimental\TestUtil.cpp	/^namespace test {$/;"	n	namespace:folly	file:
folly::test	.\experimental\TestUtil.h	/^namespace test {$/;"	n	namespace:folly
folly::test	.\io\test\RecordIOTest.cpp	/^namespace folly { namespace test {$/;"	n	namespace:folly	file:
folly::test	.\test\AtomicBitSetTest.cpp	/^namespace folly { namespace test {$/;"	n	namespace:folly	file:
folly::test	.\test\DeterministicSchedule.cpp	/^namespace folly { namespace test {$/;"	n	namespace:folly	file:
folly::test	.\test\DeterministicSchedule.h	/^namespace folly { namespace test {$/;"	n	namespace:folly
folly::test	.\test\ExceptionTest.cpp	/^namespace folly { namespace test {$/;"	n	namespace:folly	file:
folly::test	.\test\FileUtilTest.cpp	/^namespace folly { namespace test {$/;"	n	namespace:folly	file:
folly::test	.\test\MPMCPipelineTest.cpp	/^namespace folly { namespace test {$/;"	n	namespace:folly	file:
folly::test	.\test\VarintTest.cpp	/^namespace folly { namespace test {$/;"	n	namespace:folly	file:
folly::test::DeterministicAtomic	.\test\DeterministicSchedule.h	/^struct DeterministicAtomic {$/;"	s	namespace:folly::test
folly::test::DeterministicAtomic::DeterministicAtomic	.\test\DeterministicSchedule.h	/^  DeterministicAtomic() = default;$/;"	p	struct:folly::test::DeterministicAtomic	access:public	signature:()
folly::test::DeterministicAtomic::DeterministicAtomic	.\test\DeterministicSchedule.h	/^  DeterministicAtomic(DeterministicAtomic<T> const &) = delete;$/;"	p	struct:folly::test::DeterministicAtomic	access:public	signature:(DeterministicAtomic<T> const &)
folly::test::DeterministicAtomic::data	.\test\DeterministicSchedule.h	/^  std::atomic<T> data;$/;"	m	struct:folly::test::DeterministicAtomic	access:public
folly::test::DeterministicAtomic::noexcept	.\test\DeterministicSchedule.h	/^  constexpr \/* implicit *\/ DeterministicAtomic(T v) noexcept : data(v) {}$/;"	m	struct:folly::test::DeterministicAtomic	access:public
folly::test::DeterministicAtomic::operator =	.\test\DeterministicSchedule.h	/^  DeterministicAtomic<T>& operator= (DeterministicAtomic<T> const &) = delete;$/;"	p	struct:folly::test::DeterministicAtomic	access:public	signature:(DeterministicAtomic<T> const &)
folly::test::DeterministicAtomic::~DeterministicAtomic	.\test\DeterministicSchedule.h	/^  ~DeterministicAtomic() = default;$/;"	p	struct:folly::test::DeterministicAtomic	access:public	signature:()
folly::test::DeterministicSchedule	.\test\DeterministicSchedule.h	/^class DeterministicSchedule : boost::noncopyable {$/;"	c	namespace:folly::test	inherits:boost::noncopyable
folly::test::DeterministicSchedule::DeterministicSchedule	.\test\DeterministicSchedule.cpp	/^DeterministicSchedule::DeterministicSchedule($/;"	f	class:folly::test::DeterministicSchedule	signature:( const std::function<int(int)>& scheduler)
folly::test::DeterministicSchedule::DeterministicSchedule	.\test\DeterministicSchedule.h	/^  explicit DeterministicSchedule(const std::function<int(int)>& scheduler);$/;"	p	class:folly::test::DeterministicSchedule	access:public	signature:(const std::function<int(int)>& scheduler)
folly::test::DeterministicSchedule::active_	.\test\DeterministicSchedule.h	/^  std::unordered_set<std::thread::id> active_;$/;"	m	class:folly::test::DeterministicSchedule	access:private
folly::test::DeterministicSchedule::afterSharedAccess	.\test\DeterministicSchedule.cpp	/^DeterministicSchedule::afterSharedAccess() {$/;"	f	class:folly::test::DeterministicSchedule	signature:()
folly::test::DeterministicSchedule::afterSharedAccess	.\test\DeterministicSchedule.h	/^  static void afterSharedAccess();$/;"	p	class:folly::test::DeterministicSchedule	access:public	signature:()
folly::test::DeterministicSchedule::afterThreadCreate	.\test\DeterministicSchedule.cpp	/^DeterministicSchedule::afterThreadCreate(sem_t* sem) {$/;"	f	class:folly::test::DeterministicSchedule	signature:(sem_t* sem)
folly::test::DeterministicSchedule::afterThreadCreate	.\test\DeterministicSchedule.h	/^  void afterThreadCreate(sem_t*);$/;"	p	class:folly::test::DeterministicSchedule	access:private	signature:(sem_t*)
folly::test::DeterministicSchedule::beforeSharedAccess	.\test\DeterministicSchedule.cpp	/^DeterministicSchedule::beforeSharedAccess() {$/;"	f	class:folly::test::DeterministicSchedule	signature:()
folly::test::DeterministicSchedule::beforeSharedAccess	.\test\DeterministicSchedule.h	/^  static void beforeSharedAccess();$/;"	p	class:folly::test::DeterministicSchedule	access:public	signature:()
folly::test::DeterministicSchedule::beforeThreadCreate	.\test\DeterministicSchedule.cpp	/^DeterministicSchedule::beforeThreadCreate() {$/;"	f	class:folly::test::DeterministicSchedule	signature:()
folly::test::DeterministicSchedule::beforeThreadCreate	.\test\DeterministicSchedule.h	/^  sem_t* beforeThreadCreate();$/;"	p	class:folly::test::DeterministicSchedule	access:private	signature:()
folly::test::DeterministicSchedule::beforeThreadExit	.\test\DeterministicSchedule.cpp	/^DeterministicSchedule::beforeThreadExit() {$/;"	f	class:folly::test::DeterministicSchedule	signature:()
folly::test::DeterministicSchedule::beforeThreadExit	.\test\DeterministicSchedule.h	/^  void beforeThreadExit();$/;"	p	class:folly::test::DeterministicSchedule	access:private	signature:()
folly::test::DeterministicSchedule::getRandNumber	.\test\DeterministicSchedule.cpp	/^DeterministicSchedule::getRandNumber(int n) {$/;"	f	class:folly::test::DeterministicSchedule	signature:(int n)
folly::test::DeterministicSchedule::getRandNumber	.\test\DeterministicSchedule.h	/^  static int getRandNumber(int n);$/;"	p	class:folly::test::DeterministicSchedule	access:public	signature:(int n)
folly::test::DeterministicSchedule::join	.\test\DeterministicSchedule.cpp	/^DeterministicSchedule::join(std::thread& child) {$/;"	f	class:folly::test::DeterministicSchedule	signature:(std::thread& child)
folly::test::DeterministicSchedule::join	.\test\DeterministicSchedule.h	/^  static void join(std::thread& child);$/;"	p	class:folly::test::DeterministicSchedule	access:public	signature:(std::thread& child)
folly::test::DeterministicSchedule::post	.\test\DeterministicSchedule.cpp	/^DeterministicSchedule::post(sem_t* sem) {$/;"	f	class:folly::test::DeterministicSchedule	signature:(sem_t* sem)
folly::test::DeterministicSchedule::post	.\test\DeterministicSchedule.h	/^  static void post(sem_t* sem);$/;"	p	class:folly::test::DeterministicSchedule	access:public	signature:(sem_t* sem)
folly::test::DeterministicSchedule::scheduler_	.\test\DeterministicSchedule.h	/^  std::function<int(int)> scheduler_;$/;"	m	class:folly::test::DeterministicSchedule	access:private
folly::test::DeterministicSchedule::sems_	.\test\DeterministicSchedule.h	/^  std::vector<sem_t*> sems_;$/;"	m	class:folly::test::DeterministicSchedule	access:private
folly::test::DeterministicSchedule::thread	.\test\DeterministicSchedule.h	/^  static inline std::thread thread(Func&& func, Args&&... args) {$/;"	f	class:folly::test::DeterministicSchedule	access:public	signature:(Func&& func, Args&&... args)
folly::test::DeterministicSchedule::tls_sched	.\test\DeterministicSchedule.cpp	/^FOLLY_TLS DeterministicSchedule* DeterministicSchedule::tls_sched;$/;"	m	class:folly::test::DeterministicSchedule	file:
folly::test::DeterministicSchedule::tls_sched	.\test\DeterministicSchedule.h	/^  static FOLLY_TLS DeterministicSchedule* tls_sched;$/;"	m	class:folly::test::DeterministicSchedule	access:private
folly::test::DeterministicSchedule::tls_sem	.\test\DeterministicSchedule.cpp	/^FOLLY_TLS sem_t* DeterministicSchedule::tls_sem;$/;"	m	class:folly::test::DeterministicSchedule	file:
folly::test::DeterministicSchedule::tls_sem	.\test\DeterministicSchedule.h	/^  static FOLLY_TLS sem_t* tls_sem;$/;"	m	class:folly::test::DeterministicSchedule	access:private
folly::test::DeterministicSchedule::tryWait	.\test\DeterministicSchedule.cpp	/^DeterministicSchedule::tryWait(sem_t* sem) {$/;"	f	class:folly::test::DeterministicSchedule	signature:(sem_t* sem)
folly::test::DeterministicSchedule::tryWait	.\test\DeterministicSchedule.h	/^  static bool tryWait(sem_t* sem);$/;"	p	class:folly::test::DeterministicSchedule	access:public	signature:(sem_t* sem)
folly::test::DeterministicSchedule::uniform	.\test\DeterministicSchedule.cpp	/^DeterministicSchedule::uniform(long seed) {$/;"	f	class:folly::test::DeterministicSchedule	signature:(long seed)
folly::test::DeterministicSchedule::uniform	.\test\DeterministicSchedule.h	/^  static std::function<int(int)> uniform(long seed);$/;"	p	class:folly::test::DeterministicSchedule	access:public	signature:(long seed)
folly::test::DeterministicSchedule::uniformSubset	.\test\DeterministicSchedule.cpp	/^DeterministicSchedule::uniformSubset(long seed, int n, int m) {$/;"	f	class:folly::test::DeterministicSchedule	signature:(long seed, int n, int m)
folly::test::DeterministicSchedule::uniformSubset	.\test\DeterministicSchedule.h	/^  static std::function<int(int)> uniformSubset(long seed, int n = 2,$/;"	p	class:folly::test::DeterministicSchedule	access:public	signature:(long seed, int n = 2, int m = 64)
folly::test::DeterministicSchedule::wait	.\test\DeterministicSchedule.cpp	/^DeterministicSchedule::wait(sem_t* sem) {$/;"	f	class:folly::test::DeterministicSchedule	signature:(sem_t* sem)
folly::test::DeterministicSchedule::wait	.\test\DeterministicSchedule.h	/^  static void wait(sem_t* sem);$/;"	p	class:folly::test::DeterministicSchedule	access:public	signature:(sem_t* sem)
folly::test::DeterministicSchedule::~DeterministicSchedule	.\test\DeterministicSchedule.cpp	/^DeterministicSchedule::~DeterministicSchedule() {$/;"	f	class:folly::test::DeterministicSchedule	signature:()
folly::test::DeterministicSchedule::~DeterministicSchedule	.\test\DeterministicSchedule.h	/^  ~DeterministicSchedule();$/;"	p	class:folly::test::DeterministicSchedule	access:public	signature:()
folly::test::FileUtilTest	.\test\FileUtilTest.cpp	/^class FileUtilTest : public ::testing::Test {$/;"	c	namespace:folly::test	file:	inherits:::testing::Test
folly::test::FileUtilTest::FileUtilTest	.\test\FileUtilTest.cpp	/^  FileUtilTest();$/;"	p	class:folly::test::FileUtilTest	file:	access:protected	signature:()
folly::test::FileUtilTest::FileUtilTest	.\test\FileUtilTest.cpp	/^FileUtilTest::FileUtilTest()$/;"	f	class:folly::test::FileUtilTest	signature:()
folly::test::FileUtilTest::in_	.\test\FileUtilTest.cpp	/^  std::string in_;$/;"	m	class:folly::test::FileUtilTest	file:	access:protected
folly::test::FileUtilTest::reader	.\test\FileUtilTest.cpp	/^  Reader reader(std::deque<ssize_t> spec);$/;"	p	class:folly::test::FileUtilTest	file:	access:protected	signature:(std::deque<ssize_t> spec)
folly::test::FileUtilTest::reader	.\test\FileUtilTest.cpp	/^Reader FileUtilTest::reader(std::deque<ssize_t> spec) {$/;"	f	class:folly::test::FileUtilTest	signature:(std::deque<ssize_t> spec)
folly::test::FileUtilTest::readers_	.\test\FileUtilTest.cpp	/^  std::vector<std::pair<size_t, Reader>> readers_;$/;"	m	class:folly::test::FileUtilTest	file:	access:protected
folly::test::IovecBuffers	.\test\FileUtilTest.cpp	/^class IovecBuffers {$/;"	c	namespace:folly::test	file:
folly::test::IovecBuffers::IovecBuffers	.\test\FileUtilTest.cpp	/^  explicit IovecBuffers(std::initializer_list<size_t> sizes);$/;"	p	class:folly::test::IovecBuffers	file:	access:public	signature:(std::initializer_list<size_t> sizes)
folly::test::IovecBuffers::IovecBuffers	.\test\FileUtilTest.cpp	/^IovecBuffers::IovecBuffers(std::initializer_list<size_t> sizes) {$/;"	f	class:folly::test::IovecBuffers	signature:(std::initializer_list<size_t> sizes)
folly::test::IovecBuffers::buffers_	.\test\FileUtilTest.cpp	/^  std::vector<std::string> buffers_;$/;"	m	class:folly::test::IovecBuffers	file:	access:private
folly::test::IovecBuffers::iov	.\test\FileUtilTest.cpp	/^  std::vector<iovec> iov() const { return iov_; }  \/\/ yes, make a copy$/;"	f	class:folly::test::IovecBuffers	access:public	signature:() const
folly::test::IovecBuffers::iov_	.\test\FileUtilTest.cpp	/^  std::vector<iovec> iov_;$/;"	m	class:folly::test::IovecBuffers	file:	access:private
folly::test::IovecBuffers::join	.\test\FileUtilTest.cpp	/^  std::string join() const { return folly::join("", buffers_); }$/;"	f	class:folly::test::IovecBuffers	access:public	signature:() const
folly::test::IovecBuffers::size	.\test\FileUtilTest.cpp	/^  size_t size() const;$/;"	p	class:folly::test::IovecBuffers	file:	access:public	signature:() const
folly::test::IovecBuffers::size	.\test\FileUtilTest.cpp	/^size_t IovecBuffers::size() const {$/;"	f	class:folly::test::IovecBuffers	signature:() const
folly::test::TEST	.\io\test\RecordIOTest.cpp	/^TEST(RecordIOTest, ExtraMagic) {$/;"	f	namespace:folly::test	signature:(RecordIOTest, ExtraMagic)
folly::test::TEST	.\io\test\RecordIOTest.cpp	/^TEST(RecordIOTest, MultipleFileIds) {$/;"	f	namespace:folly::test	signature:(RecordIOTest, MultipleFileIds)
folly::test::TEST	.\io\test\RecordIOTest.cpp	/^TEST(RecordIOTest, Randomized) {$/;"	f	namespace:folly::test	signature:(RecordIOTest, Randomized)
folly::test::TEST	.\io\test\RecordIOTest.cpp	/^TEST(RecordIOTest, Simple) {$/;"	f	namespace:folly::test	signature:(RecordIOTest, Simple)
folly::test::TEST	.\io\test\RecordIOTest.cpp	/^TEST(RecordIOTest, SmallRecords) {$/;"	f	namespace:folly::test	signature:(RecordIOTest, SmallRecords)
folly::test::TEST	.\test\AtomicBitSetTest.cpp	/^TEST(AtomicBitSet, Simple) {$/;"	f	namespace:folly::test	signature:(AtomicBitSet, Simple)
folly::test::TEST	.\test\ExceptionTest.cpp	/^TEST(ExceptionTest, Simple) {$/;"	f	namespace:folly::test	signature:(ExceptionTest, Simple)
folly::test::TEST	.\test\FileUtilTest.cpp	/^TEST(String, readFile) {$/;"	f	namespace:folly::test	signature:(String, readFile)
folly::test::TEST	.\test\MPMCPipelineTest.cpp	/^TEST(MPMCPipeline, MultiThreaded) {$/;"	f	namespace:folly::test	signature:(MPMCPipeline, MultiThreaded)
folly::test::TEST	.\test\MPMCPipelineTest.cpp	/^TEST(MPMCPipeline, Trivial) {$/;"	f	namespace:folly::test	signature:(MPMCPipeline, Trivial)
folly::test::TEST	.\test\MPMCPipelineTest.cpp	/^TEST(MPMCPipeline, TrivialAmplification) {$/;"	f	namespace:folly::test	signature:(MPMCPipeline, TrivialAmplification)
folly::test::TEST	.\test\VarintTest.cpp	/^TEST(Varint, Simple) {$/;"	f	namespace:folly::test	signature:(Varint, Simple)
folly::test::TEST	.\test\VarintTest.cpp	/^TEST(ZigZag, Simple) {$/;"	f	namespace:folly::test	signature:(ZigZag, Simple)
folly::test::TEST_F	.\test\FileUtilTest.cpp	/^TEST_F(FileUtilTest, pread) {$/;"	f	namespace:folly::test	signature:(FileUtilTest, pread)
folly::test::TEST_F	.\test\FileUtilTest.cpp	/^TEST_F(FileUtilTest, preadv) {$/;"	f	namespace:folly::test	signature:(FileUtilTest, preadv)
folly::test::TEST_F	.\test\FileUtilTest.cpp	/^TEST_F(FileUtilTest, read) {$/;"	f	namespace:folly::test	signature:(FileUtilTest, read)
folly::test::TEST_F	.\test\FileUtilTest.cpp	/^TEST_F(FileUtilTest, readv) {$/;"	f	namespace:folly::test	signature:(FileUtilTest, readv)
folly::test::TemporaryDirectory	.\experimental\TestUtil.h	/^class TemporaryDirectory {$/;"	c	namespace:folly::test
folly::test::TemporaryDirectory::Scope	.\experimental\TestUtil.h	/^  enum class Scope {$/;"	c	class:folly::test::TemporaryDirectory	access:public
folly::test::TemporaryDirectory::Scope::PERMANENT	.\experimental\TestUtil.h	/^    PERMANENT,$/;"	m	class:folly::test::TemporaryDirectory::Scope	access:private
folly::test::TemporaryDirectory::TemporaryDirectory	.\experimental\TestUtil.cpp	/^TemporaryDirectory::TemporaryDirectory(StringPiece namePrefix,$/;"	f	class:folly::test::TemporaryDirectory	signature:(StringPiece namePrefix, fs::path dir, Scope scope)
folly::test::TemporaryDirectory::TemporaryDirectory	.\experimental\TestUtil.h	/^  explicit TemporaryDirectory(StringPiece namePrefix = StringPiece(),$/;"	p	class:folly::test::TemporaryDirectory	access:public	signature:(StringPiece namePrefix = StringPiece(), fs::path dir = fs::path(), Scope scope = Scope::DELETE_ON_DESTRUCTION)
folly::test::TemporaryDirectory::path	.\experimental\TestUtil.h	/^  const fs::path& path() const { return path_; }$/;"	f	class:folly::test::TemporaryDirectory	access:public	signature:() const
folly::test::TemporaryDirectory::path_	.\experimental\TestUtil.h	/^  fs::path path_;$/;"	m	class:folly::test::TemporaryDirectory	access:private
folly::test::TemporaryDirectory::scope_	.\experimental\TestUtil.h	/^  Scope scope_;$/;"	m	class:folly::test::TemporaryDirectory	access:private
folly::test::TemporaryDirectory::~TemporaryDirectory	.\experimental\TestUtil.cpp	/^TemporaryDirectory::~TemporaryDirectory() {$/;"	f	class:folly::test::TemporaryDirectory	signature:()
folly::test::TemporaryDirectory::~TemporaryDirectory	.\experimental\TestUtil.h	/^  ~TemporaryDirectory();$/;"	p	class:folly::test::TemporaryDirectory	access:public	signature:()
folly::test::TemporaryFile	.\experimental\TestUtil.h	/^class TemporaryFile {$/;"	c	namespace:folly::test
folly::test::TemporaryFile::Scope	.\experimental\TestUtil.h	/^  enum class Scope {$/;"	c	class:folly::test::TemporaryFile	access:public
folly::test::TemporaryFile::Scope::PERMANENT	.\experimental\TestUtil.h	/^    PERMANENT,$/;"	m	class:folly::test::TemporaryFile::Scope	access:private
folly::test::TemporaryFile::Scope::UNLINK_IMMEDIATELY	.\experimental\TestUtil.h	/^    UNLINK_IMMEDIATELY,$/;"	m	class:folly::test::TemporaryFile::Scope	access:private
folly::test::TemporaryFile::TemporaryFile	.\experimental\TestUtil.cpp	/^TemporaryFile::TemporaryFile(StringPiece namePrefix,$/;"	f	class:folly::test::TemporaryFile	signature:(StringPiece namePrefix, fs::path dir, Scope scope, bool closeOnDestruction)
folly::test::TemporaryFile::TemporaryFile	.\experimental\TestUtil.h	/^  explicit TemporaryFile(StringPiece namePrefix = StringPiece(),$/;"	p	class:folly::test::TemporaryFile	access:public	signature:(StringPiece namePrefix = StringPiece(), fs::path dir = fs::path(), Scope scope = Scope::UNLINK_ON_DESTRUCTION, bool closeOnDestruction = true)
folly::test::TemporaryFile::closeOnDestruction_	.\experimental\TestUtil.h	/^  bool closeOnDestruction_;$/;"	m	class:folly::test::TemporaryFile	access:private
folly::test::TemporaryFile::fd	.\experimental\TestUtil.h	/^  int fd() const { return fd_; }$/;"	f	class:folly::test::TemporaryFile	access:public	signature:() const
folly::test::TemporaryFile::fd_	.\experimental\TestUtil.h	/^  int fd_;$/;"	m	class:folly::test::TemporaryFile	access:private
folly::test::TemporaryFile::path	.\experimental\TestUtil.cpp	/^const fs::path& TemporaryFile::path() const {$/;"	f	class:folly::test::TemporaryFile	signature:() const
folly::test::TemporaryFile::path	.\experimental\TestUtil.h	/^  const fs::path& path() const;$/;"	p	class:folly::test::TemporaryFile	access:public	signature:() const
folly::test::TemporaryFile::path_	.\experimental\TestUtil.h	/^  fs::path path_;$/;"	m	class:folly::test::TemporaryFile	access:private
folly::test::TemporaryFile::scope_	.\experimental\TestUtil.h	/^  Scope scope_;$/;"	m	class:folly::test::TemporaryFile	access:private
folly::test::TemporaryFile::~TemporaryFile	.\experimental\TestUtil.cpp	/^TemporaryFile::~TemporaryFile() {$/;"	f	class:folly::test::TemporaryFile	signature:()
folly::test::TemporaryFile::~TemporaryFile	.\experimental\TestUtil.h	/^  ~TemporaryFile();$/;"	p	class:folly::test::TemporaryFile	access:public	signature:()
folly::test::UniformSubset	.\test\DeterministicSchedule.cpp	/^struct UniformSubset {$/;"	s	namespace:folly::test	file:
folly::test::UniformSubset::UniformSubset	.\test\DeterministicSchedule.cpp	/^  UniformSubset(long seed, int subsetSize, int stepsBetweenSelect)$/;"	f	struct:folly::test::UniformSubset	access:public	signature:(long seed, int subsetSize, int stepsBetweenSelect)
folly::test::UniformSubset::adjustPermSize	.\test\DeterministicSchedule.cpp	/^  void adjustPermSize(int numActive) {$/;"	f	struct:folly::test::UniformSubset	file:	access:private	signature:(int numActive)
folly::test::UniformSubset::operator ()	.\test\DeterministicSchedule.cpp	/^  int operator()(int numActive) {$/;"	f	struct:folly::test::UniformSubset	access:public	signature:(int numActive)
folly::test::UniformSubset::perm_	.\test\DeterministicSchedule.cpp	/^  std::vector<int> perm_;$/;"	m	struct:folly::test::UniformSubset	file:	access:private
folly::test::UniformSubset::shufflePrefix	.\test\DeterministicSchedule.cpp	/^  void shufflePrefix() {$/;"	f	struct:folly::test::UniformSubset	file:	access:private	signature:()
folly::test::UniformSubset::stepsBetweenSelect_	.\test\DeterministicSchedule.cpp	/^  const int stepsBetweenSelect_;$/;"	m	struct:folly::test::UniformSubset	file:	access:private
folly::test::UniformSubset::stepsLeft_	.\test\DeterministicSchedule.cpp	/^  int stepsLeft_;$/;"	m	struct:folly::test::UniformSubset	file:	access:private
folly::test::UniformSubset::subsetSize_	.\test\DeterministicSchedule.cpp	/^  const int subsetSize_;$/;"	m	struct:folly::test::UniformSubset	file:	access:private
folly::test::UniformSubset::uniform_	.\test\DeterministicSchedule.cpp	/^  std::function<int(int)> uniform_;$/;"	m	struct:folly::test::UniformSubset	file:	access:private
folly::test::__anon117::Reader	.\test\FileUtilTest.cpp	/^class Reader {$/;"	c	namespace:folly::test::__anon117	file:
folly::test::__anon117::Reader::Reader	.\test\FileUtilTest.cpp	/^  Reader(off_t offset, StringPiece data, std::deque<ssize_t> spec);$/;"	p	class:folly::test::__anon117::Reader	file:	access:public	signature:(off_t offset, StringPiece data, std::deque<ssize_t> spec)
folly::test::__anon117::Reader::Reader	.\test\FileUtilTest.cpp	/^Reader::Reader(off_t offset, StringPiece data, std::deque<ssize_t> spec)$/;"	f	class:folly::test::__anon117::Reader	signature:(off_t offset, StringPiece data, std::deque<ssize_t> spec)
folly::test::__anon117::Reader::data_	.\test\FileUtilTest.cpp	/^  StringPiece data_;$/;"	m	class:folly::test::__anon117::Reader	file:	access:private
folly::test::__anon117::Reader::nextSize	.\test\FileUtilTest.cpp	/^  ssize_t nextSize();$/;"	p	class:folly::test::__anon117::Reader	file:	access:private	signature:()
folly::test::__anon117::Reader::nextSize	.\test\FileUtilTest.cpp	/^ssize_t Reader::nextSize() {$/;"	f	class:folly::test::__anon117::Reader	signature:()
folly::test::__anon117::Reader::offset_	.\test\FileUtilTest.cpp	/^  off_t offset_;$/;"	m	class:folly::test::__anon117::Reader	file:	access:private
folly::test::__anon117::Reader::operator ()	.\test\FileUtilTest.cpp	/^  ssize_t operator()(int fd, const iovec* iov, int count);$/;"	p	class:folly::test::__anon117::Reader	file:	access:public	signature:(int fd, const iovec* iov, int count)
folly::test::__anon117::Reader::operator ()	.\test\FileUtilTest.cpp	/^  ssize_t operator()(int fd, const iovec* iov, int count, off_t offset);$/;"	p	class:folly::test::__anon117::Reader	file:	access:public	signature:(int fd, const iovec* iov, int count, off_t offset)
folly::test::__anon117::Reader::operator ()	.\test\FileUtilTest.cpp	/^  ssize_t operator()(int fd, void* buf, size_t count);$/;"	p	class:folly::test::__anon117::Reader	file:	access:public	signature:(int fd, void* buf, size_t count)
folly::test::__anon117::Reader::operator ()	.\test\FileUtilTest.cpp	/^  ssize_t operator()(int fd, void* buf, size_t count, off_t offset);$/;"	p	class:folly::test::__anon117::Reader	file:	access:public	signature:(int fd, void* buf, size_t count, off_t offset)
folly::test::__anon117::Reader::operator ()	.\test\FileUtilTest.cpp	/^ssize_t Reader::operator()(int fd, const iovec* iov, int count) {$/;"	f	class:folly::test::__anon117::Reader	signature:(int fd, const iovec* iov, int count)
folly::test::__anon117::Reader::operator ()	.\test\FileUtilTest.cpp	/^ssize_t Reader::operator()(int fd, const iovec* iov, int count, off_t offset) {$/;"	f	class:folly::test::__anon117::Reader	signature:(int fd, const iovec* iov, int count, off_t offset)
folly::test::__anon117::Reader::operator ()	.\test\FileUtilTest.cpp	/^ssize_t Reader::operator()(int fd, void* buf, size_t count) {$/;"	f	class:folly::test::__anon117::Reader	signature:(int fd, void* buf, size_t count)
folly::test::__anon117::Reader::operator ()	.\test\FileUtilTest.cpp	/^ssize_t Reader::operator()(int fd, void* buf, size_t count, off_t offset) {$/;"	f	class:folly::test::__anon117::Reader	signature:(int fd, void* buf, size_t count, off_t offset)
folly::test::__anon117::Reader::spec	.\test\FileUtilTest.cpp	/^  const std::deque<ssize_t> spec() const { return spec_; }$/;"	f	class:folly::test::__anon117::Reader	access:public	signature:() const
folly::test::__anon117::Reader::spec_	.\test\FileUtilTest.cpp	/^  std::deque<ssize_t> spec_;$/;"	m	class:folly::test::__anon117::Reader	file:	access:private
folly::test::__anon149::BENCHMARK	.\test\VarintTest.cpp	/^BENCHMARK(VarintDecoding, iters) {$/;"	f	namespace:folly::test::__anon149	signature:(VarintDecoding, iters)
folly::test::__anon149::BENCHMARK	.\test\VarintTest.cpp	/^BENCHMARK(VarintEncoding, iters) {$/;"	f	namespace:folly::test::__anon149	signature:(VarintEncoding, iters)
folly::test::__anon149::gDecodedValues	.\test\VarintTest.cpp	/^std::vector<uint64_t> gDecodedValues;$/;"	m	namespace:folly::test::__anon149	file:
folly::test::__anon149::gEncoded	.\test\VarintTest.cpp	/^std::vector<uint8_t> gEncoded;$/;"	m	namespace:folly::test::__anon149	file:
folly::test::__anon149::gValues	.\test\VarintTest.cpp	/^std::vector<uint64_t> gValues;$/;"	m	namespace:folly::test::__anon149	file:
folly::test::__anon149::generateRandomValues	.\test\VarintTest.cpp	/^void generateRandomValues() {$/;"	f	namespace:folly::test::__anon149	signature:()
folly::test::__anon149::kNumValues	.\test\VarintTest.cpp	/^constexpr size_t kNumValues = 1000;$/;"	m	namespace:folly::test::__anon149	file:
folly::test::__anon48::generateUniquePath	.\experimental\TestUtil.cpp	/^fs::path generateUniquePath(fs::path path, StringPiece namePrefix) {$/;"	f	namespace:folly::test::__anon48	signature:(fs::path path, StringPiece namePrefix)
folly::test::__anon73::iobufs	.\io\test\RecordIOTest.cpp	/^std::unique_ptr<IOBuf> iobufs(std::initializer_list<T> ranges) {$/;"	f	namespace:folly::test::__anon73	signature:(std::initializer_list<T> ranges)
folly::test::__anon73::sp	.\io\test\RecordIOTest.cpp	/^StringPiece sp(ByteRange br) { return StringPiece(br); }$/;"	f	namespace:folly::test::__anon73	signature:(ByteRange br)
folly::test::__anon74::corrupt	.\io\test\RecordIOTest.cpp	/^void corrupt(int fd, off_t pos) {$/;"	f	namespace:folly::test::__anon74	signature:(int fd, off_t pos)
folly::test::futexLock	.\test\DeterministicSchedule.cpp	/^static std::mutex futexLock;$/;"	m	namespace:folly::test	file:
folly::test::futexQueues	.\test\DeterministicSchedule.cpp	/^                          std::list<std::pair<uint32_t,bool*>>> futexQueues;$/;"	m	namespace:folly::test	file:
folly::test::testVarint	.\test\VarintTest.cpp	/^void testVarint(uint64_t val, std::initializer_list<uint8_t> bytes) {$/;"	f	namespace:folly::test	signature:(uint64_t val, std::initializer_list<uint8_t> bytes)
folly::threadlocal_detail	.\detail\ThreadLocalDetail.h	/^namespace threadlocal_detail {$/;"	n	namespace:folly
folly::threadlocal_detail::CustomDeleter	.\detail\ThreadLocalDetail.h	/^class CustomDeleter : public DeleterBase {$/;"	c	namespace:folly::threadlocal_detail	inherits:DeleterBase
folly::threadlocal_detail::CustomDeleter::CustomDeleter	.\detail\ThreadLocalDetail.h	/^  explicit CustomDeleter(Deleter d) : deleter_(d) { }$/;"	f	class:folly::threadlocal_detail::CustomDeleter	access:public	signature:(Deleter d)
folly::threadlocal_detail::CustomDeleter::deleter_	.\detail\ThreadLocalDetail.h	/^  Deleter deleter_;$/;"	m	class:folly::threadlocal_detail::CustomDeleter	access:private
folly::threadlocal_detail::CustomDeleter::dispose	.\detail\ThreadLocalDetail.h	/^  virtual void dispose(void* ptr, TLPDestructionMode mode) const {$/;"	f	class:folly::threadlocal_detail::CustomDeleter	access:public	signature:(void* ptr, TLPDestructionMode mode) const
folly::threadlocal_detail::DeleterBase	.\detail\ThreadLocalDetail.h	/^class DeleterBase {$/;"	c	namespace:folly::threadlocal_detail
folly::threadlocal_detail::DeleterBase::dispose	.\detail\ThreadLocalDetail.h	/^  virtual void dispose(void* ptr, TLPDestructionMode mode) const = 0;$/;"	p	class:folly::threadlocal_detail::DeleterBase	access:public	signature:(void* ptr, TLPDestructionMode mode) const
folly::threadlocal_detail::DeleterBase::~DeleterBase	.\detail\ThreadLocalDetail.h	/^  virtual ~DeleterBase() { }$/;"	f	class:folly::threadlocal_detail::DeleterBase	access:public	signature:()
folly::threadlocal_detail::ElementWrapper	.\detail\ThreadLocalDetail.h	/^struct ElementWrapper {$/;"	s	namespace:folly::threadlocal_detail
folly::threadlocal_detail::ElementWrapper::cleanup	.\detail\ThreadLocalDetail.h	/^  void cleanup() {$/;"	f	struct:folly::threadlocal_detail::ElementWrapper	access:public	signature:()
folly::threadlocal_detail::ElementWrapper::deleter	.\detail\ThreadLocalDetail.h	/^  DeleterBase* deleter;$/;"	m	struct:folly::threadlocal_detail::ElementWrapper	access:public
folly::threadlocal_detail::ElementWrapper::dispose	.\detail\ThreadLocalDetail.h	/^  void dispose(TLPDestructionMode mode) {$/;"	f	struct:folly::threadlocal_detail::ElementWrapper	access:public	signature:(TLPDestructionMode mode)
folly::threadlocal_detail::ElementWrapper::ownsDeleter	.\detail\ThreadLocalDetail.h	/^  bool ownsDeleter;$/;"	m	struct:folly::threadlocal_detail::ElementWrapper	access:public
folly::threadlocal_detail::ElementWrapper::ptr	.\detail\ThreadLocalDetail.h	/^  void* ptr;$/;"	m	struct:folly::threadlocal_detail::ElementWrapper	access:public
folly::threadlocal_detail::ElementWrapper::release	.\detail\ThreadLocalDetail.h	/^  void* release() {$/;"	f	struct:folly::threadlocal_detail::ElementWrapper	access:public	signature:()
folly::threadlocal_detail::ElementWrapper::set	.\detail\ThreadLocalDetail.h	/^  void set(Ptr p) {$/;"	f	struct:folly::threadlocal_detail::ElementWrapper	access:public	signature:(Ptr p)
folly::threadlocal_detail::ElementWrapper::set	.\detail\ThreadLocalDetail.h	/^  void set(Ptr p, Deleter d) {$/;"	f	struct:folly::threadlocal_detail::ElementWrapper	access:public	signature:(Ptr p, Deleter d)
folly::threadlocal_detail::SimpleDeleter	.\detail\ThreadLocalDetail.h	/^class SimpleDeleter : public DeleterBase {$/;"	c	namespace:folly::threadlocal_detail	inherits:DeleterBase
folly::threadlocal_detail::SimpleDeleter::dispose	.\detail\ThreadLocalDetail.h	/^  virtual void dispose(void* ptr, TLPDestructionMode mode) const {$/;"	f	class:folly::threadlocal_detail::SimpleDeleter	access:public	signature:(void* ptr, TLPDestructionMode mode) const
folly::threadlocal_detail::StaticMeta	.\detail\ThreadLocalDetail.h	/^struct StaticMeta {$/;"	s	namespace:folly::threadlocal_detail
folly::threadlocal_detail::StaticMeta::StaticMeta	.\detail\ThreadLocalDetail.h	/^  StaticMeta() : nextId_(1) {$/;"	f	struct:folly::threadlocal_detail::StaticMeta	access:public	signature:()
folly::threadlocal_detail::StaticMeta::create	.\detail\ThreadLocalDetail.h	/^  static int create() {$/;"	f	struct:folly::threadlocal_detail::StaticMeta	access:public	signature:()
folly::threadlocal_detail::StaticMeta::destroy	.\detail\ThreadLocalDetail.h	/^  static void destroy(size_t id) {$/;"	f	struct:folly::threadlocal_detail::StaticMeta	access:public	signature:(size_t id)
folly::threadlocal_detail::StaticMeta::erase	.\detail\ThreadLocalDetail.h	/^  void erase(ThreadEntry* t) {$/;"	f	struct:folly::threadlocal_detail::StaticMeta	access:public	signature:(ThreadEntry* t)
folly::threadlocal_detail::StaticMeta::freeIds_	.\detail\ThreadLocalDetail.h	/^  std::vector<int> freeIds_;$/;"	m	struct:folly::threadlocal_detail::StaticMeta	access:public
folly::threadlocal_detail::StaticMeta::get	.\detail\ThreadLocalDetail.h	/^  static ElementWrapper& get(size_t id) {$/;"	f	struct:folly::threadlocal_detail::StaticMeta	access:public	signature:(size_t id)
folly::threadlocal_detail::StaticMeta::getThreadEntry	.\detail\ThreadLocalDetail.h	/^  static ThreadEntry* getThreadEntry() {$/;"	f	struct:folly::threadlocal_detail::StaticMeta	access:public	signature:()
folly::threadlocal_detail::StaticMeta::head_	.\detail\ThreadLocalDetail.h	/^  ThreadEntry head_;$/;"	m	struct:folly::threadlocal_detail::StaticMeta	access:public
folly::threadlocal_detail::StaticMeta::inst_	.\detail\ThreadLocalDetail.h	/^  static StaticMeta<Tag>* inst_;$/;"	m	struct:folly::threadlocal_detail::StaticMeta	access:public
folly::threadlocal_detail::StaticMeta::inst_	.\detail\ThreadLocalDetail.h	/^template <class Tag> StaticMeta<Tag>* StaticMeta<Tag>::inst_ = nullptr;$/;"	m	class:folly::threadlocal_detail::StaticMeta
folly::threadlocal_detail::StaticMeta::instance	.\detail\ThreadLocalDetail.h	/^  static StaticMeta<Tag>& instance() {$/;"	f	struct:folly::threadlocal_detail::StaticMeta	access:public	signature:()
folly::threadlocal_detail::StaticMeta::lock_	.\detail\ThreadLocalDetail.h	/^  std::mutex lock_;$/;"	m	struct:folly::threadlocal_detail::StaticMeta	access:public
folly::threadlocal_detail::StaticMeta::nextId_	.\detail\ThreadLocalDetail.h	/^  int nextId_;$/;"	m	struct:folly::threadlocal_detail::StaticMeta	access:public
folly::threadlocal_detail::StaticMeta::onForkChild	.\detail\ThreadLocalDetail.h	/^  static void onForkChild(void) {$/;"	f	struct:folly::threadlocal_detail::StaticMeta	access:public	signature:(void)
folly::threadlocal_detail::StaticMeta::onForkParent	.\detail\ThreadLocalDetail.h	/^  static void onForkParent(void) {$/;"	f	struct:folly::threadlocal_detail::StaticMeta	access:public	signature:(void)
folly::threadlocal_detail::StaticMeta::onThreadExit	.\detail\ThreadLocalDetail.h	/^  static void onThreadExit(void* ptr) {$/;"	f	struct:folly::threadlocal_detail::StaticMeta	access:public	signature:(void* ptr)
folly::threadlocal_detail::StaticMeta::preFork	.\detail\ThreadLocalDetail.h	/^  static void preFork(void) {$/;"	f	struct:folly::threadlocal_detail::StaticMeta	access:public	signature:(void)
folly::threadlocal_detail::StaticMeta::pthreadKey_	.\detail\ThreadLocalDetail.h	/^  pthread_key_t pthreadKey_;$/;"	m	struct:folly::threadlocal_detail::StaticMeta	access:public
folly::threadlocal_detail::StaticMeta::push_back	.\detail\ThreadLocalDetail.h	/^  void push_back(ThreadEntry* t) {$/;"	f	struct:folly::threadlocal_detail::StaticMeta	access:public	signature:(ThreadEntry* t)
folly::threadlocal_detail::StaticMeta::reserve	.\detail\ThreadLocalDetail.h	/^  static void reserve(int id) {$/;"	f	struct:folly::threadlocal_detail::StaticMeta	access:public	signature:(int id)
folly::threadlocal_detail::StaticMeta::threadEntry_	.\detail\ThreadLocalDetail.h	/^  static FOLLY_TLS ThreadEntry threadEntry_;$/;"	m	struct:folly::threadlocal_detail::StaticMeta	access:public
folly::threadlocal_detail::StaticMeta::~StaticMeta	.\detail\ThreadLocalDetail.h	/^  ~StaticMeta() {$/;"	f	struct:folly::threadlocal_detail::StaticMeta	access:public	signature:()
folly::threadlocal_detail::ThreadEntry	.\detail\ThreadLocalDetail.h	/^struct ThreadEntry {$/;"	s	namespace:folly::threadlocal_detail
folly::threadlocal_detail::ThreadEntry::elements	.\detail\ThreadLocalDetail.h	/^  ElementWrapper* elements;$/;"	m	struct:folly::threadlocal_detail::ThreadEntry	access:public
folly::threadlocal_detail::ThreadEntry::elementsCapacity	.\detail\ThreadLocalDetail.h	/^  size_t elementsCapacity;$/;"	m	struct:folly::threadlocal_detail::ThreadEntry	access:public
folly::threadlocal_detail::ThreadEntry::next	.\detail\ThreadLocalDetail.h	/^  ThreadEntry* next;$/;"	m	struct:folly::threadlocal_detail::ThreadEntry	access:public
folly::threadlocal_detail::ThreadEntry::prev	.\detail\ThreadLocalDetail.h	/^  ThreadEntry* prev;$/;"	m	struct:folly::threadlocal_detail::ThreadEntry	access:public
folly::throwOnFail	.\Exception.h	/^void throwOnFail(V&& value, Args&&... args) {$/;"	f	namespace:folly	signature:(V&& value, Args&&... args)
folly::throwSystemError	.\Exception.h	/^FOLLY_NORETURN void throwSystemError(Args&&... args);$/;"	p	namespace:folly	signature:(Args&&.... args)
folly::throwSystemError	.\Exception.h	/^void throwSystemError(Args&&... args) {$/;"	f	namespace:folly	signature:(Args&&.... args)
folly::throwSystemErrorExplicit	.\Exception.h	/^FOLLY_NORETURN void throwSystemErrorExplicit(int err, const char*);$/;"	p	namespace:folly	signature:(int err, const char*)
folly::throwSystemErrorExplicit	.\Exception.h	/^FOLLY_NORETURN void throwSystemErrorExplicit(int, Args&&... args);$/;"	p	namespace:folly	signature:(int, Args&&... args)
folly::throwSystemErrorExplicit	.\Exception.h	/^inline void throwSystemErrorExplicit(int err, const char* msg) {$/;"	f	namespace:folly	signature:(int err, const char* msg)
folly::throwSystemErrorExplicit	.\Exception.h	/^void throwSystemErrorExplicit(int err, Args&&... args) {$/;"	f	namespace:folly	signature:(int err, Args&&... args)
folly::to	.\Conv.h	/^to(const Src & value) {$/;"	f	namespace:folly	signature:(const Src & value)
folly::toAppend	.\Conv.h	/^toAppend(Src value, Tgt * result) {$/;"	f	namespace:folly	signature:(Src value, Tgt * result)
folly::toAppend	.\Conv.h	/^toAppend(StringPiece value, Tgt * result) {$/;"	f	namespace:folly	signature:(StringPiece value, Tgt * result)
folly::toAppend	.\Conv.h	/^toAppend(__int128 value, Tgt * result) {$/;"	f	namespace:folly	signature:(__int128 value, Tgt * result)
folly::toAppend	.\Conv.h	/^toAppend(const Src& value, Tgt * result) {$/;"	f	namespace:folly	signature:(const Src& value, Tgt * result)
folly::toAppend	.\Conv.h	/^toAppend(const fbstring& value, Tgt * result) {$/;"	f	namespace:folly	signature:(const fbstring& value, Tgt * result)
folly::toAppend	.\Conv.h	/^toAppend(unsigned __int128 value, Tgt * result) {$/;"	f	namespace:folly	signature:(unsigned __int128 value, Tgt * result)
folly::toAppend	.\Conv.h	/^void toAppend(char value, Tgt * result) {$/;"	f	namespace:folly	signature:(char value, Tgt * result)
folly::toAppend	.\IPAddress.cpp	/^void toAppend(IPAddress addr, fbstring* result) {$/;"	f	namespace:folly	signature:(IPAddress addr, fbstring* result)
folly::toAppend	.\IPAddress.cpp	/^void toAppend(IPAddress addr, string* result) {$/;"	f	namespace:folly	signature:(IPAddress addr, string* result)
folly::toAppend	.\IPAddress.h	/^void toAppend(IPAddress addr, fbstring* result);$/;"	p	namespace:folly	signature:(IPAddress addr, fbstring* result)
folly::toAppend	.\IPAddress.h	/^void toAppend(IPAddress addr, std::string* result);$/;"	p	namespace:folly	signature:(IPAddress addr, std::string* result)
folly::toAppend	.\IPAddressV4.cpp	/^void toAppend(IPAddressV4 addr, fbstring* result) {$/;"	f	namespace:folly	signature:(IPAddressV4 addr, fbstring* result)
folly::toAppend	.\IPAddressV4.cpp	/^void toAppend(IPAddressV4 addr, string* result) {$/;"	f	namespace:folly	signature:(IPAddressV4 addr, string* result)
folly::toAppend	.\IPAddressV4.h	/^void toAppend(IPAddressV4 addr, fbstring* result);$/;"	p	namespace:folly	signature:(IPAddressV4 addr, fbstring* result)
folly::toAppend	.\IPAddressV4.h	/^void toAppend(IPAddressV4 addr, std::string* result);$/;"	p	namespace:folly	signature:(IPAddressV4 addr, std::string* result)
folly::toAppend	.\IPAddressV6.cpp	/^void toAppend(IPAddressV6 addr, fbstring* result) {$/;"	f	namespace:folly	signature:(IPAddressV6 addr, fbstring* result)
folly::toAppend	.\IPAddressV6.cpp	/^void toAppend(IPAddressV6 addr, string* result) {$/;"	f	namespace:folly	signature:(IPAddressV6 addr, string* result)
folly::toAppend	.\IPAddressV6.h	/^void toAppend(IPAddressV6 addr, fbstring* result);$/;"	p	namespace:folly	signature:(IPAddressV6 addr, fbstring* result)
folly::toAppend	.\IPAddressV6.h	/^void toAppend(IPAddressV6 addr, std::string* result);$/;"	p	namespace:folly	signature:(IPAddressV6 addr, std::string* result)
folly::toAppend	.\MacAddress.h	/^toAppend(MacAddress address, Tgt* result) {$/;"	f	namespace:folly	signature:(MacAddress address, Tgt* result)
folly::toDynamic	.\DynamicConverter.h	/^  template <typename T> dynamic toDynamic(const T&);$/;"	p	namespace:folly	signature:(const T&)
folly::toDynamic	.\DynamicConverter.h	/^dynamic toDynamic(const T& x) {$/;"	f	namespace:folly	signature:(const T& x)
folly::toJson	.\json.cpp	/^fbstring toJson(dynamic const& dyn) {$/;"	f	namespace:folly	signature:(dynamic const& dyn)
folly::toJson	.\json.h	/^fbstring toJson(dynamic const&);$/;"	p	namespace:folly	signature:(dynamic const&)
folly::toLowerAscii	.\String.cpp	/^void toLowerAscii(char* str, size_t length) {$/;"	f	namespace:folly	signature:(char* str, size_t length)
folly::toPrettyJson	.\json.cpp	/^fbstring toPrettyJson(dynamic const& dyn) {$/;"	f	namespace:folly	signature:(dynamic const& dyn)
folly::toPrettyJson	.\json.h	/^fbstring toPrettyJson(dynamic const&);$/;"	p	namespace:folly	signature:(dynamic const&)
folly::toStdString	.\String.h	/^const std::string& toStdString(const std::string& s) {$/;"	f	namespace:folly	signature:(const std::string& s)
folly::toStdString	.\String.h	/^std::string toStdString(const folly::fbstring& s) {$/;"	f	namespace:folly	signature:(const folly::fbstring& s)
folly::toStdString	.\String.h	/^std::string&& toStdString(std::string&& s) {$/;"	f	namespace:folly	signature:(std::string&& s)
folly::traits_detail	.\Traits.h	/^namespace traits_detail {$/;"	n	namespace:folly
folly::truncateNoInt	.\FileUtil.cpp	/^int truncateNoInt(const char* path, off_t len) {$/;"	f	namespace:folly	signature:(const char* path, off_t len)
folly::truncateNoInt	.\FileUtil.h	/^int truncateNoInt(const char* path, off_t len);$/;"	p	namespace:folly	signature:(const char* path, off_t len)
folly::try_and_catch	.\ExceptionWrapper.h	/^class try_and_catch;$/;"	x
folly::try_and_catch	.\ExceptionWrapper.h	/^class try_and_catch<> : public exception_wrapper {$/;"	c	namespace:folly	inherits:exception_wrapper
folly::try_and_catch	.\ExceptionWrapper.h	/^class try_and_catch<LastException, Exceptions...> :$/;"	c	namespace:folly	inherits:try_and_catch
folly::try_and_catch::Base	.\ExceptionWrapper.h	/^  typedef try_and_catch<Exceptions...> Base;$/;"	t	class:folly::try_and_catch	access:protected
folly::try_and_catch::assign_eptr	.\ExceptionWrapper.h	/^  assign_eptr(Ex& e) {$/;"	f	class:folly::try_and_catch	access:protected	signature:(Ex& e)
folly::try_and_catch::assign_exception	.\ExceptionWrapper.h	/^  assign_exception(Ex& e) {$/;"	f	class:folly::try_and_catch	access:protected	signature:(Ex& e)
folly::try_and_catch::call_fn	.\ExceptionWrapper.h	/^  void call_fn(F&& fn) {$/;"	f	class:folly::try_and_catch	access:protected	signature:(F&& fn)
folly::try_and_catch::optimize	.\ExceptionWrapper.h	/^  struct optimize {$/;"	s	class:folly::try_and_catch	access:protected
folly::try_and_catch::optimize::value	.\ExceptionWrapper.h	/^    static const bool value =$/;"	m	struct:folly::try_and_catch::optimize	access:public
folly::try_and_catch::try_and_catch	.\ExceptionWrapper.h	/^  explicit try_and_catch(F&& fn) : Base() {$/;"	f	class:folly::try_and_catch	access:public	signature:(F&& fn)
folly::try_and_catch::try_and_catch	.\ExceptionWrapper.h	/^  try_and_catch() : Base() {}$/;"	f	class:folly::try_and_catch	access:protected	signature:()
folly::try_and_catch::try_and_catch	.\ExceptionWrapper.h	/^  try_and_catch() {}$/;"	f	class:folly::try_and_catch	access:public	signature:()
folly::uint64ToBufferUnsafe	.\Conv.h	/^inline uint32_t uint64ToBufferUnsafe(uint64_t v, char *const buffer) {$/;"	f	namespace:folly	signature:(uint64_t v, char *const buffer)
folly::unhexlify	.\String-inl.h	/^bool unhexlify(const InputString& input, OutputString& output) {$/;"	f	namespace:folly	signature:(const InputString& input, OutputString& output)
folly::unpack	.\IPAddressV6.cpp	/^static inline uint16_t unpack(uint8_t lobyte, uint8_t hibyte) {$/;"	f	namespace:folly	signature:(uint8_t lobyte, uint8_t hibyte)
folly::unpackInto	.\IPAddressV6.cpp	/^static inline void unpackInto(const unsigned char* src,$/;"	f	namespace:folly	signature:(const unsigned char* src, uint16_t* dest, size_t count)
folly::uriEscape	.\String-inl.h	/^void uriEscape(StringPiece str, String& out, UriEscapeMode mode) {$/;"	f	namespace:folly	signature:(StringPiece str, String& out, UriEscapeMode mode)
folly::uriUnescape	.\String-inl.h	/^void uriUnescape(StringPiece str, String& out, UriEscapeMode mode) {$/;"	f	namespace:folly	signature:(StringPiece str, String& out, UriEscapeMode mode)
folly::usingJEMallocSlow	.\Malloc.cpp	/^bool usingJEMallocSlow() {$/;"	f	namespace:folly	signature:()
folly::vformat	.\Format.h	/^Formatter<true, C> vformat(StringPiece fmt, C&& container);$/;"	p	namespace:folly	signature:(StringPiece fmt, C&& container)
folly::wangle	.\experimental\wangle\ConnectionManager.cpp	/^namespace folly { namespace wangle {$/;"	n	namespace:folly	file:
folly::wangle	.\experimental\wangle\ConnectionManager.h	/^namespace folly { namespace wangle {$/;"	n	namespace:folly
folly::wangle	.\experimental\wangle\ManagedConnection.cpp	/^namespace folly { namespace wangle {$/;"	n	namespace:folly	file:
folly::wangle	.\experimental\wangle\ManagedConnection.h	/^namespace folly { namespace wangle {$/;"	n	namespace:folly
folly::wangle	.\experimental\wangle\concurrent\BlockingQueue.h	/^namespace folly { namespace wangle {$/;"	n	namespace:folly
folly::wangle	.\experimental\wangle\concurrent\CPUThreadPoolExecutor.cpp	/^namespace folly { namespace wangle {$/;"	n	namespace:folly	file:
folly::wangle	.\experimental\wangle\concurrent\CPUThreadPoolExecutor.h	/^namespace folly { namespace wangle {$/;"	n	namespace:folly
folly::wangle	.\experimental\wangle\concurrent\Executor.h	/^namespace folly { namespace wangle {$/;"	n	namespace:folly
folly::wangle	.\experimental\wangle\concurrent\IOThreadPoolExecutor.cpp	/^namespace folly { namespace wangle {$/;"	n	namespace:folly	file:
folly::wangle	.\experimental\wangle\concurrent\IOThreadPoolExecutor.h	/^namespace folly { namespace wangle {$/;"	n	namespace:folly
folly::wangle	.\experimental\wangle\concurrent\LifoSemMPMCQueue.h	/^namespace folly { namespace wangle {$/;"	n	namespace:folly
folly::wangle	.\experimental\wangle\concurrent\NamedThreadFactory.h	/^namespace folly { namespace wangle {$/;"	n	namespace:folly
folly::wangle	.\experimental\wangle\concurrent\ThreadFactory.h	/^namespace folly { namespace wangle {$/;"	n	namespace:folly
folly::wangle	.\experimental\wangle\concurrent\ThreadPoolExecutor.cpp	/^namespace folly { namespace wangle {$/;"	n	namespace:folly	file:
folly::wangle	.\experimental\wangle\concurrent\ThreadPoolExecutor.h	/^namespace folly { namespace wangle {$/;"	n	namespace:folly
folly::wangle	.\wangle\Executor.h	/^namespace folly { namespace wangle {$/;"	n	namespace:folly
folly::wangle	.\wangle\Future-inl.h	/^namespace folly { namespace wangle {$/;"	n	namespace:folly
folly::wangle	.\wangle\Future.h	/^namespace folly { namespace wangle {$/;"	n	namespace:folly
folly::wangle	.\wangle\GenericThreadGate.h	/^namespace folly { namespace wangle {$/;"	n	namespace:folly
folly::wangle	.\wangle\InlineExecutor.h	/^namespace folly { namespace wangle {$/;"	n	namespace:folly
folly::wangle	.\wangle\Later-inl.h	/^namespace folly { namespace wangle {$/;"	n	namespace:folly
folly::wangle	.\wangle\Later.h	/^namespace folly { namespace wangle {$/;"	n	namespace:folly
folly::wangle	.\wangle\ManualExecutor.cpp	/^namespace folly { namespace wangle {$/;"	n	namespace:folly	file:
folly::wangle	.\wangle\ManualExecutor.h	/^namespace folly { namespace wangle {$/;"	n	namespace:folly
folly::wangle	.\wangle\OpaqueCallbackShunt.h	/^namespace folly { namespace wangle {$/;"	n	namespace:folly
folly::wangle	.\wangle\Promise-inl.h	/^namespace folly { namespace wangle {$/;"	n	namespace:folly
folly::wangle	.\wangle\Promise.h	/^namespace folly { namespace wangle {$/;"	n	namespace:folly
folly::wangle	.\wangle\QueuedImmediateExecutor.cpp	/^namespace folly { namespace wangle {$/;"	n	namespace:folly	file:
folly::wangle	.\wangle\QueuedImmediateExecutor.h	/^namespace folly { namespace wangle {$/;"	n	namespace:folly
folly::wangle	.\wangle\ThreadGate.cpp	/^namespace folly { namespace wangle {$/;"	n	namespace:folly	file:
folly::wangle	.\wangle\ThreadGate.h	/^namespace folly { namespace wangle {$/;"	n	namespace:folly
folly::wangle	.\wangle\Try-inl.h	/^namespace folly { namespace wangle {$/;"	n	namespace:folly
folly::wangle	.\wangle\Try.h	/^namespace folly { namespace wangle {$/;"	n	namespace:folly
folly::wangle	.\wangle\WangleException.h	/^namespace folly { namespace wangle {$/;"	n	namespace:folly
folly::wangle	.\wangle\detail\State.h	/^namespace folly { namespace wangle { namespace detail {$/;"	n	namespace:folly
folly::wangle::BlockingQueue	.\experimental\wangle\concurrent\BlockingQueue.h	/^class BlockingQueue {$/;"	c	namespace:folly::wangle
folly::wangle::BlockingQueue::add	.\experimental\wangle\concurrent\BlockingQueue.h	/^  virtual void add(T item) = 0;$/;"	p	class:folly::wangle::BlockingQueue	access:public	signature:(T item)
folly::wangle::BlockingQueue::size	.\experimental\wangle\concurrent\BlockingQueue.h	/^  virtual size_t size() = 0;$/;"	p	class:folly::wangle::BlockingQueue	access:public	signature:()
folly::wangle::BlockingQueue::take	.\experimental\wangle\concurrent\BlockingQueue.h	/^  virtual T take() = 0;$/;"	p	class:folly::wangle::BlockingQueue	access:public	signature:()
folly::wangle::BlockingQueue::~BlockingQueue	.\experimental\wangle\concurrent\BlockingQueue.h	/^  virtual ~BlockingQueue() {}$/;"	f	class:folly::wangle::BlockingQueue	access:public	signature:()
folly::wangle::BrokenPromise	.\wangle\WangleException.h	/^class BrokenPromise : public WangleException {$/;"	c	namespace:folly::wangle	inherits:WangleException
folly::wangle::BrokenPromise::BrokenPromise	.\wangle\WangleException.h	/^    explicit BrokenPromise() :$/;"	f	class:folly::wangle::BrokenPromise	access:public	signature:()
folly::wangle::CPUThreadPoolExecutor	.\experimental\wangle\concurrent\CPUThreadPoolExecutor.h	/^class CPUThreadPoolExecutor : public ThreadPoolExecutor {$/;"	c	namespace:folly::wangle	inherits:ThreadPoolExecutor
folly::wangle::CPUThreadPoolExecutor::CPUThreadPoolExecutor	.\experimental\wangle\concurrent\CPUThreadPoolExecutor.cpp	/^CPUThreadPoolExecutor::CPUThreadPoolExecutor($/;"	f	class:folly::wangle::CPUThreadPoolExecutor	signature:( size_t numThreads, std::unique_ptr<BlockingQueue<Task>> taskQueue, std::unique_ptr<ThreadFactory> threadFactory)
folly::wangle::CPUThreadPoolExecutor::CPUThreadPoolExecutor	.\experimental\wangle\concurrent\CPUThreadPoolExecutor.h	/^  explicit CPUThreadPoolExecutor($/;"	p	class:folly::wangle::CPUThreadPoolExecutor	access:public	signature:( size_t numThreads, std::unique_ptr<BlockingQueue<Task>> taskQueue = folly::make_unique<LifoSemMPMCQueue<Task>>( CPUThreadPoolExecutor::kDefaultMaxQueueSize), std::unique_ptr<ThreadFactory> threadFactory = folly::make_unique<NamedThreadFactory>())
folly::wangle::CPUThreadPoolExecutor::Task	.\experimental\wangle\concurrent\CPUThreadPoolExecutor.h	/^  struct Task {$/;"	s	class:folly::wangle::CPUThreadPoolExecutor	access:public
folly::wangle::CPUThreadPoolExecutor::Task	.\experimental\wangle\concurrent\CPUThreadPoolExecutor.h	/^  struct Task;$/;"	x
folly::wangle::CPUThreadPoolExecutor::Task::Task	.\experimental\wangle\concurrent\CPUThreadPoolExecutor.h	/^    Task() : func(nullptr), poison(true) {}$/;"	f	struct:folly::wangle::CPUThreadPoolExecutor::Task	access:public	signature:()
folly::wangle::CPUThreadPoolExecutor::Task::Task	.\experimental\wangle\concurrent\CPUThreadPoolExecutor.h	/^    Task(const Task&) = default;$/;"	p	struct:folly::wangle::CPUThreadPoolExecutor::Task	access:public	signature:(const Task&)
folly::wangle::CPUThreadPoolExecutor::Task::Task	.\experimental\wangle\concurrent\CPUThreadPoolExecutor.h	/^    explicit Task(Func&& taskArg) : func(std::move(taskArg)), poison(false) {}$/;"	f	struct:folly::wangle::CPUThreadPoolExecutor::Task	access:public	signature:(Func&& taskArg)
folly::wangle::CPUThreadPoolExecutor::Task::func	.\experimental\wangle\concurrent\CPUThreadPoolExecutor.h	/^    Func func;$/;"	m	struct:folly::wangle::CPUThreadPoolExecutor::Task	access:public
folly::wangle::CPUThreadPoolExecutor::Task::noexcept	.\experimental\wangle\concurrent\CPUThreadPoolExecutor.h	/^    Task(Task&& o) noexcept : func(std::move(o.func)), poison(o.poison) {}$/;"	m	struct:folly::wangle::CPUThreadPoolExecutor::Task	access:public
folly::wangle::CPUThreadPoolExecutor::Task::operator =	.\experimental\wangle\concurrent\CPUThreadPoolExecutor.h	/^    Task& operator=(const Task&) = default;$/;"	p	struct:folly::wangle::CPUThreadPoolExecutor::Task	access:public	signature:(const Task&)
folly::wangle::CPUThreadPoolExecutor::Task::poison	.\experimental\wangle\concurrent\CPUThreadPoolExecutor.h	/^    Task(Task&& o) noexcept : func(std::move(o.func)), poison(o.poison) {}$/;"	f	struct:folly::wangle::CPUThreadPoolExecutor::Task	access:public	signature:(o.poison)
folly::wangle::CPUThreadPoolExecutor::Task::poison	.\experimental\wangle\concurrent\CPUThreadPoolExecutor.h	/^    bool poison;$/;"	m	struct:folly::wangle::CPUThreadPoolExecutor::Task	access:public
folly::wangle::CPUThreadPoolExecutor::add	.\experimental\wangle\concurrent\CPUThreadPoolExecutor.cpp	/^void CPUThreadPoolExecutor::add(Func func) {$/;"	f	class:folly::wangle::CPUThreadPoolExecutor	signature:(Func func)
folly::wangle::CPUThreadPoolExecutor::kDefaultMaxQueueSize	.\experimental\wangle\concurrent\CPUThreadPoolExecutor.cpp	/^const size_t CPUThreadPoolExecutor::kDefaultMaxQueueSize = 1 << 18;$/;"	m	class:folly::wangle::CPUThreadPoolExecutor	file:
folly::wangle::CPUThreadPoolExecutor::kDefaultMaxQueueSize	.\experimental\wangle\concurrent\CPUThreadPoolExecutor.h	/^  static const size_t kDefaultMaxQueueSize;$/;"	m	class:folly::wangle::CPUThreadPoolExecutor	access:public
folly::wangle::CPUThreadPoolExecutor::override	.\experimental\wangle\concurrent\CPUThreadPoolExecutor.h	/^  void add(Func func) override;$/;"	m	class:folly::wangle::CPUThreadPoolExecutor	access:public
folly::wangle::CPUThreadPoolExecutor::override	.\experimental\wangle\concurrent\CPUThreadPoolExecutor.h	/^  void stopThreads(size_t n) override;$/;"	m	class:folly::wangle::CPUThreadPoolExecutor	access:private
folly::wangle::CPUThreadPoolExecutor::override	.\experimental\wangle\concurrent\CPUThreadPoolExecutor.h	/^  void threadRun(ThreadPtr thread) override;$/;"	m	class:folly::wangle::CPUThreadPoolExecutor	access:private
folly::wangle::CPUThreadPoolExecutor::stopThreads	.\experimental\wangle\concurrent\CPUThreadPoolExecutor.cpp	/^void CPUThreadPoolExecutor::stopThreads(size_t n) {$/;"	f	class:folly::wangle::CPUThreadPoolExecutor	signature:(size_t n)
folly::wangle::CPUThreadPoolExecutor::taskQueue_	.\experimental\wangle\concurrent\CPUThreadPoolExecutor.h	/^  std::unique_ptr<BlockingQueue<Task>> taskQueue_;$/;"	m	class:folly::wangle::CPUThreadPoolExecutor	access:private
folly::wangle::CPUThreadPoolExecutor::threadRun	.\experimental\wangle\concurrent\CPUThreadPoolExecutor.cpp	/^void CPUThreadPoolExecutor::threadRun(std::shared_ptr<Thread> thread) {$/;"	f	class:folly::wangle::CPUThreadPoolExecutor	signature:(std::shared_ptr<Thread> thread)
folly::wangle::CPUThreadPoolExecutor::~CPUThreadPoolExecutor	.\experimental\wangle\concurrent\CPUThreadPoolExecutor.cpp	/^CPUThreadPoolExecutor::~CPUThreadPoolExecutor() {$/;"	f	class:folly::wangle::CPUThreadPoolExecutor	signature:()
folly::wangle::CPUThreadPoolExecutor::~CPUThreadPoolExecutor	.\experimental\wangle\concurrent\CPUThreadPoolExecutor.h	/^  ~CPUThreadPoolExecutor();$/;"	p	class:folly::wangle::CPUThreadPoolExecutor	access:public	signature:()
folly::wangle::ConnectionManager	.\experimental\wangle\ConnectionManager.h	/^class ConnectionManager: public folly::DelayedDestruction {$/;"	c	namespace:folly::wangle	inherits:folly::DelayedDestruction
folly::wangle::ConnectionManager	.\experimental\wangle\ManagedConnection.h	/^class ConnectionManager;$/;"	x
folly::wangle::ConnectionManager::Callback	.\experimental\wangle\ConnectionManager.h	/^  class Callback {$/;"	c	class:folly::wangle::ConnectionManager	access:public
folly::wangle::ConnectionManager::Callback::onConnectionAdded	.\experimental\wangle\ConnectionManager.h	/^    virtual void onConnectionAdded(const ConnectionManager& cm) = 0;$/;"	p	class:folly::wangle::ConnectionManager::Callback	access:public	signature:(const ConnectionManager& cm)
folly::wangle::ConnectionManager::Callback::onConnectionRemoved	.\experimental\wangle\ConnectionManager.h	/^    virtual void onConnectionRemoved(const ConnectionManager& cm) = 0;$/;"	p	class:folly::wangle::ConnectionManager::Callback	access:public	signature:(const ConnectionManager& cm)
folly::wangle::ConnectionManager::Callback::onEmpty	.\experimental\wangle\ConnectionManager.h	/^    virtual void onEmpty(const ConnectionManager& cm) = 0;$/;"	p	class:folly::wangle::ConnectionManager::Callback	access:public	signature:(const ConnectionManager& cm)
folly::wangle::ConnectionManager::Callback::~Callback	.\experimental\wangle\ConnectionManager.h	/^    virtual ~Callback() {}$/;"	f	class:folly::wangle::ConnectionManager::Callback	access:public	signature:()
folly::wangle::ConnectionManager::CloseIdleConnsCallback	.\experimental\wangle\ConnectionManager.h	/^  class CloseIdleConnsCallback :$/;"	c	class:folly::wangle::ConnectionManager	inherits:folly::EventBase::LoopCallback,folly::AsyncTimeout	access:private
folly::wangle::ConnectionManager::CloseIdleConnsCallback::CloseIdleConnsCallback	.\experimental\wangle\ConnectionManager.h	/^    explicit CloseIdleConnsCallback(ConnectionManager* manager)$/;"	f	class:folly::wangle::ConnectionManager::CloseIdleConnsCallback	access:public	signature:(ConnectionManager* manager)
folly::wangle::ConnectionManager::CloseIdleConnsCallback::manager_	.\experimental\wangle\ConnectionManager.h	/^    ConnectionManager* manager_;$/;"	m	class:folly::wangle::ConnectionManager::CloseIdleConnsCallback	access:private
folly::wangle::ConnectionManager::ConnectionManager	.\experimental\wangle\ConnectionManager.cpp	/^ConnectionManager::ConnectionManager(EventBase* eventBase,$/;"	f	class:folly::wangle::ConnectionManager	signature:(EventBase* eventBase, milliseconds timeout, Callback* callback)
folly::wangle::ConnectionManager::ConnectionManager	.\experimental\wangle\ConnectionManager.h	/^  ConnectionManager(const ConnectionManager&) = delete;$/;"	p	class:folly::wangle::ConnectionManager	access:private	signature:(const ConnectionManager&)
folly::wangle::ConnectionManager::ConnectionManager	.\experimental\wangle\ConnectionManager.h	/^  ConnectionManager(folly::EventBase* eventBase,$/;"	p	class:folly::wangle::ConnectionManager	access:public	signature:(folly::EventBase* eventBase, std::chrono::milliseconds timeout, Callback* callback = nullptr)
folly::wangle::ConnectionManager::ShutdownAction	.\experimental\wangle\ConnectionManager.h	/^  enum class ShutdownAction : uint8_t {$/;"	c	class:folly::wangle::ConnectionManager	inherits:uint8_t	access:private
folly::wangle::ConnectionManager::ShutdownAction::DRAIN1	.\experimental\wangle\ConnectionManager.h	/^    DRAIN1 = 0,$/;"	m	class:folly::wangle::ConnectionManager::ShutdownAction	access:private
folly::wangle::ConnectionManager::ShutdownAction::DRAIN2	.\experimental\wangle\ConnectionManager.h	/^    DRAIN2 = 1,$/;"	m	class:folly::wangle::ConnectionManager::ShutdownAction	access:private
folly::wangle::ConnectionManager::UniquePtr	.\experimental\wangle\ConnectionManager.h	/^  typedef std::unique_ptr<ConnectionManager, Destructor> UniquePtr;$/;"	t	class:folly::wangle::ConnectionManager	access:public
folly::wangle::ConnectionManager::addConnection	.\experimental\wangle\ConnectionManager.cpp	/^ConnectionManager::addConnection(ManagedConnection* connection,$/;"	f	class:folly::wangle::ConnectionManager	signature:(ManagedConnection* connection, bool timeout)
folly::wangle::ConnectionManager::addConnection	.\experimental\wangle\ConnectionManager.h	/^  void addConnection(ManagedConnection* connection,$/;"	p	class:folly::wangle::ConnectionManager	access:public	signature:(ManagedConnection* connection, bool timeout = false)
folly::wangle::ConnectionManager::callback_	.\experimental\wangle\ConnectionManager.h	/^  Callback* callback_;$/;"	m	class:folly::wangle::ConnectionManager	access:private
folly::wangle::ConnectionManager::connTimeouts_	.\experimental\wangle\ConnectionManager.h	/^  folly::HHWheelTimer::UniquePtr connTimeouts_;$/;"	m	class:folly::wangle::ConnectionManager	access:private
folly::wangle::ConnectionManager::conns_	.\experimental\wangle\ConnectionManager.h	/^    ManagedConnection,&ManagedConnection::listHook_> conns_;$/;"	m	class:folly::wangle::ConnectionManager	access:private
folly::wangle::ConnectionManager::drainAllConnections	.\experimental\wangle\ConnectionManager.cpp	/^ConnectionManager::drainAllConnections() {$/;"	f	class:folly::wangle::ConnectionManager	signature:()
folly::wangle::ConnectionManager::drainAllConnections	.\experimental\wangle\ConnectionManager.h	/^  void drainAllConnections();$/;"	p	class:folly::wangle::ConnectionManager	access:private	signature:()
folly::wangle::ConnectionManager::dropAllConnections	.\experimental\wangle\ConnectionManager.cpp	/^ConnectionManager::dropAllConnections() {$/;"	f	class:folly::wangle::ConnectionManager	signature:()
folly::wangle::ConnectionManager::dropAllConnections	.\experimental\wangle\ConnectionManager.h	/^  void dropAllConnections();$/;"	p	class:folly::wangle::ConnectionManager	access:public	signature:()
folly::wangle::ConnectionManager::eventBase_	.\experimental\wangle\ConnectionManager.h	/^  folly::EventBase* eventBase_;$/;"	m	class:folly::wangle::ConnectionManager	access:private
folly::wangle::ConnectionManager::getNumConnections	.\experimental\wangle\ConnectionManager.h	/^  size_t getNumConnections() const { return conns_.size(); }$/;"	f	class:folly::wangle::ConnectionManager	access:public	signature:() const
folly::wangle::ConnectionManager::idleIterator_	.\experimental\wangle\ConnectionManager.h	/^    ManagedConnection,&ManagedConnection::listHook_>::iterator idleIterator_;$/;"	m	class:folly::wangle::ConnectionManager	access:private
folly::wangle::ConnectionManager::idleLoopCallback_	.\experimental\wangle\ConnectionManager.h	/^  CloseIdleConnsCallback idleLoopCallback_;$/;"	m	class:folly::wangle::ConnectionManager	access:private
folly::wangle::ConnectionManager::initiateGracefulShutdown	.\experimental\wangle\ConnectionManager.cpp	/^ConnectionManager::initiateGracefulShutdown($/;"	f	class:folly::wangle::ConnectionManager	signature:( std::chrono::milliseconds idleGrace)
folly::wangle::ConnectionManager::initiateGracefulShutdown	.\experimental\wangle\ConnectionManager.h	/^  void initiateGracefulShutdown(std::chrono::milliseconds idleGrace);$/;"	p	class:folly::wangle::ConnectionManager	access:public	signature:(std::chrono::milliseconds idleGrace)
folly::wangle::ConnectionManager::makeUnique	.\experimental\wangle\ConnectionManager.h	/^  static UniquePtr makeUnique(Args&&... args) {$/;"	f	class:folly::wangle::ConnectionManager	access:public	signature:(Args&&.... args)
folly::wangle::ConnectionManager::operator =	.\experimental\wangle\ConnectionManager.h	/^  ConnectionManager& operator=(ConnectionManager&) = delete;$/;"	p	class:folly::wangle::ConnectionManager	access:private	signature:(ConnectionManager&)
folly::wangle::ConnectionManager::removeConnection	.\experimental\wangle\ConnectionManager.cpp	/^ConnectionManager::removeConnection(ManagedConnection* connection) {$/;"	f	class:folly::wangle::ConnectionManager	signature:(ManagedConnection* connection)
folly::wangle::ConnectionManager::removeConnection	.\experimental\wangle\ConnectionManager.h	/^  void removeConnection(ManagedConnection* connection);$/;"	p	class:folly::wangle::ConnectionManager	access:public	signature:(ManagedConnection* connection)
folly::wangle::ConnectionManager::scheduleTimeout	.\experimental\wangle\ConnectionManager.cpp	/^ConnectionManager::scheduleTimeout(ManagedConnection* connection) {$/;"	f	class:folly::wangle::ConnectionManager	signature:(ManagedConnection* connection)
folly::wangle::ConnectionManager::scheduleTimeout	.\experimental\wangle\ConnectionManager.cpp	/^void ConnectionManager::scheduleTimeout($/;"	f	class:folly::wangle::ConnectionManager	signature:( folly::HHWheelTimer::Callback* callback, std::chrono::milliseconds timeout)
folly::wangle::ConnectionManager::scheduleTimeout	.\experimental\wangle\ConnectionManager.h	/^  void scheduleTimeout(ManagedConnection* connection);$/;"	p	class:folly::wangle::ConnectionManager	access:public	signature:(ManagedConnection* connection)
folly::wangle::ConnectionManager::scheduleTimeout	.\experimental\wangle\ConnectionManager.h	/^  void scheduleTimeout(folly::HHWheelTimer::Callback* callback,$/;"	p	class:folly::wangle::ConnectionManager	access:public	signature:(folly::HHWheelTimer::Callback* callback, std::chrono::milliseconds timeout)
folly::wangle::ConnectionManager::timeout_	.\experimental\wangle\ConnectionManager.h	/^  std::chrono::milliseconds timeout_;$/;"	m	class:folly::wangle::ConnectionManager	access:private
folly::wangle::ConnectionManager::~ConnectionManager	.\experimental\wangle\ConnectionManager.h	/^  ~ConnectionManager() {}$/;"	f	class:folly::wangle::ConnectionManager	access:private	signature:()
folly::wangle::Executor	.\experimental\wangle\concurrent\Executor.h	/^class Executor {$/;"	c	namespace:folly::wangle
folly::wangle::Executor	.\wangle\Executor.h	/^  class Executor : boost::noncopyable {$/;"	c	namespace:folly::wangle	inherits:boost::noncopyable
folly::wangle::Executor::Action	.\wangle\Executor.h	/^     typedef std::function<void()> Action;$/;"	t	class:folly::wangle::Executor	access:public
folly::wangle::Executor::Duration	.\wangle\Executor.h	/^     typedef std::chrono::microseconds Duration;$/;"	t	class:folly::wangle::Executor	access:public
folly::wangle::Executor::TimePoint	.\wangle\Executor.h	/^     typedef std::chrono::steady_clock::time_point TimePoint;$/;"	t	class:folly::wangle::Executor	access:public
folly::wangle::Executor::add	.\experimental\wangle\concurrent\Executor.h	/^  virtual void add(Func func) = 0;$/;"	p	class:folly::wangle::Executor	access:public	signature:(Func func)
folly::wangle::Executor::add	.\wangle\Executor.h	/^     virtual void add(Action&&) = 0;$/;"	p	class:folly::wangle::Executor	access:public	signature:(Action&&)
folly::wangle::Executor::addPtr	.\wangle\Executor.h	/^     void addPtr(P fn) {$/;"	f	class:folly::wangle::Executor	access:public	signature:(P fn)
folly::wangle::Executor::now	.\wangle\Executor.h	/^     virtual TimePoint now() {$/;"	f	class:folly::wangle::Executor	access:public	signature:()
folly::wangle::Executor::schedule	.\wangle\Executor.h	/^     void schedule(Action&& a) { add(std::move(a)); }$/;"	f	class:folly::wangle::Executor	access:public	signature:(Action&& a)
folly::wangle::Executor::schedule	.\wangle\Executor.h	/^     void schedule(Action&& a, Duration const& dur) {$/;"	f	class:folly::wangle::Executor	access:public	signature:(Action&& a, Duration const& dur)
folly::wangle::Executor::scheduleAt	.\wangle\Executor.h	/^     virtual void scheduleAt(Action&& a, TimePoint const& t) {$/;"	f	class:folly::wangle::Executor	access:public	signature:(Action&& a, TimePoint const& t)
folly::wangle::Executor::~Executor	.\experimental\wangle\concurrent\Executor.h	/^  virtual ~Executor() {};$/;"	f	class:folly::wangle::Executor	access:public	signature:()
folly::wangle::Executor::~Executor	.\wangle\Executor.h	/^     virtual ~Executor() = default;$/;"	p	class:folly::wangle::Executor	access:public	signature:()
folly::wangle::Func	.\experimental\wangle\concurrent\Executor.h	/^typedef std::function<void()> Func;$/;"	t	namespace:folly::wangle
folly::wangle::Future	.\wangle\Future.h	/^  -> Future<decltype(func())>;$/;"	m	namespace:folly::wangle
folly::wangle::Future	.\wangle\Future.h	/^class Future {$/;"	c	namespace:folly::wangle
folly::wangle::Future	.\wangle\Promise.h	/^template <class T> class Future;$/;"	x
folly::wangle::Future::Future	.\wangle\Future.h	/^  Future(Future const&) = delete;$/;"	p	class:folly::wangle::Future	access:public	signature:(Future const&)
folly::wangle::Future::Future	.\wangle\Future.h	/^  Future(statePtr obj) : state_(obj) {}$/;"	f	class:folly::wangle::Future	access:private	signature:(statePtr obj)
folly::wangle::Future::Promise	.\wangle\Future.h	/^  friend class Promise<T>;$/;"	x
folly::wangle::Future::activate	.\wangle\Future.h	/^  void activate() {$/;"	f	class:folly::wangle::Future	access:public	signature:()
folly::wangle::Future::deactivate	.\wangle\Future.h	/^  void deactivate() {$/;"	f	class:folly::wangle::Future	access:public	signature:()
folly::wangle::Future::detach	.\wangle\Future-inl.h	/^void Future<T>::detach() {$/;"	f	class:folly::wangle::Future	signature:()
folly::wangle::Future::detach	.\wangle\Future.h	/^  void detach();$/;"	p	class:folly::wangle::Future	access:private	signature:()
folly::wangle::Future::getTry	.\wangle\Future-inl.h	/^Try<T>& Future<T>::getTry() {$/;"	f	class:folly::wangle::Future	signature:()
folly::wangle::Future::getTry	.\wangle\Future.h	/^  Try<T>& getTry();$/;"	p	class:folly::wangle::Future	access:public	signature:()
folly::wangle::Future::isReady	.\wangle\Future-inl.h	/^bool Future<T>::isReady() const {$/;"	f	class:folly::wangle::Future	signature:() const
folly::wangle::Future::isReady	.\wangle\Future.h	/^  bool isReady() const;$/;"	p	class:folly::wangle::Future	access:public	signature:() const
folly::wangle::Future::noexcept	.\wangle\Future.h	/^  Future(Future&&) noexcept;$/;"	m	class:folly::wangle::Future	access:public
folly::wangle::Future::operator =	.\wangle\Future-inl.h	/^Future<T>& Future<T>::operator=(Future<T>&& other) {$/;"	f	class:folly::wangle::Future	signature:(Future<T>&& other)
folly::wangle::Future::operator =	.\wangle\Future.h	/^  Future& operator=(Future const&) = delete;$/;"	p	class:folly::wangle::Future	access:public	signature:(Future const&)
folly::wangle::Future::operator =	.\wangle\Future.h	/^  Future& operator=(Future&&);$/;"	p	class:folly::wangle::Future	access:public	signature:(Future&&)
folly::wangle::Future::setCallback_	.\wangle\Future-inl.h	/^void Future<T>::setCallback_(F&& func) {$/;"	f	class:folly::wangle::Future	signature:(F&& func)
folly::wangle::Future::setCallback_	.\wangle\Future.h	/^  void setCallback_(F&& func);$/;"	p	class:folly::wangle::Future	access:public	signature:(F&& func)
folly::wangle::Future::statePtr	.\wangle\Future.h	/^  typedef detail::State<T>* statePtr;$/;"	t	class:folly::wangle::Future	access:private
folly::wangle::Future::state_	.\wangle\Future.h	/^  statePtr state_;$/;"	m	class:folly::wangle::Future	access:private
folly::wangle::Future::std::enable_if::then	.\wangle\Future.h	/^  inline then(Caller *instance, R(Caller::*func)(Try<T>&&)) {$/;"	f	class:folly::wangle::Future::std::enable_if	access:public	signature:(Caller *instance, R(Caller::*func)(Try<T>&&))
folly::wangle::Future::std::enable_if::then	.\wangle\Future.h	/^  inline then(R(*func)(Try<T>&&)) {$/;"	f	class:folly::wangle::Future::std::enable_if	access:public	signature:(R(func)Try<T>&&))
folly::wangle::Future::then	.\wangle\Future-inl.h	/^Future<T>::then(F&& func) {$/;"	f	class:folly::wangle::Future	signature:(F&& func)
folly::wangle::Future::then	.\wangle\Future-inl.h	/^Future<void> Future<T>::then() {$/;"	f	class:folly::wangle::Future	signature:()
folly::wangle::Future::then	.\wangle\Future.h	/^  Future<void> then();$/;"	p	class:folly::wangle::Future	access:public	signature:()
folly::wangle::Future::then	.\wangle\Future.h	/^  then(F&& func);$/;"	p	class:folly::wangle::Future	access:public	signature:(F&& func)
folly::wangle::Future::throwIfInvalid	.\wangle\Future-inl.h	/^void Future<T>::throwIfInvalid() const {$/;"	f	class:folly::wangle::Future	signature:() const
folly::wangle::Future::throwIfInvalid	.\wangle\Future.h	/^  void throwIfInvalid() const;$/;"	p	class:folly::wangle::Future	access:private	signature:() const
folly::wangle::Future::value	.\wangle\Future-inl.h	/^typename std::add_lvalue_reference<T>::type Future<T>::value() {$/;"	f	class:folly::wangle::Future	signature:()
folly::wangle::Future::value	.\wangle\Future-inl.h	/^typename std::add_lvalue_reference<const T>::type Future<T>::value() const {$/;"	f	class:folly::wangle::Future	signature:() const
folly::wangle::Future::value	.\wangle\Future.h	/^  value() const;$/;"	p	class:folly::wangle::Future	access:public	signature:() const
folly::wangle::Future::value	.\wangle\Future.h	/^  value();$/;"	p	class:folly::wangle::Future	access:public	signature:()
folly::wangle::Future::value_type	.\wangle\Future.h	/^  typedef T value_type;$/;"	t	class:folly::wangle::Future	access:public
folly::wangle::Future::via	.\wangle\Future-inl.h	/^inline Future<T> Future<T>::via(Executor* executor) {$/;"	f	class:folly::wangle::Future	signature:(Executor* executor)
folly::wangle::Future::via	.\wangle\Future.h	/^  Future<T> via(Executor* executor);$/;"	p	class:folly::wangle::Future	access:public	signature:(Executor* executor)
folly::wangle::Future::~Future	.\wangle\Future-inl.h	/^Future<T>::~Future() {$/;"	f	class:folly::wangle::Future	signature:()
folly::wangle::Future::~Future	.\wangle\Future.h	/^  ~Future();$/;"	p	class:folly::wangle::Future	access:public	signature:()
folly::wangle::FutureAlreadyRetrieved	.\wangle\WangleException.h	/^class FutureAlreadyRetrieved : public WangleException {$/;"	c	namespace:folly::wangle	inherits:WangleException
folly::wangle::FutureAlreadyRetrieved::FutureAlreadyRetrieved	.\wangle\WangleException.h	/^    explicit FutureAlreadyRetrieved () :$/;"	f	class:folly::wangle::FutureAlreadyRetrieved	access:public	signature:()
folly::wangle::FutureNotReady	.\wangle\WangleException.h	/^class FutureNotReady : public WangleException {$/;"	c	namespace:folly::wangle	inherits:WangleException
folly::wangle::FutureNotReady::FutureNotReady	.\wangle\WangleException.h	/^    explicit FutureNotReady() :$/;"	f	class:folly::wangle::FutureNotReady	access:public	signature:()
folly::wangle::GenericThreadGate	.\wangle\GenericThreadGate.h	/^class GenericThreadGate : public ThreadGate {$/;"	c	namespace:folly::wangle	inherits:ThreadGate
folly::wangle::GenericThreadGate::GenericThreadGate	.\wangle\GenericThreadGate.h	/^  GenericThreadGate(WestExecutorPtr west,$/;"	f	class:folly::wangle::GenericThreadGate	access:public	signature:(WestExecutorPtr west, EastExecutorPtr east, WaiterPtr waiter = nullptr)
folly::wangle::GenericThreadGate::addEast	.\wangle\GenericThreadGate.h	/^  void addEast(std::function<void()>&& fn) { eastExecutor->add(std::move(fn)); }$/;"	f	class:folly::wangle::GenericThreadGate	access:public	signature:(std::function<void()>&& fn)
folly::wangle::GenericThreadGate::addWest	.\wangle\GenericThreadGate.h	/^  void addWest(std::function<void()>&& fn) { westExecutor->add(std::move(fn)); }$/;"	f	class:folly::wangle::GenericThreadGate	access:public	signature:(std::function<void()>&& fn)
folly::wangle::GenericThreadGate::eastExecutor	.\wangle\GenericThreadGate.h	/^  EastExecutorPtr eastExecutor;$/;"	m	class:folly::wangle::GenericThreadGate	access:public
folly::wangle::GenericThreadGate::makeProgress	.\wangle\GenericThreadGate.h	/^  virtual void makeProgress() {$/;"	f	class:folly::wangle::GenericThreadGate	access:public	signature:()
folly::wangle::GenericThreadGate::makeProgress_	.\wangle\GenericThreadGate.h	/^  void makeProgress_(std::false_type const&) {$/;"	f	class:folly::wangle::GenericThreadGate	access:private	signature:(std::false_type const&)
folly::wangle::GenericThreadGate::makeProgress_	.\wangle\GenericThreadGate.h	/^  void makeProgress_(std::true_type const&) {$/;"	f	class:folly::wangle::GenericThreadGate	access:private	signature:(std::true_type const&)
folly::wangle::GenericThreadGate::waiter	.\wangle\GenericThreadGate.h	/^  WaiterPtr waiter;$/;"	m	class:folly::wangle::GenericThreadGate	access:public
folly::wangle::GenericThreadGate::westExecutor	.\wangle\GenericThreadGate.h	/^  WestExecutorPtr westExecutor;$/;"	m	class:folly::wangle::GenericThreadGate	access:public
folly::wangle::IOThreadPoolExecutor	.\experimental\wangle\concurrent\IOThreadPoolExecutor.h	/^class IOThreadPoolExecutor : public ThreadPoolExecutor {$/;"	c	namespace:folly::wangle	inherits:ThreadPoolExecutor
folly::wangle::IOThreadPoolExecutor::IOThread	.\experimental\wangle\concurrent\IOThreadPoolExecutor.h	/^  struct FOLLY_ALIGN_TO_AVOID_FALSE_SHARING IOThread : public Thread {$/;"	s	class:folly::wangle::IOThreadPoolExecutor	inherits:Thread	access:private
folly::wangle::IOThreadPoolExecutor::IOThread::IOThread	.\experimental\wangle\concurrent\IOThreadPoolExecutor.h	/^    IOThread() : shouldRun(true), outstandingTasks(0) {};$/;"	f	struct:folly::wangle::IOThreadPoolExecutor::IOThread	access:public	signature:()
folly::wangle::IOThreadPoolExecutor::IOThread::eventBase	.\experimental\wangle\concurrent\IOThreadPoolExecutor.h	/^    EventBase eventBase;$/;"	m	struct:folly::wangle::IOThreadPoolExecutor::IOThread	access:public
folly::wangle::IOThreadPoolExecutor::IOThread::outstandingTasks	.\experimental\wangle\concurrent\IOThreadPoolExecutor.h	/^    std::atomic<size_t> outstandingTasks;$/;"	m	struct:folly::wangle::IOThreadPoolExecutor::IOThread	access:public
folly::wangle::IOThreadPoolExecutor::IOThread::shouldRun	.\experimental\wangle\concurrent\IOThreadPoolExecutor.h	/^    std::atomic<bool> shouldRun;$/;"	m	struct:folly::wangle::IOThreadPoolExecutor::IOThread	access:public
folly::wangle::IOThreadPoolExecutor::IOThreadPoolExecutor	.\experimental\wangle\concurrent\IOThreadPoolExecutor.cpp	/^IOThreadPoolExecutor::IOThreadPoolExecutor($/;"	f	class:folly::wangle::IOThreadPoolExecutor	signature:( size_t numThreads, std::unique_ptr<ThreadFactory> threadFactory)
folly::wangle::IOThreadPoolExecutor::IOThreadPoolExecutor	.\experimental\wangle\concurrent\IOThreadPoolExecutor.h	/^  explicit IOThreadPoolExecutor($/;"	p	class:folly::wangle::IOThreadPoolExecutor	access:public	signature:( size_t numThreads, std::unique_ptr<ThreadFactory> threadFactory = folly::make_unique<NamedThreadFactory>())
folly::wangle::IOThreadPoolExecutor::add	.\experimental\wangle\concurrent\IOThreadPoolExecutor.cpp	/^void IOThreadPoolExecutor::add(Func func) {$/;"	f	class:folly::wangle::IOThreadPoolExecutor	signature:(Func func)
folly::wangle::IOThreadPoolExecutor::makeThread	.\experimental\wangle\concurrent\IOThreadPoolExecutor.cpp	/^IOThreadPoolExecutor::makeThread() {$/;"	f	class:folly::wangle::IOThreadPoolExecutor	signature:()
folly::wangle::IOThreadPoolExecutor::nextThread_	.\experimental\wangle\concurrent\IOThreadPoolExecutor.h	/^  size_t nextThread_;$/;"	m	class:folly::wangle::IOThreadPoolExecutor	access:private
folly::wangle::IOThreadPoolExecutor::override	.\experimental\wangle\concurrent\IOThreadPoolExecutor.h	/^  ThreadPtr makeThread() override;$/;"	m	class:folly::wangle::IOThreadPoolExecutor	access:private
folly::wangle::IOThreadPoolExecutor::override	.\experimental\wangle\concurrent\IOThreadPoolExecutor.h	/^  void add(Func func) override;$/;"	m	class:folly::wangle::IOThreadPoolExecutor	access:public
folly::wangle::IOThreadPoolExecutor::override	.\experimental\wangle\concurrent\IOThreadPoolExecutor.h	/^  void stopThreads(size_t n) override;$/;"	m	class:folly::wangle::IOThreadPoolExecutor	access:private
folly::wangle::IOThreadPoolExecutor::override	.\experimental\wangle\concurrent\IOThreadPoolExecutor.h	/^  void threadRun(ThreadPtr thread) override;$/;"	m	class:folly::wangle::IOThreadPoolExecutor	access:private
folly::wangle::IOThreadPoolExecutor::stopThreads	.\experimental\wangle\concurrent\IOThreadPoolExecutor.cpp	/^void IOThreadPoolExecutor::stopThreads(size_t n) {$/;"	f	class:folly::wangle::IOThreadPoolExecutor	signature:(size_t n)
folly::wangle::IOThreadPoolExecutor::threadRun	.\experimental\wangle\concurrent\IOThreadPoolExecutor.cpp	/^void IOThreadPoolExecutor::threadRun(ThreadPtr thread) {$/;"	f	class:folly::wangle::IOThreadPoolExecutor	signature:(ThreadPtr thread)
folly::wangle::IOThreadPoolExecutor::~IOThreadPoolExecutor	.\experimental\wangle\concurrent\IOThreadPoolExecutor.cpp	/^IOThreadPoolExecutor::~IOThreadPoolExecutor() {$/;"	f	class:folly::wangle::IOThreadPoolExecutor	signature:()
folly::wangle::IOThreadPoolExecutor::~IOThreadPoolExecutor	.\experimental\wangle\concurrent\IOThreadPoolExecutor.h	/^  ~IOThreadPoolExecutor();$/;"	p	class:folly::wangle::IOThreadPoolExecutor	access:public	signature:()
folly::wangle::InlineExecutor	.\wangle\InlineExecutor.h	/^  class InlineExecutor : public Executor {$/;"	c	namespace:folly::wangle	inherits:Executor
folly::wangle::Later	.\wangle\Later.h	/^class Later {$/;"	c	namespace:folly::wangle
folly::wangle::Later::Later	.\wangle\Later-inl.h	/^Later<T>::Later() {$/;"	f	class:folly::wangle::Later	signature:()
folly::wangle::Later::Later	.\wangle\Later-inl.h	/^Later<T>::Later(E const& e) :$/;"	f	class:folly::wangle::Later	signature:(E const& e)
folly::wangle::Later::Later	.\wangle\Later-inl.h	/^Later<T>::Later(Future<T>&& f) {$/;"	f	class:folly::wangle::Later	signature:(Future<T>&& f)
folly::wangle::Later::Later	.\wangle\Later-inl.h	/^Later<T>::Later(Promise<void>&& starter)$/;"	f	class:folly::wangle::Later	signature:(Promise<void>&& starter)
folly::wangle::Later::Later	.\wangle\Later-inl.h	/^Later<T>::Later(U&& input) {$/;"	f	class:folly::wangle::Later	signature:(U&& input)
folly::wangle::Later::Later	.\wangle\Later-inl.h	/^Later<T>::Later(std::exception_ptr const& eptr) {$/;"	f	class:folly::wangle::Later	signature:(std::exception_ptr const& eptr)
folly::wangle::Later::Later	.\wangle\Later-inl.h	/^Later<T>::Later(std::function<void(std::function<void(U&&)>&&)>&& fn) {$/;"	f	class:folly::wangle::Later	signature:(std::function<void(std::function<void(U&&)>&&)>&& fn)
folly::wangle::Later::Later	.\wangle\Later.h	/^  Later();$/;"	p	class:folly::wangle::Later	access:public	signature:()
folly::wangle::Later::Later	.\wangle\Later.h	/^  \/* implicit *\/ Later(Future<T>&& f);$/;"	p	class:folly::wangle::Later	access:public	signature:(Future<T>&& f)
folly::wangle::Later::Later	.\wangle\Later.h	/^  explicit Later(E const& e);$/;"	p	class:folly::wangle::Later	access:public	signature:(E const& e)
folly::wangle::Later::Later	.\wangle\Later.h	/^  explicit Later(Promise<void>&& starter);$/;"	p	class:folly::wangle::Later	access:private	signature:(Promise<void>&& starter)
folly::wangle::Later::Later	.\wangle\Later.h	/^  explicit Later(U&& input);$/;"	p	class:folly::wangle::Later	access:public	signature:(U&& input)
folly::wangle::Later::Later	.\wangle\Later.h	/^  explicit Later(std::exception_ptr const&);$/;"	p	class:folly::wangle::Later	access:public	signature:(std::exception_ptr const&)
folly::wangle::Later::Later	.\wangle\Later.h	/^  explicit Later(std::function<void(std::function<void(U&&)>&&)>&& fn);$/;"	p	class:folly::wangle::Later	access:public	signature:(std::function<void(std::function<void(U&&)>&&)>&& fn)
folly::wangle::Later::Later	.\wangle\Later.h	/^  friend class Later;$/;"	x
folly::wangle::Later::fireAndForget	.\wangle\Later.h	/^  void fireAndForget() __attribute__ ((__deprecated__)) { launch(); }$/;"	f	class:folly::wangle::Later	access:public	signature:()
folly::wangle::Later::future_	.\wangle\Later.h	/^  folly::Optional<Future<T>> future_;$/;"	m	class:folly::wangle::Later	access:private
folly::wangle::Later::hide	.\wangle\Later.h	/^  struct hide { };$/;"	s	class:folly::wangle::Later	access:private
folly::wangle::Later::launch	.\wangle\Later-inl.h	/^Future<T> Later<T>::launch() {$/;"	f	class:folly::wangle::Later	signature:()
folly::wangle::Later::launch	.\wangle\Later.h	/^  Future<T> launch();$/;"	p	class:folly::wangle::Later	access:public	signature:()
folly::wangle::Later::starter_	.\wangle\Later.h	/^  Promise<void> starter_;$/;"	m	class:folly::wangle::Later	access:private
folly::wangle::Later::std::enable_if::then	.\wangle\Later.h	/^  inline then(Caller *instance, R(Caller::*func)(Try<T>&&)) {$/;"	f	class:folly::wangle::Later::std::enable_if	access:public	signature:(Caller *instance, R(Caller::*func)(Try<T>&&))
folly::wangle::Later::std::enable_if::then	.\wangle\Later.h	/^  inline then(R(*func)(Try<T>&&)) {$/;"	f	class:folly::wangle::Later::std::enable_if	access:public	signature:(R(func)Try<T>&&))
folly::wangle::Later::then	.\wangle\Later-inl.h	/^Later<T>::then(F&& fn) {$/;"	f	class:folly::wangle::Later	signature:(F&& fn)
folly::wangle::Later::then	.\wangle\Later.h	/^  then(F&& fn);$/;"	p	class:folly::wangle::Later	access:public	signature:(F&& fn)
folly::wangle::Later::value_type	.\wangle\Later.h	/^  typedef T value_type;$/;"	t	class:folly::wangle::Later	access:public
folly::wangle::Later::via	.\wangle\Later-inl.h	/^Later<T> Later<T>::via(Executor* executor) {$/;"	f	class:folly::wangle::Later	signature:(Executor* executor)
folly::wangle::Later::via	.\wangle\Later.h	/^  Later<T> via(Executor* executor);$/;"	p	class:folly::wangle::Later	access:public	signature:(Executor* executor)
folly::wangle::LifoSemMPMCQueue	.\experimental\wangle\concurrent\LifoSemMPMCQueue.h	/^class LifoSemMPMCQueue : public BlockingQueue<T> {$/;"	c	namespace:folly::wangle	inherits:BlockingQueue
folly::wangle::LifoSemMPMCQueue::LifoSemMPMCQueue	.\experimental\wangle\concurrent\LifoSemMPMCQueue.h	/^  explicit LifoSemMPMCQueue(size_t capacity) : queue_(capacity) {}$/;"	f	class:folly::wangle::LifoSemMPMCQueue	access:public	signature:(size_t capacity)
folly::wangle::LifoSemMPMCQueue::capacity	.\experimental\wangle\concurrent\LifoSemMPMCQueue.h	/^  size_t capacity() {$/;"	f	class:folly::wangle::LifoSemMPMCQueue	access:public	signature:()
folly::wangle::LifoSemMPMCQueue::queue_	.\experimental\wangle\concurrent\LifoSemMPMCQueue.h	/^  MPMCQueue<T> queue_;$/;"	m	class:folly::wangle::LifoSemMPMCQueue	access:private
folly::wangle::LifoSemMPMCQueue::sem_	.\experimental\wangle\concurrent\LifoSemMPMCQueue.h	/^  LifoSem sem_;$/;"	m	class:folly::wangle::LifoSemMPMCQueue	access:private
folly::wangle::ManagedConnection	.\experimental\wangle\ManagedConnection.h	/^class ManagedConnection:$/;"	c	namespace:folly::wangle	inherits:folly::HHWheelTimer::Callback,folly::DelayedDestruction
folly::wangle::ManagedConnection::ConnectionManager	.\experimental\wangle\ManagedConnection.h	/^  friend class ConnectionManager;$/;"	x
folly::wangle::ManagedConnection::ManagedConnection	.\experimental\wangle\ManagedConnection.cpp	/^ManagedConnection::ManagedConnection()$/;"	f	class:folly::wangle::ManagedConnection	signature:()
folly::wangle::ManagedConnection::ManagedConnection	.\experimental\wangle\ManagedConnection.h	/^  ManagedConnection();$/;"	p	class:folly::wangle::ManagedConnection	access:public	signature:()
folly::wangle::ManagedConnection::closeWhenIdle	.\experimental\wangle\ManagedConnection.h	/^  virtual void closeWhenIdle() = 0;$/;"	p	class:folly::wangle::ManagedConnection	access:public	signature:()
folly::wangle::ManagedConnection::connectionManager_	.\experimental\wangle\ManagedConnection.h	/^  ConnectionManager* connectionManager_;$/;"	m	class:folly::wangle::ManagedConnection	access:private
folly::wangle::ManagedConnection::describe	.\experimental\wangle\ManagedConnection.h	/^  virtual void describe(std::ostream& os) const = 0;$/;"	p	class:folly::wangle::ManagedConnection	access:public	signature:(std::ostream& os) const
folly::wangle::ManagedConnection::dropConnection	.\experimental\wangle\ManagedConnection.h	/^  virtual void dropConnection() = 0;$/;"	p	class:folly::wangle::ManagedConnection	access:public	signature:()
folly::wangle::ManagedConnection::dumpConnectionState	.\experimental\wangle\ManagedConnection.h	/^  virtual void dumpConnectionState(uint8_t loglevel) = 0;$/;"	p	class:folly::wangle::ManagedConnection	access:public	signature:(uint8_t loglevel)
folly::wangle::ManagedConnection::getConnectionManager	.\experimental\wangle\ManagedConnection.h	/^  ConnectionManager* getConnectionManager() {$/;"	f	class:folly::wangle::ManagedConnection	access:public	signature:()
folly::wangle::ManagedConnection::isBusy	.\experimental\wangle\ManagedConnection.h	/^  virtual bool isBusy() const = 0;$/;"	p	class:folly::wangle::ManagedConnection	access:public	signature:() const
folly::wangle::ManagedConnection::listHook_	.\experimental\wangle\ManagedConnection.h	/^  folly::SafeIntrusiveListHook listHook_;$/;"	m	class:folly::wangle::ManagedConnection	access:private
folly::wangle::ManagedConnection::noexcept	.\experimental\wangle\ManagedConnection.h	/^  virtual void timeoutExpired() noexcept = 0;$/;"	m	class:folly::wangle::ManagedConnection	access:public
folly::wangle::ManagedConnection::notifyPendingShutdown	.\experimental\wangle\ManagedConnection.h	/^  virtual void notifyPendingShutdown() = 0;$/;"	p	class:folly::wangle::ManagedConnection	access:public	signature:()
folly::wangle::ManagedConnection::resetTimeout	.\experimental\wangle\ManagedConnection.cpp	/^ManagedConnection::resetTimeout() {$/;"	f	class:folly::wangle::ManagedConnection	signature:()
folly::wangle::ManagedConnection::resetTimeout	.\experimental\wangle\ManagedConnection.h	/^  virtual void resetTimeout();$/;"	p	class:folly::wangle::ManagedConnection	access:public	signature:()
folly::wangle::ManagedConnection::scheduleTimeout	.\experimental\wangle\ManagedConnection.cpp	/^ManagedConnection::scheduleTimeout($/;"	f	class:folly::wangle::ManagedConnection	signature:( folly::HHWheelTimer::Callback* callback, std::chrono::milliseconds timeout)
folly::wangle::ManagedConnection::scheduleTimeout	.\experimental\wangle\ManagedConnection.h	/^  virtual void scheduleTimeout($/;"	p	class:folly::wangle::ManagedConnection	access:public	signature:( folly::HHWheelTimer::Callback* callback, std::chrono::milliseconds timeout)
folly::wangle::ManagedConnection::setConnectionManager	.\experimental\wangle\ManagedConnection.h	/^  void setConnectionManager(ConnectionManager* mgr) {$/;"	f	class:folly::wangle::ManagedConnection	access:private	signature:(ConnectionManager* mgr)
folly::wangle::ManagedConnection::~ManagedConnection	.\experimental\wangle\ManagedConnection.cpp	/^ManagedConnection::~ManagedConnection() {$/;"	f	class:folly::wangle::ManagedConnection	signature:()
folly::wangle::ManagedConnection::~ManagedConnection	.\experimental\wangle\ManagedConnection.h	/^  virtual ~ManagedConnection();$/;"	p	class:folly::wangle::ManagedConnection	access:protected	signature:()
folly::wangle::ManualExecutor	.\wangle\ManualExecutor.h	/^  class ManualExecutor : public Executor {$/;"	c	namespace:folly::wangle	inherits:Executor
folly::wangle::ManualExecutor::ManualExecutor	.\wangle\ManualExecutor.cpp	/^ManualExecutor::ManualExecutor() {$/;"	f	class:folly::wangle::ManualExecutor	signature:()
folly::wangle::ManualExecutor::ManualExecutor	.\wangle\ManualExecutor.h	/^    ManualExecutor();$/;"	p	class:folly::wangle::ManualExecutor	access:public	signature:()
folly::wangle::ManualExecutor::ScheduledAction	.\wangle\ManualExecutor.h	/^    struct ScheduledAction {$/;"	s	class:folly::wangle::ManualExecutor	access:private
folly::wangle::ManualExecutor::ScheduledAction::ScheduledAction	.\wangle\ManualExecutor.h	/^      ScheduledAction(TimePoint const& t, Action&& a)$/;"	f	struct:folly::wangle::ManualExecutor::ScheduledAction	access:public	signature:(TimePoint const& t, Action&& a)
folly::wangle::ManualExecutor::ScheduledAction::action	.\wangle\ManualExecutor.h	/^      Action action;$/;"	m	struct:folly::wangle::ManualExecutor::ScheduledAction	access:public
folly::wangle::ManualExecutor::ScheduledAction::operator <	.\wangle\ManualExecutor.h	/^      bool operator<(ScheduledAction const& b) const {$/;"	f	struct:folly::wangle::ManualExecutor::ScheduledAction	access:public	signature:(ScheduledAction const& b) const
folly::wangle::ManualExecutor::ScheduledAction::ordinal	.\wangle\ManualExecutor.h	/^      size_t ordinal;$/;"	m	struct:folly::wangle::ManualExecutor::ScheduledAction	access:public
folly::wangle::ManualExecutor::ScheduledAction::time	.\wangle\ManualExecutor.h	/^      TimePoint time;$/;"	m	struct:folly::wangle::ManualExecutor::ScheduledAction	access:public
folly::wangle::ManualExecutor::actions_	.\wangle\ManualExecutor.h	/^    std::queue<Action> actions_;$/;"	m	class:folly::wangle::ManualExecutor	access:private
folly::wangle::ManualExecutor::add	.\wangle\ManualExecutor.cpp	/^void ManualExecutor::add(std::function<void()>&& callback) {$/;"	f	class:folly::wangle::ManualExecutor	signature:(std::function<void()>&& callback)
folly::wangle::ManualExecutor::advance	.\wangle\ManualExecutor.h	/^    void advance(Duration const& dur) {$/;"	f	class:folly::wangle::ManualExecutor	access:public	signature:(Duration const& dur)
folly::wangle::ManualExecutor::advanceTo	.\wangle\ManualExecutor.cpp	/^void ManualExecutor::advanceTo(TimePoint const& t) {$/;"	f	class:folly::wangle::ManualExecutor	signature:(TimePoint const& t)
folly::wangle::ManualExecutor::advanceTo	.\wangle\ManualExecutor.h	/^    void advanceTo(TimePoint const& t);$/;"	p	class:folly::wangle::ManualExecutor	access:public	signature:(TimePoint const& t)
folly::wangle::ManualExecutor::lock_	.\wangle\ManualExecutor.h	/^    std::mutex lock_;$/;"	m	class:folly::wangle::ManualExecutor	access:private
folly::wangle::ManualExecutor::makeProgress	.\wangle\ManualExecutor.h	/^    void makeProgress() {$/;"	f	class:folly::wangle::ManualExecutor	access:public	signature:()
folly::wangle::ManualExecutor::now_	.\wangle\ManualExecutor.h	/^    TimePoint now_ = now_.min();$/;"	m	class:folly::wangle::ManualExecutor	access:private
folly::wangle::ManualExecutor::override	.\wangle\ManualExecutor.h	/^    void add(Action&&) override;$/;"	m	class:folly::wangle::ManualExecutor	access:public
folly::wangle::ManualExecutor::run	.\wangle\ManualExecutor.cpp	/^size_t ManualExecutor::run() {$/;"	f	class:folly::wangle::ManualExecutor	signature:()
folly::wangle::ManualExecutor::run	.\wangle\ManualExecutor.h	/^    size_t run();$/;"	p	class:folly::wangle::ManualExecutor	access:public	signature:()
folly::wangle::ManualExecutor::scheduledActions_	.\wangle\ManualExecutor.h	/^    std::priority_queue<ScheduledAction> scheduledActions_;$/;"	m	class:folly::wangle::ManualExecutor	access:private
folly::wangle::ManualExecutor::sem_	.\wangle\ManualExecutor.h	/^    sem_t sem_;$/;"	m	class:folly::wangle::ManualExecutor	access:private
folly::wangle::ManualExecutor::wait	.\wangle\ManualExecutor.cpp	/^void ManualExecutor::wait() {$/;"	f	class:folly::wangle::ManualExecutor	signature:()
folly::wangle::ManualExecutor::wait	.\wangle\ManualExecutor.h	/^    void wait();$/;"	p	class:folly::wangle::ManualExecutor	access:public	signature:()
folly::wangle::ManualExecutor::waitFor	.\wangle\ManualExecutor.h	/^    template <class F> void waitFor(F const& f) {$/;"	f	class:folly::wangle::ManualExecutor	access:public	signature:(F const& f)
folly::wangle::NamedThreadFactory	.\experimental\wangle\concurrent\NamedThreadFactory.h	/^class NamedThreadFactory : public ThreadFactory {$/;"	c	namespace:folly::wangle	inherits:ThreadFactory
folly::wangle::NamedThreadFactory::NamedThreadFactory	.\experimental\wangle\concurrent\NamedThreadFactory.h	/^  explicit NamedThreadFactory(folly::StringPiece prefix)$/;"	f	class:folly::wangle::NamedThreadFactory	access:public	signature:(folly::StringPiece prefix)
folly::wangle::NamedThreadFactory::prefix_	.\experimental\wangle\concurrent\NamedThreadFactory.h	/^  folly::StringPiece prefix_;$/;"	m	class:folly::wangle::NamedThreadFactory	access:private
folly::wangle::NamedThreadFactory::suffix_	.\experimental\wangle\concurrent\NamedThreadFactory.h	/^  std::atomic<uint64_t> suffix_;$/;"	m	class:folly::wangle::NamedThreadFactory	access:private
folly::wangle::NoState	.\wangle\WangleException.h	/^class NoState : public WangleException {$/;"	c	namespace:folly::wangle	inherits:WangleException
folly::wangle::NoState::NoState	.\wangle\WangleException.h	/^    explicit NoState() : WangleException("No state") { }$/;"	f	class:folly::wangle::NoState	access:public	signature:()
folly::wangle::OpaqueCallbackLaterShunt	.\wangle\OpaqueCallbackShunt.h	/^class OpaqueCallbackLaterShunt {$/;"	c	namespace:folly::wangle
folly::wangle::OpaqueCallbackLaterShunt::OpaqueCallbackLaterShunt	.\wangle\OpaqueCallbackShunt.h	/^  OpaqueCallbackLaterShunt(T&& obj, std::function<void(T&&)>&& fn)$/;"	f	class:folly::wangle::OpaqueCallbackLaterShunt	access:public	signature:(T&& obj, std::function<void(T&&)>&& fn)
folly::wangle::OpaqueCallbackLaterShunt::callback	.\wangle\OpaqueCallbackShunt.h	/^  static void callback(void* arg) {$/;"	f	class:folly::wangle::OpaqueCallbackLaterShunt	access:public	signature:(void* arg)
folly::wangle::OpaqueCallbackLaterShunt::fn_	.\wangle\OpaqueCallbackShunt.h	/^  std::function<void(T&&)> fn_;$/;"	m	class:folly::wangle::OpaqueCallbackLaterShunt	access:private
folly::wangle::OpaqueCallbackLaterShunt::obj_	.\wangle\OpaqueCallbackShunt.h	/^  T obj_;$/;"	m	class:folly::wangle::OpaqueCallbackLaterShunt	access:private
folly::wangle::OpaqueCallbackShunt	.\wangle\OpaqueCallbackShunt.h	/^class OpaqueCallbackShunt {$/;"	c	namespace:folly::wangle
folly::wangle::OpaqueCallbackShunt::OpaqueCallbackShunt	.\wangle\OpaqueCallbackShunt.h	/^  explicit OpaqueCallbackShunt(T&& obj)$/;"	f	class:folly::wangle::OpaqueCallbackShunt	access:public	signature:(T&& obj)
folly::wangle::OpaqueCallbackShunt::callback	.\wangle\OpaqueCallbackShunt.h	/^  static void callback(void* arg) {$/;"	f	class:folly::wangle::OpaqueCallbackShunt	access:public	signature:(void* arg)
folly::wangle::OpaqueCallbackShunt::obj_	.\wangle\OpaqueCallbackShunt.h	/^  T obj_;$/;"	m	class:folly::wangle::OpaqueCallbackShunt	access:private
folly::wangle::OpaqueCallbackShunt::promise_	.\wangle\OpaqueCallbackShunt.h	/^  folly::wangle::Promise<T> promise_;$/;"	m	class:folly::wangle::OpaqueCallbackShunt	access:public
folly::wangle::Promise	.\wangle\Promise.h	/^class Promise {$/;"	c	namespace:folly::wangle
folly::wangle::Promise::Promise	.\wangle\Promise-inl.h	/^Promise<T>::Promise() : retrieved_(false), state_(new detail::State<T>())$/;"	f	class:folly::wangle::Promise	signature:()
folly::wangle::Promise::Promise	.\wangle\Promise-inl.h	/^Promise<T>::Promise(Promise<T>&& other) : state_(nullptr) {$/;"	f	class:folly::wangle::Promise	signature:(Promise<T>&& other)
folly::wangle::Promise::Promise	.\wangle\Promise.h	/^  Promise();$/;"	p	class:folly::wangle::Promise	access:public	signature:()
folly::wangle::Promise::Promise	.\wangle\Promise.h	/^  Promise(Promise const&) = delete;$/;"	p	class:folly::wangle::Promise	access:public	signature:(Promise const&)
folly::wangle::Promise::Promise	.\wangle\Promise.h	/^  Promise(Promise<T>&&);$/;"	p	class:folly::wangle::Promise	access:public	signature:(Promise<T>&&)
folly::wangle::Promise::detach	.\wangle\Promise-inl.h	/^void Promise<T>::detach() {$/;"	f	class:folly::wangle::Promise	signature:()
folly::wangle::Promise::detach	.\wangle\Promise.h	/^  void detach();$/;"	p	class:folly::wangle::Promise	access:private	signature:()
folly::wangle::Promise::fulfil	.\wangle\Promise-inl.h	/^void Promise<T>::fulfil(F&& func) {$/;"	f	class:folly::wangle::Promise	signature:(F&& func)
folly::wangle::Promise::fulfil	.\wangle\Promise.h	/^  void fulfil(F&& func);$/;"	p	class:folly::wangle::Promise	access:public	signature:(F&& func)
folly::wangle::Promise::fulfilTry	.\wangle\Promise-inl.h	/^void Promise<T>::fulfilTry(Try<T>&& t) {$/;"	f	class:folly::wangle::Promise	signature:(Try<T>&& t)
folly::wangle::Promise::fulfilTry	.\wangle\Promise.h	/^  void fulfilTry(Try<T>&& t);$/;"	p	class:folly::wangle::Promise	access:public	signature:(Try<T>&& t)
folly::wangle::Promise::getFuture	.\wangle\Promise-inl.h	/^Future<T> Promise<T>::getFuture() {$/;"	f	class:folly::wangle::Promise	signature:()
folly::wangle::Promise::getFuture	.\wangle\Promise.h	/^  Future<T> getFuture();$/;"	p	class:folly::wangle::Promise	access:public	signature:()
folly::wangle::Promise::operator =	.\wangle\Promise-inl.h	/^Promise<T>& Promise<T>::operator=(Promise<T>&& other) {$/;"	f	class:folly::wangle::Promise	signature:(Promise<T>&& other)
folly::wangle::Promise::operator =	.\wangle\Promise.h	/^  Promise& operator=(Promise const&) = delete;$/;"	p	class:folly::wangle::Promise	access:public	signature:(Promise const&)
folly::wangle::Promise::operator =	.\wangle\Promise.h	/^  Promise& operator=(Promise<T>&&);$/;"	p	class:folly::wangle::Promise	access:public	signature:(Promise<T>&&)
folly::wangle::Promise::retrieved_	.\wangle\Promise.h	/^  bool retrieved_;$/;"	m	class:folly::wangle::Promise	access:private
folly::wangle::Promise::setException	.\wangle\Promise-inl.h	/^void Promise<T>::setException(E const& e) {$/;"	f	class:folly::wangle::Promise	signature:(E const& e)
folly::wangle::Promise::setException	.\wangle\Promise-inl.h	/^void Promise<T>::setException(std::exception_ptr const& e) {$/;"	f	class:folly::wangle::Promise	signature:(std::exception_ptr const& e)
folly::wangle::Promise::setException	.\wangle\Promise.h	/^  template <class E> void setException(E const&);$/;"	p	class:folly::wangle::Promise	access:public	signature:(E const&)
folly::wangle::Promise::setException	.\wangle\Promise.h	/^  void setException(std::exception_ptr const&);$/;"	p	class:folly::wangle::Promise	access:public	signature:(std::exception_ptr const&)
folly::wangle::Promise::setValue	.\wangle\Promise-inl.h	/^void Promise<T>::setValue() {$/;"	f	class:folly::wangle::Promise	signature:()
folly::wangle::Promise::setValue	.\wangle\Promise-inl.h	/^void Promise<T>::setValue(M&& v) {$/;"	f	class:folly::wangle::Promise	signature:(M&& v)
folly::wangle::Promise::setValue	.\wangle\Promise.h	/^  void setValue();$/;"	p	class:folly::wangle::Promise	access:public	signature:()
folly::wangle::Promise::setValue	.\wangle\Promise.h	/^  void setValue(M&& value);$/;"	p	class:folly::wangle::Promise	access:public	signature:(M&& value)
folly::wangle::Promise::statePtr	.\wangle\Promise.h	/^  typedef typename Future<T>::statePtr statePtr;$/;"	t	class:folly::wangle::Promise	access:private
folly::wangle::Promise::state_	.\wangle\Promise.h	/^  statePtr state_;$/;"	m	class:folly::wangle::Promise	access:private
folly::wangle::Promise::throwIfFulfilled	.\wangle\Promise-inl.h	/^void Promise<T>::throwIfFulfilled() {$/;"	f	class:folly::wangle::Promise	signature:()
folly::wangle::Promise::throwIfFulfilled	.\wangle\Promise.h	/^  void throwIfFulfilled();$/;"	p	class:folly::wangle::Promise	access:private	signature:()
folly::wangle::Promise::throwIfRetrieved	.\wangle\Promise-inl.h	/^void Promise<T>::throwIfRetrieved() {$/;"	f	class:folly::wangle::Promise	signature:()
folly::wangle::Promise::throwIfRetrieved	.\wangle\Promise.h	/^  void throwIfRetrieved();$/;"	p	class:folly::wangle::Promise	access:private	signature:()
folly::wangle::Promise::~Promise	.\wangle\Promise-inl.h	/^Promise<T>::~Promise() {$/;"	f	class:folly::wangle::Promise	signature:()
folly::wangle::Promise::~Promise	.\wangle\Promise.h	/^  ~Promise();$/;"	p	class:folly::wangle::Promise	access:public	signature:()
folly::wangle::PromiseAlreadySatisfied	.\wangle\WangleException.h	/^class PromiseAlreadySatisfied : public WangleException {$/;"	c	namespace:folly::wangle	inherits:WangleException
folly::wangle::PromiseAlreadySatisfied::PromiseAlreadySatisfied	.\wangle\WangleException.h	/^    explicit PromiseAlreadySatisfied() :$/;"	f	class:folly::wangle::PromiseAlreadySatisfied	access:public	signature:()
folly::wangle::QueuedImmediateExecutor	.\wangle\QueuedImmediateExecutor.h	/^class QueuedImmediateExecutor : public Executor {$/;"	c	namespace:folly::wangle	inherits:Executor
folly::wangle::QueuedImmediateExecutor::add	.\wangle\QueuedImmediateExecutor.cpp	/^void QueuedImmediateExecutor::add(Action&& callback)$/;"	f	class:folly::wangle::QueuedImmediateExecutor	signature:(Action&& callback)
folly::wangle::QueuedImmediateExecutor::override	.\wangle\QueuedImmediateExecutor.h	/^  void add(Action&&) override;$/;"	m	class:folly::wangle::QueuedImmediateExecutor	access:public
folly::wangle::ThreadFactory	.\experimental\wangle\concurrent\ThreadFactory.h	/^class ThreadFactory {$/;"	c	namespace:folly::wangle
folly::wangle::ThreadFactory::newThread	.\experimental\wangle\concurrent\ThreadFactory.h	/^  virtual std::thread newThread(Func&& func) = 0;$/;"	p	class:folly::wangle::ThreadFactory	access:public	signature:(Func&& func)
folly::wangle::ThreadFactory::~ThreadFactory	.\experimental\wangle\concurrent\ThreadFactory.h	/^  virtual ~ThreadFactory() {}$/;"	f	class:folly::wangle::ThreadFactory	access:public	signature:()
folly::wangle::ThreadGate	.\wangle\ThreadGate.h	/^class ThreadGate {$/;"	c	namespace:folly::wangle
folly::wangle::ThreadGate::addEast	.\wangle\ThreadGate.h	/^  virtual void addEast(std::function<void()>&&) = 0;$/;"	p	class:folly::wangle::ThreadGate	access:public	signature:(std::function<void()>&&)
folly::wangle::ThreadGate::addWest	.\wangle\ThreadGate.h	/^  virtual void addWest(std::function<void()>&&) = 0;$/;"	p	class:folly::wangle::ThreadGate	access:public	signature:(std::function<void()>&&)
folly::wangle::ThreadGate::gate	.\wangle\ThreadGate.h	/^  Future<T> gate(std::function<Future<T>()>&& fn) {$/;"	f	class:folly::wangle::ThreadGate	access:public	signature:(std::function<Future<T>()>&& fn)
folly::wangle::ThreadGate::gate	.\wangle\ThreadGate.h	/^  void gate(std::function<Future<T>()>&& fn,$/;"	f	class:folly::wangle::ThreadGate	access:public	signature:(std::function<Future<T>()>&& fn, Promise<T>&& p)
folly::wangle::ThreadGate::makeProgress	.\wangle\ThreadGate.cpp	/^void ThreadGate::makeProgress()$/;"	f	class:folly::wangle::ThreadGate	signature:()
folly::wangle::ThreadGate::makeProgress	.\wangle\ThreadGate.h	/^  virtual void makeProgress();$/;"	p	class:folly::wangle::ThreadGate	access:public	signature:()
folly::wangle::ThreadGate::value	.\wangle\ThreadGate.h	/^  value(Future<T> const& f) {$/;"	f	class:folly::wangle::ThreadGate	access:public	signature:(Future<T> const& f)
folly::wangle::ThreadGate::value	.\wangle\ThreadGate.h	/^  value(Future<T>& f) {$/;"	f	class:folly::wangle::ThreadGate	access:public	signature:(Future<T>& f)
folly::wangle::ThreadGate::waitFor	.\wangle\ThreadGate.h	/^  void waitFor(Future<T> const& f) {$/;"	f	class:folly::wangle::ThreadGate	access:public	signature:(Future<T> const& f)
folly::wangle::ThreadGate::~ThreadGate	.\wangle\ThreadGate.h	/^  virtual ~ThreadGate() {}$/;"	f	class:folly::wangle::ThreadGate	access:public	signature:()
folly::wangle::ThreadPoolExecutor	.\experimental\wangle\concurrent\ThreadPoolExecutor.h	/^class ThreadPoolExecutor : public Executor {$/;"	c	namespace:folly::wangle	inherits:Executor
folly::wangle::ThreadPoolExecutor::StoppedThreadQueue	.\experimental\wangle\concurrent\ThreadPoolExecutor.h	/^  class StoppedThreadQueue : public BlockingQueue<ThreadPtr> {$/;"	c	class:folly::wangle::ThreadPoolExecutor	inherits:BlockingQueue	access:protected
folly::wangle::ThreadPoolExecutor::StoppedThreadQueue::add	.\experimental\wangle\concurrent\ThreadPoolExecutor.cpp	/^void ThreadPoolExecutor::StoppedThreadQueue::add($/;"	f	class:folly::wangle::ThreadPoolExecutor::StoppedThreadQueue	signature:( ThreadPoolExecutor::ThreadPtr item)
folly::wangle::ThreadPoolExecutor::StoppedThreadQueue::mutex_	.\experimental\wangle\concurrent\ThreadPoolExecutor.h	/^    std::mutex mutex_;$/;"	m	class:folly::wangle::ThreadPoolExecutor::StoppedThreadQueue	access:private
folly::wangle::ThreadPoolExecutor::StoppedThreadQueue::override	.\experimental\wangle\concurrent\ThreadPoolExecutor.h	/^    ThreadPtr take() override;$/;"	m	class:folly::wangle::ThreadPoolExecutor::StoppedThreadQueue	access:public
folly::wangle::ThreadPoolExecutor::StoppedThreadQueue::override	.\experimental\wangle\concurrent\ThreadPoolExecutor.h	/^    size_t size() override;$/;"	m	class:folly::wangle::ThreadPoolExecutor::StoppedThreadQueue	access:public
folly::wangle::ThreadPoolExecutor::StoppedThreadQueue::override	.\experimental\wangle\concurrent\ThreadPoolExecutor.h	/^    void add(ThreadPtr item) override;$/;"	m	class:folly::wangle::ThreadPoolExecutor::StoppedThreadQueue	access:public
folly::wangle::ThreadPoolExecutor::StoppedThreadQueue::queue_	.\experimental\wangle\concurrent\ThreadPoolExecutor.h	/^    std::queue<ThreadPtr> queue_;$/;"	m	class:folly::wangle::ThreadPoolExecutor::StoppedThreadQueue	access:private
folly::wangle::ThreadPoolExecutor::StoppedThreadQueue::sem_	.\experimental\wangle\concurrent\ThreadPoolExecutor.h	/^    LifoSem sem_;$/;"	m	class:folly::wangle::ThreadPoolExecutor::StoppedThreadQueue	access:private
folly::wangle::ThreadPoolExecutor::StoppedThreadQueue::size	.\experimental\wangle\concurrent\ThreadPoolExecutor.cpp	/^size_t ThreadPoolExecutor::StoppedThreadQueue::size() {$/;"	f	class:folly::wangle::ThreadPoolExecutor::StoppedThreadQueue	signature:()
folly::wangle::ThreadPoolExecutor::StoppedThreadQueue::take	.\experimental\wangle\concurrent\ThreadPoolExecutor.cpp	/^ThreadPoolExecutor::ThreadPtr ThreadPoolExecutor::StoppedThreadQueue::take() {$/;"	f	class:folly::wangle::ThreadPoolExecutor::StoppedThreadQueue	signature:()
folly::wangle::ThreadPoolExecutor::Thread	.\experimental\wangle\concurrent\ThreadPoolExecutor.h	/^  struct FOLLY_ALIGN_TO_AVOID_FALSE_SHARING Thread {$/;"	s	class:folly::wangle::ThreadPoolExecutor	access:protected
folly::wangle::ThreadPoolExecutor::Thread::Thread	.\experimental\wangle\concurrent\ThreadPoolExecutor.h	/^    Thread() : id(nextId++), handle(), idle(true) {};$/;"	f	struct:folly::wangle::ThreadPoolExecutor::Thread	access:public	signature:()
folly::wangle::ThreadPoolExecutor::Thread::handle	.\experimental\wangle\concurrent\ThreadPoolExecutor.h	/^    std::thread handle;$/;"	m	struct:folly::wangle::ThreadPoolExecutor::Thread	access:public
folly::wangle::ThreadPoolExecutor::Thread::id	.\experimental\wangle\concurrent\ThreadPoolExecutor.h	/^    uint64_t id;$/;"	m	struct:folly::wangle::ThreadPoolExecutor::Thread	access:public
folly::wangle::ThreadPoolExecutor::Thread::idle	.\experimental\wangle\concurrent\ThreadPoolExecutor.h	/^    bool idle;$/;"	m	struct:folly::wangle::ThreadPoolExecutor::Thread	access:public
folly::wangle::ThreadPoolExecutor::Thread::nextId	.\experimental\wangle\concurrent\ThreadPoolExecutor.h	/^    static std::atomic<uint64_t> nextId;$/;"	m	struct:folly::wangle::ThreadPoolExecutor::Thread	access:public
folly::wangle::ThreadPoolExecutor::Thread::~Thread	.\experimental\wangle\concurrent\ThreadPoolExecutor.h	/^    virtual ~Thread() {}$/;"	f	struct:folly::wangle::ThreadPoolExecutor::Thread	access:public	signature:()
folly::wangle::ThreadPoolExecutor::ThreadList	.\experimental\wangle\concurrent\ThreadPoolExecutor.h	/^  class ThreadList {$/;"	c	class:folly::wangle::ThreadPoolExecutor	access:protected
folly::wangle::ThreadPoolExecutor::ThreadList::add	.\experimental\wangle\concurrent\ThreadPoolExecutor.h	/^    void add(const ThreadPtr& state) {$/;"	f	class:folly::wangle::ThreadPoolExecutor::ThreadList	access:public	signature:(const ThreadPtr& state)
folly::wangle::ThreadPoolExecutor::ThreadList::compare	.\experimental\wangle\concurrent\ThreadPoolExecutor.h	/^    static bool compare(const ThreadPtr& ts1, const ThreadPtr& ts2) {$/;"	f	class:folly::wangle::ThreadPoolExecutor::ThreadList	access:private	signature:(const ThreadPtr& ts1, const ThreadPtr& ts2)
folly::wangle::ThreadPoolExecutor::ThreadList::get	.\experimental\wangle\concurrent\ThreadPoolExecutor.h	/^    const std::vector<ThreadPtr>& get() const {$/;"	f	class:folly::wangle::ThreadPoolExecutor::ThreadList	access:public	signature:() const
folly::wangle::ThreadPoolExecutor::ThreadList::remove	.\experimental\wangle\concurrent\ThreadPoolExecutor.h	/^    void remove(const ThreadPtr& state) {$/;"	f	class:folly::wangle::ThreadPoolExecutor::ThreadList	access:public	signature:(const ThreadPtr& state)
folly::wangle::ThreadPoolExecutor::ThreadList::vec_	.\experimental\wangle\concurrent\ThreadPoolExecutor.h	/^    std::vector<ThreadPtr> vec_;$/;"	m	class:folly::wangle::ThreadPoolExecutor::ThreadList	access:private
folly::wangle::ThreadPoolExecutor::ThreadPoolExecutor	.\experimental\wangle\concurrent\ThreadPoolExecutor.cpp	/^ThreadPoolExecutor::ThreadPoolExecutor($/;"	f	class:folly::wangle::ThreadPoolExecutor	signature:( size_t numThreads, std::unique_ptr<ThreadFactory> threadFactory)
folly::wangle::ThreadPoolExecutor::ThreadPoolExecutor	.\experimental\wangle\concurrent\ThreadPoolExecutor.h	/^  explicit ThreadPoolExecutor($/;"	p	class:folly::wangle::ThreadPoolExecutor	access:public	signature:( size_t numThreads, std::unique_ptr<ThreadFactory> threadFactory)
folly::wangle::ThreadPoolExecutor::ThreadPtr	.\experimental\wangle\concurrent\ThreadPoolExecutor.h	/^  typedef std::shared_ptr<Thread> ThreadPtr;$/;"	t	class:folly::wangle::ThreadPoolExecutor	access:protected
folly::wangle::ThreadPoolExecutor::addThreads	.\experimental\wangle\concurrent\ThreadPoolExecutor.cpp	/^void ThreadPoolExecutor::addThreads(size_t n) {$/;"	f	class:folly::wangle::ThreadPoolExecutor	signature:(size_t n)
folly::wangle::ThreadPoolExecutor::addThreads	.\experimental\wangle\concurrent\ThreadPoolExecutor.h	/^  void addThreads(size_t n);$/;"	p	class:folly::wangle::ThreadPoolExecutor	access:protected	signature:(size_t n)
folly::wangle::ThreadPoolExecutor::isJoin_	.\experimental\wangle\concurrent\ThreadPoolExecutor.h	/^  std::atomic<bool> isJoin_; \/\/ whether the current downsizing is a join$/;"	m	class:folly::wangle::ThreadPoolExecutor	access:protected
folly::wangle::ThreadPoolExecutor::join	.\experimental\wangle\concurrent\ThreadPoolExecutor.cpp	/^void ThreadPoolExecutor::join() {$/;"	f	class:folly::wangle::ThreadPoolExecutor	signature:()
folly::wangle::ThreadPoolExecutor::join	.\experimental\wangle\concurrent\ThreadPoolExecutor.h	/^  void join();$/;"	p	class:folly::wangle::ThreadPoolExecutor	access:public	signature:()
folly::wangle::ThreadPoolExecutor::makeThread	.\experimental\wangle\concurrent\ThreadPoolExecutor.h	/^  virtual ThreadPtr makeThread() {$/;"	f	class:folly::wangle::ThreadPoolExecutor	access:protected	signature:()
folly::wangle::ThreadPoolExecutor::numThreads	.\experimental\wangle\concurrent\ThreadPoolExecutor.cpp	/^size_t ThreadPoolExecutor::numThreads() {$/;"	f	class:folly::wangle::ThreadPoolExecutor	signature:()
folly::wangle::ThreadPoolExecutor::numThreads	.\experimental\wangle\concurrent\ThreadPoolExecutor.h	/^  size_t numThreads();$/;"	p	class:folly::wangle::ThreadPoolExecutor	access:public	signature:()
folly::wangle::ThreadPoolExecutor::removeThreads	.\experimental\wangle\concurrent\ThreadPoolExecutor.cpp	/^void ThreadPoolExecutor::removeThreads(size_t n, bool isJoin) {$/;"	f	class:folly::wangle::ThreadPoolExecutor	signature:(size_t n, bool isJoin)
folly::wangle::ThreadPoolExecutor::removeThreads	.\experimental\wangle\concurrent\ThreadPoolExecutor.h	/^  void removeThreads(size_t n, bool isJoin);$/;"	p	class:folly::wangle::ThreadPoolExecutor	access:protected	signature:(size_t n, bool isJoin)
folly::wangle::ThreadPoolExecutor::setNumThreads	.\experimental\wangle\concurrent\ThreadPoolExecutor.cpp	/^void ThreadPoolExecutor::setNumThreads(size_t n) {$/;"	f	class:folly::wangle::ThreadPoolExecutor	signature:(size_t n)
folly::wangle::ThreadPoolExecutor::setNumThreads	.\experimental\wangle\concurrent\ThreadPoolExecutor.h	/^  void setNumThreads(size_t numThreads);$/;"	p	class:folly::wangle::ThreadPoolExecutor	access:public	signature:(size_t numThreads)
folly::wangle::ThreadPoolExecutor::stop	.\experimental\wangle\concurrent\ThreadPoolExecutor.cpp	/^void ThreadPoolExecutor::stop() {$/;"	f	class:folly::wangle::ThreadPoolExecutor	signature:()
folly::wangle::ThreadPoolExecutor::stop	.\experimental\wangle\concurrent\ThreadPoolExecutor.h	/^  void stop();$/;"	p	class:folly::wangle::ThreadPoolExecutor	access:public	signature:()
folly::wangle::ThreadPoolExecutor::stopThreads	.\experimental\wangle\concurrent\ThreadPoolExecutor.h	/^  virtual void stopThreads(size_t n) = 0;$/;"	p	class:folly::wangle::ThreadPoolExecutor	access:protected	signature:(size_t n)
folly::wangle::ThreadPoolExecutor::stoppedThreads_	.\experimental\wangle\concurrent\ThreadPoolExecutor.h	/^  StoppedThreadQueue stoppedThreads_;$/;"	m	class:folly::wangle::ThreadPoolExecutor	access:protected
folly::wangle::ThreadPoolExecutor::threadFactory_	.\experimental\wangle\concurrent\ThreadPoolExecutor.h	/^  std::unique_ptr<ThreadFactory> threadFactory_;$/;"	m	class:folly::wangle::ThreadPoolExecutor	access:protected
folly::wangle::ThreadPoolExecutor::threadListLock_	.\experimental\wangle\concurrent\ThreadPoolExecutor.h	/^  RWSpinLock threadListLock_;$/;"	m	class:folly::wangle::ThreadPoolExecutor	access:protected
folly::wangle::ThreadPoolExecutor::threadList_	.\experimental\wangle\concurrent\ThreadPoolExecutor.h	/^  ThreadList threadList_;$/;"	m	class:folly::wangle::ThreadPoolExecutor	access:protected
folly::wangle::ThreadPoolExecutor::threadRun	.\experimental\wangle\concurrent\ThreadPoolExecutor.h	/^  virtual void threadRun(ThreadPtr thread) = 0;$/;"	p	class:folly::wangle::ThreadPoolExecutor	access:protected	signature:(ThreadPtr thread)
folly::wangle::ThreadPoolExecutor::~ThreadPoolExecutor	.\experimental\wangle\concurrent\ThreadPoolExecutor.cpp	/^ThreadPoolExecutor::~ThreadPoolExecutor() {$/;"	f	class:folly::wangle::ThreadPoolExecutor	signature:()
folly::wangle::ThreadPoolExecutor::~ThreadPoolExecutor	.\experimental\wangle\concurrent\ThreadPoolExecutor.h	/^  ~ThreadPoolExecutor();$/;"	p	class:folly::wangle::ThreadPoolExecutor	access:public	signature:()
folly::wangle::Try	.\wangle\Try.h	/^class Try {$/;"	c	namespace:folly::wangle
folly::wangle::Try	.\wangle\Try.h	/^class Try<void> {$/;"	c	namespace:folly::wangle
folly::wangle::Try::Contains	.\wangle\Try.h	/^  enum class Contains {$/;"	c	class:folly::wangle::Try	access:private
folly::wangle::Try::Contains::EXCEPTION	.\wangle\Try.h	/^    EXCEPTION,$/;"	m	class:folly::wangle::Try::Contains	access:private
folly::wangle::Try::Contains::NOTHING	.\wangle\Try.h	/^    NOTHING,$/;"	m	class:folly::wangle::Try::Contains	access:private
folly::wangle::Try::Contains::VALUE	.\wangle\Try.h	/^    VALUE,$/;"	m	class:folly::wangle::Try::Contains	access:private
folly::wangle::Try::Try	.\wangle\Try-inl.h	/^Try<T>::Try(Try<T>&& t) : contains_(t.contains_) {$/;"	f	class:folly::wangle::Try	signature:(Try<T>&& t)
folly::wangle::Try::Try	.\wangle\Try.h	/^  Try() : contains_(Contains::NOTHING) {}$/;"	f	class:folly::wangle::Try	access:public	signature:()
folly::wangle::Try::Try	.\wangle\Try.h	/^  Try() : hasValue_(true) {}$/;"	f	class:folly::wangle::Try	access:public	signature:()
folly::wangle::Try::Try	.\wangle\Try.h	/^  Try(Try<T>&& t);$/;"	p	class:folly::wangle::Try	access:public	signature:(Try<T>&& t)
folly::wangle::Try::Try	.\wangle\Try.h	/^  explicit Try(T&& v) : contains_(Contains::VALUE), value_(std::move(v)) {}$/;"	f	class:folly::wangle::Try	access:public	signature:(T&& v)
folly::wangle::Try::Try	.\wangle\Try.h	/^  explicit Try(const T& v) : contains_(Contains::VALUE), value_(v) {}$/;"	f	class:folly::wangle::Try	access:public	signature:(const T& v)
folly::wangle::Try::Try	.\wangle\Try.h	/^  explicit Try(std::exception_ptr e) : contains_(Contains::EXCEPTION), e_(e) {}$/;"	f	class:folly::wangle::Try	access:public	signature:(std::exception_ptr e)
folly::wangle::Try::Try	.\wangle\Try.h	/^  explicit Try(std::exception_ptr e) : hasValue_(false), e_(e) {}$/;"	f	class:folly::wangle::Try	access:public	signature:(std::exception_ptr e)
folly::wangle::Try::__anon154::e_	.\wangle\Try.h	/^    std::exception_ptr e_;$/;"	m	union:folly::wangle::Try::__anon154	access:public
folly::wangle::Try::__anon154::value_	.\wangle\Try.h	/^    T value_;$/;"	m	union:folly::wangle::Try::__anon154	access:public
folly::wangle::Try::contains_	.\wangle\Try.h	/^  Contains contains_;$/;"	m	class:folly::wangle::Try	access:private
folly::wangle::Try::e_	.\wangle\Try.h	/^  std::exception_ptr e_;$/;"	m	class:folly::wangle::Try	access:private
folly::wangle::Try::element_type	.\wangle\Try.h	/^  typedef T element_type;$/;"	t	class:folly::wangle::Try	access:public
folly::wangle::Try::hasException	.\wangle\Try.h	/^  bool hasException() const { return !hasValue_; }$/;"	f	class:folly::wangle::Try	access:public	signature:() const
folly::wangle::Try::hasException	.\wangle\Try.h	/^  bool hasException() const { return contains_ == Contains::EXCEPTION; }$/;"	f	class:folly::wangle::Try	access:public	signature:() const
folly::wangle::Try::hasValue	.\wangle\Try.h	/^  bool hasValue() const { return contains_ == Contains::VALUE; }$/;"	f	class:folly::wangle::Try	access:public	signature:() const
folly::wangle::Try::hasValue	.\wangle\Try.h	/^  bool hasValue() const { return hasValue_; }$/;"	f	class:folly::wangle::Try	access:public	signature:() const
folly::wangle::Try::hasValue_	.\wangle\Try.h	/^  bool hasValue_;$/;"	m	class:folly::wangle::Try	access:private
folly::wangle::Try::operator *	.\wangle\Try.h	/^        T& operator*()       { return value(); }$/;"	f	class:folly::wangle::Try	access:public	signature:()
folly::wangle::Try::operator *	.\wangle\Try.h	/^  const T& operator*() const { return value(); }$/;"	f	class:folly::wangle::Try	access:public	signature:() const
folly::wangle::Try::operator *	.\wangle\Try.h	/^  void operator*() const { return value(); }$/;"	f	class:folly::wangle::Try	access:public	signature:() const
folly::wangle::Try::operator ->	.\wangle\Try.h	/^        T* operator->()       { return &value(); }$/;"	f	class:folly::wangle::Try	access:public	signature:()
folly::wangle::Try::operator ->	.\wangle\Try.h	/^  const T* operator->() const { return &value(); }$/;"	f	class:folly::wangle::Try	access:public	signature:() const
folly::wangle::Try::operator =	.\wangle\Try-inl.h	/^Try<T>& Try<T>::operator=(Try<T>&& t) {$/;"	f	class:folly::wangle::Try	signature:(Try<T>&& t)
folly::wangle::Try::operator =	.\wangle\Try.h	/^  Try& operator=(Try<T>&& t);$/;"	p	class:folly::wangle::Try	access:public	signature:(Try<T>&& t)
folly::wangle::Try::t	.\wangle\Try.h	/^  Try& operator=(const Try<T>& t) = delete;$/;"	m	class:folly::wangle::Try	access:public
folly::wangle::Try::t	.\wangle\Try.h	/^  Try(const Try<T>& t) = delete;$/;"	m	class:folly::wangle::Try	access:public
folly::wangle::Try::throwIfFailed	.\wangle\Try-inl.h	/^void Try<T>::throwIfFailed() const {$/;"	f	class:folly::wangle::Try	signature:() const
folly::wangle::Try::throwIfFailed	.\wangle\Try-inl.h	/^void Try<void>::throwIfFailed() const {$/;"	f	class:folly::wangle::Try	signature:() const
folly::wangle::Try::throwIfFailed	.\wangle\Try.h	/^  inline void throwIfFailed() const;$/;"	p	class:folly::wangle::Try	access:public	signature:() const
folly::wangle::Try::throwIfFailed	.\wangle\Try.h	/^  void throwIfFailed() const;$/;"	p	class:folly::wangle::Try	access:public	signature:() const
folly::wangle::Try::value	.\wangle\Try-inl.h	/^T& Try<T>::value() {$/;"	f	class:folly::wangle::Try	signature:()
folly::wangle::Try::value	.\wangle\Try-inl.h	/^const T& Try<T>::value() const {$/;"	f	class:folly::wangle::Try	signature:() const
folly::wangle::Try::value	.\wangle\Try.h	/^  T& value();$/;"	p	class:folly::wangle::Try	access:public	signature:()
folly::wangle::Try::value	.\wangle\Try.h	/^  const T& value() const;$/;"	p	class:folly::wangle::Try	access:public	signature:() const
folly::wangle::Try::value	.\wangle\Try.h	/^  void value() const { throwIfFailed(); }$/;"	f	class:folly::wangle::Try	access:public	signature:() const
folly::wangle::Try::~Try	.\wangle\Try-inl.h	/^Try<T>::~Try() {$/;"	f	class:folly::wangle::Try	signature:()
folly::wangle::Try::~Try	.\wangle\Try.h	/^  ~Try();$/;"	p	class:folly::wangle::Try	access:public	signature:()
folly::wangle::UsingUninitializedTry	.\wangle\WangleException.h	/^class UsingUninitializedTry : public WangleException {$/;"	c	namespace:folly::wangle	inherits:WangleException
folly::wangle::UsingUninitializedTry::UsingUninitializedTry	.\wangle\WangleException.h	/^    explicit UsingUninitializedTry() :$/;"	f	class:folly::wangle::UsingUninitializedTry	access:public	signature:()
folly::wangle::WangleException	.\wangle\WangleException.h	/^class WangleException : public std::exception {$/;"	c	namespace:folly::wangle	inherits:std::exception
folly::wangle::WangleException::WangleException	.\wangle\WangleException.h	/^  explicit WangleException(std::string message_arg)$/;"	f	class:folly::wangle::WangleException	access:public	signature:(std::string message_arg)
folly::wangle::WangleException::message	.\wangle\WangleException.h	/^    std::string message;$/;"	m	class:folly::wangle::WangleException	access:protected
folly::wangle::WangleException::operator !=	.\wangle\WangleException.h	/^  bool operator!=(const WangleException &other) const{$/;"	f	class:folly::wangle::WangleException	access:public	signature:(const WangleException &other) const
folly::wangle::WangleException::operator ==	.\wangle\WangleException.h	/^  bool operator==(const WangleException &other) const{$/;"	f	class:folly::wangle::WangleException	access:public	signature:(const WangleException &other) const
folly::wangle::WangleException::what	.\wangle\WangleException.h	/^  virtual const char *what() const throw() {$/;"	f	class:folly::wangle::WangleException	access:public	signature:() const
folly::wangle::WangleException::~WangleException	.\wangle\WangleException.h	/^  ~WangleException() throw(){}$/;"	f	class:folly::wangle::WangleException	access:public	signature:()
folly::wangle::detail	.\wangle\detail\State.h	/^namespace folly { namespace wangle { namespace detail {$/;"	n	namespace:folly::wangle
folly::wangle::detail::State	.\wangle\detail\State.h	/^class State {$/;"	c	namespace:folly::wangle::detail
folly::wangle::detail::State::State	.\wangle\detail\State.h	/^  State() = default;$/;"	p	class:folly::wangle::detail::State	access:public	signature:()
folly::wangle::detail::State::State	.\wangle\detail\State.h	/^  State(State const&) = delete;$/;"	p	class:folly::wangle::detail::State	access:public	signature:(State const&)
folly::wangle::detail::State::activate	.\wangle\detail\State.h	/^  void activate() {$/;"	f	class:folly::wangle::detail::State	access:public	signature:()
folly::wangle::detail::State::active_	.\wangle\detail\State.h	/^  bool active_ = true;$/;"	m	class:folly::wangle::detail::State	access:private
folly::wangle::detail::State::callback_	.\wangle\detail\State.h	/^  std::function<void(Try<T>&&)> callback_;$/;"	m	class:folly::wangle::detail::State	access:private
folly::wangle::detail::State::calledBack_	.\wangle\detail\State.h	/^  bool calledBack_ = false;$/;"	m	class:folly::wangle::detail::State	access:private
folly::wangle::detail::State::deactivate	.\wangle\detail\State.h	/^  void deactivate() {$/;"	f	class:folly::wangle::detail::State	access:public	signature:()
folly::wangle::detail::State::detachFuture	.\wangle\detail\State.h	/^  void detachFuture() {$/;"	f	class:folly::wangle::detail::State	access:public	signature:()
folly::wangle::detail::State::detachOne	.\wangle\detail\State.h	/^  void detachOne() {$/;"	f	class:folly::wangle::detail::State	access:private	signature:()
folly::wangle::detail::State::detachPromise	.\wangle\detail\State.h	/^  void detachPromise() {$/;"	f	class:folly::wangle::detail::State	access:public	signature:()
folly::wangle::detail::State::detached_	.\wangle\detail\State.h	/^  unsigned char detached_ = 0;$/;"	m	class:folly::wangle::detail::State	access:private
folly::wangle::detail::State::fulfil	.\wangle\detail\State.h	/^  void fulfil(Try<T>&& t) {$/;"	f	class:folly::wangle::detail::State	access:public	signature:(Try<T>&& t)
folly::wangle::detail::State::getTry	.\wangle\detail\State.h	/^  Try<T>& getTry() {$/;"	f	class:folly::wangle::detail::State	access:public	signature:()
folly::wangle::detail::State::maybeCallback	.\wangle\detail\State.h	/^  void maybeCallback() {$/;"	f	class:folly::wangle::detail::State	access:private	signature:()
folly::wangle::detail::State::mutex_	.\wangle\detail\State.h	/^  std::recursive_mutex mutex_;$/;"	m	class:folly::wangle::detail::State	access:private
folly::wangle::detail::State::noexcept	.\wangle\detail\State.h	/^  State(State&&) noexcept = delete;$/;"	m	class:folly::wangle::detail::State	access:public
folly::wangle::detail::State::operator =	.\wangle\detail\State.h	/^  State& operator=(State const&) = delete;$/;"	p	class:folly::wangle::detail::State	access:public	signature:(State const&)
folly::wangle::detail::State::operator =	.\wangle\detail\State.h	/^  State& operator=(State&&) = delete;$/;"	p	class:folly::wangle::detail::State	access:public	signature:(State&&)
folly::wangle::detail::State::ready	.\wangle\detail\State.h	/^  bool ready() const {$/;"	f	class:folly::wangle::detail::State	access:public	signature:() const
folly::wangle::detail::State::setCallback	.\wangle\detail\State.h	/^  void setCallback(F func) {$/;"	f	class:folly::wangle::detail::State	access:public	signature:(F func)
folly::wangle::detail::State::setException	.\wangle\detail\State.h	/^  template <class E> void setException(E const& e) {$/;"	f	class:folly::wangle::detail::State	access:public	signature:(E const& e)
folly::wangle::detail::State::setException	.\wangle\detail\State.h	/^  void setException(std::exception_ptr const& e) {$/;"	f	class:folly::wangle::detail::State	access:public	signature:(std::exception_ptr const& e)
folly::wangle::detail::State::value	.\wangle\detail\State.h	/^  typename std::add_lvalue_reference<T>::type value() {$/;"	f	class:folly::wangle::detail::State	access:public	signature:()
folly::wangle::detail::State::value_	.\wangle\detail\State.h	/^  folly::Optional<Try<T>> value_;$/;"	m	class:folly::wangle::detail::State	access:private
folly::wangle::detail::State::~State	.\wangle\detail\State.h	/^  ~State() {$/;"	f	class:folly::wangle::detail::State	access:public	signature:()
folly::wangle::detail::VariadicContext	.\wangle\detail\State.h	/^struct VariadicContext {$/;"	s	namespace:folly::wangle::detail
folly::wangle::detail::VariadicContext::VariadicContext	.\wangle\detail\State.h	/^  VariadicContext() : total(0), count(0) {}$/;"	f	struct:folly::wangle::detail::VariadicContext	access:public	signature:()
folly::wangle::detail::VariadicContext::count	.\wangle\detail\State.h	/^  std::atomic<size_t> count;$/;"	m	struct:folly::wangle::detail::VariadicContext	access:public
folly::wangle::detail::VariadicContext::p	.\wangle\detail\State.h	/^  Promise<std::tuple<Try<Ts>... > > p;$/;"	m	struct:folly::wangle::detail::VariadicContext	access:public
folly::wangle::detail::VariadicContext::results	.\wangle\detail\State.h	/^  std::tuple<Try<Ts>... > results;$/;"	m	struct:folly::wangle::detail::VariadicContext	access:public
folly::wangle::detail::VariadicContext::total	.\wangle\detail\State.h	/^  size_t total;$/;"	m	struct:folly::wangle::detail::VariadicContext	access:public
folly::wangle::detail::VariadicContext::type	.\wangle\detail\State.h	/^  typedef Future<std::tuple<Try<Ts>...>> type;$/;"	t	struct:folly::wangle::detail::VariadicContext	access:public
folly::wangle::detail::WhenAllContext	.\wangle\detail\State.h	/^struct WhenAllContext {$/;"	s	namespace:folly::wangle::detail
folly::wangle::detail::WhenAllContext::WhenAllContext	.\wangle\detail\State.h	/^  explicit WhenAllContext() : count(0), total(0) {}$/;"	f	struct:folly::wangle::detail::WhenAllContext	access:public	signature:()
folly::wangle::detail::WhenAllContext::count	.\wangle\detail\State.h	/^  std::atomic<size_t> count;$/;"	m	struct:folly::wangle::detail::WhenAllContext	access:public
folly::wangle::detail::WhenAllContext::p	.\wangle\detail\State.h	/^  Promise<std::vector<Try<T> > > p;$/;"	m	struct:folly::wangle::detail::WhenAllContext	access:public
folly::wangle::detail::WhenAllContext::results	.\wangle\detail\State.h	/^  std::vector<Try<T> > results;$/;"	m	struct:folly::wangle::detail::WhenAllContext	access:public
folly::wangle::detail::WhenAllContext::total	.\wangle\detail\State.h	/^  size_t total;$/;"	m	struct:folly::wangle::detail::WhenAllContext	access:public
folly::wangle::detail::WhenAllLaterContext	.\wangle\detail\State.h	/^struct WhenAllLaterContext {$/;"	s	namespace:folly::wangle::detail
folly::wangle::detail::WhenAllLaterContext::WhenAllLaterContext	.\wangle\detail\State.h	/^  explicit WhenAllLaterContext() : count(0), total(0) {}$/;"	f	struct:folly::wangle::detail::WhenAllLaterContext	access:public	signature:()
folly::wangle::detail::WhenAllLaterContext::count	.\wangle\detail\State.h	/^  std::atomic<size_t> count;$/;"	m	struct:folly::wangle::detail::WhenAllLaterContext	access:public
folly::wangle::detail::WhenAllLaterContext::fn	.\wangle\detail\State.h	/^  std::function<void(std::vector<Try<T>>&&)> fn;$/;"	m	struct:folly::wangle::detail::WhenAllLaterContext	access:public
folly::wangle::detail::WhenAllLaterContext::results	.\wangle\detail\State.h	/^  std::vector<Try<T> > results;$/;"	m	struct:folly::wangle::detail::WhenAllLaterContext	access:public
folly::wangle::detail::WhenAllLaterContext::total	.\wangle\detail\State.h	/^  size_t total;$/;"	m	struct:folly::wangle::detail::WhenAllLaterContext	access:public
folly::wangle::detail::WhenAnyContext	.\wangle\detail\State.h	/^struct WhenAnyContext {$/;"	s	namespace:folly::wangle::detail
folly::wangle::detail::WhenAnyContext::WhenAnyContext	.\wangle\detail\State.h	/^  explicit WhenAnyContext(size_t n) : done(false), ref_count(n) {};$/;"	f	struct:folly::wangle::detail::WhenAnyContext	access:public	signature:(size_t n)
folly::wangle::detail::WhenAnyContext::decref	.\wangle\detail\State.h	/^  void decref() {$/;"	f	struct:folly::wangle::detail::WhenAnyContext	access:public	signature:()
folly::wangle::detail::WhenAnyContext::done	.\wangle\detail\State.h	/^  std::atomic<bool> done;$/;"	m	struct:folly::wangle::detail::WhenAnyContext	access:public
folly::wangle::detail::WhenAnyContext::p	.\wangle\detail\State.h	/^  Promise<std::pair<size_t, Try<T>>> p;$/;"	m	struct:folly::wangle::detail::WhenAnyContext	access:public
folly::wangle::detail::WhenAnyContext::ref_count	.\wangle\detail\State.h	/^  std::atomic<size_t> ref_count;$/;"	m	struct:folly::wangle::detail::WhenAnyContext	access:public
folly::wangle::detail::empty_callback	.\wangle\detail\State.h	/^void empty_callback(Try<T>&&) { }$/;"	f	namespace:folly::wangle::detail	signature:(Try<T>&&)
folly::wangle::detail::whenAllVariadicHelper	.\wangle\detail\State.h	/^whenAllVariadicHelper(VariadicContext<Ts...> *ctx, THead&& head, Fs&&... tail) {$/;"	f	namespace:folly::wangle::detail	signature:(VariadicContext<Ts...> *ctx, THead&& head, Fs&&... tail)
folly::wangle::isFuture	.\wangle\Future-inl.h	/^struct isFuture {$/;"	s	namespace:folly::wangle
folly::wangle::isFuture	.\wangle\Future-inl.h	/^struct isFuture<Future<T> > {$/;"	s	namespace:folly::wangle
folly::wangle::isFuture	.\wangle\Future.h	/^template <typename T> struct isFuture;$/;"	x
folly::wangle::isFuture::value	.\wangle\Future-inl.h	/^  static const bool value = false;$/;"	m	struct:folly::wangle::isFuture	access:public
folly::wangle::isFuture::value	.\wangle\Future-inl.h	/^  static const bool value = true;$/;"	m	struct:folly::wangle::isFuture	access:public
folly::wangle::isLater	.\wangle\Later-inl.h	/^struct isLater {$/;"	s	namespace:folly::wangle
folly::wangle::isLater	.\wangle\Later-inl.h	/^struct isLater<Later<T> > {$/;"	s	namespace:folly::wangle
folly::wangle::isLater	.\wangle\Later.h	/^template <typename T> struct isLater;$/;"	x
folly::wangle::isLater::value	.\wangle\Later-inl.h	/^  static const bool value = false;$/;"	m	struct:folly::wangle::isLater	access:public
folly::wangle::isLater::value	.\wangle\Later-inl.h	/^  static const bool value = true;$/;"	m	struct:folly::wangle::isLater	access:public
folly::wangle::isLaterOrFuture	.\wangle\Later-inl.h	/^struct isLaterOrFuture {$/;"	s	namespace:folly::wangle
folly::wangle::isLaterOrFuture	.\wangle\Later-inl.h	/^struct isLaterOrFuture<Future<T>> {$/;"	s	namespace:folly::wangle
folly::wangle::isLaterOrFuture	.\wangle\Later-inl.h	/^struct isLaterOrFuture<Later<T>> {$/;"	s	namespace:folly::wangle
folly::wangle::isLaterOrFuture	.\wangle\Later.h	/^template <typename T> struct isLaterOrFuture;$/;"	x
folly::wangle::isLaterOrFuture::value	.\wangle\Later-inl.h	/^  static const bool value = false;$/;"	m	struct:folly::wangle::isLaterOrFuture	access:public
folly::wangle::isLaterOrFuture::value	.\wangle\Later-inl.h	/^  static const bool value = true;$/;"	m	struct:folly::wangle::isLaterOrFuture	access:public
folly::wangle::makeFuture	.\wangle\Future-inl.h	/^Future<T> makeFuture(Try<T>&& t) {$/;"	f	namespace:folly::wangle	signature:(Try<T>&& t)
folly::wangle::makeFuture	.\wangle\Future-inl.h	/^Future<T> makeFuture(std::exception_ptr const& e) {$/;"	f	namespace:folly::wangle	signature:(std::exception_ptr const& e)
folly::wangle::makeFuture	.\wangle\Future-inl.h	/^Future<typename std::decay<T>::type> makeFuture(T&& t) {$/;"	f	namespace:folly::wangle	signature:(T&& t)
folly::wangle::makeFuture	.\wangle\Future-inl.h	/^Future<void> makeFuture() {$/;"	f	namespace:folly::wangle	signature:()
folly::wangle::makeFuture	.\wangle\Future-inl.h	/^inline Future<void> makeFuture(Try<void>&& t) {$/;"	f	namespace:folly::wangle	signature:(Try<void>&& t)
folly::wangle::makeFuture	.\wangle\Future-inl.h	/^makeFuture(E const& e) {$/;"	f	namespace:folly::wangle	signature:(E const& e)
folly::wangle::makeFuture	.\wangle\Future.h	/^Future<T> makeFuture(Try<T>&& t);$/;"	p	namespace:folly::wangle	signature:(Try<T>&& t)
folly::wangle::makeFuture	.\wangle\Future.h	/^Future<T> makeFuture(std::exception_ptr const& e);$/;"	p	namespace:folly::wangle	signature:(std::exception_ptr const& e)
folly::wangle::makeFuture	.\wangle\Future.h	/^Future<typename std::decay<T>::type> makeFuture(T&& t);$/;"	p	namespace:folly::wangle	signature:(T&& t)
folly::wangle::makeFuture	.\wangle\Future.h	/^Future<void> makeFuture();$/;"	p	namespace:folly::wangle	signature:()
folly::wangle::makeFuture	.\wangle\Future.h	/^makeFuture(E const& e);$/;"	p	namespace:folly::wangle	signature:(E const& e)
folly::wangle::makeTryFunction	.\wangle\Try-inl.h	/^makeTryFunction(F&& f) {$/;"	f	namespace:folly::wangle	signature:(F&& f)
folly::wangle::makeTryFunction	.\wangle\Try.h	/^makeTryFunction(F&& f);$/;"	p	namespace:folly::wangle	signature:(F&& f)
folly::wangle::moveFromTry	.\wangle\Try-inl.h	/^inline T moveFromTry(wangle::Try<T>&& t) {$/;"	f	namespace:folly::wangle	signature:(wangle::Try<T>&& t)
folly::wangle::moveFromTry	.\wangle\Try-inl.h	/^inline void moveFromTry(wangle::Try<void>&& t) {$/;"	f	namespace:folly::wangle	signature:(wangle::Try<void>&& t)
folly::wangle::moveFromTry	.\wangle\Try.h	/^T moveFromTry(wangle::Try<T>&& t);$/;"	p	namespace:folly::wangle	signature:(wangle::Try<T>&& t)
folly::wangle::moveFromTry	.\wangle\Try.h	/^void moveFromTry(wangle::Try<void>&& t);$/;"	p	namespace:folly::wangle	signature:(wangle::Try<void>&& t)
folly::wangle::operator <<	.\experimental\wangle\ManagedConnection.cpp	/^operator<<(std::ostream& os, const ManagedConnection& conn) {$/;"	f	namespace:folly::wangle	signature:(std::ostream& os, const ManagedConnection& conn)
folly::wangle::operator <<	.\experimental\wangle\ManagedConnection.h	/^std::ostream& operator<<(std::ostream& os, const ManagedConnection& conn);$/;"	p	namespace:folly::wangle	signature:(std::ostream& os, const ManagedConnection& conn)
folly::wangle::state_	.\wangle\Future-inl.h	/^Future<T>::Future(Future<T>&& other) noexcept : state_(nullptr) {$/;"	f	namespace:folly::wangle	signature:(nullptr)
folly::wangle::waitWithSemaphore	.\wangle\Future-inl.h	/^inline Future<void> waitWithSemaphore<void>(Future<void>&& f) {$/;"	f	namespace:folly::wangle	signature:(Future<void>&& f)
folly::wangle::waitWithSemaphore	.\wangle\Future-inl.h	/^waitWithSemaphore(Future<T>&& f) {$/;"	f	namespace:folly::wangle	signature:(Future<T>&& f)
folly::wangle::waitWithSemaphore	.\wangle\Future-inl.h	/^waitWithSemaphore(Future<T>&& f, Duration timeout) {$/;"	f	namespace:folly::wangle	signature:(Future<T>&& f, Duration timeout)
folly::wangle::waitWithSemaphore	.\wangle\Future-inl.h	/^waitWithSemaphore(Future<void>&& f, Duration timeout) {$/;"	f	namespace:folly::wangle	signature:(Future<void>&& f, Duration timeout)
folly::wangle::waitWithSemaphore	.\wangle\Future.h	/^Future<T> waitWithSemaphore(Future<T>&& f);$/;"	p	namespace:folly::wangle	signature:(Future<T>&& f)
folly::wangle::waitWithSemaphore	.\wangle\Future.h	/^Future<T> waitWithSemaphore(Future<T>&& f, Duration timeout);$/;"	p	namespace:folly::wangle	signature:(Future<T>&& f, Duration timeout)
folly::wangle::whenAll	.\wangle\Future-inl.h	/^whenAll(Fs&&... fs)$/;"	f	namespace:folly::wangle	signature:(Fs&&.... fs)
folly::wangle::whenAll	.\wangle\Future-inl.h	/^whenAll(InputIterator first, InputIterator last)$/;"	f	namespace:folly::wangle	signature:(InputIterator first, InputIterator last)
folly::wangle::whenAll	.\wangle\Future.h	/^whenAll(Fs&&... fs);$/;"	p	namespace:folly::wangle	signature:(Fs&&.... fs)
folly::wangle::whenAll	.\wangle\Future.h	/^whenAll(InputIterator first, InputIterator last);$/;"	p	namespace:folly::wangle	signature:(InputIterator first, InputIterator last)
folly::wangle::whenAllLater	.\wangle\Later-inl.h	/^Later<std::vector<Try<T>>> whenAllLater(std::vector<Later<T>>&& laters) {$/;"	f	namespace:folly::wangle	signature:(std::vector<Later<T>>&& laters)
folly::wangle::whenAllLater	.\wangle\Later.h	/^Later<std::vector<Try<T>>> whenAllLater(std::vector<Later<T>>&& laters);$/;"	p	namespace:folly::wangle	signature:(std::vector<Later<T>>&& laters)
folly::wangle::whenAny	.\wangle\Future-inl.h	/^whenAny(InputIterator first, InputIterator last) {$/;"	f	namespace:folly::wangle	signature:(InputIterator first, InputIterator last)
folly::wangle::whenAny	.\wangle\Future.h	/^whenAny(InputIterator first, InputIterator last);$/;"	p	namespace:folly::wangle	signature:(InputIterator first, InputIterator last)
folly::wangle::whenN	.\wangle\Future-inl.h	/^whenN(InputIterator first, InputIterator last, size_t n) {$/;"	f	namespace:folly::wangle	signature:(InputIterator first, InputIterator last, size_t n)
folly::wangle::whenN	.\wangle\Future.h	/^whenN(InputIterator first, InputIterator last, size_t n);$/;"	p	namespace:folly::wangle	signature:(InputIterator first, InputIterator last, size_t n)
folly::writeFull	.\FileUtil.cpp	/^ssize_t writeFull(int fd, const void* buf, size_t count) {$/;"	f	namespace:folly	signature:(int fd, const void* buf, size_t count)
folly::writeFull	.\FileUtil.h	/^ssize_t writeFull(int fd, const void* buf, size_t n);$/;"	p	namespace:folly	signature:(int fd, const void* buf, size_t n)
folly::writeNoInt	.\FileUtil.cpp	/^ssize_t writeNoInt(int fd, const void* buf, size_t count) {$/;"	f	namespace:folly	signature:(int fd, const void* buf, size_t count)
folly::writeNoInt	.\FileUtil.h	/^ssize_t writeNoInt(int fd, const void* buf, size_t n);$/;"	p	namespace:folly	signature:(int fd, const void* buf, size_t n)
folly::writeTo	.\Format-inl.h	/^void writeTo(FILE* fp,$/;"	f	namespace:folly	signature:(FILE* fp, const BaseFormatter<Derived, containerMode, Args...>& formatter)
folly::writevFull	.\FileUtil.cpp	/^ssize_t writevFull(int fd, iovec* iov, int count) {$/;"	f	namespace:folly	signature:(int fd, iovec* iov, int count)
folly::writevFull	.\FileUtil.h	/^ssize_t writevFull(int fd, iovec* iov, int count);$/;"	p	namespace:folly	signature:(int fd, iovec* iov, int count)
folly::writevNoInt	.\FileUtil.cpp	/^ssize_t writevNoInt(int fd, const iovec* iov, int count) {$/;"	f	namespace:folly	signature:(int fd, const iovec* iov, int count)
folly::writevNoInt	.\FileUtil.h	/^ssize_t writevNoInt(int fd, const iovec* iov, int count);$/;"	p	namespace:folly	signature:(int fd, const iovec* iov, int count)
follyAtoiMeasure	.\test\ConvTest.cpp	/^void follyAtoiMeasure(unsigned int n, unsigned int digits) {$/;"	f	signature:(unsigned int n, unsigned int digits)
folly_popcount_ifunc	.\Bits.cpp	/^extern "C" Type_popcount* folly_popcount_ifunc() {$/;"	f	namespace:__anon3	signature:()
folly_popcountll_ifunc	.\Bits.cpp	/^extern "C" Type_popcountll* folly_popcountll_ifunc() {$/;"	f	namespace:__anon3	signature:()
folly_test	.\test\StringTest.cpp	/^namespace folly_test {$/;"	n	file:
folly_test::ThisIsAVeryLongStructureName	.\test\StringTest.cpp	/^struct ThisIsAVeryLongStructureName {$/;"	s	namespace:folly_test	file:
foo	.\experimental\exception_tracer\ExceptionTracerTest.cpp	/^void foo() {$/;"	f	signature:()
foo	.\experimental\symbolizer\test\SymbolizerTest.cpp	/^void foo() {$/;"	f	namespace:folly::symbolizer::test	signature:()
foo	.\test\ApplyTupleTest.cpp	/^  int foo;$/;"	m	struct:__anon104::Wat	file:	access:public
foo	.\test\LazyTest.cpp	/^auto const foo = folly::lazy([]() -> std::string {$/;"	m	namespace:folly	file:
foo	.\test\PackedSyncPtrTest.cpp	/^struct ignore { PackedSyncPtr<int> foo; char c; } FOLLY_PACK_ATTR;$/;"	m	struct:__anon126::ignore	file:	access:public
foo	.\test\PortabilityTest.cpp	/^  virtual int foo() const { return 1; }$/;"	f	class:Base	access:public	signature:() const
foo	.\test\SmallLocksTest.cpp	/^struct ignore1 { MicroSpinLock msl; int16_t foo; } FOLLY_PACK_ATTR;$/;"	m	struct:__anon131::ignore1	file:	access:public
foo	.\test\SmallLocksTest.cpp	/^struct ignore2 { PicoSpinLock<uint32_t> psl; int16_t foo; }$/;"	m	struct:__anon131::ignore2	file:	access:public
foo1	.\experimental\symbolizer\test\StackTraceTest.cpp	/^FOLLY_NOINLINE void foo1();$/;"	p	file:	signature:()
foo1	.\experimental\symbolizer\test\StackTraceTest.cpp	/^void foo1() {$/;"	f	signature:()
foo2	.\experimental\symbolizer\test\StackTraceTest.cpp	/^FOLLY_NOINLINE void foo2();$/;"	p	file:	signature:()
foo2	.\experimental\symbolizer\test\StackTraceTest.cpp	/^void foo2() {$/;"	f	signature:()
fooBase	.\test\PortabilityTest.cpp	/^int fooBase(const Base* p) { return p->foo() + 1; }$/;"	f	signature:(const Base* p)
fooDerived	.\test\PortabilityTest.cpp	/^int fooDerived(const Derived* p) { return p->foo() + 1; }$/;"	f	signature:(const Derived* p)
forEachBucket	.\stats\BucketedTimeSeries-defs.h	/^void BucketedTimeSeries<VT, TT>::forEachBucket(Function fn) const {$/;"	f	class:folly::BucketedTimeSeries	signature:(Function fn) const
forEachBucket	.\stats\BucketedTimeSeries-defs.h	/^void BucketedTimeSeries<VT, TT>::forEachBucket(TimeType start, TimeType end,$/;"	f	class:folly::BucketedTimeSeries	signature:(TimeType start, TimeType end, Function fn) const
forEachBucket	.\stats\BucketedTimeSeries.h	/^  void forEachBucket(Function fn) const;$/;"	p	class:folly::BucketedTimeSeries	access:public	signature:(Function fn) const
forEachBucket	.\stats\BucketedTimeSeries.h	/^  void forEachBucket(TimeType start, TimeType end, Function fn) const;$/;"	p	class:folly::BucketedTimeSeries	access:private	signature:(TimeType start, TimeType end, Function fn) const
foreach	.\gen\Base-inl.h	/^    virtual void foreach(const std::function<void(Value)>& body) const = 0;$/;"	p	class:folly::gen::VirtualGen::WrapperBase	access:public	signature:(const std::function<void(Value)>& body) const
foreach	.\gen\Base-inl.h	/^    virtual void foreach(const std::function<void(Value)>& body) const {$/;"	f	class:folly::gen::VirtualGen::WrapperImpl	access:public	signature:(const std::function<void(Value)>& body) const
foreach	.\gen\Base-inl.h	/^    void foreach(Body&& body) const {$/;"	f	class:folly::gen::detail::Concat::Generator	access:public	signature:(Body&& body) const
foreach	.\gen\Base-inl.h	/^    void foreach(Body&& body) const {$/;"	f	class:folly::gen::detail::Dereference::Generator	access:public	signature:(Body&& body) const
foreach	.\gen\Base-inl.h	/^    void foreach(Body&& body) const {$/;"	f	class:folly::gen::detail::Distinct::Generator	access:public	signature:(Body&& body) const
foreach	.\gen\Base-inl.h	/^    void foreach(Body&& body) const {$/;"	f	class:folly::gen::detail::Filter::Generator	access:public	signature:(Body&& body) const
foreach	.\gen\Base-inl.h	/^    void foreach(Body&& body) const {$/;"	f	class:folly::gen::detail::Map::Generator	access:public	signature:(Body&& body) const
foreach	.\gen\Base-inl.h	/^    void foreach(Body&& body) const {$/;"	f	class:folly::gen::detail::Order::Generator	access:public	signature:(Body&& body) const
foreach	.\gen\Base-inl.h	/^    void foreach(Body&& body) const {$/;"	f	class:folly::gen::detail::RangeConcat::Generator	access:public	signature:(Body&& body) const
foreach	.\gen\Base-inl.h	/^    void foreach(Body&& body) const {$/;"	f	class:folly::gen::detail::Skip::Generator	access:public	signature:(Body&& body) const
foreach	.\gen\Base-inl.h	/^   void foreach(Body&& body) const {$/;"	f	class:folly::gen::detail::Stride::Generator	access:public	signature:(Body&& body) const
foreach	.\gen\Base-inl.h	/^  void foreach(Body&& body) const {$/;"	f	class:folly::gen::detail::CopiedSource	access:public	signature:(Body&& body) const
foreach	.\gen\Base-inl.h	/^  void foreach(Body&& body) const {$/;"	f	class:folly::gen::detail::Just	access:public	signature:(Body&& body) const
foreach	.\gen\Base-inl.h	/^  void foreach(Body&& body) const {$/;"	f	class:folly::gen::detail::RangeSource	access:public	signature:(Body&& body) const
foreach	.\gen\Base-inl.h	/^  void foreach(Body&& body) const {$/;"	f	class:folly::gen::detail::ReferencedSource	access:public	signature:(Body&& body) const
foreach	.\gen\Base-inl.h	/^  void foreach(Body&& body) const {$/;"	f	class:folly::gen::detail::Sequence	access:public	signature:(Body&& body) const
foreach	.\gen\Base-inl.h	/^  void foreach(Body&& body) const {$/;"	f	class:folly::gen::detail::Yield	access:public	signature:(Body&& body) const
foreach	.\gen\Base-inl.h	/^  void foreach(Body&&) const {}$/;"	f	class:folly::gen::detail::Empty	access:public	signature:(Body&&) const
foreach	.\gen\Base-inl.h	/^  void foreach(const std::function<void(Value)>& body) const {$/;"	f	class:folly::gen::VirtualGen	access:public	signature:(const std::function<void(Value)>& body) const
foreach	.\gen\Core-inl.h	/^  void foreach(Body&& body) const {$/;"	f	class:folly::gen::GenImpl	access:public	signature:(Body&& body) const
foreach	.\gen\Core-inl.h	/^  void foreach(Body&& body) const {$/;"	f	class:folly::gen::detail::Chain	access:public	signature:(Body&& body) const
foreach	.\gen\Parallel-inl.h	/^      void foreach(Body&& body) const {$/;"	f	class:folly::gen::detail::Parallel::Generator::Puller	access:public	signature:(Body&& body) const
foreach	.\gen\Parallel-inl.h	/^    void foreach(Body&& body) const {$/;"	f	class:folly::gen::detail::Parallel::Generator	access:public	signature:(Body&& body) const
foreach	.\gen\ParallelMap-inl.h	/^    void foreach(Body&& body) const {$/;"	f	class:folly::gen::detail::PMap::Generator	access:public	signature:(Body&& body) const
form	.\experimental\symbolizer\Dwarf.h	/^      uint64_t form;$/;"	m	struct:folly::symbolizer::Dwarf::DIEAbbreviation::Attribute	access:public
format	.\Format-inl.h	/^  void format(FormatArg& arg, FormatCallback& cb) const {$/;"	f	class:folly::FormatValue	access:public	signature:(FormatArg& arg, FormatCallback& cb) const
format	.\Format.h	/^Formatter<false, Args...> format(StringPiece fmt, Args&&... args);$/;"	p	namespace:folly	signature:(StringPiece fmt, Args&&... args)
format	.\dynamic-inl.h	/^  void format(FormatArg& arg, FormatCallback& cb) const {$/;"	f	class:folly::FormatValue	access:public	signature:(FormatArg& arg, FormatCallback& cb) const
format	.\experimental\symbolizer\Symbolizer.cpp	/^folly::StringPiece AddressFormatter::format(uintptr_t address) {$/;"	f	class:folly::symbolizer::AddressFormatter	signature:(uintptr_t address)
format	.\experimental\symbolizer\Symbolizer.h	/^  StringPiece format(uintptr_t address);$/;"	p	class:folly::symbolizer::AddressFormatter	access:public	signature:(uintptr_t address)
format	.\test\FormatTest.cpp	/^  void format(FormatArg& arg, FormatCallback& cb) const {$/;"	f	class:folly::FormatValue	access:public	signature:(FormatArg& arg, FormatCallback& cb) const
formatFormatter	.\Format-inl.h	/^void formatFormatter($/;"	f	namespace:folly::format_value	signature:( const BaseFormatter<Derived, containerMode, Args...>& formatter, FormatArg& arg, FormatCallback& cb)
formatNumber	.\Format-inl.h	/^void formatNumber(StringPiece val, int prefixLen, FormatArg& arg,$/;"	f	namespace:folly::format_value	signature:(StringPiece val, int prefixLen, FormatArg& arg, FormatCallback& cb)
formatOrFail	.\Format-inl.h	/^  static void formatOrFail(T& value, FormatArg& arg, FormatCallback& cb) {$/;"	f	class:folly::TryFormatValue	access:public	signature:(T& value, FormatArg& arg, FormatCallback& cb)
formatString	.\Format-inl.h	/^void formatString(StringPiece val, FormatArg& arg, FormatCallback& cb) {$/;"	f	namespace:folly::format_value	signature:(StringPiece val, FormatArg& arg, FormatCallback& cb)
format_value	.\Format-inl.h	/^namespace format_value {$/;"	n	namespace:folly
forward	.\Range.h	/^    -> decltype(process(std::declval<Range>(), std::forward<Args>(args)...))$/;"	f	class:folly::Range::std	access:public	signature:(args)
forward	.\gen\Base.h	/^  decltype(std::forward<Value>(value)) {$/;"	f	class:folly::gen::Identity	access:public	signature:(value)
forward	.\gen\Combine-inl.h	/^                         std::forward<Type2>(t2))) {$/;"	f	class:folly::gen::detail::std	signature:(t2)
forward	.\gen\Combine-inl.h	/^                        std::get<1>(std::forward<Tuple>(value)))) {$/;"	f	class:folly::gen::detail::MergeTuples::std	access:public	signature:(value)
forward	.\gen\Combine-inl.h	/^                        std::make_tuple(std::forward<Type2>(t2)))) {$/;"	f	class:folly::gen::detail::std	signature:(t2)
forwardPointers	.\experimental\EliasFanoCoding.h	/^  folly::ByteRange forwardPointers;$/;"	m	struct:folly::compression::EliasFanoCompressedList	access:public
forwardPointers_	.\experimental\EliasFanoCoding.h	/^  SkipValueType* forwardPointers_ = nullptr;$/;"	m	struct:folly::compression::EliasFanoEncoder	access:private
forwardPointers_	.\experimental\EliasFanoCoding.h	/^  const unsigned char* const forwardPointers_;$/;"	m	class:folly::compression::detail::UpperBitsReader	access:private
forwardQuantum	.\experimental\EliasFanoCoding.h	/^  static constexpr size_t forwardQuantum = kForwardQuantum;$/;"	m	struct:folly::compression::EliasFanoEncoder	access:public
found	.\experimental\symbolizer\Symbolizer.h	/^  bool found;$/;"	m	struct:folly::symbolizer::SymbolizedFrame	access:public
fp_	.\Fingerprint.h	/^  uint64_t fp_[1 + (BITS-1)\/64];$/;"	m	class:folly::Fingerprint	access:private
fp_	.\detail\SlowFingerprint.h	/^  FingerprintPolynomial<BITS-1> fp_;$/;"	m	class:folly::detail::SlowFingerprint	access:private
fragment	.\Uri.h	/^  const fbstring& fragment() const { return fragment_; }$/;"	f	class:folly::Uri	access:public	signature:() const
fragment_	.\Uri.h	/^  fbstring fragment_;$/;"	m	class:folly::Uri	access:private
frameCount	.\experimental\exception_tracer\StackTrace.h	/^  size_t frameCount;$/;"	m	struct:folly::exception_tracer::StackTrace	access:public
frameCount	.\experimental\symbolizer\Symbolizer.h	/^  size_t frameCount;$/;"	m	struct:folly::symbolizer::FrameArray	access:public
frames	.\experimental\exception_tracer\ExceptionTracer.h	/^  std::vector<uintptr_t> frames;  \/\/ front() is top of stack$/;"	m	struct:folly::exception_tracer::ExceptionInfo	access:public
frames	.\experimental\symbolizer\Symbolizer.h	/^  SymbolizedFrame frames[N];$/;"	m	struct:folly::symbolizer::FrameArray	access:public
free	.\SocketAddress.h	/^    void free() {$/;"	f	struct:folly::SocketAddress::ExternalUnixAddr	access:public	signature:()
free	.\experimental\EliasFanoCoding.h	/^  void free() {$/;"	f	struct:folly::compression::EliasFanoCompressedList	access:public	signature:()
free	.\experimental\test\EliasFanoCodingTest.cpp	/^void free() {$/;"	f	namespace:bm	signature:()
freeExtBuffer	.\io\IOBuf.cpp	/^void IOBuf::freeExtBuffer() {$/;"	f	class:folly::IOBuf	signature:()
freeExtBuffer	.\io\IOBuf.h	/^  void freeExtBuffer();$/;"	p	class:folly::IOBuf	access:private	signature:()
freeFn	.\io\IOBuf.h	/^    FreeFunction freeFn;$/;"	m	struct:folly::IOBuf::SharedInfo	access:public
freeHeap	.\small_vector.h	/^    void freeHeap() {$/;"	f	namespace:folly	signature:()
freeIds_	.\detail\ThreadLocalDetail.h	/^  std::vector<int> freeIds_;$/;"	m	struct:folly::threadlocal_detail::StaticMeta	access:public
freeInternalBuf	.\io\IOBuf.cpp	/^void IOBuf::freeInternalBuf(void* buf, void* userData) {$/;"	f	class:folly::IOBuf	signature:(void* buf, void* userData)
freeInternalBuf	.\io\IOBuf.h	/^  static void freeInternalBuf(void* buf, void* userData);$/;"	p	class:folly::IOBuf	access:private	signature:(void* buf, void* userData)
freeProtectedBuf	.\test\RangeTest.cpp	/^void freeProtectedBuf(char* buf) {$/;"	f	signature:(char* buf)
freeUniquePtrBuffer	.\io\IOBuf.h	/^  static void freeUniquePtrBuffer(void* ptr, void* userData) {$/;"	f	class:folly::IOBuf	access:private	signature:(void* ptr, void* userData)
fresh	.\LifoSem.h	/^  static inline constexpr LifoSemHead fresh(uint32_t value) {$/;"	f	class:folly::detail::LifoSemHead	access:public	signature:(uint32_t value)
from	.\String-inl.h	/^  static Dst from(const Dst& src) { return src; }$/;"	f	struct:folly::detail::convertTo	access:public	signature:(const Dst& src)
from	.\String-inl.h	/^  static Dst from(const Src& src) { return folly::to<Dst>(src); }$/;"	f	struct:folly::detail::convertTo	access:public	signature:(const Src& src)
from	.\gen\Base.h	/^From from(Container& source) {$/;"	f	namespace:folly::gen	signature:(Container& source)
from	.\gen\Base.h	/^From from(Container&& source) {$/;"	f	namespace:folly::gen	signature:(Container&& source)
from	.\gen\Base.h	/^From from(std::initializer_list<Value> source) {$/;"	f	namespace:folly::gen	signature:(std::initializer_list<Value> source)
fromBinary	.\IPAddress.cpp	/^IPAddress IPAddress::fromBinary(ByteRange bytes) {$/;"	f	class:folly::IPAddress	signature:(ByteRange bytes)
fromBinary	.\IPAddress.h	/^  static IPAddress fromBinary(ByteRange bytes);$/;"	p	class:folly::IPAddress	access:public	signature:(ByteRange bytes)
fromBinary	.\IPAddressV4.h	/^  static IPAddressV4 fromBinary(ByteRange bytes) {$/;"	f	class:folly::IPAddressV4	access:public	signature:(ByteRange bytes)
fromBinary	.\IPAddressV6.h	/^  static IPAddressV6 fromBinary(ByteRange bytes) {$/;"	f	class:folly::IPAddressV6	access:public	signature:(ByteRange bytes)
fromBinary	.\MacAddress.h	/^  static MacAddress fromBinary(ByteRange value) {$/;"	f	class:folly::MacAddress	access:public	signature:(ByteRange value)
fromConst	.\gen\Base.h	/^From fromConst(const Container& source) {$/;"	f	namespace:folly::gen	signature:(const Container& source)
fromCopy	.\gen\Base.h	/^CopyOf fromCopy(Container&& source) {$/;"	f	namespace:folly::gen	signature:(Container&& source)
fromFile	.\gen\File.h	/^S fromFile(File file, size_t bufferSize=4096) {$/;"	f	namespace:folly::gen	signature:(File file, size_t bufferSize=4096)
fromFile	.\gen\File.h	/^S fromFile(File file, std::unique_ptr<IOBuf> buffer) {$/;"	f	namespace:folly::gen	signature:(File file, std::unique_ptr<IOBuf> buffer)
fromHBO	.\MacAddress.h	/^  static MacAddress fromHBO(uint64_t value) {$/;"	f	class:folly::MacAddress	access:public	signature:(uint64_t value)
fromInteger	.\RWSpinLock.h	/^  static inline __m128i fromInteger(uint32_t from) {$/;"	f	struct:folly::detail::RWTicketIntTrait	access:public	signature:(uint32_t from)
fromInteger	.\RWSpinLock.h	/^  static inline __m128i fromInteger(uint64_t from) {$/;"	f	struct:folly::detail::RWTicketIntTrait	access:public	signature:(uint64_t from)
fromLong	.\IPAddress.cpp	/^IPAddress IPAddress::fromLong(uint32_t src) {$/;"	f	class:folly::IPAddress	signature:(uint32_t src)
fromLong	.\IPAddress.h	/^  static IPAddress fromLong(uint32_t src);$/;"	p	class:folly::IPAddress	access:public	signature:(uint32_t src)
fromLong	.\IPAddressV4.cpp	/^IPAddressV4 IPAddressV4::fromLong(uint32_t src) {$/;"	f	class:folly::IPAddressV4	signature:(uint32_t src)
fromLong	.\IPAddressV4.h	/^  static IPAddressV4 fromLong(uint32_t src);$/;"	p	class:folly::IPAddressV4	access:public	signature:(uint32_t src)
fromLongHBO	.\IPAddress.cpp	/^IPAddress IPAddress::fromLongHBO(uint32_t src) {$/;"	f	class:folly::IPAddress	signature:(uint32_t src)
fromLongHBO	.\IPAddress.h	/^  static IPAddress fromLongHBO(uint32_t src);$/;"	p	class:folly::IPAddress	access:public	signature:(uint32_t src)
fromLongHBO	.\IPAddressV4.cpp	/^IPAddressV4 IPAddressV4::fromLongHBO(uint32_t src) {$/;"	f	class:folly::IPAddressV4	signature:(uint32_t src)
fromLongHBO	.\IPAddressV4.h	/^  static IPAddressV4 fromLongHBO(uint32_t src);$/;"	p	class:folly::IPAddressV4	access:public	signature:(uint32_t src)
fromNBO	.\MacAddress.h	/^  static MacAddress fromNBO(uint64_t value) {$/;"	f	class:folly::MacAddress	access:public	signature:(uint64_t value)
fromStr	.\io\test\IOBufTest.cpp	/^std::unique_ptr<IOBuf> fromStr(StringPiece sp) {$/;"	f	namespace:__anon72	signature:(StringPiece sp)
front	.\FBVector.h	/^  const_reference front() const {$/;"	f	signature:() const
front	.\FBVector.h	/^  reference front() {$/;"	f	signature:()
front	.\Padded.h	/^  const value_type& front() const {$/;"	f	class:folly::Adaptor	access:public	signature:() const
front	.\Padded.h	/^  value_type& front() {$/;"	f	class:folly::Adaptor	access:public	signature:()
front	.\Range.h	/^  const value_type& front() const {$/;"	f	class:folly::Range	access:public	signature:() const
front	.\Range.h	/^  value_type& front() {$/;"	f	class:folly::Range	access:public	signature:()
front	.\detail\CacheLocality.cpp	/^    CacheLocality::system<>().numCachesByLevel.front());$/;"	p	namespace:folly::detail	file:	signature:()
front	.\io\IOBufQueue.h	/^  const folly::IOBuf* front() const {$/;"	f	class:folly::IOBufQueue	access:public	signature:() const
front	.\io\TypedIOBuf.h	/^  T& front() {$/;"	f	class:folly::TypedIOBuf	access:public	signature:()
front	.\io\TypedIOBuf.h	/^  const T& front() const {$/;"	f	class:folly::TypedIOBuf	access:public	signature:() const
front	.\small_vector.h	/^  const_reference front() const { assert(!empty()); return *begin(); }$/;"	f	class:folly::small_vector	access:public	signature:() const
front	.\small_vector.h	/^  reference front()             { assert(!empty()); return *begin(); }$/;"	f	class:folly::small_vector	access:public	signature:()
front	.\test\DeterministicSchedule.cpp	/^    CacheLocality::system<>().numCachesByLevel.front());$/;"	p	namespace:folly::detail	file:	signature:()
frontPtr	.\ProducerConsumerQueue.h	/^  T* frontPtr() {$/;"	f	struct:folly::ProducerConsumerQueue	access:public	signature:()
fs	.\experimental\io\FsUtil.cpp	/^namespace fs {$/;"	n	namespace:folly	file:
fs	.\experimental\io\FsUtil.h	/^namespace fs {$/;"	n	namespace:folly
fs	.\experimental\io\test\AsyncIOTest.cpp	/^namespace fs = folly::fs;$/;"	x	file:
fsyncNoInt	.\FileUtil.cpp	/^int fsyncNoInt(int fd) {$/;"	f	namespace:folly	signature:(int fd)
fsyncNoInt	.\FileUtil.h	/^int fsyncNoInt(int fd);$/;"	p	namespace:folly	signature:(int fd)
ftruncateNoInt	.\FileUtil.cpp	/^int ftruncateNoInt(int fd, off_t len) {$/;"	f	namespace:folly	signature:(int fd, off_t len)
ftruncateNoInt	.\FileUtil.h	/^int ftruncateNoInt(int fd, off_t len);$/;"	p	namespace:folly	signature:(int fd, off_t len)
fulfil	.\wangle\Promise-inl.h	/^void Promise<T>::fulfil(F&& func) {$/;"	f	class:folly::wangle::Promise	signature:(F&& func)
fulfil	.\wangle\Promise.h	/^  void fulfil(F&& func);$/;"	p	class:folly::wangle::Promise	access:public	signature:(F&& func)
fulfil	.\wangle\detail\State.h	/^  void fulfil(Try<T>&& t) {$/;"	f	class:folly::wangle::detail::State	access:public	signature:(Try<T>&& t)
fulfilTry	.\wangle\Promise-inl.h	/^void Promise<T>::fulfilTry(Try<T>&& t) {$/;"	f	class:folly::wangle::Promise	signature:(Try<T>&& t)
fulfilTry	.\wangle\Promise.h	/^  void fulfilTry(Try<T>&& t);$/;"	p	class:folly::wangle::Promise	access:public	signature:(Try<T>&& t)
fullArgString	.\FormatArg.h	/^  StringPiece fullArgString;$/;"	m	struct:folly::FormatArg	access:public
fullNode	.\Padded.h	/^  static Node fullNode(const value_type& value) {$/;"	f	class:folly::Adaptor	access:private	signature:(const value_type& value)
fullyLinked	.\ConcurrentSkipList-inl.h	/^  bool fullyLinked() const      { return getFlags() & FULLY_LINKED; }$/;"	f	class:folly::detail::SkipListNode	access:public	signature:() const
fun	.\test\BenchmarkTest.cpp	/^void fun() {$/;"	f	signature:()
func	.\experimental\wangle\concurrent\CPUThreadPoolExecutor.h	/^    Func func;$/;"	m	struct:folly::wangle::CPUThreadPoolExecutor::Task	access:public
func	.\test\ApplyTupleTest.cpp	/^  bool func(bool) { return true; }$/;"	f	struct:__anon104::Overloaded	access:public	signature:(bool)
func	.\test\ApplyTupleTest.cpp	/^  int func(int) { return 0; }$/;"	f	struct:__anon104::Overloaded	access:public	signature:(int)
func	.\test\ApplyTupleTest.cpp	/^  void func(int a, int b, double c) {$/;"	f	struct:__anon104::Wat	access:public	signature:(int a, int b, double c)
func	.\test\ApplyTupleTest.cpp	/^void func(int a, int b, double c) {$/;"	f	namespace:__anon104	signature:(int a, int b, double c)
func_	.\Lazy.h	/^  Func func_;$/;"	m	struct:folly::detail::Lazy	access:private
function	.\Traits.h	/^FOLLY_ASSUME_FBVECTOR_COMPATIBLE_1(std::function);$/;"	v
function_	.\ScopeGuard.h	/^  FunctionType function_;$/;"	m	class:folly::ScopeGuardImpl	access:private
function_	.\ScopeGuard.h	/^  FunctionType function_;$/;"	m	class:folly::detail::ScopeGuardForNewException	access:private
function_	.\io\async\EventBase.cpp	/^  Callback function_;$/;"	m	class:__anon62::FunctionLoopCallback	file:	access:private
futexErrnoToFutexResult	.\detail\Futex.cpp	/^FutexResult futexErrnoToFutexResult(int returnVal, int futexErrno) {$/;"	f	namespace:folly::detail	signature:(int returnVal, int futexErrno)
futexErrnoToFutexResult	.\detail\Futex.h	/^FutexResult futexErrnoToFutexResult(int returnVal, int futexErrno);$/;"	p	namespace:folly::detail	signature:(int returnVal, int futexErrno)
futexLock	.\test\DeterministicSchedule.cpp	/^static std::mutex futexLock;$/;"	m	namespace:folly::test	file:
futexQueues	.\test\DeterministicSchedule.cpp	/^                          std::list<std::pair<uint32_t,bool*>>> futexQueues;$/;"	m	namespace:folly::test	file:
futexWait	.\detail\Futex.h	/^  bool futexWait(uint32_t expected, uint32_t waitMask = -1);$/;"	p	struct:folly::detail::Futex	access:public	signature:(uint32_t expected, uint32_t waitMask = -1)
futexWait	.\detail\Futex.h	/^inline bool Futex<std::atomic>::futexWait(uint32_t expected,$/;"	f	class:folly::detail::Futex	signature:(uint32_t expected, uint32_t waitMask)
futexWait	.\detail\MemoryIdler.h	/^  static bool futexWait($/;"	f	struct:folly::detail::MemoryIdler	access:public	signature:( Futex<Atom>& fut, uint32_t expected, uint32_t waitMask = -1, typename Clock::duration idleTimeout = defaultIdleTimeout.load(std::memory_order_acquire), size_t stackToRetain = kDefaultStackToRetain, float timeoutVariationFrac = 0.5)
futexWait	.\test\DeterministicSchedule.cpp	/^bool Futex<DeterministicAtomic>::futexWait(uint32_t expected,$/;"	f	class:folly::detail::Futex	signature:(uint32_t expected, uint32_t waitMask)
futexWaitImpl	.\detail\Futex.h	/^  int futexWaitImpl(uint32_t expected,$/;"	p	struct:folly::detail::Futex	access:private	signature:(uint32_t expected, const struct timespec* absTimeout, int extraOpFlags, uint32_t waitMask)
futexWaitImpl	.\detail\Futex.h	/^Futex<std::atomic>::futexWaitImpl(uint32_t expected,$/;"	f	class:folly::detail::Futex	signature:(uint32_t expected, const struct timespec* absTimeout, int extraOpFlags, uint32_t waitMask)
futexWaitUntil	.\detail\Futex.h	/^  FutexResult futexWaitUntil(uint32_t expected,$/;"	p	struct:folly::detail::Futex	access:public	signature:(uint32_t expected, const time_point<Clock, Duration>& absTime, uint32_t waitMask = -1)
futexWaitUntil	.\detail\Futex.h	/^Futex<Atom>::futexWaitUntil($/;"	f	class:folly::detail::Futex	signature:( uint32_t expected, const time_point<Clock, Duration>& absTime, uint32_t waitMask)
futexWaitUntilImpl	.\test\DeterministicSchedule.cpp	/^FutexResult futexWaitUntilImpl(Futex<DeterministicAtomic>* futex,$/;"	f	namespace:folly::detail	signature:(Futex<DeterministicAtomic>* futex, uint32_t expected, uint32_t waitMask)
futexWake	.\detail\Futex.h	/^  int futexWake(int count = std::numeric_limits<int>::max(),$/;"	p	struct:folly::detail::Futex	access:public	signature:(int count = std::numeric_limits<int>::max(), uint32_t wakeMask = -1)
futexWake	.\detail\Futex.h	/^inline int Futex<std::atomic>::futexWake(int count, uint32_t wakeMask) {$/;"	f	class:folly::detail::Futex	signature:(int count, uint32_t wakeMask)
futexWake	.\test\DeterministicSchedule.cpp	/^int Futex<DeterministicAtomic>::futexWake(int count, uint32_t wakeMask) {$/;"	f	class:folly::detail::Futex	signature:(int count, uint32_t wakeMask)
future_	.\wangle\Later.h	/^  folly::Optional<Future<T>> future_;$/;"	m	class:folly::wangle::Later	access:private
gAlreadyInstalled	.\experimental\symbolizer\SignalHandler.cpp	/^std::atomic<bool> gAlreadyInstalled;$/;"	m	namespace:folly::symbolizer::__anon38	file:
gCodecFactories	.\io\Compression.cpp	/^CodecFactory gCodecFactories[$/;"	m	namespace:folly::io::__anon64	file:
gData	.\test\ConcurrentSkipListBenchmark.cpp	/^static std::vector<ValueType> gData;$/;"	m	namespace:__anon113	file:
gDecodedValues	.\test\VarintTest.cpp	/^std::vector<uint64_t> gDecodedValues;$/;"	m	namespace:folly::test::__anon149	file:
gDestroyed	.\test\ThreadLocalTest.cpp	/^std::atomic<uint64_t> gDestroyed;$/;"	m	namespace:__anon146	file:
gEncoded	.\test\VarintTest.cpp	/^std::vector<uint8_t> gEncoded;$/;"	m	namespace:folly::test::__anon149	file:
gFatalSignalCallbackRegistry	.\experimental\symbolizer\SignalHandler.cpp	/^FatalSignalCallbackRegistry* gFatalSignalCallbackRegistry =$/;"	m	namespace:folly::symbolizer::__anon36	file:
gInRecursiveSignalHandler	.\experimental\symbolizer\SignalHandler.cpp	/^std::atomic<bool> gInRecursiveSignalHandler(false);$/;"	p	namespace:folly::symbolizer::__anon36	file:	signature:(false)
gPrinter	.\experimental\symbolizer\SignalHandler.cpp	/^auto gPrinter = new FDSymbolizePrinter(STDERR_FILENO,$/;"	m	namespace:folly::symbolizer::__anon36	file:
gSignalSafeElfCache	.\experimental\symbolizer\SignalHandler.cpp	/^auto gSignalSafeElfCache = new SignalSafeElfCache(kDefaultCapacity);$/;"	m	namespace:folly::symbolizer::__anon36	file:
gSignalThread	.\experimental\symbolizer\SignalHandler.cpp	/^std::atomic<pthread_t> gSignalThread(kInvalidThreadId);$/;"	p	namespace:folly::symbolizer::__anon36	file:	signature:(kInvalidThreadId)
gValues	.\test\VarintTest.cpp	/^std::vector<uint64_t> gValues;$/;"	m	namespace:folly::test::__anon149	file:
g_data	.\test\ConcurrentSkipListBenchmark.cpp	/^static std::map<int, std::shared_ptr<ConcurrentAccessData> > g_data;$/;"	m	namespace:__anon113	file:
gate	.\wangle\ThreadGate.h	/^  Future<T> gate(std::function<Future<T>()>&& fn) {$/;"	f	class:folly::wangle::ThreadGate	access:public	signature:(std::function<Future<T>()>&& fn)
gate	.\wangle\ThreadGate.h	/^  void gate(std::function<Future<T>()>&& fn,$/;"	f	class:folly::wangle::ThreadGate	access:public	signature:(std::function<Future<T>()>&& fn, Promise<T>&& p)
gather	.\io\Cursor.h	/^  void gather(size_t n) {$/;"	f	class:folly::io::RWCursor	access:public	signature:(size_t n)
gather	.\io\IOBuf.h	/^  void gather(uint64_t maxLength) {$/;"	f	class:folly::IOBuf	access:public	signature:(uint64_t maxLength)
gatherAtMost	.\io\Cursor.h	/^  void gatherAtMost(size_t n) {$/;"	f	class:folly::io::RWCursor	access:public	signature:(size_t n)
gen	.\gen\Base-inl.h	/^namespace folly { namespace gen {$/;"	n	namespace:folly
gen	.\gen\Base.h	/^namespace folly { namespace gen {$/;"	n	namespace:folly
gen	.\gen\Combine-inl.h	/^namespace gen {$/;"	n	namespace:folly
gen	.\gen\Combine.h	/^namespace gen {$/;"	n	namespace:folly
gen	.\gen\Core-inl.h	/^namespace folly { namespace gen {$/;"	n	namespace:folly
gen	.\gen\Core.h	/^namespace folly { namespace gen {$/;"	n	namespace:folly
gen	.\gen\File-inl.h	/^namespace gen {$/;"	n	namespace:folly
gen	.\gen\File.h	/^namespace gen {$/;"	n	namespace:folly
gen	.\gen\Parallel-inl.h	/^namespace gen {$/;"	n	namespace:folly
gen	.\gen\Parallel.h	/^namespace folly { namespace gen {$/;"	n	namespace:folly
gen	.\gen\ParallelMap-inl.h	/^namespace folly { namespace gen { namespace detail {$/;"	n	namespace:folly
gen	.\gen\ParallelMap.h	/^namespace folly { namespace gen {$/;"	n	namespace:folly
gen	.\gen\String-inl.h	/^namespace gen {$/;"	n	namespace:folly
gen	.\gen\String.h	/^namespace gen {$/;"	n	namespace:folly
genVal	.\test\AtomicHashMapTest.cpp	/^static int genVal(int key) {$/;"	f	file:	signature:(int key)
generate	.\build\generate_escape_tables.py	/^def generate(f):$/;"	f	access:public
generate	.\build\generate_format_tables.py	/^def generate(f):$/;"	f	access:public
generate	.\build\generate_varint_tables.py	/^def generate(f):$/;"	f	access:public
generate	.\test\ProducerConsumerQueueTest.cpp	/^  T generate() const { return rand() % 26; }$/;"	f	struct:__anon128::TestTraits	access:public	signature:() const
generate	.\test\ProducerConsumerQueueTest.cpp	/^  std::string generate() const { return std::string(12, ' '); }$/;"	f	struct:__anon128::TestTraits	access:public	signature:() const
generateRandomList	.\experimental\test\CodingTestUtils.h	/^inline std::vector<uint32_t> generateRandomList(size_t n, uint32_t maxId) {$/;"	f	namespace:folly::compression	signature:(size_t n, uint32_t maxId)
generateRandomList	.\experimental\test\CodingTestUtils.h	/^std::vector<uint32_t> generateRandomList(size_t n, uint32_t maxId, URNG&& g) {$/;"	f	namespace:folly::compression	signature:(size_t n, uint32_t maxId, URNG&& g)
generateRandomValues	.\test\VarintTest.cpp	/^void generateRandomValues() {$/;"	f	namespace:folly::test::__anon149	signature:()
generateSeqList	.\experimental\test\CodingTestUtils.h	/^inline std::vector<uint32_t> generateSeqList(uint32_t minId, uint32_t maxId,$/;"	f	namespace:folly::compression	signature:(uint32_t minId, uint32_t maxId, uint32_t step = 1)
generateString	.\test\RangeFindBenchmark.cpp	/^string generateString(int len) {$/;"	f	namespace:__anon129	signature:(int len)
generateUniquePath	.\experimental\TestUtil.cpp	/^fs::path generateUniquePath(fs::path path, StringPiece namePrefix) {$/;"	f	namespace:folly::test::__anon48	signature:(fs::path path, StringPiece namePrefix)
generate_conv_table	.\build\generate_format_tables.py	/^def generate_conv_table(f, name, values):$/;"	f	access:public
generate_table	.\build\generate_format_tables.py	/^def generate_table(f, type_name, name, map):$/;"	f	access:public
generator	.\gen\Base.h	/^Yield generator(Source&& source) {$/;"	f	namespace:folly::gen	signature:(Source&& source)
get	.\DiscriminatedPtr.h	/^  T* get() {$/;"	f	class:folly::DiscriminatedPtr	access:public	signature:()
get	.\DiscriminatedPtr.h	/^  const T* get() const {$/;"	f	class:folly::DiscriminatedPtr	access:public	signature:() const
get	.\EvictingCacheMap.h	/^  TValue& get(const TKey& key) {$/;"	f	class:folly::EvictingCacheMap	access:public	signature:(const TKey& key)
get	.\PackedSyncPtr.h	/^  T* get() const {$/;"	f	class:folly::PackedSyncPtr	access:public	signature:() const
get	.\Random.cpp	/^  void get(void* data, size_t size) {$/;"	f	class:folly::__anon82::BufferedRandomDevice	access:public	signature:(void* data, size_t size)
get	.\ThreadLocal.h	/^  T* get() const {$/;"	f	class:folly::ThreadLocal	access:public	signature:() const
get	.\ThreadLocal.h	/^  T* get() const {$/;"	f	class:folly::ThreadLocalPtr	access:public	signature:() const
get	.\detail\CacheLocality.h	/^  static size_t get() {$/;"	f	struct:folly::detail::SequentialThreadId	access:public	signature:()
get	.\detail\ThreadLocalDetail.h	/^  static ElementWrapper& get(size_t id) {$/;"	f	struct:folly::threadlocal_detail::StaticMeta	access:public	signature:(size_t id)
get	.\dynamic-inl.h	/^  static Array* get(Data& d) { return &d.array; }$/;"	f	struct:folly::dynamic::GetAddrImpl	access:public	signature:(Data& d)
get	.\dynamic-inl.h	/^  static ObjectImpl* get(Data& d) {$/;"	f	struct:folly::dynamic::GetAddrImpl	access:public	signature:(Data& d)
get	.\dynamic-inl.h	/^  static bool* get(Data& d) { return &d.boolean; }$/;"	f	struct:folly::dynamic::GetAddrImpl	access:public	signature:(Data& d)
get	.\dynamic-inl.h	/^  static double* get(Data& d) { return &d.doubl; }$/;"	f	struct:folly::dynamic::GetAddrImpl	access:public	signature:(Data& d)
get	.\dynamic-inl.h	/^  static fbstring* get(Data& d) { return &d.string; }$/;"	f	struct:folly::dynamic::GetAddrImpl	access:public	signature:(Data& d)
get	.\dynamic-inl.h	/^  static int64_t* get(Data& d) { return &d.integer; }$/;"	f	struct:folly::dynamic::GetAddrImpl	access:public	signature:(Data& d)
get	.\dynamic-inl.h	/^  static void** get(Data& d) { return &d.nul; }$/;"	f	struct:folly::dynamic::GetAddrImpl	access:public	signature:(Data& d)
get	.\dynamic-inl.h	/^T const& dynamic::get() const {$/;"	f	class:folly::dynamic	signature:() const
get	.\dynamic-inl.h	/^T& dynamic::get() {$/;"	f	class:folly::dynamic	signature:()
get	.\dynamic.h	/^  template<class T> T const& get() const;$/;"	p	struct:folly::dynamic	access:private	signature:() const
get	.\dynamic.h	/^  template<class T> T&       get();$/;"	p	struct:folly::dynamic	access:private	signature:()
get	.\experimental\Bits.h	/^  static UnderlyingType get(const T* p, size_t bitStart, size_t count);$/;"	p	struct:folly::Bits	access:public	signature:(const T* p, size_t bitStart, size_t count)
get	.\experimental\Singleton.h	/^  static T* get(SingletonVault* vault = nullptr \/* for testing *\/) {$/;"	f	class:folly::Singleton	access:public	signature:(SingletonVault* vault = nullptr )
get	.\experimental\Singleton.h	/^  static T* get(const char* name,$/;"	f	class:folly::Singleton	access:public	signature:(const char* name, SingletonVault* vault = nullptr )
get	.\experimental\wangle\concurrent\ThreadPoolExecutor.h	/^    const std::vector<ThreadPtr>& get() const {$/;"	f	class:folly::wangle::ThreadPoolExecutor::ThreadList	access:public	signature:() const
get	.\gen\Base.h	/^  decltype(std::get<n>(std::forward<Value>(value))) {$/;"	f	class:folly::gen::Get	access:public	signature:(std::forward<Value>(
get	.\gen\Base.h	/^Get get() {$/;"	f	namespace:folly::gen	signature:()
get	.\io\async\EventBase.h	/^    double get() const {$/;"	f	class:folly::EventBase::SmoothLoopTime	access:public	signature:() const
get	.\io\async\Request.h	/^  static RequestContext* get() {$/;"	f	class:folly::RequestContext	access:public	signature:()
get	.\test\AHMIntStressTest.cpp	/^  std::shared_ptr<MyObject> get(int key) {$/;"	f	struct:__anon102::MyObjectDirectory	access:public	signature:(int key)
get	.\test\ThreadLocalTest.cpp	/^  T* get() const {$/;"	f	class:PThreadGetSpecific	access:public	signature:() const
get	.\test\stl_tests\StlVectorTest.cpp	/^  static A get() { return A(); }$/;"	f	struct:allocGen	access:public	signature:()
get	.\test\stl_tests\StlVectorTest.cpp	/^  static Alloc<T> get() {$/;"	f	struct:allocGen	access:public	signature:()
get16bits	.\Hash.h	270;"	d
get16bits	.\Hash.h	324;"	d
getAbbreviation	.\experimental\symbolizer\Dwarf.cpp	/^Dwarf::DIEAbbreviation Dwarf::getAbbreviation(uint64_t code, uint64_t offset)$/;"	f	class:folly::symbolizer::Dwarf	signature:(uint64_t code, uint64_t offset) const
getAbbreviation	.\experimental\symbolizer\Dwarf.h	/^  DIEAbbreviation getAbbreviation(uint64_t code, uint64_t offset) const;$/;"	p	class:folly::symbolizer::Dwarf	access:private	signature:(uint64_t code, uint64_t offset) const
getActualSize	.\SocketAddress.cpp	/^socklen_t SocketAddress::getActualSize() const {$/;"	f	class:folly::SocketAddress	signature:() const
getActualSize	.\SocketAddress.h	/^  socklen_t getActualSize() const;$/;"	p	class:folly::SocketAddress	access:public	signature:() const
getAddrInfo	.\SocketAddress.cpp	/^struct addrinfo* SocketAddress::getAddrInfo(const char* host,$/;"	f	class:folly::SocketAddress	signature:(const char* host, const char* port, int flags)
getAddrInfo	.\SocketAddress.cpp	/^struct addrinfo* SocketAddress::getAddrInfo(const char* host,$/;"	f	class:folly::SocketAddress	signature:(const char* host, uint16_t port, int flags)
getAddrInfo	.\SocketAddress.h	/^  struct addrinfo* getAddrInfo(const char* host, const char* port, int flags);$/;"	p	class:folly::SocketAddress	access:private	signature:(const char* host, const char* port, int flags)
getAddrInfo	.\SocketAddress.h	/^  struct addrinfo* getAddrInfo(const char* host, uint16_t port, int flags);$/;"	p	class:folly::SocketAddress	access:private	signature:(const char* host, uint16_t port, int flags)
getAddress	.\SocketAddress.h	/^  socklen_t getAddress(sockaddr_storage* addr) const {$/;"	f	class:folly::SocketAddress	access:public	signature:(sockaddr_storage* addr) const
getAddress	.\dynamic-inl.h	/^T const* dynamic::getAddress() const {$/;"	f	class:folly::dynamic	signature:() const
getAddress	.\dynamic-inl.h	/^T* dynamic::getAddress() {$/;"	f	class:folly::dynamic	signature:()
getAddress	.\dynamic.h	/^  template<class T> T const* getAddress() const;$/;"	p	struct:folly::dynamic	access:private	signature:() const
getAddress	.\dynamic.h	/^  template<class T> T*       getAddress();$/;"	p	struct:folly::dynamic	access:private	signature:()
getAddressStr	.\SocketAddress.cpp	/^std::string SocketAddress::getAddressStr() const {$/;"	f	class:folly::SocketAddress	signature:() const
getAddressStr	.\SocketAddress.cpp	/^void SocketAddress::getAddressStr(char* buf, size_t buflen) const {$/;"	f	class:folly::SocketAddress	signature:(char* buf, size_t buflen) const
getAddressStr	.\SocketAddress.h	/^  std::string getAddressStr() const;$/;"	p	class:folly::SocketAddress	access:public	signature:() const
getAddressStr	.\SocketAddress.h	/^  void getAddressStr(char* buf, size_t buflen) const;$/;"	p	class:folly::SocketAddress	access:public	signature:(char* buf, size_t buflen) const
getAvgLoopTime	.\io\async\EventBase.h	/^  double getAvgLoopTime() const {$/;"	f	class:folly::EventBase	access:public	signature:() const
getBaseAddress	.\experimental\symbolizer\Elf.h	/^  uintptr_t getBaseAddress() const {$/;"	f	class:folly::symbolizer::ElfFile	access:public	signature:() const
getBucket	.\stats\TimeseriesHistogram.h	/^  const ContainerType& getBucket(int bucketIdx) const {$/;"	f	class:folly::TimeseriesHistogram	access:public	signature:(int bucketIdx) const
getBucketByIndex	.\stats\BucketedTimeSeries.h	/^  const Bucket& getBucketByIndex(size_t idx) const {$/;"	f	class:folly::BucketedTimeSeries	access:public	signature:(size_t idx) const
getBucketByIndex	.\stats\Histogram.h	/^  const Bucket& getBucketByIndex(int idx) const {$/;"	f	class:folly::Histogram	access:public	signature:(int idx) const
getBucketIdx	.\stats\BucketedTimeSeries-defs.h	/^size_t BucketedTimeSeries<VT, TT>::getBucketIdx(TimeType time) const {$/;"	f	class:folly::BucketedTimeSeries	signature:(TimeType time) const
getBucketIdx	.\stats\BucketedTimeSeries.h	/^  size_t getBucketIdx(TimeType time) const;$/;"	p	class:folly::BucketedTimeSeries	access:public	signature:(TimeType time) const
getBucketIdx	.\stats\Histogram-defs.h	/^unsigned int HistogramBuckets<T, BucketType>::getBucketIdx($/;"	f	class:folly::detail::HistogramBuckets	signature:( ValueType value) const
getBucketIdx	.\stats\Histogram.h	/^  unsigned int getBucketIdx(ValueType value) const;$/;"	p	class:folly::detail::HistogramBuckets	access:public	signature:(ValueType value) const
getBucketIdx	.\stats\TimeseriesHistogram.h	/^  int getBucketIdx(const ValueType& value) const;$/;"	p	class:folly::TimeseriesHistogram	access:public	signature:(const ValueType& value) const
getBucketInfo	.\stats\BucketedTimeSeries-defs.h	/^void BucketedTimeSeries<VT, TT>::getBucketInfo($/;"	f	class:folly::BucketedTimeSeries	signature:( TimeType time, size_t *bucketIdx, TimeType* bucketStart, TimeType* nextBucketStart) const
getBucketInfo	.\stats\BucketedTimeSeries.h	/^  void getBucketInfo(TimeType time, size_t* bucketIdx,$/;"	p	class:folly::BucketedTimeSeries	access:public	signature:(TimeType time, size_t* bucketIdx, TimeType* bucketStart, TimeType* nextBucketStart) const
getBucketMax	.\stats\Histogram.h	/^  ValueType getBucketMax(unsigned int idx) const {$/;"	f	class:folly::Histogram	access:public	signature:(unsigned int idx) const
getBucketMax	.\stats\Histogram.h	/^  ValueType getBucketMax(unsigned int idx) const {$/;"	f	class:folly::detail::HistogramBuckets	access:public	signature:(unsigned int idx) const
getBucketMin	.\stats\Histogram.h	/^  ValueType getBucketMin(unsigned int idx) const {$/;"	f	class:folly::Histogram	access:public	signature:(unsigned int idx) const
getBucketMin	.\stats\Histogram.h	/^  ValueType getBucketMin(unsigned int idx) const {$/;"	f	class:folly::detail::HistogramBuckets	access:public	signature:(unsigned int idx) const
getBucketMin	.\stats\TimeseriesHistogram.h	/^  ValueType getBucketMin(int bucketIdx) const {$/;"	f	class:folly::TimeseriesHistogram	access:public	signature:(int bucketIdx) const
getBucketSize	.\stats\Histogram.h	/^  ValueType getBucketSize() const {$/;"	f	class:folly::Histogram	access:public	signature:() const
getBucketSize	.\stats\Histogram.h	/^  ValueType getBucketSize() const {$/;"	f	class:folly::detail::HistogramBuckets	access:public	signature:() const
getBucketSize	.\stats\TimeseriesHistogram.h	/^  ValueType getBucketSize() const { return buckets_.getBucketSize(); }$/;"	f	class:folly::TimeseriesHistogram	access:public	signature:() const
getByIndex	.\stats\Histogram.h	/^  BucketType& getByIndex(unsigned int idx) {$/;"	f	class:folly::detail::HistogramBuckets	access:public	signature:(unsigned int idx)
getByIndex	.\stats\Histogram.h	/^  const BucketType& getByIndex(unsigned int idx) const {$/;"	f	class:folly::detail::HistogramBuckets	access:public	signature:(unsigned int idx) const
getByValue	.\stats\Histogram.h	/^  BucketType& getByValue(ValueType value) {$/;"	f	class:folly::detail::HistogramBuckets	access:public	signature:(ValueType value)
getByValue	.\stats\Histogram.h	/^  const BucketType& getByValue(ValueType value) const {$/;"	f	class:folly::detail::HistogramBuckets	access:public	signature:(ValueType value) const
getByte	.\MacAddress.h	/^  inline uint64_t getByte(size_t index) const {$/;"	f	class:folly::MacAddress	access:private	signature:(size_t index) const
getCacheSize	.\ThreadCachedInt.h	/^  uint32_t getCacheSize() const {$/;"	f	class:folly::ThreadCachedInt	access:public	signature:() const
getCapacity	.\small_vector.h	/^    InternalSizeType* getCapacity() const {$/;"	f	namespace:folly	signature:() const
getCapacity	.\small_vector.h	/^    InternalSizeType* getCapacity() {$/;"	f	namespace:folly	signature:()
getCapacity	.\small_vector.h	/^    InternalSizeType* getCapacity() {$/;"	f	struct:folly::small_vector::HeapPtr	access:public	signature:()
getCapacity	.\small_vector.h	/^    InternalSizeType* getCapacity() {$/;"	f	struct:folly::small_vector::HeapPtrWithCapacity	access:public	signature:()
getCodec	.\io\Compression.cpp	/^std::unique_ptr<Codec> getCodec(CodecType type, int level) {$/;"	f	namespace:folly::io	signature:(CodecType type, int level)
getCodec	.\io\Compression.h	/^std::unique_ptr<Codec> getCodec(CodecType type,$/;"	p	namespace:folly::io	signature:(CodecType type, int level = COMPRESSION_LEVEL_DEFAULT)
getConnectionManager	.\experimental\wangle\ManagedConnection.h	/^  ConnectionManager* getConnectionManager() {$/;"	f	class:folly::wangle::ManagedConnection	access:public	signature:()
getContextData	.\io\async\Request.h	/^  RequestData* getContextData(const std::string& val) {$/;"	f	class:folly::RequestContext	access:public	signature:(const std::string& val)
getCopied	.\ExceptionWrapper.h	/^  const std::exception* getCopied() const { return item_.get(); }$/;"	f	class:folly::exception_wrapper	access:public	signature:() const
getCopied	.\ExceptionWrapper.h	/^  std::exception* getCopied() { return item_.get(); }$/;"	f	class:folly::exception_wrapper	access:public	signature:()
getCurrentExceptions	.\experimental\exception_tracer\ExceptionTracer.cpp	/^std::vector<ExceptionInfo> getCurrentExceptions() {$/;"	f	namespace:folly::exception_tracer	signature:()
getCurrentExceptions	.\experimental\exception_tracer\ExceptionTracer.h	/^std::vector<ExceptionInfo> getCurrentExceptions();$/;"	p	namespace:folly::exception_tracer	signature:()
getCurrentQueue	.\io\async\NotificationQueue.h	/^    NotificationQueue* getCurrentQueue() const {$/;"	f	class:folly::NotificationQueue::Consumer	access:public	signature:() const
getData	.\SmallLocks.h	/^  IntType getData() const {$/;"	f	struct:folly::PicoSpinLock	access:public	signature:() const
getDefault	.\dynamic-inl.h	/^inline dynamic dynamic::getDefault(const dynamic& k, const dynamic& v) const {$/;"	f	class:folly::dynamic	signature:(const dynamic& k, const dynamic& v) const
getDefault	.\dynamic-inl.h	/^inline dynamic&& dynamic::getDefault(const dynamic& k, dynamic&& v) const {$/;"	f	class:folly::dynamic	signature:(const dynamic& k, dynamic&& v) const
getDefault	.\dynamic.h	/^  dynamic&& getDefault(const dynamic& k, dynamic&& v) const;$/;"	p	struct:folly::dynamic	access:public	signature:(const dynamic& k, dynamic&& v) const
getDefault	.\dynamic.h	/^  getDefault(const dynamic& k, const dynamic& v = dynamic::object) const;$/;"	p	struct:folly::dynamic	access:public	signature:(const dynamic& k, const dynamic& v = dynamic::object) const
getDefaultHugePageSize	.\experimental\io\HugePages.cpp	/^size_t getDefaultHugePageSize() {$/;"	f	namespace:folly::__anon30	signature:()
getDefinitionByAddress	.\experimental\symbolizer\Elf.cpp	/^ElfFile::Symbol ElfFile::getDefinitionByAddress(uintptr_t address) const {$/;"	f	class:folly::symbolizer::ElfFile	signature:(uintptr_t address) const
getDefinitionByAddress	.\experimental\symbolizer\Elf.h	/^  Symbol getDefinitionByAddress(uintptr_t address) const;$/;"	p	class:folly::symbolizer::ElfFile	access:public	signature:(uintptr_t address) const
getDestructorGuardCount	.\io\async\DelayedDestruction.h	/^  uint32_t getDestructorGuardCount() const {$/;"	f	class:folly::DelayedDestruction	access:protected	signature:() const
getDeviceOptions	.\MemoryMapping.cpp	/^void getDeviceOptions(dev_t device, off_t& pageSize, bool& autoExtend) {$/;"	f	namespace:folly::__anon77	signature:(dev_t device, off_t& pageSize, bool& autoExtend)
getEarliestTime	.\stats\BucketedTimeSeries-defs.h	/^TT BucketedTimeSeries<VT, TT>::getEarliestTime() const {$/;"	f	class:folly::BucketedTimeSeries	signature:() const
getEarliestTime	.\stats\BucketedTimeSeries.h	/^  TimeType getEarliestTime() const;$/;"	p	class:folly::BucketedTimeSeries	access:public	signature:() const
getEarliestTimeNonEmpty	.\stats\BucketedTimeSeries-defs.h	/^TT BucketedTimeSeries<VT, TT>::getEarliestTimeNonEmpty() const {$/;"	f	class:folly::BucketedTimeSeries	signature:() const
getEarliestTimeNonEmpty	.\stats\BucketedTimeSeries.h	/^  TimeType getEarliestTimeNonEmpty() const;$/;"	p	class:folly::BucketedTimeSeries	access:private	signature:() const
getEntryCountThreadCacheSize	.\AtomicHashArray.h	/^  int getEntryCountThreadCacheSize() const {$/;"	f	class:folly::AtomicHashArray	access:public	signature:() const
getEvent	.\io\async\AsyncTimeout.h	/^  struct event* getEvent() {$/;"	f	class:folly::AsyncTimeout	access:public	signature:()
getEventBase	.\io\async\NotificationQueue.h	/^    EventBase* getEventBase() {$/;"	f	class:folly::NotificationQueue::Consumer	access:public	signature:()
getExceptionPtr	.\ExceptionWrapper.h	/^  std::exception_ptr getExceptionPtr() const {$/;"	f	class:folly::exception_wrapper	access:public	signature:() const
getExceptionStackTraceStack	.\experimental\exception_tracer\ExceptionTracer.cpp	/^StackTraceStack* getExceptionStackTraceStack(void) __attribute__((__weak__));$/;"	p	file:	signature:(void)
getExceptionStackTraceStack	.\experimental\exception_tracer\ExceptionTracerLib.cpp	/^extern "C" StackTraceStack* getExceptionStackTraceStack() {$/;"	f	signature:()
getExceptionStackTraceStackFn	.\experimental\exception_tracer\ExceptionTracer.cpp	/^GetExceptionStackTraceStackType getExceptionStackTraceStackFn;$/;"	v
getFD	.\experimental\symbolizer\Symbolizer.cpp	/^int getFD(const std::ios& stream) {$/;"	f	namespace:folly::symbolizer::__anon43	signature:(const std::ios& stream)
getFamily	.\SocketAddress.h	/^  sa_family_t getFamily() const {$/;"	f	class:folly::SocketAddress	access:public	signature:() const
getFile	.\experimental\symbolizer\ElfCache.cpp	/^std::shared_ptr<ElfFile> ElfCache::getFile(StringPiece p) {$/;"	f	class:folly::symbolizer::ElfCache	signature:(StringPiece p)
getFile	.\experimental\symbolizer\ElfCache.cpp	/^std::shared_ptr<ElfFile> SignalSafeElfCache::getFile(StringPiece p) {$/;"	f	class:folly::symbolizer::SignalSafeElfCache	signature:(StringPiece p)
getFile	.\experimental\symbolizer\ElfCache.h	/^  virtual std::shared_ptr<ElfFile> getFile(StringPiece path) = 0;$/;"	p	class:folly::symbolizer::ElfCacheBase	access:public	signature:(StringPiece path)
getFileName	.\experimental\symbolizer\Dwarf.cpp	/^Dwarf::LineNumberVM::FileName Dwarf::LineNumberVM::getFileName(uint64_t index)$/;"	f	class:folly::symbolizer::Dwarf::LineNumberVM	signature:(uint64_t index) const
getFileName	.\experimental\symbolizer\Dwarf.h	/^    FileName getFileName(uint64_t index) const;$/;"	p	class:folly::symbolizer::Dwarf::LineNumberVM	access:private	signature:(uint64_t index) const
getFlags	.\ConcurrentSkipList-inl.h	/^  uint16_t getFlags() const {$/;"	f	class:folly::detail::SkipListNode	access:private	signature:() const
getFrameInfo	.\experimental\symbolizer\StackTrace.cpp	/^inline bool getFrameInfo(unw_cursor_t* cursor, uintptr_t& ip) {$/;"	f	namespace:folly::symbolizer::__anon39	signature:(unw_cursor_t* cursor, uintptr_t& ip)
getFullyQualified	.\SocketAddress.cpp	/^std::string SocketAddress::getFullyQualified() const {$/;"	f	class:folly::SocketAddress	signature:() const
getFullyQualified	.\SocketAddress.h	/^  std::string getFullyQualified() const;$/;"	p	class:folly::SocketAddress	access:public	signature:() const
getFuture	.\wangle\Promise-inl.h	/^Future<T> Promise<T>::getFuture() {$/;"	f	class:folly::wangle::Promise	signature:()
getFuture	.\wangle\Promise.h	/^  Future<T> getFuture();$/;"	p	class:folly::wangle::Promise	access:public	signature:()
getHeight	.\ConcurrentSkipList-inl.h	/^  int getHeight(int maxHeight) const {$/;"	f	class:folly::detail::SkipListRandomHeight	access:public	signature:(int maxHeight) const
getHostStr	.\SocketAddress.cpp	/^std::string SocketAddress::getHostStr() const {$/;"	f	class:folly::SocketAddress	signature:() const
getHostStr	.\SocketAddress.h	/^  std::string getHostStr() const;$/;"	p	class:folly::SocketAddress	access:public	signature:() const
getHugePageSize	.\experimental\io\HugePages.cpp	/^const HugePageSize* getHugePageSize(size_t size) {$/;"	f	namespace:folly	signature:(size_t size)
getHugePageSize	.\experimental\io\HugePages.h	/^const HugePageSize* getHugePageSize(size_t size = 0);$/;"	p	namespace:folly	signature:(size_t size = 0)
getHugePageSizeForDevice	.\experimental\io\HugePages.cpp	/^const HugePageSize* getHugePageSizeForDevice(dev_t device) {$/;"	f	namespace:folly	signature:(dev_t device)
getHugePageSizeForDevice	.\experimental\io\HugePages.h	/^const HugePageSize* getHugePageSizeForDevice(dev_t device);$/;"	p	namespace:folly	signature:(dev_t device)
getHugePageSizes	.\experimental\io\HugePages.cpp	/^const HugePageSizeVec& getHugePageSizes() {$/;"	f	namespace:folly	signature:()
getHugePageSizes	.\experimental\io\HugePages.h	/^const HugePageSizeVec& getHugePageSizes();$/;"	p	namespace:folly	signature:()
getIPAddress	.\SocketAddress.cpp	/^const folly::IPAddress& SocketAddress::getIPAddress() const {$/;"	f	class:folly::SocketAddress	signature:() const
getIPAddress	.\SocketAddress.h	/^  const folly::IPAddress& getIPAddress() const;$/;"	p	class:folly::SocketAddress	access:public	signature:() const
getIPv4For6To4	.\IPAddressV6.cpp	/^IPAddressV4 IPAddressV6::getIPv4For6To4() const {$/;"	f	class:folly::IPAddressV6	signature:() const
getIPv4For6To4	.\IPAddressV6.h	/^  IPAddressV4 getIPv4For6To4() const;$/;"	p	class:folly::IPAddressV6	access:public	signature:() const
getImpl	.\Random.cpp	/^uint32_t ThreadLocalPRNG::getImpl(LocalInstancePRNG* local) {$/;"	f	class:folly::ThreadLocalPRNG	signature:(LocalInstancePRNG* local)
getImpl	.\Random.h	/^  static result_type getImpl(LocalInstancePRNG* local);$/;"	p	class:folly::ThreadLocalPRNG	access:private	signature:(LocalInstancePRNG* local)
getIncludeDirectory	.\experimental\symbolizer\Dwarf.cpp	/^folly::StringPiece Dwarf::LineNumberVM::getIncludeDirectory(uint64_t index)$/;"	f	class:folly::symbolizer::Dwarf::LineNumberVM	signature:(uint64_t index) const
getIncludeDirectory	.\experimental\symbolizer\Dwarf.h	/^    folly::StringPiece getIncludeDirectory(uint64_t index) const;$/;"	p	class:folly::symbolizer::Dwarf::LineNumberVM	access:private	signature:(uint64_t index) const
getIndex	.\AtomicHashArray-inl.h	/^  uint32_t getIndex() const { return offset_; }$/;"	f	struct:folly::AtomicHashArray::aha_iterator	access:public	signature:() const
getIndex	.\AtomicHashMap-inl.h	/^  uint32_t getIndex() const {$/;"	f	struct:folly::AtomicHashMap::ahm_iterator	access:public	signature:() const
getInt	.\test\ExceptionWrapperTest.cpp	/^  virtual int getInt() const = 0;$/;"	p	class:AbstractIntException	file:	access:public	signature:() const
getInt	.\test\ExceptionWrapperTest.cpp	/^  virtual int getInt() const { return i_; }$/;"	f	class:IntException	access:public	signature:() const
getIov	.\io\IOBuf.cpp	/^folly::fbvector<struct iovec> IOBuf::getIov() const {$/;"	f	class:folly::IOBuf	signature:() const
getIov	.\io\IOBuf.h	/^  folly::fbvector<struct iovec> getIov() const;$/;"	p	class:folly::IOBuf	access:public	signature:() const
getIpString	.\SocketAddress.cpp	/^std::string SocketAddress::getIpString(int flags) const {$/;"	f	class:folly::SocketAddress	signature:(int flags) const
getIpString	.\SocketAddress.cpp	/^void SocketAddress::getIpString(char *buf, size_t buflen, int flags) const {$/;"	f	class:folly::SocketAddress	signature:(char *buf, size_t buflen, int flags) const
getIpString	.\SocketAddress.h	/^  std::string getIpString(int flags) const;$/;"	p	class:folly::SocketAddress	access:private	signature:(int flags) const
getIpString	.\SocketAddress.h	/^  void getIpString(char *buf, size_t buflen, int flags) const;$/;"	p	class:folly::SocketAddress	access:private	signature:(char *buf, size_t buflen, int flags) const
getLastElement	.\Conv.h	/^  getLastElement(const T& v, const Ts&... vs) {$/;"	f	class:folly::detail::std::tuple_element	signature:(const T& v, const Ts&... vs)
getLastElement	.\Conv.h	/^const T& getLastElement(const T & v) {$/;"	f	namespace:folly::detail	signature:(const T & v)
getLatestTime	.\stats\BucketedTimeSeries.h	/^  TimeType getLatestTime() const {$/;"	f	class:folly::BucketedTimeSeries	access:public	signature:() const
getLevel	.\stats\MultiLevelTimeSeries.h	/^  const Level& getLevel(TimeType start) const {$/;"	f	class:folly::MultiLevelTimeSeries	access:public	signature:(TimeType start) const
getLevel	.\stats\MultiLevelTimeSeries.h	/^  const Level& getLevel(int level) const {$/;"	f	class:folly::MultiLevelTimeSeries	access:public	signature:(int level) const
getLibeventBase	.\io\async\EventBase.h	/^  event_base* getLibeventBase() const { return evb_; }$/;"	f	class:folly::EventBase	access:public	signature:() const
getLibeventMethod	.\io\async\EventBase.h	/^  static const char* getLibeventMethod() { return event_get_method(); }$/;"	f	class:folly::EventBase	access:public	signature:()
getLibeventVersion	.\io\async\EventBase.h	/^  static const char* getLibeventVersion() { return event_get_version(); }$/;"	f	class:folly::EventBase	access:public	signature:()
getMax	.\stats\Histogram.h	/^  ValueType getMax() const {$/;"	f	class:folly::Histogram	access:public	signature:() const
getMax	.\stats\Histogram.h	/^  ValueType getMax() const {$/;"	f	class:folly::detail::HistogramBuckets	access:public	signature:() const
getMax	.\stats\TimeseriesHistogram.h	/^  ValueType getMax() const { return buckets_.getMax(); }$/;"	f	class:folly::TimeseriesHistogram	access:public	signature:() const
getMaxReadAtOnce	.\io\async\NotificationQueue.h	/^    uint32_t getMaxReadAtOnce() const {$/;"	f	class:folly::NotificationQueue::Consumer	access:public	signature:() const
getMaxSize	.\EvictingCacheMap.h	/^  size_t getMaxSize() const {$/;"	f	class:folly::EvictingCacheMap	access:public	signature:() const
getMeyersSingleton	.\experimental\test\SingletonTest.cpp	/^int* getMeyersSingleton() {$/;"	f	signature:()
getMin	.\stats\Histogram.h	/^  ValueType getMin() const {$/;"	f	class:folly::Histogram	access:public	signature:() const
getMin	.\stats\Histogram.h	/^  ValueType getMin() const {$/;"	f	class:folly::detail::HistogramBuckets	access:public	signature:() const
getMin	.\stats\TimeseriesHistogram.h	/^  ValueType getMin() const { return buckets_.getMin(); }$/;"	f	class:folly::TimeseriesHistogram	access:public	signature:() const
getMulticastFlags	.\IPAddressV6.cpp	/^uint8_t IPAddressV6::getMulticastFlags() const {$/;"	f	class:folly::IPAddressV6	signature:() const
getMulticastFlags	.\IPAddressV6.h	/^  uint8_t getMulticastFlags() const;$/;"	p	class:folly::IPAddressV6	access:public	signature:() const
getMulticastScope	.\IPAddressV6.cpp	/^uint8_t IPAddressV6::getMulticastScope() const {$/;"	f	class:folly::IPAddressV6	signature:() const
getMulticastScope	.\IPAddressV6.h	/^  uint8_t getMulticastScope() const;$/;"	p	class:folly::IPAddressV6	access:public	signature:() const
getName	.\io\async\EventBase.cpp	/^const std::string& EventBase::getName() {$/;"	f	class:folly::EventBase	signature:()
getName	.\io\async\EventBase.h	/^  const std::string& getName();$/;"	p	class:folly::EventBase	access:public	signature:()
getNormalSingleton	.\experimental\test\SingletonTest.cpp	/^int* getNormalSingleton() {$/;"	f	signature:()
getNotificationQueueSize	.\io\async\EventBase.cpp	/^int EventBase::getNotificationQueueSize() const {$/;"	f	class:folly::EventBase	signature:() const
getNotificationQueueSize	.\io\async\EventBase.h	/^  int getNotificationQueueSize() const;$/;"	p	class:folly::EventBase	access:public	signature:() const
getNthLSBit	.\IPAddress.h	/^  bool getNthLSBit(size_t bitIndex) const {$/;"	f	class:folly::IPAddress	access:public	signature:(size_t bitIndex) const
getNthLSBit	.\IPAddressV4.h	/^  bool getNthLSBit(size_t bitIndex) const {$/;"	f	class:folly::IPAddressV4	access:public	signature:(size_t bitIndex) const
getNthLSBit	.\IPAddressV6.h	/^  bool getNthLSBit(size_t bitIndex) const {$/;"	f	class:folly::IPAddressV6	access:public	signature:(size_t bitIndex) const
getNthLSByte	.\IPAddress.h	/^  uint8_t getNthLSByte(size_t byteIndex) const {$/;"	f	class:folly::IPAddress	access:public	signature:(size_t byteIndex) const
getNthLSByte	.\IPAddressV4.h	/^  uint8_t getNthLSByte(size_t byteIndex) const {$/;"	f	class:folly::IPAddressV4	access:public	signature:(size_t byteIndex) const
getNthLSByte	.\IPAddressV6.h	/^  uint8_t getNthLSByte(size_t byteIndex) const {$/;"	f	class:folly::IPAddressV6	access:public	signature:(size_t byteIndex) const
getNthMSBit	.\IPAddress.h	/^  bool getNthMSBit(size_t bitIndex) const {$/;"	f	class:folly::IPAddress	access:public	signature:(size_t bitIndex) const
getNthMSBit	.\IPAddressV4.h	/^  bool getNthMSBit(size_t bitIndex) const {$/;"	f	class:folly::IPAddressV4	access:public	signature:(size_t bitIndex) const
getNthMSBit	.\IPAddressV6.h	/^  bool getNthMSBit(size_t bitIndex) const {$/;"	f	class:folly::IPAddressV6	access:public	signature:(size_t bitIndex) const
getNthMSBitImpl	.\detail\IPAddress.h	/^inline bool getNthMSBitImpl(const IPAddrType& ip, uint8_t bitIndex,$/;"	f	namespace:folly::detail	signature:(const IPAddrType& ip, uint8_t bitIndex, sa_family_t family)
getNthMSByte	.\IPAddress.cpp	/^uint8_t IPAddress::getNthMSByte(size_t byteIndex) const {$/;"	f	class:folly::IPAddress	signature:(size_t byteIndex) const
getNthMSByte	.\IPAddress.h	/^  uint8_t getNthMSByte(size_t byteIndex) const;$/;"	p	class:folly::IPAddress	access:public	signature:(size_t byteIndex) const
getNthMSByte	.\IPAddressV4.cpp	/^uint8_t IPAddressV4::getNthMSByte(size_t byteIndex) const {$/;"	f	class:folly::IPAddressV4	signature:(size_t byteIndex) const
getNthMSByte	.\IPAddressV4.h	/^  uint8_t getNthMSByte(size_t byteIndex) const;$/;"	p	class:folly::IPAddressV4	access:public	signature:(size_t byteIndex) const
getNthMSByte	.\IPAddressV6.cpp	/^uint8_t IPAddressV6::getNthMSByte(size_t byteIndex) const {$/;"	f	class:folly::IPAddressV6	signature:(size_t byteIndex) const
getNthMSByte	.\IPAddressV6.h	/^  uint8_t getNthMSByte(size_t byteIndex) const;$/;"	p	class:folly::IPAddressV6	access:public	signature:(size_t byteIndex) const
getNumBuckets	.\stats\Histogram.h	/^  unsigned int getNumBuckets() const {$/;"	f	class:folly::Histogram	access:public	signature:() const
getNumBuckets	.\stats\Histogram.h	/^  unsigned int getNumBuckets() const {$/;"	f	class:folly::detail::HistogramBuckets	access:public	signature:() const
getNumBuckets	.\stats\TimeseriesHistogram.h	/^  int getNumBuckets() const { return buckets_.getNumBuckets(); }$/;"	f	class:folly::TimeseriesHistogram	access:public	signature:() const
getNumConnections	.\experimental\wangle\ConnectionManager.h	/^  size_t getNumConnections() const { return conns_.size(); }$/;"	f	class:folly::wangle::ConnectionManager	access:public	signature:() const
getNumLevels	.\stats\TimeseriesHistogram.h	/^  int getNumLevels() const {$/;"	f	class:folly::TimeseriesHistogram	access:public	signature:() const
getObserver	.\io\async\EventBase.h	/^  const std::shared_ptr<EventBaseObserver>& getObserver() {$/;"	f	class:folly::EventBase	access:public	signature:()
getOpenFds	.\test\SubprocessTest.cpp	/^boost::container::flat_set<int> getOpenFds() {$/;"	f	namespace:__anon140	signature:()
getOpts	.\json.cpp	/^  json::serialization_opts const& getOpts() {$/;"	f	class:folly::json::__anon75::Input::json	access:public	signature:()
getPath	.\SocketAddress.cpp	/^std::string SocketAddress::getPath() const {$/;"	f	class:folly::SocketAddress	signature:() const
getPath	.\SocketAddress.h	/^  std::string getPath() const;$/;"	p	class:folly::SocketAddress	access:public	signature:() const
getPercentileBucketIdx	.\stats\Histogram-defs.h	/^unsigned int HistogramBuckets<T, BucketType>::getPercentileBucketIdx($/;"	f	class:folly::detail::HistogramBuckets	signature:( double pct, CountFn countFromBucket, double* lowPct, double* highPct) const
getPercentileBucketIdx	.\stats\Histogram.h	/^  unsigned int getPercentileBucketIdx(double pct,$/;"	f	class:folly::Histogram	access:public	signature:(double pct, double* lowPct = nullptr, double* highPct = nullptr) const
getPercentileBucketIdx	.\stats\Histogram.h	/^  unsigned int getPercentileBucketIdx(double pct,$/;"	p	class:folly::detail::HistogramBuckets	access:public	signature:(double pct, CountFn countFromBucket, double* lowPct = nullptr, double* highPct = nullptr) const
getPercentileBucketIdx	.\stats\TimeseriesHistogram-defs.h	/^int TimeseriesHistogram<T, TT, C>::getPercentileBucketIdx($/;"	f	class:folly::TimeseriesHistogram	signature:( double pct, int level ) const
getPercentileBucketIdx	.\stats\TimeseriesHistogram-defs.h	/^int TimeseriesHistogram<T, TT, C>::getPercentileBucketIdx(double pct,$/;"	f	class:folly::TimeseriesHistogram	signature:(double pct, TimeType start, TimeType end) const
getPercentileBucketIdx	.\stats\TimeseriesHistogram.h	/^  int getPercentileBucketIdx(double pct, TimeType start, TimeType end) const;$/;"	p	class:folly::TimeseriesHistogram	access:public	signature:(double pct, TimeType start, TimeType end) const
getPercentileBucketIdx	.\stats\TimeseriesHistogram.h	/^  int getPercentileBucketIdx(double pct, int level) const;$/;"	p	class:folly::TimeseriesHistogram	access:public	signature:(double pct, int level) const
getPercentileBucketMin	.\stats\TimeseriesHistogram.h	/^  int getPercentileBucketMin(double pct, TimeType start, TimeType end) const {$/;"	f	class:folly::TimeseriesHistogram	access:public	signature:(double pct, TimeType start, TimeType end) const
getPercentileBucketMin	.\stats\TimeseriesHistogram.h	/^  int getPercentileBucketMin(double pct, int level) const {$/;"	f	class:folly::TimeseriesHistogram	access:public	signature:(double pct, int level) const
getPercentileEstimate	.\stats\Histogram-defs.h	/^T HistogramBuckets<T, BucketType>::getPercentileEstimate($/;"	f	class:folly::detail::HistogramBuckets	signature:( double pct, CountFn countFromBucket, AvgFn avgFromBucket) const
getPercentileEstimate	.\stats\Histogram.h	/^  ValueType getPercentileEstimate(double pct) const {$/;"	f	class:folly::Histogram	access:public	signature:(double pct) const
getPercentileEstimate	.\stats\Histogram.h	/^  ValueType getPercentileEstimate(double pct,$/;"	p	class:folly::detail::HistogramBuckets	access:public	signature:(double pct, CountFn countFromBucket, AvgFn avgFromBucket) const
getPercentileEstimate	.\stats\TimeseriesHistogram-defs.h	/^T TimeseriesHistogram<T, TT, C>::getPercentileEstimate(double pct,$/;"	f	class:folly::TimeseriesHistogram	signature:(double pct, TimeType start, TimeType end) const
getPercentileEstimate	.\stats\TimeseriesHistogram-defs.h	/^T TimeseriesHistogram<T, TT, C>::getPercentileEstimate(double pct,$/;"	f	class:folly::TimeseriesHistogram	signature:(double pct, int level) const
getPercentileEstimate	.\stats\TimeseriesHistogram.h	/^  ValueType getPercentileEstimate(double pct, TimeType start, TimeType end)$/;"	p	class:folly::TimeseriesHistogram	access:public	signature:(double pct, TimeType start, TimeType end) const
getPercentileEstimate	.\stats\TimeseriesHistogram.h	/^  ValueType getPercentileEstimate(double pct, int level) const;$/;"	p	class:folly::TimeseriesHistogram	access:public	signature:(double pct, int level) const
getPort	.\SocketAddress.cpp	/^uint16_t SocketAddress::getPort() const {$/;"	f	class:folly::SocketAddress	signature:() const
getPort	.\SocketAddress.h	/^  uint16_t getPort() const;$/;"	p	class:folly::SocketAddress	access:public	signature:() const
getQueryParams	.\Uri.h	/^  const std::vector<std::pair<fbstring, fbstring>>& getQueryParams() const {$/;"	f	class:folly::Uri	access:public	signature:() const
getRandNumber	.\test\DeterministicSchedule.cpp	/^DeterministicSchedule::getRandNumber(int n) {$/;"	f	class:folly::test::DeterministicSchedule	signature:(int n)
getRandNumber	.\test\DeterministicSchedule.h	/^  static int getRandNumber(int n);$/;"	p	class:folly::test::DeterministicSchedule	access:public	signature:(int n)
getRegisteredEvents	.\io\async\EventHandler.h	/^  uint16_t getRegisteredEvents() const {$/;"	f	class:folly::EventHandler	access:public	signature:() const
getSampleRate	.\io\async\EventBase.h	/^  virtual uint32_t getSampleRate() const = 0;$/;"	p	class:folly::EventBaseObserver	access:public	signature:() const
getScopeId	.\IPAddressV6.h	/^  uint16_t getScopeId() const { return scope_; }$/;"	f	class:folly::IPAddressV6	access:public	signature:() const
getSection	.\experimental\symbolizer\Dwarf.cpp	/^bool Dwarf::getSection(const char* name, folly::StringPiece* section) const {$/;"	f	class:folly::symbolizer::Dwarf	signature:(const char* name, folly::StringPiece* section) const
getSection	.\experimental\symbolizer\Dwarf.h	/^  bool getSection(const char* name, folly::StringPiece* section) const;$/;"	p	class:folly::symbolizer::Dwarf	access:private	signature:(const char* name, folly::StringPiece* section) const
getSectionByIndex	.\experimental\symbolizer\Elf.cpp	/^const ElfW(Shdr)* ElfFile::getSectionByIndex(size_t idx) const {$/;"	f	class:folly::symbolizer::ElfFile	signature:(size_t idx) const
getSectionByIndex	.\experimental\symbolizer\Elf.h	/^  const ElfW(Shdr)* getSectionByIndex(size_t idx) const;$/;"	p	class:folly::symbolizer::ElfFile	access:public	signature:(size_t idx) const
getSectionByName	.\experimental\symbolizer\Elf.cpp	/^const ElfW(Shdr)* ElfFile::getSectionByName(const char* name) const {$/;"	f	class:folly::symbolizer::ElfFile	signature:(const char* name) const
getSectionByName	.\experimental\symbolizer\Elf.h	/^  const ElfW(Shdr)* getSectionByName(const char* name) const;$/;"	p	class:folly::symbolizer::ElfFile	access:public	signature:(const char* name) const
getSizeLimit	.\ConcurrentSkipList-inl.h	/^  size_t getSizeLimit(int height) const {$/;"	f	class:folly::detail::SkipListRandomHeight	access:public	signature:(int height) const
getSlow	.\Random.cpp	/^  void getSlow(unsigned char* data, size_t size);$/;"	p	class:folly::__anon82::BufferedRandomDevice	file:	access:private	signature:(unsigned char* data, size_t size)
getSlow	.\Random.cpp	/^void BufferedRandomDevice::getSlow(unsigned char* data, size_t size) {$/;"	f	class:folly::__anon82::BufferedRandomDevice	signature:(unsigned char* data, size_t size)
getSolicitedNodeAddress	.\IPAddressV6.cpp	/^IPAddressV6 IPAddressV6::getSolicitedNodeAddress() const {$/;"	f	class:folly::IPAddressV6	signature:() const
getSolicitedNodeAddress	.\IPAddressV6.h	/^  IPAddressV6 getSolicitedNodeAddress() const;$/;"	p	class:folly::IPAddressV6	access:public	signature:() const
getStackPtr	.\detail\MemoryIdler.cpp	/^FOLLY_NOINLINE static uintptr_t getStackPtr() {$/;"	f	namespace:folly::detail	signature:()
getStackTrace	.\experimental\symbolizer\StackTrace.cpp	/^ssize_t getStackTrace(uintptr_t* addresses, size_t maxAddresses) {$/;"	f	namespace:folly::symbolizer	signature:(uintptr_t* addresses, size_t maxAddresses)
getStackTrace	.\experimental\symbolizer\StackTrace.h	/^ssize_t getStackTrace(uintptr_t* addresses, size_t maxAddresses);$/;"	p	namespace:folly::symbolizer	signature:(uintptr_t* addresses, size_t maxAddresses)
getStackTrace	.\experimental\symbolizer\Symbolizer.h	/^inline bool getStackTrace(FrameArray<N>& fa) {$/;"	f	namespace:folly::symbolizer	signature:(FrameArray<N>& fa)
getStackTraceSafe	.\experimental\symbolizer\StackTrace.cpp	/^ssize_t getStackTraceSafe(uintptr_t* addresses, size_t maxAddresses) {$/;"	f	namespace:folly::symbolizer	signature:(uintptr_t* addresses, size_t maxAddresses)
getStackTraceSafe	.\experimental\symbolizer\StackTrace.h	/^ssize_t getStackTraceSafe(uintptr_t* addresses, size_t maxAddresses);$/;"	p	namespace:folly::symbolizer	signature:(uintptr_t* addresses, size_t maxAddresses)
getStackTraceSafe	.\experimental\symbolizer\Symbolizer.h	/^FOLLY_ALWAYS_INLINE bool getStackTraceSafe(FrameArray<N>& fa);$/;"	p	namespace:folly::symbolizer	signature:(FrameArray<N>& fa)
getStackTraceSafe	.\experimental\symbolizer\Symbolizer.h	/^inline bool getStackTraceSafe(FrameArray<N>& fa) {$/;"	f	namespace:folly::symbolizer	signature:(FrameArray<N>& fa)
getStaticContext	.\io\async\Request.h	/^  getStaticContext() {$/;"	f	class:folly::RequestContext	access:public	signature:()
getString	.\stats\TimeseriesHistogram-defs.h	/^std::string TimeseriesHistogram<T, TT, C>::getString(TimeType start,$/;"	f	class:folly::TimeseriesHistogram	signature:(TimeType start, TimeType end) const
getString	.\stats\TimeseriesHistogram-defs.h	/^std::string TimeseriesHistogram<T, TT, C>::getString(int level) const {$/;"	f	class:folly::TimeseriesHistogram	signature:(int level) const
getString	.\stats\TimeseriesHistogram.h	/^  std::string getString(TimeType start, TimeType end) const;$/;"	p	class:folly::TimeseriesHistogram	access:public	signature:(TimeType start, TimeType end) const
getString	.\stats\TimeseriesHistogram.h	/^  std::string getString(int level) const;$/;"	p	class:folly::TimeseriesHistogram	access:public	signature:(int level) const
getStringFromStringSection	.\experimental\symbolizer\Dwarf.cpp	/^folly::StringPiece Dwarf::getStringFromStringSection(uint64_t offset) const {$/;"	f	class:folly::symbolizer::Dwarf	signature:(uint64_t offset) const
getStringFromStringSection	.\experimental\symbolizer\Dwarf.h	/^  folly::StringPiece getStringFromStringSection(uint64_t offset) const;$/;"	p	class:folly::symbolizer::Dwarf	access:private	signature:(uint64_t offset) const
getSymbolByName	.\experimental\symbolizer\Elf.cpp	/^ElfFile::Symbol ElfFile::getSymbolByName(const char* name) const {$/;"	f	class:folly::symbolizer::ElfFile	signature:(const char* name) const
getSymbolByName	.\experimental\symbolizer\Elf.h	/^  Symbol getSymbolByName(const char* name) const;$/;"	p	class:folly::symbolizer::ElfFile	access:public	signature:(const char* name) const
getSymbolName	.\experimental\symbolizer\Elf.cpp	/^const char* ElfFile::getSymbolName(Symbol symbol) const {$/;"	f	class:folly::symbolizer::ElfFile	signature:(Symbol symbol) const
getSymbolName	.\experimental\symbolizer\Elf.h	/^  const char* getSymbolName(Symbol symbol) const;$/;"	p	class:folly::symbolizer::ElfFile	access:public	signature:(Symbol symbol) const
getSystemLocalityInfo	.\detail\CacheLocality.cpp	/^static CacheLocality getSystemLocalityInfo() {$/;"	f	namespace:folly::detail	signature:()
getThreadEntry	.\detail\ThreadLocalDetail.h	/^  static ThreadEntry* getThreadEntry() {$/;"	f	struct:folly::threadlocal_detail::StaticMeta	access:public	signature:()
getTickInterval	.\io\async\HHWheelTimer.h	/^  std::chrono::milliseconds getTickInterval() const {$/;"	f	class:folly::HHWheelTimer	access:public	signature:() const
getTimeDelta	.\io\async\EventBase.cpp	/^getTimeDelta(std::chrono::steady_clock::time_point* prev) {$/;"	f	namespace:folly	signature:(std::chrono::steady_clock::time_point* prev)
getTimeRemaining	.\io\async\HHWheelTimer.h	/^    std::chrono::milliseconds getTimeRemaining($/;"	f	class:folly::HHWheelTimer::Callback	access:private	signature:( std::chrono::milliseconds now) const
getTimeoutManager	.\io\async\AsyncTimeout.h	/^  const TimeoutManager* getTimeoutManager() {$/;"	f	class:folly::AsyncTimeout	access:public	signature:()
getTotal	.\test\stl_tests\StlVectorTest.cpp	/^int getTotal() {$/;"	f	signature:()
getTry	.\wangle\Future-inl.h	/^Try<T>& Future<T>::getTry() {$/;"	f	class:folly::wangle::Future	signature:()
getTry	.\wangle\Future.h	/^  Try<T>& getTry();$/;"	p	class:folly::wangle::Future	access:public	signature:()
getTry	.\wangle\detail\State.h	/^  Try<T>& getTry() {$/;"	f	class:folly::wangle::detail::State	access:public	signature:()
getValue	.\test\AtomicHashMapTest.cpp	/^  int64_t getValue(int64_t obj_id) {$/;"	f	class:Counters	access:public	signature:(int64_t obj_id)
getWithoutPromotion	.\EvictingCacheMap.h	/^  TValue& getWithoutPromotion(const TKey& key) {$/;"	f	class:folly::EvictingCacheMap	access:public	signature:(const TKey& key)
getWithoutPromotion	.\EvictingCacheMap.h	/^  const TValue& getWithoutPromotion(const TKey& key) const {$/;"	f	class:folly::EvictingCacheMap	access:public	signature:(const TKey& key) const
get_allocator	.\Memory.h	/^  allocator_type& get_allocator() const {$/;"	f	class:folly::allocator_delete	access:public	signature:() const
get_default	.\MapUtil.h	/^typename Map::mapped_type get_default($/;"	f	namespace:folly	signature:( const Map& map, const typename Map::key_type& key, const typename Map::mapped_type& dflt = typename Map::mapped_type())
get_entry	.\experimental\Singleton.h	/^  SingletonEntry* get_entry(detail::TypeDescriptor type,$/;"	f	class:folly::SingletonVault	access:private	signature:(detail::TypeDescriptor type, std::unique_lock<std::mutex>* lock)
get_growth_policy	.\sorted_vector_types.h	/^  get_growth_policy() { return *this; }$/;"	f	class:folly::sorted_vector_map	access:private	signature:()
get_growth_policy	.\sorted_vector_types.h	/^  get_growth_policy() { return *this; }$/;"	f	class:folly::sorted_vector_set	access:private	signature:()
get_nothrow	.\dynamic-inl.h	/^T const* dynamic::get_nothrow() const {$/;"	f	class:folly::dynamic	signature:() const
get_nothrow	.\dynamic-inl.h	/^T* dynamic::get_nothrow() {$/;"	f	class:folly::dynamic	signature:()
get_nothrow	.\dynamic.h	/^  template<class T> T const* get_nothrow() const;$/;"	p	struct:folly::dynamic	access:private	signature:() const
get_nothrow	.\dynamic.h	/^  template<class T> T*       get_nothrow();$/;"	p	struct:folly::dynamic	access:private	signature:()
get_pointer	.\Optional.h	/^T* get_pointer(Optional<T>& opt) {$/;"	f	namespace:folly	signature:(Optional<T>& opt)
get_pointer	.\Optional.h	/^const T* get_pointer(const Optional<T>& opt) {$/;"	f	namespace:folly	signature:(const Optional<T>& opt)
get_ptr	.\MapUtil.h	/^const typename Map::mapped_type* get_ptr($/;"	f	namespace:folly	signature:( const Map& map, const typename Map::key_type& key)
get_ptr	.\MapUtil.h	/^typename Map::mapped_type* get_ptr($/;"	f	namespace:folly	signature:( Map& map, const typename Map::key_type& key)
get_ptr	.\dynamic-inl.h	/^inline const dynamic* dynamic::get_ptr(dynamic const& idx) const {$/;"	f	class:folly::dynamic	signature:(dynamic const& idx) const
get_ptr	.\dynamic-inl.h	/^inline dynamic* dynamic::get_ptr(dynamic const& idx) {$/;"	f	class:folly::dynamic	signature:(dynamic const& idx)
get_ptr	.\dynamic.h	/^  const dynamic* get_ptr(dynamic const&) const;$/;"	p	struct:folly::dynamic	access:public	signature:(dynamic const&) const
get_ptr	.\dynamic.h	/^  dynamic* get_ptr(dynamic const&);$/;"	p	struct:folly::dynamic	access:public	signature:(dynamic const&)
get_ptr	.\experimental\Singleton.h	/^  static T* get_ptr(detail::TypeDescriptor type_descriptor = {typeid(T), ""},$/;"	f	class:folly::Singleton	access:private	signature:(detail::TypeDescriptor type_descriptor = {typeid(T), }, SingletonVault* vault = nullptr )
get_ptr	.\experimental\Singleton.h	/^  void* get_ptr(detail::TypeDescriptor type) {$/;"	f	class:folly::SingletonVault	access:public	signature:(detail::TypeDescriptor type)
get_rand_str	.\test\RangeTest.cpp	/^std::string get_rand_str($/;"	f	signature:( int size, std::uniform_int_distribution<>& dist, std::mt19937& gen)
get_ref_default	.\MapUtil.h	/^const typename Map::mapped_type& get_ref_default($/;"	f	namespace:folly	signature:( const Map& map, const typename Map::key_type& key, const typename Map::mapped_type& dflt)
get_shared	.\experimental\Singleton.h	/^  static std::shared_ptr<T> get_shared($/;"	f	class:folly::Singleton	access:private	signature:( detail::TypeDescriptor type_descriptor = {typeid(T), }, SingletonVault* vault = nullptr )
get_shared	.\experimental\Singleton.h	/^  std::shared_ptr<void> get_shared(detail::TypeDescriptor type) {$/;"	f	class:folly::SingletonVault	access:public	signature:(detail::TypeDescriptor type)
get_weak	.\experimental\Singleton.h	/^  static std::weak_ptr<T> get_weak($/;"	f	class:folly::Singleton	access:public	signature:( SingletonVault* vault = nullptr )
get_weak	.\experimental\Singleton.h	/^  static std::weak_ptr<T> get_weak($/;"	f	class:folly::Singleton	access:public	signature:( const char* name, SingletonVault* vault = nullptr )
get_weak	.\experimental\Singleton.h	/^  std::weak_ptr<T> get_weak(const char* name) {$/;"	f	class:folly::Singleton	access:public	signature:(const char* name)
getcpu	.\detail\CacheLocality.h	/^  static int getcpu(unsigned* cpu, unsigned* node, void* unused) {$/;"	f	struct:folly::detail::SequentialThreadId	access:public	signature:(unsigned* cpu, unsigned* node, void* unused)
getcpuFunc_	.\detail\CacheLocality.h	/^  Getcpu::Func getcpuFunc_;$/;"	m	struct:folly::detail::AccessSpreader	access:private
gflags	.\Portability.h	/^namespace gflags {$/;"	n
globalAHA	.\test\AtomicHashMapTest.cpp	/^static AHArrayT::SmartPtr globalAHA(nullptr);$/;"	p	file:	signature:(nullptr)
globalAHM	.\test\AtomicHashMapTest.cpp	/^static std::unique_ptr<AHMapT> globalAHM;$/;"	v	file:
globalCount	.\test\LazyTest.cpp	/^auto globalCount = folly::lazy([]{ return 0; });$/;"	m	namespace:folly	file:
globalHead_	.\IndexedMemPool.h	/^  AtomicStruct<TaggedPtr,Atom> FOLLY_ALIGN_TO_AVOID_FALSE_SHARING globalHead_;$/;"	m	namespace:folly
globalNext	.\IndexedMemPool.h	/^    uint32_t globalNext;$/;"	m	struct:folly::IndexedMemPool::Slot	access:public
globalPop	.\IndexedMemPool.h	/^  uint32_t globalPop() {$/;"	f	namespace:folly	signature:()
globalPush	.\IndexedMemPool.h	/^  void globalPush(Slot& s, uint32_t localHead) {$/;"	f	namespace:folly	signature:(Slot& s, uint32_t localHead)
globalTL32Baseline	.\test\ThreadCachedIntTest.cpp	/^ThreadLocal<int32_t> globalTL32Baseline;$/;"	v
globalTL64Baseline	.\test\ThreadCachedIntTest.cpp	/^ThreadLocal<int64_t> globalTL64Baseline;$/;"	v
global__thread32	.\test\ThreadCachedIntTest.cpp	/^FOLLY_TLS int32_t global__thread32;$/;"	v
global__thread64	.\test\ThreadCachedIntTest.cpp	/^FOLLY_TLS int64_t global__thread64;$/;"	v
global_counter	.\test\ArenaSmartPtrTest.cpp	/^  global_counter(): count_(0) {}$/;"	f	struct:global_counter	access:public	signature:()
global_counter	.\test\ArenaSmartPtrTest.cpp	/^struct global_counter {$/;"	s	file:
global_counter::count	.\test\ArenaSmartPtrTest.cpp	/^  unsigned count() const { return count_; }$/;"	f	struct:global_counter	access:public	signature:() const
global_counter::count_	.\test\ArenaSmartPtrTest.cpp	/^  unsigned count_;$/;"	m	struct:global_counter	file:	access:private
global_counter::decrease	.\test\ArenaSmartPtrTest.cpp	/^  void decrease() {$/;"	f	struct:global_counter	access:public	signature:()
global_counter::global_counter	.\test\ArenaSmartPtrTest.cpp	/^  global_counter(): count_(0) {}$/;"	f	struct:global_counter	access:public	signature:()
global_counter::increase	.\test\ArenaSmartPtrTest.cpp	/^  void increase() { ++count_; }$/;"	f	struct:global_counter	access:public	signature:()
global_watchdog	.\experimental\test\SingletonTest.cpp	/^Singleton<GlobalWatchdog> global_watchdog;$/;"	m	namespace:__anon47	file:
go	.\test\SmallLocksTest.cpp	/^  void go() {$/;"	f	struct:__anon131::TestClobber	access:public	signature:()
goldenFrames	.\experimental\symbolizer\test\SymbolizerTest.cpp	/^FrameArray<100> goldenFrames;$/;"	m	namespace:folly::symbolizer::test	file:
good	.\ConcurrentSkipList.h	/^  bool good() const { return node_ != nullptr; }$/;"	f	class:folly::detail::csl_iterator	access:public	signature:() const
good	.\ConcurrentSkipList.h	/^  bool good() const { return succs_[0] != nullptr; }$/;"	f	class:folly::ConcurrentSkipList::Skipper	access:public	signature:() const
goodExtBufferSize	.\io\IOBuf.cpp	/^size_t IOBuf::goodExtBufferSize(uint64_t minCapacity) {$/;"	f	class:folly::IOBuf	signature:(uint64_t minCapacity)
goodExtBufferSize	.\io\IOBuf.h	/^  static size_t goodExtBufferSize(uint64_t minCapacity);$/;"	p	class:folly::IOBuf	access:private	signature:(uint64_t minCapacity)
goodSize	.\Arena.h	/^  static size_t goodSize(const Alloc& alloc, size_t size) {$/;"	f	struct:folly::ArenaAllocatorTraits	access:public	signature:(const Alloc& alloc, size_t size)
goodSize	.\Arena.h	/^  static size_t goodSize(const SysAlloc& alloc, size_t size) {$/;"	f	struct:folly::ArenaAllocatorTraits	access:public	signature:(const SysAlloc& alloc, size_t size)
greater	.\ConcurrentSkipList.h	/^  static bool greater(const value_type &data, const NodeType *node) {$/;"	f	class:folly::ConcurrentSkipList	access:private	signature:(const value_type &data, const NodeType *node)
greater_than	.\Traits.h	/^bool greater_than(LHS const lhs) {$/;"	f	namespace:folly	signature:(LHS const lhs)
greater_than_impl	.\Traits.h	/^bool greater_than_impl($/;"	f	namespace:folly::detail	signature:( typename std::enable_if< (rhs < std::numeric_limits<LHS>::min()), LHS >::type const )
greater_than_impl	.\Traits.h	/^bool greater_than_impl($/;"	f	namespace:folly::detail	signature:( typename std::enable_if< (rhs <= std::numeric_limits<LHS>::max() && rhs >= std::numeric_limits<LHS>::min()), LHS >::type const lhs )
greater_than_impl	.\Traits.h	/^bool greater_than_impl($/;"	f	namespace:folly::detail	signature:( typename std::enable_if< (rhs > std::numeric_limits<LHS>::max()), LHS >::type const )
grow	.\MemoryMapping.h	/^    bool grow = false;$/;"	m	struct:folly::MemoryMapping::Options	access:public
growHeight	.\ConcurrentSkipList.h	/^  void growHeight(int height) {$/;"	f	class:folly::ConcurrentSkipList	access:private	signature:(int height)
growthFactor	.\AtomicHashArray.h	/^    double growthFactor;$/;"	m	struct:folly::AtomicHashArray::Config	access:public
growth_	.\io\Cursor.h	/^  size_t growth_;$/;"	m	class:folly::io::QueueAppender	access:private
growth_	.\io\Cursor.h	/^  uint64_t growth_;$/;"	m	class:folly::io::Appender	access:private
growth_policy_wrapper	.\sorted_vector_types.h	/^  struct growth_policy_wrapper : private Policy {$/;"	s	namespace:folly::detail	inherits:Policy
growth_policy_wrapper	.\sorted_vector_types.h	/^  struct growth_policy_wrapper<void> {$/;"	s	namespace:folly::detail
guard	.\gen\Base.h	/^GuardImpl guard(ErrorHandler&& handler) {$/;"	f	namespace:folly::gen	signature:(ErrorHandler&& handler)
guard	.\test\ApplyTupleTest.cpp	/^guard(F&& f, Args&&... args) {$/;"	f	namespace:__anon104	signature:(F&& f, Args&&... args)
guard1_	.\experimental\exception_tracer\StackTrace.h	/^  uintptr_t guard1_;$/;"	m	class:folly::exception_tracer::StackTraceStack	access:private
guard2_	.\experimental\exception_tracer\StackTrace.h	/^  uintptr_t guard2_;$/;"	m	class:folly::exception_tracer::StackTraceStack	access:private
guardCount_	.\io\async\DelayedDestruction.h	/^  uint32_t guardCount_;$/;"	m	class:folly::DelayedDestruction	access:private
handle	.\experimental\wangle\concurrent\ThreadPoolExecutor.h	/^    std::thread handle;$/;"	m	struct:folly::wangle::ThreadPoolExecutor::Thread	access:public
handleFormatStrError	.\Format-inl.h	/^void BaseFormatter<Derived, containerMode, Args...>::handleFormatStrError()$/;"	f	class:folly::BaseFormatter	signature:() const
handleFormatStrError	.\Format.h	/^  FOLLY_NORETURN void handleFormatStrError() const;$/;"	p	class:folly::BaseFormatter	access:private	signature:() const
handleRead	.\Subprocess.cpp	/^bool handleRead(int fd, IOBufQueue& queue) {$/;"	f	namespace:folly::__anon99	signature:(int fd, IOBufQueue& queue)
handleWrite	.\Subprocess.cpp	/^bool handleWrite(int fd, IOBufQueue& queue) {$/;"	f	namespace:folly::__anon99	signature:(int fd, IOBufQueue& queue)
handled	.\experimental\symbolizer\test\StackTraceTest.cpp	/^volatile bool handled = false;$/;"	v
handler	.\experimental\symbolizer\test\StackTraceTest.cpp	/^void handler(int num, siginfo_t* info, void* ctx) {$/;"	f	signature:(int num, siginfo_t* info, void* ctx)
handlerCount	.\experimental\exception_tracer\ExceptionAbi.h	/^  int handlerCount;$/;"	m	struct:__cxxabiv1::__cxa_exception	access:public
handlerSwitchValue	.\experimental\exception_tracer\ExceptionAbi.h	/^  int handlerSwitchValue;$/;"	m	struct:__cxxabiv1::__cxa_exception	access:public
handler_	.\gen\Base-inl.h	/^    ErrorHandler handler_;$/;"	m	class:folly::gen::detail::GuardImpl::Generator	access:private
handler_	.\gen\Base-inl.h	/^  ErrorHandler handler_;$/;"	m	class:folly::gen::detail::GuardImpl	access:private
handlers_	.\experimental\symbolizer\SignalHandler.cpp	/^  std::vector<SignalCallback> handlers_;$/;"	m	class:folly::symbolizer::__anon36::FatalSignalCallbackRegistry	file:	access:private
handoff	.\LifoSem.h	/^  Handoff& handoff() {$/;"	f	struct:folly::detail::LifoSemNode	access:public	signature:()
handoff	.\LifoSem.h	/^  const Handoff& handoff() const {$/;"	f	struct:folly::detail::LifoSemNode	access:public	signature:() const
handwrittenAtoi	.\test\ConvTest.cpp	/^static int64_t handwrittenAtoi(const char* start, const char* end) {$/;"	f	file:	signature:(const char* start, const char* end)
handwrittenAtoiMeasure	.\test\ConvTest.cpp	/^void handwrittenAtoiMeasure(unsigned int n, unsigned int digits) {$/;"	f	signature:(unsigned int n, unsigned int digits)
hardReset	.\test\stl_tests\StlVectorTest.cpp	/^void hardReset() {$/;"	f	signature:()
hasCapacity	.\small_vector.h	/^    bool hasCapacity() const {$/;"	f	namespace:folly	signature:() const
hasChildren	.\experimental\symbolizer\Dwarf.h	/^    bool hasChildren;$/;"	m	struct:folly::symbolizer::Dwarf::DIEAbbreviation	access:public
hasContextData	.\io\async\Request.h	/^  bool hasContextData(const std::string& val) {$/;"	f	class:folly::RequestContext	access:public	signature:(const std::string& val)
hasException	.\wangle\Try.h	/^  bool hasException() const { return !hasValue_; }$/;"	f	class:folly::wangle::Try	access:public	signature:() const
hasException	.\wangle\Try.h	/^  bool hasException() const { return contains_ == Contains::EXCEPTION; }$/;"	f	class:folly::wangle::Try	access:public	signature:() const
hasFileAndLine	.\experimental\symbolizer\Dwarf.h	/^    bool hasFileAndLine;$/;"	m	struct:folly::symbolizer::Dwarf::LocationInfo	access:public
hasMainFile	.\experimental\symbolizer\Dwarf.h	/^    bool hasMainFile;$/;"	m	struct:folly::symbolizer::Dwarf::LocationInfo	access:public
hasType	.\DiscriminatedPtr.h	/^  bool hasType() const {$/;"	f	class:folly::DiscriminatedPtr	access:public	signature:() const
hasValue	.\Optional.h	/^  bool hasValue() const { return hasValue_; }$/;"	f	class:folly::Optional	access:public	signature:() const
hasValue	.\test\OptionalTest.cpp	/^  bool hasValue() const { return opt_.hasValue(); }$/;"	f	class:folly::ContainsOptional	access:public	signature:() const
hasValue	.\wangle\Try.h	/^  bool hasValue() const { return contains_ == Contains::VALUE; }$/;"	f	class:folly::wangle::Try	access:public	signature:() const
hasValue	.\wangle\Try.h	/^  bool hasValue() const { return hasValue_; }$/;"	f	class:folly::wangle::Try	access:public	signature:() const
hasValue_	.\Optional.h	/^    : hasValue_(false) {$/;"	f	class:folly::Optional	access:public	signature:(false)
hasValue_	.\Optional.h	/^  bool hasValue_;$/;"	m	class:folly::Optional	access:private
hasValue_	.\wangle\Try.h	/^  bool hasValue_;$/;"	m	class:folly::wangle::Try	access:private
has_nothrow_constructor	.\String.h	/^struct has_nothrow_constructor<folly::basic_fbstring<T> > : true_type {$/;"	s	namespace:folly::boost	inherits:true_type
has_nothrow_constructor	.\Traits.h	/^struct has_nothrow_constructor< std::pair<T, U> >$/;"	s	namespace:boost	inherits:::boost::mpl::and_
hash	.\Hash.h	/^  static size_t hash(const T& t) {$/;"	f	class:folly::hash::StdHasher	access:public	signature:(const T& t)
hash	.\Hash.h	/^  struct hash<std::pair<T1, T2> > {$/;"	s	namespace:std
hash	.\Hash.h	/^  struct hash<std::tuple<Ts...>> {$/;"	s	namespace:std
hash	.\Hash.h	/^namespace folly { namespace hash {$/;"	n	namespace:folly
hash	.\IPAddress.h	/^  std::size_t hash() const {$/;"	f	class:folly::IPAddress	access:public	signature:() const
hash	.\IPAddress.h	/^struct hash<folly::IPAddress> {$/;"	s	namespace:std
hash	.\IPAddressV4.h	/^  size_t hash() const {$/;"	f	class:folly::IPAddressV4	access:public	signature:() const
hash	.\IPAddressV4.h	/^struct hash<folly::IPAddressV4> {$/;"	s	namespace:std
hash	.\IPAddressV6.cpp	/^size_t IPAddressV6::hash() const {$/;"	f	class:folly::IPAddressV6	signature:() const
hash	.\IPAddressV6.h	/^  size_t hash() const;$/;"	p	class:folly::IPAddressV6	access:public	signature:() const
hash	.\IPAddressV6.h	/^struct hash<folly::IPAddressV6> {$/;"	s	namespace:std
hash	.\Range.h	/^  uint32_t hash() const {$/;"	f	class:folly::Range	access:public	signature:() const
hash	.\SocketAddress.cpp	/^size_t SocketAddress::hash() const {$/;"	f	class:folly::SocketAddress	signature:() const
hash	.\SocketAddress.h	/^  size_t hash() const;$/;"	p	class:folly::SocketAddress	access:public	signature:() const
hash	.\SocketAddress.h	/^struct hash<folly::SocketAddress> {$/;"	s	namespace:std
hash	.\SpookyHashV1.cpp	/^namespace hash {$/;"	n	namespace:folly	file:
hash	.\SpookyHashV1.h	/^namespace hash {$/;"	n	namespace:folly
hash	.\SpookyHashV2.cpp	/^namespace hash {$/;"	n	namespace:folly	file:
hash	.\SpookyHashV2.h	/^namespace hash {$/;"	n	namespace:folly
hash	.\dynamic-inl.h	/^inline std::size_t dynamic::hash() const {$/;"	f	class:folly::dynamic	signature:() const
hash	.\dynamic-inl.h	/^struct hash< ::folly::dynamic> {$/;"	s	namespace:std
hash	.\dynamic.h	/^  std::size_t hash() const;$/;"	p	struct:folly::dynamic	access:public	signature:() const
hash	.\io\test\CompressionTest.cpp	/^  uint64_t hash(size_t size) const;$/;"	p	class:folly::io::test::DataHolder	file:	access:public	signature:(size_t size) const
hash	.\io\test\CompressionTest.cpp	/^uint64_t DataHolder::hash(size_t size) const {$/;"	f	class:folly::io::test::DataHolder	signature:(size_t size) const
hash	.\test\HashTest.cpp	/^  static size_t hash(const std::pair<int, int>& p) {$/;"	f	class:TestHasher	access:public	signature:(const std::pair<int, int>& p)
hashCache_	.\io\test\CompressionTest.cpp	/^  mutable std::unordered_map<uint64_t, uint64_t> hashCache_;$/;"	m	class:folly::io::test::DataHolder	file:	access:protected
hashFunction	.\io\RecordIO-inl.h	/^  uint8_t  hashFunction;  \/\/ 0 = SpookyHashV2$/;"	m	struct:folly::recordio_helpers::detail::Header	access:public
hashIOBuf	.\io\test\CompressionTest.cpp	/^uint64_t hashIOBuf(const IOBuf* buf) {$/;"	f	namespace:folly::io::test	signature:(const IOBuf* buf)
hash_128_to_64	.\Hash.h	/^inline size_t hash_128_to_64(const size_t upper, const size_t lower) {$/;"	f	namespace:folly::hash	signature:(const size_t upper, const size_t lower)
hash_combine	.\Hash.h	/^size_t hash_combine(const T& t, const Ts&... ts) {$/;"	f	namespace:folly::hash	signature:(const T& t, const Ts&... ts)
hash_combine_generic	.\Hash.h	/^inline size_t hash_combine_generic() {$/;"	f	namespace:folly::hash	signature:()
hash_combine_generic	.\Hash.h	/^size_t hash_combine_generic(const T& t, const Ts&... ts) {$/;"	f	namespace:folly::hash	signature:(const T& t, const Ts&... ts)
hash_combine_test	.\test\HashTest.cpp	/^size_t hash_combine_test(const T& t, const Ts&... ts) {$/;"	f	signature:(const T& t, const Ts&... ts)
hash_function	.\AtomicHashMap.h	/^  hasher hash_function() const { return hasher(); }$/;"	f	class:folly::AtomicHashMap	access:public	signature:() const
hash_range	.\Hash.h	/^uint64_t hash_range(Iter begin,$/;"	f	namespace:folly::hash	signature:(Iter begin, Iter end, uint64_t hash = 0, Hash hasher = Hash())
hash_value	.\EvictingCacheMap.h	/^    friend std::size_t hash_value(const Node& node) {$/;"	f	struct:folly::EvictingCacheMap::Node	access:friend	signature:(const Node& node)
hash_value	.\IPAddress.cpp	/^size_t hash_value(const IPAddress& addr) {$/;"	f	namespace:folly	signature:(const IPAddress& addr)
hash_value	.\IPAddress.h	/^std::size_t hash_value(const IPAddress& addr);$/;"	p	namespace:folly	signature:(const IPAddress& addr)
hash_value	.\IPAddressV4.cpp	/^size_t hash_value(const IPAddressV4& addr) {$/;"	f	namespace:folly	signature:(const IPAddressV4& addr)
hash_value	.\IPAddressV4.h	/^size_t hash_value(const IPAddressV4& addr);$/;"	p	namespace:folly	signature:(const IPAddressV4& addr)
hash_value	.\IPAddressV6.cpp	/^size_t hash_value(const IPAddressV6& addr) {$/;"	f	namespace:folly	signature:(const IPAddressV6& addr)
hash_value	.\IPAddressV6.h	/^std::size_t hash_value(const IPAddressV6& addr);$/;"	p	namespace:folly	signature:(const IPAddressV6& addr)
hash_value	.\SocketAddress.cpp	/^size_t hash_value(const SocketAddress& address) {$/;"	f	namespace:folly	signature:(const SocketAddress& address)
hash_value	.\SocketAddress.h	/^size_t hash_value(const SocketAddress& address);$/;"	p	namespace:folly	signature:(const SocketAddress& address)
hash_vector	.\test\HashTest.cpp	/^size_t hash_vector(const std::vector<T>& v) {$/;"	f	namespace:__anon124	signature:(const std::vector<T>& v)
hasher	.\AtomicHashMap.h	/^  typedef HashFcn             hasher;$/;"	t	class:folly::AtomicHashMap	access:public
hasher	.\Hash.h	/^struct hasher;$/;"	x
hasher	.\Hash.h	/^template<> struct hasher<int32_t> {$/;"	s	namespace:folly
hasher	.\Hash.h	/^template<> struct hasher<int64_t> {$/;"	s	namespace:folly
hasher	.\Hash.h	/^template<> struct hasher<uint32_t> {$/;"	s	namespace:folly
hasher	.\Hash.h	/^template<> struct hasher<uint64_t> {$/;"	s	namespace:folly
haveNotSeenValue_	.\stats\TimeseriesHistogram.h	/^  bool haveNotSeenValue_;$/;"	m	class:folly::TimeseriesHistogram	access:private
head	.\ConcurrentSkipList.h	/^  NodeType* head() const {$/;"	f	class:folly::ConcurrentSkipList::Skipper	access:private	signature:() const
head	.\IndexedMemPool.h	/^    AtomicStruct<TaggedPtr,Atom> head;$/;"	m	struct:folly::LocalList	access:public
head	.\io\Cursor.h	/^  BufType* head() {$/;"	f	class:folly::io::detail::CursorBase	access:protected	signature:()
headHeight_	.\ConcurrentSkipList.h	/^  int headHeight_;$/;"	m	class:folly::ConcurrentSkipList::Skipper	access:private
head_	.\ConcurrentSkipList.h	/^  std::atomic<NodeType*> head_;$/;"	m	class:folly::ConcurrentSkipList	access:private
head_	.\detail\ThreadLocalDetail.h	/^  ThreadEntry head_;$/;"	m	struct:folly::threadlocal_detail::StaticMeta	access:public
head_	.\io\IOBufQueue.h	/^  std::unique_ptr<folly::IOBuf> head_;$/;"	m	class:folly::IOBufQueue	access:private
headerHash	.\io\RecordIO-inl.h	/^  uint32_t headerHash;  \/\/ must be last$/;"	m	struct:folly::recordio_helpers::detail::Header	access:public
headerHash	.\io\RecordIO.cpp	/^uint32_t headerHash(const Header& header) {$/;"	f	namespace:folly::recordio_helpers::__anon68	signature:(const Header& header)
headerSize	.\io\RecordIO-inl.h	/^constexpr size_t headerSize() { return sizeof(detail::Header); }$/;"	f	namespace:folly::recordio_helpers	signature:()
headerSize	.\io\RecordIO.h	/^constexpr size_t headerSize();  \/\/ defined in RecordIO-inl.h$/;"	p	namespace:folly::recordio_helpers	signature:()
headroom	.\io\IOBuf.h	/^  uint64_t headroom() const {$/;"	f	class:folly::IOBuf	access:public	signature:() const
headroom	.\io\IOBufQueue.cpp	/^IOBufQueue::headroom() {$/;"	f	class:folly::IOBufQueue	signature:()
headroom	.\io\IOBufQueue.h	/^  std::pair<void*, uint64_t> headroom();$/;"	p	class:folly::IOBufQueue	access:public	signature:()
headroom	.\io\TypedIOBuf.h	/^  uint32_t headroom() const {$/;"	f	class:folly::TypedIOBuf	access:public	signature:() const
heap_	.\small_vector.h	/^    void* heap_;$/;"	m	struct:folly::small_vector::HeapPtr	access:public
heap_	.\small_vector.h	/^    void* heap_;$/;"	m	struct:folly::small_vector::HeapPtrWithCapacity	access:public
heavyWork	.\gen\test\ParallelTest.cpp	/^auto heavyWork = map(primeFactors);$/;"	v
height	.\ConcurrentSkipList-inl.h	/^  int height() const { return height_; }$/;"	f	class:folly::detail::SkipListNode	access:public	signature:() const
height	.\ConcurrentSkipList.h	/^  int height() const {$/;"	f	class:folly::ConcurrentSkipList	access:private	signature:() const
height	.\ConcurrentSkipList.h	/^  size_t height() const { return sl_->height(); }$/;"	f	class:folly::ConcurrentSkipList::Accessor	access:public	signature:() const
height_	.\ConcurrentSkipList-inl.h	/^  const uint8_t height_;$/;"	m	class:folly::detail::SkipListNode	access:private
helloArray	.\test\RangeTest.cpp	/^constexpr char helloArray[] = "hello";$/;"	v
hexDump	.\String-inl.h	/^void hexDump(const void* ptr, size_t size, OutIt out) {$/;"	f	namespace:folly	signature:(const void* ptr, size_t size, OutIt out)
hexDump	.\String.cpp	/^std::string hexDump(const void* ptr, size_t size) {$/;"	f	namespace:folly	signature:(const void* ptr, size_t size)
hexDump	.\String.h	/^std::string hexDump(const void* ptr, size_t size);$/;"	p	class:folly::UriEscapeMode	access:private	signature:(const void* ptr, size_t size)
hexDump	.\String.h	/^void hexDump(const void* ptr, size_t size, OutIt out);$/;"	p	class:folly::UriEscapeMode	access:private	signature:(const void* ptr, size_t size, OutIt out)
hexDumpLine	.\String-inl.h	/^size_t hexDumpLine(const void* ptr, size_t offset, size_t size,$/;"	p	namespace:folly::detail	signature:(const void* ptr, size_t offset, size_t size, std::string& line)
hexDumpLine	.\String.cpp	/^size_t hexDumpLine(const void* ptr, size_t offset, size_t size,$/;"	f	namespace:folly::detail	signature:(const void* ptr, size_t offset, size_t size, std::string& line)
hex_values	.\build\generate_format_tables.py	/^def hex_values(upper):$/;"	f	access:public
hexlify	.\String-inl.h	/^bool hexlify(const InputString& input, OutputString& output,$/;"	f	namespace:folly	signature:(const InputString& input, OutputString& output, bool append_output)
hexlify	.\String.h	/^bool hexlify(const InputString& input, OutputString& output,$/;"	p	class:folly::UriEscapeMode	access:private	signature:(const InputString& input, OutputString& output, bool append=false)
hide	.\wangle\Later.h	/^  struct hide { };$/;"	s	class:folly::wangle::Later	access:private
highCompression_	.\io\Compression.cpp	/^  bool highCompression_;$/;"	m	class:folly::io::__anon64::FOLLY_FINAL	file:	access:private
hintLinearScan	.\MemoryMapping.cpp	/^void MemoryMapping::hintLinearScan() {$/;"	f	class:folly::MemoryMapping	signature:()
hintLinearScan	.\MemoryMapping.h	/^  void hintLinearScan();$/;"	p	class:folly::MemoryMapping	access:public	signature:()
hints_	.\ConcurrentSkipList.h	/^  uint8_t hints_[MAX_HEIGHT];$/;"	m	class:folly::ConcurrentSkipList::Skipper	access:private
hist_	.\test\ProducerConsumerQueueBenchmark.cpp	/^  Histogram<int> hist_;$/;"	m	struct:__anon127::LatencyTest	file:	access:public
hook	.\io\async\EventBase.h	/^    ListHook hook;$/;"	m	class:folly::EventBase::CobTimeout	access:public
hook_	.\io\async\EventBase.h	/^    ListHook hook_;$/;"	m	class:folly::EventBase::LoopCallback	access:private
hook_	.\io\async\HHWheelTimer.h	/^    ListHook hook_;$/;"	m	class:folly::HHWheelTimer::Callback	access:private
host	.\SocketAddress.cpp	/^  const char* host;$/;"	m	struct:__anon90::HostAndPort	file:	access:public
host	.\Uri.h	/^  const fbstring& host() const { return host_; }$/;"	f	class:folly::Uri	access:public	signature:() const
host_	.\Uri.h	/^  fbstring host_;$/;"	m	class:folly::Uri	access:private
hostname	.\Uri.cpp	/^fbstring Uri::hostname() const {$/;"	f	class:folly::Uri	signature:() const
hostname	.\Uri.h	/^  fbstring hostname() const;$/;"	p	class:folly::Uri	access:public	signature:() const
hs	.\io\IOBuf.cpp	/^  HeapStorage hs;$/;"	m	struct:folly::IOBuf::HeapFullStorage	file:	access:public
hsieh_hash32	.\Hash.h	/^inline uint32_t hsieh_hash32(const char* s) {$/;"	f	namespace:folly::hash	signature:(const char* s)
hsieh_hash32_buf	.\Hash.h	/^inline uint32_t hsieh_hash32_buf(const void* buf, int len) {$/;"	f	namespace:folly::hash	signature:(const void* buf, int len)
hsieh_hash32_str	.\Hash.h	/^inline uint32_t hsieh_hash32_str(const std::string& str) {$/;"	f	namespace:folly::hash	signature:(const std::string& str)
huge	.\gen\test\ParallelBenchmark.cpp	/^auto huge = from(v);$/;"	v
humanReadable	.\Benchmark.cpp	/^static string humanReadable(double n, unsigned int decimals,$/;"	f	namespace:folly	signature:(double n, unsigned int decimals, const ScaleInfo* scales)
humanify	.\String-inl.h	/^void humanify(const String1& input, String2& output) {$/;"	f	namespace:folly	signature:(const String1& input, String2& output)
humanify	.\String.h	/^String humanify(const String& input) {$/;"	f	class:folly::UriEscapeMode	access:private	signature:(const String& input)
humanify	.\String.h	/^void humanify(const String1& input, String2& output);$/;"	p	class:folly::UriEscapeMode	access:private	signature:(const String1& input, String2& output)
i	.\AtomicHashMap.h	/^  struct SimpleRetT { uint32_t i; size_t j; bool success;$/;"	m	struct:folly::AtomicHashMap::SimpleRetT	access:public
i	.\test\AHMIntStressTest.cpp	/^  int i;$/;"	m	struct:__anon102::MyObject	file:	access:public
i	.\test\DynamicConverterTest.cpp	/^  int i;$/;"	m	struct:A	file:	access:public
i_	.\test\ExceptionWrapperTest.cpp	/^  int i_;$/;"	m	class:IntException	file:	access:private
id	.\TimeoutQueue.h	/^    Id id;$/;"	m	struct:folly::TimeoutQueue::Event	access:public
id	.\experimental\wangle\concurrent\ThreadPoolExecutor.h	/^    uint64_t id;$/;"	m	struct:folly::wangle::ThreadPoolExecutor::Thread	access:public
id	.\test\stl_tests\StlVectorTest.cpp	/^  int id;$/;"	m	struct:Alloc	file:	access:public
id_	.\ThreadLocal.h	/^        id_(other.id_) {$/;"	f	class:folly::ThreadLocalPtr::Accessor	access:public	signature:(other.id_)
id_	.\ThreadLocal.h	/^    int id_;$/;"	m	class:folly::ThreadLocalPtr::Accessor	access:private
id_	.\ThreadLocal.h	/^  int id_;  \/\/ every instantiation has a unique id$/;"	m	class:folly::ThreadLocalPtr	access:private
idle	.\experimental\wangle\concurrent\ThreadPoolExecutor.h	/^    bool idle;$/;"	m	struct:folly::wangle::ThreadPoolExecutor::Thread	access:public
idleIterator_	.\experimental\wangle\ConnectionManager.h	/^    ManagedConnection,&ManagedConnection::listHook_>::iterator idleIterator_;$/;"	m	class:folly::wangle::ConnectionManager	access:private
idleLoopCallback_	.\experimental\wangle\ConnectionManager.h	/^  CloseIdleConnsCallback idleLoopCallback_;$/;"	m	class:folly::wangle::ConnectionManager	access:private
idx	.\AtomicHashArray.h	/^  struct SimpleRetT { size_t idx; bool success;$/;"	m	struct:folly::AtomicHashArray::SimpleRetT	access:public
idx	.\IndexedMemPool.h	/^    uint32_t idx;$/;"	m	struct:folly::IndexedMemPool::TaggedPtr	access:public
idx	.\LifoSem.h	/^  inline uint32_t idx() const {$/;"	f	class:folly::detail::LifoSemHead	access:public	signature:() const
idxToNode	.\LifoSem.h	/^  static LifoSemNode<Handoff, Atom>& idxToNode(uint32_t idx) {$/;"	f	struct:folly::detail::LifoSemBase	access:private	signature:(uint32_t idx)
idxToRec	.\AtomicHashMap.h	/^  inline const value_type& idxToRec(uint32_t idx) const {$/;"	f	class:folly::AtomicHashMap	access:public	signature:(uint32_t idx) const
idx_	.\test\ThreadLocalTest.cpp	/^  uint64_t idx_;$/;"	m	class:__anon146::FillObject	file:	access:private
ignore	.\test\PackedSyncPtrTest.cpp	/^struct ignore { PackedSyncPtr<int> foo; char c; } FOLLY_PACK_ATTR;$/;"	s	namespace:__anon126	file:
ignore1	.\test\SmallLocksTest.cpp	/^struct ignore1 { MicroSpinLock msl; int16_t foo; } FOLLY_PACK_ATTR;$/;"	s	namespace:__anon131	file:
ignore2	.\test\SmallLocksTest.cpp	/^struct ignore2 { PicoSpinLock<uint32_t> psl; int16_t foo; }$/;"	s	namespace:__anon131	file:
ijarC	.\test\stl_tests\StlVectorTest.cpp	/^static int ijarC[12] = { 0, 1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89 };$/;"	v	file:
ijarr	.\test\stl_tests\StlVectorTest.cpp	/^static int ijarr[12] = { 0, 1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89 };$/;"	v	file:
impl_	.\FBVector.h	/^  } impl_;$/;"	m	class:folly::fbvector	typeref:struct:folly::fbvector::Impl	access:private
impl_	.\gen\Base-inl.h	/^  SequenceImpl impl_;$/;"	m	class:folly::gen::detail::Sequence	access:private
in6Addr_	.\IPAddressV6.h	/^    in6_addr in6Addr_;$/;"	m	union:folly::IPAddressV6::AddressStorage	access:public
inAddr_	.\IPAddressV4.h	/^    in_addr inAddr_;$/;"	m	union:folly::IPAddressV4::AddressStorage	access:public
inBinarySubnet	.\IPAddressV6.cpp	/^bool IPAddressV6::inBinarySubnet(const std::array<uint8_t, 2> addr,$/;"	f	class:folly::IPAddressV6	signature:(const std::array<uint8_t, 2> addr, size_t numBits) const
inBinarySubnet	.\IPAddressV6.h	/^  bool inBinarySubnet(const std::array<uint8_t, 2> addr,$/;"	p	class:folly::IPAddressV6	access:protected	signature:(const std::array<uint8_t, 2> addr, size_t numBits) const
inQueue_	.\gen\Parallel-inl.h	/^      InQueue inQueue_;$/;"	m	class:folly::gen::detail::Parallel::Generator::Executor	access:private
inRunningEventBaseThread	.\io\async\EventBase.h	/^  bool inRunningEventBaseThread() const {$/;"	f	class:folly::EventBase	access:public	signature:() const
inSubnet	.\IPAddress.cpp	/^bool IPAddress::inSubnet(StringPiece cidrNetwork) const {$/;"	f	class:folly::IPAddress	signature:(StringPiece cidrNetwork) const
inSubnet	.\IPAddress.cpp	/^bool IPAddress::inSubnet(const IPAddress& subnet, uint8_t cidr) const {$/;"	f	class:folly::IPAddress	signature:(const IPAddress& subnet, uint8_t cidr) const
inSubnet	.\IPAddress.h	/^  bool inSubnet(StringPiece ipSlashCidr) const;$/;"	p	class:folly::IPAddress	access:public	signature:(StringPiece ipSlashCidr) const
inSubnet	.\IPAddress.h	/^  bool inSubnet(const IPAddress& subnet, uint8_t cidr) const;$/;"	p	class:folly::IPAddress	access:public	signature:(const IPAddress& subnet, uint8_t cidr) const
inSubnet	.\IPAddressV4.cpp	/^bool IPAddressV4::inSubnet(StringPiece cidrNetwork) const {$/;"	f	class:folly::IPAddressV4	signature:(StringPiece cidrNetwork) const
inSubnet	.\IPAddressV4.h	/^  bool inSubnet(StringPiece cidrNetwork) const;$/;"	p	class:folly::IPAddressV4	access:public	signature:(StringPiece cidrNetwork) const
inSubnet	.\IPAddressV4.h	/^  bool inSubnet(const IPAddressV4& subnet, uint8_t cidr) const {$/;"	f	class:folly::IPAddressV4	access:public	signature:(const IPAddressV4& subnet, uint8_t cidr) const
inSubnet	.\IPAddressV6.cpp	/^bool IPAddressV6::inSubnet(StringPiece cidrNetwork) const {$/;"	f	class:folly::IPAddressV6	signature:(StringPiece cidrNetwork) const
inSubnet	.\IPAddressV6.h	/^  bool inSubnet(StringPiece cidrNetwork) const;$/;"	p	class:folly::IPAddressV6	access:public	signature:(StringPiece cidrNetwork) const
inSubnet	.\IPAddressV6.h	/^  bool inSubnet(const IPAddressV6& subnet, uint8_t cidr) const {$/;"	f	class:folly::IPAddressV6	access:public	signature:(const IPAddressV6& subnet, uint8_t cidr) const
inSubnet	.\test\IPAddressTest.h	/^  bool inSubnet;$/;"	m	struct:folly::MaskBoundaryData	access:public
inSubnetWithMask	.\IPAddress.cpp	/^bool IPAddress::inSubnetWithMask(const IPAddress& subnet,$/;"	f	class:folly::IPAddress	signature:(const IPAddress& subnet, ByteRange mask) const
inSubnetWithMask	.\IPAddress.h	/^  bool inSubnetWithMask(const IPAddress& subnet, ByteRange mask) const;$/;"	p	class:folly::IPAddress	access:public	signature:(const IPAddress& subnet, ByteRange mask) const
inSubnetWithMask	.\IPAddressV4.cpp	/^bool IPAddressV4::inSubnetWithMask(const IPAddressV4& subnet,$/;"	f	class:folly::IPAddressV4	signature:(const IPAddressV4& subnet, const ByteArray4 cidrMask) const
inSubnetWithMask	.\IPAddressV4.h	/^  bool inSubnetWithMask(const IPAddressV4& subnet, const ByteArray4 mask) const;$/;"	p	class:folly::IPAddressV4	access:public	signature:(const IPAddressV4& subnet, const ByteArray4 mask) const
inSubnetWithMask	.\IPAddressV6.cpp	/^bool IPAddressV6::inSubnetWithMask(const IPAddressV6& subnet,$/;"	f	class:folly::IPAddressV6	signature:(const IPAddressV6& subnet, const ByteArray16& cidrMask) const
inSubnetWithMask	.\IPAddressV6.h	/^  bool inSubnetWithMask(const IPAddressV6& subnet,$/;"	p	class:folly::IPAddressV6	access:public	signature:(const IPAddressV6& subnet, const ByteArray16& mask) const
in_	.\test\FileUtilTest.cpp	/^  std::string in_;$/;"	m	class:folly::test::FileUtilTest	file:	access:protected
inc	.\test\ThreadCachedIntTest.cpp	/^  inline void inc(int64_t val = 1) {$/;"	f	struct:ShardedAtomicInt	access:public	signature:(int64_t val = 1)
includeDirectories_	.\experimental\symbolizer\Dwarf.h	/^    folly::StringPiece includeDirectories_;$/;"	m	class:folly::symbolizer::Dwarf::LineNumberVM	access:private
includeDirectoryCount_	.\experimental\symbolizer\Dwarf.h	/^    size_t includeDirectoryCount_;$/;"	m	class:folly::symbolizer::Dwarf::LineNumberVM	access:private
incr	.\detail\FileUtilDetail.h	/^inline void incr(ssize_t n) { }$/;"	f	namespace:folly::fileutil_detail	signature:(ssize_t n)
incr	.\detail\FileUtilDetail.h	/^inline void incr(ssize_t n, off_t& offset) { offset += n; }$/;"	f	namespace:folly::fileutil_detail	signature:(ssize_t n, off_t& offset)
incrOrPop	.\LifoSem.h	/^  uint32_t incrOrPop(uint32_t n) {$/;"	f	struct:folly::detail::LifoSemBase	access:private	signature:(uint32_t n)
increase	.\test\ArenaSmartPtrTest.cpp	/^  void increase() { ++count_; }$/;"	f	struct:global_counter	access:public	signature:()
increase_capacity	.\sorted_vector_types.h	/^    Iterator increase_capacity(Container& c, Iterator desired_insertion)$/;"	f	struct:folly::detail::growth_policy_wrapper	access:public	signature:(Container& c, Iterator desired_insertion)
increase_capacity	.\sorted_vector_types.h	/^    Iterator increase_capacity(Container&, Iterator it) {$/;"	f	struct:folly::detail::growth_policy_wrapper	access:public	signature:(Container&, Iterator it)
increase_capacity	.\test\sorted_vector_test.cpp	/^  void increase_capacity(Container& c) {$/;"	f	struct:__anon133::OneAtATimePolicy	access:public	signature:(Container& c)
increment	.\AtomicHashArray-inl.h	/^  void increment() {$/;"	f	struct:folly::AtomicHashArray::aha_iterator	access:private	signature:()
increment	.\AtomicHashMap-inl.h	/^  void increment() {$/;"	f	struct:folly::AtomicHashMap::ahm_iterator	access:private	signature:()
increment	.\ConcurrentSkipList.h	/^  void increment() { node_ = node_->next(); };$/;"	f	class:folly::detail::csl_iterator	access:private	signature:()
increment	.\DynamicConverter.h	/^  void increment() {$/;"	f	class:folly::dynamicconverter_detail::Transformer	access:private	signature:()
increment	.\Padded.h	/^  void increment() {$/;"	f	namespace:folly::padded	access:private	signature:()
increment	.\ThreadCachedInt.h	/^    void increment(IntT inc) {$/;"	f	struct:folly::ThreadCachedInt::IntCache	access:public	signature:(IntT inc)
increment	.\ThreadCachedInt.h	/^  void increment(IntT inc) {$/;"	f	class:folly::ThreadCachedInt	access:public	signature:(IntT inc)
increment	.\ThreadLocal.h	/^      void increment() {$/;"	f	class:folly::ThreadLocalPtr::Accessor::Iterator	access:private	signature:()
increment	.\io\IOBuf.h	/^  void increment() {$/;"	f	class:folly::IOBuf::Iterator	access:private	signature:()
increment	.\io\RecordIO-inl.h	/^  void increment() {$/;"	f	class:folly::RecordIOReader::Iterator	access:private	signature:()
increment	.\test\AtomicHashMapTest.cpp	/^  void increment(int64_t obj_id) {$/;"	f	class:Counters	access:public	signature:(int64_t obj_id)
incrementSize	.\ConcurrentSkipList.h	/^  size_t incrementSize(int delta) {$/;"	f	class:folly::ConcurrentSkipList	access:private	signature:(int delta)
incrementToValid	.\ThreadLocal.h	/^      void incrementToValid() {$/;"	f	class:folly::ThreadLocalPtr::Accessor::Iterator	access:private	signature:()
indent	.\json.cpp	/^  void indent() const {$/;"	f	struct:folly::json::__anon75::Printer	file:	access:private	signature:() const
indentLevel_	.\json.cpp	/^  unsigned* const indentLevel_;$/;"	m	struct:folly::json::__anon75::Printer	file:	access:private
index	.\DiscriminatedPtr.h	/^  uint16_t index() const { return data_ >> 48; }$/;"	f	class:folly::DiscriminatedPtr	access:private	signature:() const
indexBuckets_	.\EvictingCacheMap.h	/^  std::unique_ptr<typename NodeMap::bucket_type[]> indexBuckets_;$/;"	m	class:folly::EvictingCacheMap	access:private
indexTraits_	.\EvictingCacheMap.h	/^  typename NodeMap::bucket_traits indexTraits_;$/;"	m	class:folly::EvictingCacheMap	access:private
index_	.\EvictingCacheMap.h	/^  NodeMap index_;$/;"	m	class:folly::EvictingCacheMap	access:private
infinite	.\gen\Base-inl.h	/^    static constexpr bool infinite = Source::infinite;$/;"	m	class:folly::gen::detail::Batch::Generator	access:public
infinite	.\gen\Base-inl.h	/^    static constexpr bool infinite = Source::infinite;$/;"	m	class:folly::gen::detail::Concat::Generator	access:public
infinite	.\gen\Base-inl.h	/^    static constexpr bool infinite = Source::infinite;$/;"	m	class:folly::gen::detail::Cycle::Generator	access:public
infinite	.\gen\Base-inl.h	/^    static constexpr bool infinite = Source::infinite;$/;"	m	class:folly::gen::detail::Dereference::Generator	access:public
infinite	.\gen\Base-inl.h	/^    static constexpr bool infinite = Source::infinite;$/;"	m	class:folly::gen::detail::Filter::Generator	access:public
infinite	.\gen\Base-inl.h	/^    static constexpr bool infinite = Source::infinite;$/;"	m	class:folly::gen::detail::GuardImpl::Generator	access:public
infinite	.\gen\Base-inl.h	/^    static constexpr bool infinite = Source::infinite;$/;"	m	class:folly::gen::detail::Map::Generator	access:public
infinite	.\gen\Base-inl.h	/^    static constexpr bool infinite = Source::infinite;$/;"	m	class:folly::gen::detail::Skip::Generator	access:public
infinite	.\gen\Base-inl.h	/^  static constexpr bool infinite = false;$/;"	m	class:folly::gen::detail::Until	access:public
infinite	.\gen\Core-inl.h	/^  static constexpr bool infinite = First::infinite || Second::infinite;$/;"	m	class:folly::gen::detail::Chain	access:public
infinite	.\gen\Core-inl.h	/^  static constexpr bool infinite = false;$/;"	m	class:folly::gen::GenImpl	access:public
infinite	.\gen\File-inl.h	/^  static constexpr bool infinite = false;$/;"	m	class:folly::gen::detail::FileReader	access:public
infinite	.\gen\ParallelMap-inl.h	/^    static constexpr bool infinite = Source::infinite;$/;"	m	class:folly::gen::detail::PMap::Generator	access:public
infinite	.\gen\String-inl.h	/^    static constexpr bool infinite = Source::infinite;$/;"	m	class:folly::gen::detail::StringResplitter::Generator	access:public
info	.\SocketAddress.cpp	/^  struct addrinfo* info;$/;"	m	struct:__anon90::ScopedAddrInfo	typeref:struct:__anon90::ScopedAddrInfo::addrinfo	file:	access:public
info_	.\experimental\symbolizer\Dwarf.h	/^  folly::StringPiece info_;       \/\/ .debug_info$/;"	m	class:folly::symbolizer::Dwarf	access:private
init	.\ConcurrentSkipList.h	/^  void init() {$/;"	f	class:folly::ConcurrentSkipList::Skipper	access:public	signature:()
init	.\FBVector.h	/^    void init(size_type n) {$/;"	f	struct:folly::fbvector::Impl	access:public	signature:(size_type n)
init	.\LifoSem.h	/^  void init(Args&&... args) {$/;"	f	struct:folly::detail::LifoSemNode	access:public	signature:(Args&&.... args)
init	.\MemoryMapping.cpp	/^void MemoryMapping::init(off_t offset, off_t length) {$/;"	f	class:folly::MemoryMapping	signature:(off_t offset, off_t length)
init	.\MemoryMapping.h	/^  void init(off_t offset, off_t length);$/;"	p	class:folly::MemoryMapping	access:private	signature:(off_t offset, off_t length)
init	.\PackedSyncPtr.h	/^  void init(T* initialPtr = 0, uint16_t initialExtra = 0) {$/;"	f	class:folly::PackedSyncPtr	access:public	signature:(T* initialPtr = 0, uint16_t initialExtra = 0)
init	.\SmallLocks.h	/^  void init() {$/;"	f	struct:folly::MicroSpinLock	access:public	signature:()
init	.\SmallLocks.h	/^  void init(IntType initialValue = 0) {$/;"	f	struct:folly::PicoSpinLock	access:public	signature:(IntType initialValue = 0)
init	.\SocketAddress.h	/^    void init() {$/;"	f	struct:folly::SocketAddress::ExternalUnixAddr	access:public	signature:()
init	.\SocketAddress.h	/^    void init(const ExternalUnixAddr &other) {$/;"	f	struct:folly::SocketAddress::ExternalUnixAddr	access:public	signature:(const ExternalUnixAddr &other)
init	.\experimental\io\AsyncIO.cpp	/^void AsyncIOOp::init() {$/;"	f	class:folly::AsyncIOOp	signature:()
init	.\experimental\io\AsyncIO.h	/^  void init();$/;"	p	class:folly::AsyncIOOp	access:private	signature:()
init	.\experimental\symbolizer\Dwarf.cpp	/^void Dwarf::LineNumberVM::init() {$/;"	f	class:folly::symbolizer::Dwarf::LineNumberVM	signature:()
init	.\experimental\symbolizer\Dwarf.cpp	/^void Dwarf::init() {$/;"	f	class:folly::symbolizer::Dwarf	signature:()
init	.\experimental\symbolizer\Dwarf.h	/^    void init();$/;"	p	class:folly::symbolizer::Dwarf::LineNumberVM	access:private	signature:()
init	.\experimental\symbolizer\Dwarf.h	/^  void init();$/;"	p	class:folly::symbolizer::Dwarf	access:private	signature:()
init	.\experimental\symbolizer\Elf.cpp	/^bool ElfFile::init(const char** msg) {$/;"	f	class:folly::symbolizer::ElfFile	signature:(const char** msg)
init	.\experimental\symbolizer\Elf.h	/^  bool init(const char** msg);$/;"	p	class:folly::symbolizer::ElfFile	access:private	signature:(const char** msg)
init	.\experimental\test\EliasFanoCodingTest.cpp	/^void init() {$/;"	f	namespace:bm	signature:()
init	.\io\async\NotificationQueue.h	/^    void init(EventBase* eventBase, NotificationQueue* queue);$/;"	p	class:folly::NotificationQueue::Consumer	access:private	signature:(EventBase* eventBase, NotificationQueue* queue)
init	.\io\async\NotificationQueue.h	/^void NotificationQueue<MessageT>::Consumer::init($/;"	f	class:folly::NotificationQueue::Consumer	signature:( EventBase* eventBase, NotificationQueue* queue)
initBenchmark	.\test\StringTest.cpp	/^void initBenchmark() {$/;"	f	namespace:__anon136	signature:()
initData	.\test\ConcurrentSkipListBenchmark.cpp	/^static void initData() {$/;"	f	namespace:__anon113	signature:()
initDelims	.\test\RangeFindBenchmark.cpp	/^void initDelims(int len) {$/;"	f	namespace:__anon129	signature:(int len)
initExtBuffer	.\io\IOBuf.cpp	/^void IOBuf::initExtBuffer(uint8_t* buf, size_t mallocSize,$/;"	f	class:folly::IOBuf	signature:(uint8_t* buf, size_t mallocSize, SharedInfo** infoReturn, uint64_t* capacityReturn)
initExtBuffer	.\io\IOBuf.h	/^  static void initExtBuffer(uint8_t* buf, size_t mallocSize,$/;"	p	class:folly::IOBuf	access:private	signature:(uint8_t* buf, size_t mallocSize, SharedInfo** infoReturn, uint64_t* capacityReturn)
initHandler	.\io\async\EventHandler.cpp	/^void EventHandler::initHandler(EventBase* eventBase, int fd) {$/;"	f	class:folly::EventHandler	signature:(EventBase* eventBase, int fd)
initHandler	.\io\async\EventHandler.h	/^  void initHandler(EventBase* eventBase, int fd);$/;"	p	class:folly::EventHandler	access:public	signature:(EventBase* eventBase, int fd)
initLocal	.\Random.cpp	/^ThreadLocalPRNG::LocalInstancePRNG* ThreadLocalPRNG::initLocal() {$/;"	f	class:folly::ThreadLocalPRNG	signature:()
initLocal	.\Random.h	/^  static LocalInstancePRNG* initLocal();$/;"	p	class:folly::ThreadLocalPRNG	access:private	signature:()
initLookupTable	.\ConcurrentSkipList-inl.h	/^  void initLookupTable() {$/;"	f	class:folly::detail::SkipListRandomHeight	access:private	signature:()
initMutex_	.\experimental\io\AsyncIO.h	/^  std::mutex initMutex_;$/;"	m	class:folly::AsyncIO	access:private
initNotificationQueue	.\io\async\EventBase.cpp	/^void EventBase::initNotificationQueue() {$/;"	f	class:folly::EventBase	signature:()
initNotificationQueue	.\io\async\EventBase.h	/^  void initNotificationQueue();$/;"	p	class:folly::EventBase	access:private	signature:()
initRNG	.\test\FBStringTestBenchmarks.cpp.h	/^void BENCHFUN(initRNG)(int iters, int) {$/;"	f	signature:(int iters, int)
initSlow	.\Format.cpp	/^void FormatArg::initSlow() {$/;"	f	class:folly::FormatArg	signature:()
initSlow	.\FormatArg.h	/^  void initSlow();$/;"	p	struct:folly::FormatArg	access:private	signature:()
initStr	.\test\RangeFindBenchmark.cpp	/^void initStr(int len) {$/;"	f	namespace:__anon129	signature:(int len)
initStringResplitterBenchmark	.\gen\test\StringBenchmark.cpp	/^void initStringResplitterBenchmark() {$/;"	f	namespace:__anon58	signature:()
initialize	.\experimental\exception_tracer\ExceptionTracerLib.cpp	/^void initialize() {$/;"	f	namespace:__anon25	signature:()
initializeContext	.\experimental\io\AsyncIO.cpp	/^void AsyncIO::initializeContext() {$/;"	f	class:folly::AsyncIO	signature:()
initializeContext	.\experimental\io\AsyncIO.h	/^  void initializeContext();$/;"	p	class:folly::AsyncIO	access:private	signature:()
initialized	.\experimental\exception_tracer\ExceptionTracerLib.cpp	/^pthread_once_t initialized = PTHREAD_ONCE_INIT;$/;"	m	namespace:__anon25	file:
initializer	.\Subprocess.cpp	/^Initializer initializer;$/;"	m	namespace:folly::__anon100	file:
initializer	.\experimental\exception_tracer\ExceptionTracerLib.cpp	/^Initializer initializer;$/;"	m	namespace:__anon27	file:
initializer	.\io\test\IOBufQueueTest.cpp	/^Initializer initializer;$/;"	m	namespace:__anon70	file:
initiateGracefulShutdown	.\experimental\wangle\ConnectionManager.cpp	/^ConnectionManager::initiateGracefulShutdown($/;"	f	class:folly::wangle::ConnectionManager	signature:( std::chrono::milliseconds idleGrace)
initiateGracefulShutdown	.\experimental\wangle\ConnectionManager.h	/^  void initiateGracefulShutdown(std::chrono::milliseconds idleGrace);$/;"	p	class:folly::wangle::ConnectionManager	access:public	signature:(std::chrono::milliseconds idleGrace)
inlineExecutor	.\wangle\test\LaterTest.cpp	/^  InlineExecutor inlineExecutor;$/;"	m	struct:LaterFixture	file:	access:public
innerGet	.\experimental\Bits.h	/^  static UnderlyingType innerGet(const T* p, size_t bitStart, size_t count);$/;"	p	struct:folly::Bits	access:private	signature:(const T* p, size_t bitStart, size_t count)
innerSet	.\experimental\Bits.h	/^  static void innerSet(T* p, size_t bitStart, size_t count,$/;"	p	struct:folly::Bits	access:private	signature:(T* p, size_t bitStart, size_t count, UnderlyingType value)
innerSet	.\experimental\Bits.h	/^inline void Bits<T, Traits>::innerSet(T* p, size_t offset, size_t count,$/;"	f	class:folly::Bits	signature:(T* p, size_t offset, size_t count, UnderlyingType value)
innerSignalHandler	.\experimental\symbolizer\SignalHandler.cpp	/^void innerSignalHandler(int signum, siginfo_t* info, void* uctx) {$/;"	f	namespace:folly::symbolizer::__anon36	signature:(int signum, siginfo_t* info, void* uctx)
inner_	.\experimental\EliasFanoCoding.h	/^  size_t inner_;  \/\/ Inner offset: (bit) position in current block.$/;"	m	class:folly::compression::detail::UpperBitsReader	access:private
insert	.\AtomicHashArray.h	/^  std::pair<iterator,bool> insert(const value_type& r) {$/;"	f	class:folly::AtomicHashArray	access:public	signature:(const value_type& r)
insert	.\AtomicHashArray.h	/^  std::pair<iterator,bool> insert(value_type&& r) {$/;"	f	class:folly::AtomicHashArray	access:public	signature:(value_type&& r)
insert	.\AtomicHashMap-inl.h	/^insert(key_type k, const mapped_type& v) {$/;"	f	class:folly::AtomicHashMap	signature:(key_type k, const mapped_type& v)
insert	.\AtomicHashMap-inl.h	/^insert(key_type k, mapped_type&& v) {$/;"	f	class:folly::AtomicHashMap	signature:(key_type k, mapped_type&& v)
insert	.\AtomicHashMap.h	/^  std::pair<iterator,bool> insert(const value_type& r) {$/;"	f	class:folly::AtomicHashMap	access:public	signature:(const value_type& r)
insert	.\AtomicHashMap.h	/^  std::pair<iterator,bool> insert(key_type k, const mapped_type& v);$/;"	p	class:folly::AtomicHashMap	access:public	signature:(key_type k, const mapped_type& v)
insert	.\AtomicHashMap.h	/^  std::pair<iterator,bool> insert(key_type k, mapped_type&& v);$/;"	p	class:folly::AtomicHashMap	access:public	signature:(key_type k, mapped_type&& v)
insert	.\AtomicHashMap.h	/^  std::pair<iterator,bool> insert(value_type&& r) {$/;"	f	class:folly::AtomicHashMap	access:public	signature:(value_type&& r)
insert	.\ConcurrentSkipList.h	/^  std::pair<iterator, bool> insert(U&& data) {$/;"	f	class:folly::ConcurrentSkipList::Accessor	access:public	signature:(U&& data)
insert	.\FBVector.h	/^  iterator insert(const_iterator cpos, FIt first, FIt last,$/;"	f	signature:(const_iterator cpos, FIt first, FIt last, std::forward_iterator_tag)
insert	.\FBVector.h	/^  iterator insert(const_iterator cpos, IIt first, IIt last,$/;"	f	signature:(const_iterator cpos, IIt first, IIt last, std::input_iterator_tag)
insert	.\FBVector.h	/^  iterator insert(const_iterator cpos, It first, It last) {$/;"	f	signature:(const_iterator cpos, It first, It last)
insert	.\FBVector.h	/^  iterator insert(const_iterator cpos, T&& value) {$/;"	f	signature:(const_iterator cpos, T&& value)
insert	.\FBVector.h	/^  iterator insert(const_iterator cpos, const T& value) {$/;"	f	signature:(const_iterator cpos, const T& value)
insert	.\FBVector.h	/^  iterator insert(const_iterator cpos, size_type n, VT value) {$/;"	f	signature:(const_iterator cpos, size_type n, VT value)
insert	.\FBVector.h	/^  iterator insert(const_iterator cpos, std::initializer_list<T> il) {$/;"	f	signature:(const_iterator cpos, std::initializer_list<T> il)
insert	.\dynamic-inl.h	/^template<class K, class V> inline void dynamic::insert(K&& key, V&& val) {$/;"	f	class:folly::dynamic	signature:(K&& key, V&& val)
insert	.\dynamic.h	/^  template<class K, class V> void insert(K&&, V&& val);$/;"	p	struct:folly::dynamic	access:public	signature:(K&&, V&& val)
insert	.\io\Cursor.h	/^  void insert(std::unique_ptr<folly::IOBuf> buf) {$/;"	f	class:folly::io::QueueAppender	access:public	signature:(std::unique_ptr<folly::IOBuf> buf)
insert	.\io\Cursor.h	/^  void insert(std::unique_ptr<folly::IOBuf> buf) {$/;"	f	class:folly::io::RWCursor	access:public	signature:(std::unique_ptr<folly::IOBuf> buf)
insert	.\small_vector.h	/^  iterator insert(const_iterator constp, value_type&& t) {$/;"	f	class:folly::small_vector	access:public	signature:(const_iterator constp, value_type&& t)
insert	.\small_vector.h	/^  iterator insert(const_iterator p, Arg arg1, Arg arg2) {$/;"	f	class:folly::small_vector	access:public	signature:(const_iterator p, Arg arg1, Arg arg2)
insert	.\small_vector.h	/^  iterator insert(const_iterator p, std::initializer_list<value_type> il) {$/;"	f	class:folly::small_vector	access:public	signature:(const_iterator p, std::initializer_list<value_type> il)
insert	.\small_vector.h	/^  iterator insert(const_iterator p, value_type const& t) {$/;"	f	class:folly::small_vector	access:public	signature:(const_iterator p, value_type const& t)
insert	.\small_vector.h	/^  iterator insert(const_iterator pos, size_type n, value_type const& val) {$/;"	f	class:folly::small_vector	access:public	signature:(const_iterator pos, size_type n, value_type const& val)
insert	.\sorted_vector_types.h	/^  iterator insert(iterator hint, const value_type& value) {$/;"	f	class:folly::sorted_vector_map	access:public	signature:(iterator hint, const value_type& value)
insert	.\sorted_vector_types.h	/^  iterator insert(iterator hint, const value_type& value) {$/;"	f	class:folly::sorted_vector_set	access:public	signature:(iterator hint, const value_type& value)
insert	.\sorted_vector_types.h	/^  iterator insert(iterator hint, value_type&& value) {$/;"	f	class:folly::sorted_vector_map	access:public	signature:(iterator hint, value_type&& value)
insert	.\sorted_vector_types.h	/^  iterator insert(iterator hint, value_type&& value) {$/;"	f	class:folly::sorted_vector_set	access:public	signature:(iterator hint, value_type&& value)
insert	.\sorted_vector_types.h	/^  std::pair<iterator,bool> insert(const value_type& value) {$/;"	f	class:folly::sorted_vector_map	access:public	signature:(const value_type& value)
insert	.\sorted_vector_types.h	/^  std::pair<iterator,bool> insert(const value_type& value) {$/;"	f	class:folly::sorted_vector_set	access:public	signature:(const value_type& value)
insert	.\sorted_vector_types.h	/^  std::pair<iterator,bool> insert(value_type&& value) {$/;"	f	class:folly::sorted_vector_map	access:public	signature:(value_type&& value)
insert	.\sorted_vector_types.h	/^  std::pair<iterator,bool> insert(value_type&& value) {$/;"	f	class:folly::sorted_vector_set	access:public	signature:(value_type&& value)
insert	.\sorted_vector_types.h	/^  void insert(InputIterator first, InputIterator last) {$/;"	f	class:folly::sorted_vector_map	access:public	signature:(InputIterator first, InputIterator last)
insert	.\sorted_vector_types.h	/^  void insert(InputIterator first, InputIterator last) {$/;"	f	class:folly::sorted_vector_set	access:public	signature:(InputIterator first, InputIterator last)
insert	.\test\FBVectorTestBenchmarks.cpp.h	/^void BENCHFUN(insert)(int iters, int size) {$/;"	f	signature:(int iters, int size)
insertImpl	.\small_vector.h	/^  iterator insertImpl(iterator pos, It first, It last, std::false_type) {$/;"	f	class:folly::small_vector	access:private	signature:(iterator pos, It first, It last, std::false_type)
insertImpl	.\small_vector.h	/^  iterator insertImpl(iterator pos, size_type n, const value_type& val,$/;"	f	class:folly::small_vector	access:private	signature:(iterator pos, size_type n, const value_type& val, std::true_type)
insertInternal	.\AtomicHashArray-inl.h	/^insertInternal(KeyT key_in, T&& value) {$/;"	f	class:folly::AtomicHashArray	signature:(KeyT key_in, T&& value)
insertInternal	.\AtomicHashArray.h	/^  SimpleRetT insertInternal(KeyT key, T&& value);$/;"	p	class:folly::AtomicHashArray	access:private	signature:(KeyT key, T&& value)
insertInternal	.\AtomicHashMap-inl.h	/^insertInternal(key_type key, T&& value) {$/;"	f	class:folly::AtomicHashMap	signature:(key_type key, T&& value)
insertInternal	.\AtomicHashMap.h	/^  SimpleRetT insertInternal(KeyT key, T&& value);$/;"	p	class:folly::AtomicHashMap	access:private	signature:(KeyT key, T&& value)
insertItCheck	.\test\stl_tests\StlVectorTest.cpp	/^void insertItCheck(const Vector& a, DataState<Vector>& dsa,$/;"	f	signature:(const Vector& a, DataState<Vector>& dsa, int idx, int* b, int* e)
insertNTCheck	.\test\stl_tests\StlVectorTest.cpp	/^void insertNTCheck(const Vector& a, DataState<Vector>& dsa,$/;"	f	signature:(const Vector& a, DataState<Vector>& dsa, int idx, int n, int val)
insertThread	.\test\AtomicHashMapTest.cpp	/^void* insertThread(void* jj) {$/;"	f	namespace:__anon105	signature:(void* jj)
insertThreadArr	.\test\AtomicHashMapTest.cpp	/^void* insertThreadArr(void* jj) {$/;"	f	namespace:__anon105	signature:(void* jj)
insert_use_fresh	.\FBVector.h	/^  bool insert_use_fresh(const_iterator cposition, size_type n) {$/;"	f	signature:(const_iterator cposition, size_type n)
insert_with_hint	.\sorted_vector_types.h	/^  insert_with_hint(OurContainer& sorted,$/;"	f	namespace:folly::detail	signature:(OurContainer& sorted, Vector& cont, typename OurContainer::iterator hint, typename OurContainer::value_type&& value, GrowthPolicy& po)
insertedLevel	.\test\AtomicHashMapTest.cpp	/^std::atomic<int32_t> insertedLevel;$/;"	m	namespace:__anon107	file:
inst_	.\detail\ThreadLocalDetail.h	/^  static StaticMeta<Tag>* inst_;$/;"	m	struct:folly::threadlocal_detail::StaticMeta	access:public
inst_	.\detail\ThreadLocalDetail.h	/^template <class Tag> StaticMeta<Tag>* StaticMeta<Tag>::inst_ = nullptr;$/;"	m	class:folly::threadlocal_detail::StaticMeta
installFatalSignalCallbacks	.\experimental\symbolizer\SignalHandler.cpp	/^void installFatalSignalCallbacks() {$/;"	f	namespace:folly::symbolizer	signature:()
installFatalSignalCallbacks	.\experimental\symbolizer\SignalHandler.h	/^void installFatalSignalCallbacks();$/;"	p	namespace:folly::symbolizer	signature:()
installFatalSignalHandler	.\experimental\symbolizer\SignalHandler.cpp	/^void installFatalSignalHandler() {$/;"	f	namespace:folly::symbolizer	signature:()
installFatalSignalHandler	.\experimental\symbolizer\SignalHandler.h	/^void installFatalSignalHandler();$/;"	p	namespace:folly::symbolizer	signature:()
installHandlers	.\experimental\exception_tracer\ExceptionTracer.cpp	/^void installHandlers() {$/;"	f	namespace:folly::exception_tracer	signature:()
installHandlers	.\experimental\exception_tracer\ExceptionTracer.h	/^void installHandlers();$/;"	p	namespace:folly::exception_tracer	signature:()
installed_	.\experimental\symbolizer\SignalHandler.cpp	/^  std::atomic<bool> installed_;$/;"	m	class:folly::symbolizer::__anon36::FatalSignalCallbackRegistry	file:	access:private
instance	.\ConcurrentSkipList-inl.h	/^  static SkipListRandomHeight *instance() {$/;"	f	class:folly::detail::SkipListRandomHeight	access:public	signature:()
instance	.\detail\ThreadLocalDetail.h	/^  static StaticMeta<Tag>& instance() {$/;"	f	struct:folly::threadlocal_detail::StaticMeta	access:public	signature:()
instance	.\experimental\Singleton.h	/^    std::shared_ptr<void> instance;$/;"	m	struct:folly::SingletonVault::SingletonEntry	access:public
instance_ptr	.\experimental\Singleton.h	/^    void* instance_ptr = nullptr;$/;"	m	struct:folly::SingletonVault::SingletonEntry	access:public
instructions	.\experimental\EliasFanoCoding.h	/^namespace instructions {$/;"	n	namespace:folly::compression
integer	.\dynamic.h	/^    int64_t integer;$/;"	m	union:folly::dynamic::Data	access:public
interleave	.\gen\Combine.h	/^Interleave interleave(Source2&& source2) {$/;"	f	namespace:folly::gen	signature:(Source2&& source2)
internalDoNotUse	.\Synchronized.h	/^  ConstLockedPtr internalDoNotUse() const {$/;"	f	struct:folly::Synchronized	access:public	signature:() const
internalDoNotUse	.\Synchronized.h	/^  LockedPtr internalDoNotUse() {$/;"	f	struct:folly::Synchronized	access:public	signature:()
internalJoin	.\String-inl.h	/^internalJoin(Delim delimiter,$/;"	f	namespace:folly::detail	signature:(Delim delimiter, Iterator begin, Iterator end, String& output)
internalJoinAppend	.\String-inl.h	/^void internalJoinAppend(Delim delimiter,$/;"	f	namespace:folly::detail	signature:(Delim delimiter, Iterator begin, Iterator end, String& output)
internalSplit	.\String-inl.h	/^void internalSplit(DelimT delim, StringPiece sp, OutputIterator out,$/;"	f	namespace:folly::detail	signature:(DelimT delim, StringPiece sp, OutputIterator out, bool ignoreEmpty)
interval_	.\io\async\HHWheelTimer.h	/^  std::chrono::milliseconds interval_;$/;"	m	class:folly::HHWheelTimer	access:private
intrusive_ptr	.\test\MPMCQueueTest.cpp	/^FOLLY_ASSUME_FBVECTOR_COMPATIBLE_1(boost::intrusive_ptr);$/;"	v
intrusive_ptr_add_ref	.\test\MPMCQueueTest.cpp	/^void intrusive_ptr_add_ref(RefCounted const* p) {$/;"	f	signature:(RefCounted const* p)
intrusive_ptr_release	.\test\MPMCQueueTest.cpp	/^void intrusive_ptr_release(RefCounted const* p) {$/;"	f	signature:(RefCounted const* p)
ints_	.\test\ThreadCachedIntTest.cpp	/^  std::atomic<int64_t> ints_[kBuckets_];$/;"	m	struct:ShardedAtomicInt	file:	access:public
invalid	.\experimental\exception_tracer\ExceptionTracerLib.cpp	/^FOLLY_TLS bool invalid;$/;"	m	namespace:__anon25	file:
invalidAddressProvider	.\test\IPAddressTest.cpp	/^static vector<string> invalidAddressProvider = {$/;"	v	file:
invalidBinaryProvider	.\test\IPAddressTest.cpp	/^static vector<ByteVector> invalidBinaryProvider = {$/;"	v	file:
invalidMasks	.\test\IPAddressTest.cpp	/^static vector<pair<string, uint8_t> > invalidMasks = {$/;"	v	file:
io	.\io\Compression.cpp	/^namespace folly { namespace io {$/;"	n	namespace:folly	file:
io	.\io\Compression.h	/^namespace folly { namespace io {$/;"	n	namespace:folly
io	.\io\Cursor.h	/^namespace folly { namespace io {$/;"	n	namespace:folly
io	.\io\test\CompressionTest.cpp	/^namespace folly { namespace io { namespace test {$/;"	n	namespace:folly	file:
ioBuf	.\io\TypedIOBuf.h	/^  IOBuf* ioBuf() {$/;"	f	class:folly::TypedIOBuf	access:public	signature:()
ioBuf	.\io\TypedIOBuf.h	/^  const IOBuf* ioBuf() const {$/;"	f	class:folly::TypedIOBuf	access:public	signature:() const
iobuf_benchmark	.\io\test\IOBufCursorTest.cpp	/^unique_ptr<IOBuf> iobuf_benchmark;$/;"	v
iobuf_read_benchmark	.\io\test\IOBufCursorTest.cpp	/^unique_ptr<IOBuf> iobuf_read_benchmark;$/;"	v
iobufs	.\io\test\RecordIOTest.cpp	/^std::unique_ptr<IOBuf> iobufs(std::initializer_list<T> ranges) {$/;"	f	namespace:folly::test::__anon73	signature:(std::initializer_list<T> ranges)
iocbCmdToString	.\experimental\io\AsyncIO.cpp	/^const char* iocbCmdToString(short int cmd_short) {$/;"	f	namespace:folly::__anon28	signature:(short int cmd_short)
iocb_	.\experimental\io\AsyncIO.h	/^  iocb iocb_;$/;"	m	class:folly::AsyncIOOp	access:private
iov	.\test\FileUtilTest.cpp	/^  std::vector<iovec> iov() const { return iov_; }  \/\/ yes, make a copy$/;"	f	class:folly::test::IovecBuffers	access:public	signature:() const
iov_	.\test\FileUtilTest.cpp	/^  std::vector<iovec> iov_;$/;"	m	class:folly::test::IovecBuffers	file:	access:private
ipV4Addr	.\IPAddress.h	/^    IPAddressV4 ipV4Addr;$/;"	m	union:folly::IPAddress::IPAddressV46	access:public
ipV6Addr	.\IPAddress.h	/^    IPAddressV6 ipV6Addr;$/;"	m	union:folly::IPAddress::IPAddressV46	access:public
is64Bit	.\experimental\symbolizer\Dwarf.h	/^    bool is64Bit() const { return is64Bit_; }$/;"	f	class:folly::symbolizer::Dwarf::Section	access:public	signature:() const
is64Bit_	.\experimental\symbolizer\Dwarf.h	/^    bool is64Bit_;$/;"	m	class:folly::symbolizer::Dwarf::LineNumberVM	access:private
is64Bit_	.\experimental\symbolizer\Dwarf.h	/^    bool is64Bit_;$/;"	m	class:folly::symbolizer::Dwarf::Section	access:private
is6To4	.\IPAddressV6.h	/^  bool is6To4() const {$/;"	f	class:folly::IPAddressV6	access:public	signature:() const
isAbiCppException	.\experimental\exception_tracer\ExceptionTracer.cpp	/^bool isAbiCppException(const __cxa_exception* exc) {$/;"	f	namespace:folly::exception_tracer::__anon23	signature:(const __cxa_exception* exc)
isAligned	.\Arena.h	/^  bool isAligned(uintptr_t address) const {$/;"	f	class:folly::Arena	access:private	signature:(uintptr_t address) const
isAligned	.\Arena.h	/^  bool isAligned(void* p) const {$/;"	f	class:folly::Arena	access:private	signature:(void* p) const
isAllTime	.\stats\BucketedTimeSeries.h	/^  bool isAllTime() const {$/;"	f	class:folly::BucketedTimeSeries	access:public	signature:() const
isAllocated	.\IndexedMemPool.h	/^  bool isAllocated(uint32_t idx) const {$/;"	f	struct:folly::IndexedMemPool	access:public	signature:(uint32_t idx) const
isArray	.\dynamic-inl.h	/^inline bool dynamic::isArray()  const { return get_nothrow<Array>(); }$/;"	f	class:folly::dynamic	signature:() const
isArray	.\dynamic.h	/^  bool isArray() const;$/;"	p	struct:folly::dynamic	access:public	signature:() const
isBool	.\dynamic-inl.h	/^inline bool dynamic::isBool()   const { return get_nothrow<bool>(); }$/;"	f	class:folly::dynamic	signature:() const
isBool	.\dynamic.h	/^  bool isBool() const;$/;"	p	struct:folly::dynamic	access:public	signature:() const
isBroadcast	.\MacAddress.h	/^  bool isBroadcast() const {$/;"	f	class:folly::MacAddress	access:public	signature:() const
isBusy	.\experimental\wangle\ManagedConnection.h	/^  virtual bool isBusy() const = 0;$/;"	p	class:folly::wangle::ManagedConnection	access:public	signature:() const
isChained	.\io\IOBuf.h	/^  bool isChained() const {$/;"	f	class:folly::IOBuf	access:public	signature:() const
isDouble	.\dynamic-inl.h	/^inline bool dynamic::isDouble() const { return get_nothrow<double>(); }$/;"	f	class:folly::dynamic	signature:() const
isDouble	.\dynamic.h	/^  bool isDouble() const;$/;"	p	struct:folly::dynamic	access:public	signature:() const
isEmpty	.\ProducerConsumerQueue.h	/^  bool isEmpty() const {$/;"	f	struct:folly::ProducerConsumerQueue	access:public	signature:() const
isEnd	.\AtomicHashMap-inl.h	/^  bool isEnd() const { return ahm_ == nullptr; }$/;"	f	struct:folly::AtomicHashMap::ahm_iterator	access:private	signature:() const
isEventRegistered	.\io\async\EventUtil.h	/^  static bool isEventRegistered(const struct event* ev) {$/;"	f	class:folly::EventUtil	access:public	signature:(const struct event* ev)
isExtern	.\small_vector.h	/^    std::size_t isExtern() const {$/;"	f	struct:folly::detail::IntegralSizePolicy	access:protected	signature:() const
isFull	.\ProducerConsumerQueue.h	/^  bool isFull() const {$/;"	f	struct:folly::ProducerConsumerQueue	access:public	signature:() const
isFull_	.\AtomicHashArray.h	/^  std::atomic<int64_t> isFull_; \/\/ Used by insertInternal$/;"	m	class:folly::AtomicHashArray	access:private
isFuture	.\wangle\Future-inl.h	/^struct isFuture {$/;"	s	namespace:folly::wangle
isFuture	.\wangle\Future-inl.h	/^struct isFuture<Future<T> > {$/;"	s	namespace:folly::wangle
isFuture	.\wangle\Future.h	/^template <typename T> struct isFuture;$/;"	x
isHandlerRegistered	.\io\async\EventHandler.h	/^  bool isHandlerRegistered() const {$/;"	f	class:folly::EventHandler	access:public	signature:() const
isHeadNode	.\ConcurrentSkipList-inl.h	/^  bool isHeadNode() const       { return getFlags() & IS_HEAD_NODE; }$/;"	f	class:folly::detail::SkipListNode	access:public	signature:() const
isHex	.\test\StringTest.cpp	/^bool isHex(int v) {$/;"	f	namespace:__anon135	signature:(int v)
isIPv4Mapped	.\IPAddress.h	/^  bool isIPv4Mapped() const {$/;"	f	class:folly::IPAddress	access:public	signature:() const
isIPv4Mapped	.\IPAddressV6.cpp	/^bool IPAddressV6::isIPv4Mapped() const {$/;"	f	class:folly::IPAddressV6	signature:() const
isIPv4Mapped	.\IPAddressV6.h	/^  bool isIPv4Mapped() const;$/;"	p	class:folly::IPAddressV6	access:public	signature:() const
isIPv4Mapped	.\SocketAddress.h	/^  bool isIPv4Mapped() const {$/;"	f	class:folly::SocketAddress	access:public	signature:() const
isInEventBaseThread	.\io\async\EventBase.h	/^  bool isInEventBaseThread() const {$/;"	f	class:folly::EventBase	access:public	signature:() const
isInTimeoutManagerThread	.\io\async\EventBase.h	/^  bool isInTimeoutManagerThread() {$/;"	f	class:folly::EventBase	access:private	signature:()
isInTimeoutManagerThread	.\io\async\TimeoutManager.h	/^  virtual bool isInTimeoutManagerThread() = 0;$/;"	p	class:folly::TimeoutManager	access:public	signature:()
isInitialized	.\SocketAddress.h	/^  bool isInitialized() const {$/;"	f	class:folly::SocketAddress	access:public	signature:() const
isInt	.\dynamic-inl.h	/^inline bool dynamic::isInt()    const { return get_nothrow<int64_t>(); }$/;"	f	class:folly::dynamic	signature:() const
isInt	.\dynamic.h	/^  bool isInt() const;$/;"	p	struct:folly::dynamic	access:public	signature:() const
isJoin_	.\experimental\wangle\concurrent\ThreadPoolExecutor.h	/^  std::atomic<bool> isJoin_; \/\/ whether the current downsizing is a join$/;"	m	class:folly::wangle::ThreadPoolExecutor	access:protected
isLater	.\wangle\Later-inl.h	/^struct isLater {$/;"	s	namespace:folly::wangle
isLater	.\wangle\Later-inl.h	/^struct isLater<Later<T> > {$/;"	s	namespace:folly::wangle
isLater	.\wangle\Later.h	/^template <typename T> struct isLater;$/;"	x
isLaterOrFuture	.\wangle\Later-inl.h	/^struct isLaterOrFuture {$/;"	s	namespace:folly::wangle
isLaterOrFuture	.\wangle\Later-inl.h	/^struct isLaterOrFuture<Future<T>> {$/;"	s	namespace:folly::wangle
isLaterOrFuture	.\wangle\Later-inl.h	/^struct isLaterOrFuture<Later<T>> {$/;"	s	namespace:folly::wangle
isLaterOrFuture	.\wangle\Later.h	/^template <typename T> struct isLaterOrFuture;$/;"	x
isLinkLocal	.\IPAddressV6.cpp	/^bool IPAddressV6::isLinkLocal() const {$/;"	f	class:folly::IPAddressV6	signature:() const
isLinkLocal	.\IPAddressV6.h	/^  bool isLinkLocal() const;$/;"	p	class:folly::IPAddressV6	access:public	signature:() const
isLinkLocal	.\test\IPAddressTest.h	/^  bool isLinkLocal() const {$/;"	f	struct:folly::AddressFlags	access:public	signature:() const
isLinkLocalBroadcast	.\IPAddress.h	/^  bool isLinkLocalBroadcast() const {$/;"	f	class:folly::IPAddress	access:public	signature:() const
isLinkLocalBroadcast	.\IPAddressV4.h	/^  bool isLinkLocalBroadcast() const {$/;"	f	class:folly::IPAddressV4	access:public	signature:() const
isLinkLocalBroadcast	.\IPAddressV6.cpp	/^bool IPAddressV6::isLinkLocalBroadcast() const {$/;"	f	class:folly::IPAddressV6	signature:() const
isLinkLocalBroadcast	.\IPAddressV6.h	/^  bool isLinkLocalBroadcast() const;$/;"	p	class:folly::IPAddressV6	access:public	signature:() const
isLinkLocalBroadcast	.\test\IPAddressTest.h	/^  bool isLinkLocalBroadcast() const {$/;"	f	struct:folly::AddressFlags	access:public	signature:() const
isLocallyAdministered	.\MacAddress.h	/^  bool isLocallyAdministered() const {$/;"	f	class:folly::MacAddress	access:public	signature:() const
isLoopCallbackScheduled	.\io\async\EventBase.h	/^    bool isLoopCallbackScheduled() const {$/;"	f	class:folly::EventBase::LoopCallback	access:public	signature:() const
isLoopback	.\IPAddress.h	/^  bool isLoopback() const {$/;"	f	class:folly::IPAddress	access:public	signature:() const
isLoopback	.\IPAddressV4.cpp	/^bool IPAddressV4::isLoopback() const {$/;"	f	class:folly::IPAddressV4	signature:() const
isLoopback	.\IPAddressV4.h	/^  bool isLoopback() const;$/;"	p	class:folly::IPAddressV4	access:public	signature:() const
isLoopback	.\IPAddressV6.cpp	/^bool IPAddressV6::isLoopback() const {$/;"	f	class:folly::IPAddressV6	signature:() const
isLoopback	.\IPAddressV6.h	/^  bool isLoopback() const;$/;"	p	class:folly::IPAddressV6	access:public	signature:() const
isLoopback	.\test\IPAddressTest.h	/^  bool isLoopback() const {$/;"	f	struct:folly::AddressFlags	access:public	signature:() const
isLoopbackAddress	.\SocketAddress.cpp	/^bool SocketAddress::isLoopbackAddress() const {$/;"	f	class:folly::SocketAddress	signature:() const
isLoopbackAddress	.\SocketAddress.h	/^  bool isLoopbackAddress() const;$/;"	p	class:folly::SocketAddress	access:public	signature:() const
isMulticast	.\IPAddress.h	/^  bool isMulticast() const {$/;"	f	class:folly::IPAddress	access:public	signature:() const
isMulticast	.\IPAddressV4.cpp	/^bool IPAddressV4::isMulticast() const {$/;"	f	class:folly::IPAddressV4	signature:() const
isMulticast	.\IPAddressV4.h	/^  bool isMulticast() const;$/;"	p	class:folly::IPAddressV4	access:public	signature:() const
isMulticast	.\IPAddressV6.cpp	/^bool IPAddressV6::isMulticast() const {$/;"	f	class:folly::IPAddressV6	signature:() const
isMulticast	.\IPAddressV6.h	/^  bool isMulticast() const;$/;"	p	class:folly::IPAddressV6	access:public	signature:() const
isMulticast	.\MacAddress.h	/^  bool isMulticast() const {$/;"	f	class:folly::MacAddress	access:public	signature:() const
isNodeIdx	.\LifoSem.h	/^  inline constexpr bool isNodeIdx() const {$/;"	f	class:folly::detail::LifoSemHead	access:public	signature:() const
isNonroutable	.\IPAddress.h	/^  bool isNonroutable() const {$/;"	f	class:folly::IPAddress	access:public	signature:() const
isNonroutable	.\IPAddressV4.cpp	/^bool IPAddressV4::isNonroutable() const {$/;"	f	class:folly::IPAddressV4	signature:() const
isNonroutable	.\IPAddressV4.h	/^  bool isNonroutable() const;$/;"	p	class:folly::IPAddressV4	access:public	signature:() const
isNonroutable	.\IPAddressV6.h	/^  bool isNonroutable() const {$/;"	f	class:folly::IPAddressV6	access:public	signature:() const
isNonroutable	.\test\IPAddressTest.h	/^  bool isNonroutable() const {$/;"	f	struct:folly::AddressFlags	access:public	signature:() const
isNull	.\dynamic-inl.h	/^inline bool dynamic::isNull()   const { return get_nothrow<void*>(); }$/;"	f	class:folly::dynamic	signature:() const
isNull	.\dynamic.h	/^  bool isNull() const;$/;"	p	struct:folly::dynamic	access:public	signature:() const
isNumber	.\dynamic-inl.h	/^inline bool dynamic::isNumber() const { return isInt() || isDouble(); }$/;"	f	class:folly::dynamic	signature:() const
isNumber	.\dynamic.h	/^  bool isNumber() const;$/;"	p	struct:folly::dynamic	access:public	signature:() const
isObject	.\dynamic-inl.h	/^inline bool dynamic::isObject() const { return get_nothrow<ObjectImpl>(); }$/;"	f	class:folly::dynamic	signature:() const
isObject	.\dynamic.h	/^  bool isObject() const;$/;"	p	struct:folly::dynamic	access:public	signature:() const
isPending	.\io\async\EventHandler.cpp	/^bool EventHandler::isPending() const {$/;"	f	class:folly::EventHandler	signature:() const
isPending	.\io\async\EventHandler.h	/^  bool isPending() const;$/;"	p	class:folly::EventHandler	access:public	signature:() const
isPrime	.\gen\test\ParallelBenchmark.cpp	/^static auto isPrime = [](int n) {$/;"	v	file:
isPrime	.\gen\test\ParallelTest.cpp	/^static auto isPrime = [](int n) {$/;"	v	file:
isPrimeSlow	.\gen\test\ParallelBenchmark.cpp	/^static auto isPrimeSlow = [](int n) {$/;"	v	file:
isPrivate	.\IPAddress.h	/^  bool isPrivate() const {$/;"	f	class:folly::IPAddress	access:public	signature:() const
isPrivate	.\IPAddressV4.cpp	/^bool IPAddressV4::isPrivate() const {$/;"	f	class:folly::IPAddressV4	signature:() const
isPrivate	.\IPAddressV4.h	/^  bool isPrivate() const;$/;"	p	class:folly::IPAddressV4	access:public	signature:() const
isPrivate	.\IPAddressV6.cpp	/^bool IPAddressV6::isPrivate() const {$/;"	f	class:folly::IPAddressV6	signature:() const
isPrivate	.\IPAddressV6.h	/^  bool isPrivate() const;$/;"	p	class:folly::IPAddressV6	access:public	signature:() const
isPrivate	.\test\IPAddressTest.h	/^  bool isPrivate() const {$/;"	f	struct:folly::AddressFlags	access:public	signature:() const
isPrivateAddress	.\SocketAddress.cpp	/^bool SocketAddress::isPrivateAddress() const {$/;"	f	class:folly::SocketAddress	signature:() const
isPrivateAddress	.\SocketAddress.h	/^  bool isPrivateAddress() const;$/;"	p	class:folly::SocketAddress	access:public	signature:() const
isPropCopy	.\test\stl_tests\StlVectorTest.cpp	/^struct isPropCopy : true_type {};$/;"	s	file:	inherits:true_type
isPropCopy	.\test\stl_tests\StlVectorTest.cpp	/^struct isPropCopy<Data<f, pad>> :$/;"	s	file:	inherits:std::integral_constant
isPropMove	.\test\stl_tests\StlVectorTest.cpp	/^struct isPropMove : true_type {};$/;"	s	file:	inherits:true_type
isPropMove	.\test\stl_tests\StlVectorTest.cpp	/^struct isPropMove<Data<f, pad>> :$/;"	s	file:	inherits:std::integral_constant
isPropSwap	.\test\stl_tests\StlVectorTest.cpp	/^struct isPropSwap : true_type {};$/;"	s	file:	inherits:true_type
isPropSwap	.\test\stl_tests\StlVectorTest.cpp	/^struct isPropSwap<Data<f, pad>> :$/;"	s	file:	inherits:std::integral_constant
isReady	.\wangle\Future-inl.h	/^bool Future<T>::isReady() const {$/;"	f	class:folly::wangle::Future	signature:() const
isReady	.\wangle\Future.h	/^  bool isReady() const;$/;"	p	class:folly::wangle::Future	access:public	signature:() const
isRoutable	.\IPAddressV6.cpp	/^bool IPAddressV6::isRoutable() const {$/;"	f	class:folly::IPAddressV6	signature:() const
isRoutable	.\IPAddressV6.h	/^  bool isRoutable() const;$/;"	p	class:folly::IPAddressV6	access:public	signature:() const
isRunning	.\io\async\EventBase.h	/^  bool isRunning() const {$/;"	f	class:folly::EventBase	access:public	signature:() const
isSane	.\test\stl_tests\StlVectorTest.cpp	/^void isSane() {$/;"	f	signature:()
isScheduled	.\io\async\AsyncTimeout.cpp	/^bool AsyncTimeout::isScheduled() const {$/;"	f	class:folly::AsyncTimeout	signature:() const
isScheduled	.\io\async\AsyncTimeout.h	/^  bool isScheduled() const;$/;"	p	class:folly::AsyncTimeout	access:public	signature:() const
isScheduled	.\io\async\HHWheelTimer.h	/^    bool isScheduled() const {$/;"	f	class:folly::HHWheelTimer::Callback	access:public	signature:() const
isShared	.\io\IOBuf.h	/^  bool isShared() const {$/;"	f	class:folly::IOBuf	access:public	signature:() const
isSharedOne	.\io\IOBuf.h	/^  bool isSharedOne() const {$/;"	f	class:folly::IOBuf	access:public	signature:() const
isShutdown	.\LifoSem.h	/^  bool isShutdown() const {$/;"	f	struct:folly::detail::LifoSemBase	access:public	signature:() const
isShutdown	.\LifoSem.h	/^  inline constexpr bool isShutdown() const {$/;"	f	class:folly::detail::LifoSemHead	access:public	signature:() const
isShutdownNotice	.\LifoSem.h	/^  bool isShutdownNotice() const { return next == uint32_t(-1); }$/;"	f	struct:folly::detail::LifoSemRawNode	access:public	signature:() const
isSignalFrame	.\experimental\symbolizer\Symbolizer.h	/^  bool isSignalFrame;$/;"	m	struct:folly::symbolizer::SymbolizedFrame	access:public
isStmt_	.\experimental\symbolizer\Dwarf.h	/^    bool isStmt_;$/;"	m	class:folly::symbolizer::Dwarf::LineNumberVM	access:private
isString	.\dynamic-inl.h	/^inline bool dynamic::isString() const { return get_nothrow<fbstring>(); }$/;"	f	class:folly::dynamic	signature:() const
isString	.\dynamic.h	/^  bool isString() const;$/;"	p	struct:folly::dynamic	access:public	signature:() const
isTeredo	.\IPAddressV6.h	/^  bool isTeredo() const {$/;"	f	class:folly::IPAddressV6	access:public	signature:() const
isTty	.\experimental\symbolizer\Symbolizer.cpp	/^bool isTty(int options, int fd) {$/;"	f	namespace:folly::symbolizer::__anon43	signature:(int options, int fd)
isTty_	.\experimental\symbolizer\Symbolizer.h	/^  const bool isTty_;$/;"	m	class:folly::symbolizer::SymbolizePrinter	access:protected
isUnicast	.\MacAddress.h	/^  bool isUnicast() const {$/;"	f	class:folly::MacAddress	access:public	signature:() const
isV4	.\IPAddress.h	/^  bool isV4() const { return (family_ == AF_INET); }$/;"	f	class:folly::IPAddress	access:public	signature:() const
isV6	.\IPAddress.h	/^  bool isV6() const { return (family_ == AF_INET6); }$/;"	f	class:folly::IPAddress	access:public	signature:() const
isValid	.\AtomicHashArray-inl.h	/^  bool isValid() const {$/;"	f	struct:folly::AtomicHashArray::aha_iterator	access:private	signature:() const
isValid	.\FBVector.h	/^  bool isValid(const_iterator it) {$/;"	f	signature:(const_iterator it)
isZero	.\IPAddress.h	/^  bool isZero() const {$/;"	f	class:folly::IPAddress	access:public	signature:() const
isZero	.\IPAddressV4.h	/^  bool isZero() const {$/;"	f	class:folly::IPAddressV4	access:public	signature:() const
isZero	.\IPAddressV6.h	/^  bool isZero() const {$/;"	f	class:folly::IPAddressV6	access:public	signature:() const
isZero	.\detail\IPAddress.h	/^  static bool isZero(const uint8_t* src, std::size_t len) {$/;"	f	struct:folly::detail::Bytes	access:public	signature:(const uint8_t* src, std::size_t len)
isZero	.\test\IPAddressTest.h	/^  bool isZero() const {$/;"	f	struct:folly::AddressFlags	access:public	signature:() const
is_compatible_with	.\ExceptionWrapper.h	/^  bool is_compatible_with() const {$/;"	f	class:folly::exception_wrapper	access:public	signature:() const
is_complete	.\Traits.h	/^class is_complete {$/;"	c	namespace:folly
is_container	.\DynamicConverter.h	/^template <typename T> struct is_container$/;"	s	namespace:folly::dynamicconverter_detail	inherits:std::conditional::type
is_copy_constructibleAndAssignable	.\test\stl_tests\StlVectorTest.cpp	/^struct is_copy_constructibleAndAssignable$/;"	s	file:	inherits:std::integral_constant
is_map	.\DynamicConverter.h	/^template <typename T> struct is_map$/;"	s	namespace:folly::dynamicconverter_detail	inherits:std::integral_constant
is_move_constructibleAndAssignable	.\test\stl_tests\StlVectorTest.cpp	/^struct is_move_constructibleAndAssignable$/;"	s	file:	inherits:std::integral_constant
is_negative	.\Traits.h	/^constexpr bool is_negative(T x) {$/;"	f	namespace:folly	signature:(T x)
is_negative_impl	.\Traits.h	/^struct is_negative_impl {$/;"	s	namespace:folly::detail
is_negative_impl	.\Traits.h	/^struct is_negative_impl<T, false> {$/;"	s	namespace:folly::detail
is_non_negative	.\Traits.h	/^constexpr bool is_non_negative(T x) {$/;"	f	namespace:folly	signature:(T x)
is_non_positive	.\Traits.h	/^constexpr bool is_non_positive(T x) { return !x || folly::is_negative(x); }$/;"	f	namespace:folly	signature:(T x)
is_positive	.\Traits.h	/^constexpr bool is_positive(T x) { return !is_non_positive(x); }$/;"	f	namespace:folly	signature:(T x)
is_range	.\DynamicConverter.h	/^template <typename T> struct is_range$/;"	s	namespace:folly::dynamicconverter_detail	inherits:std::conditional::type
is_simple_allocator	.\Memory.h	/^class is_simple_allocator {$/;"	c	namespace:folly
isa_	.\experimental\symbolizer\Dwarf.h	/^    uint64_t isa_;$/;"	m	class:folly::symbolizer::Dwarf::LineNumberVM	access:private
item_	.\ExceptionWrapper.h	/^  std::shared_ptr<std::exception> item_;$/;"	m	class:folly::exception_wrapper	access:protected
items	.\dynamic-inl.h	/^inline dynamic::IterableProxy<dynamic::const_item_iterator> dynamic::items()$/;"	f	class:folly::dynamic	signature:() const
items	.\dynamic.h	/^  IterableProxy<const_item_iterator> items() const;$/;"	p	struct:folly::dynamic	access:public	signature:() const
iterSpotter	.\test\stl_tests\StlVectorTest.cpp	/^iterSpotter(Vector& v, int i) {$/;"	f	signature:(Vector& v, int i)
iterateSections	.\experimental\symbolizer\Elf-inl.h	/^const ElfW(Shdr)* ElfFile::iterateSections(Fn fn) const {$/;"	f	class:folly::symbolizer::ElfFile	signature:(Fn fn) const
iterateSections	.\experimental\symbolizer\Elf.h	/^  const ElfW(Shdr)* iterateSections(Fn fn) const;$/;"	p	class:folly::symbolizer::ElfFile	access:public	signature:(Fn fn) const
iterateSectionsWithType	.\experimental\symbolizer\Elf-inl.h	/^const ElfW(Shdr)* ElfFile::iterateSectionsWithType(uint32_t type, Fn fn)$/;"	f	class:folly::symbolizer::ElfFile	signature:(uint32_t type, Fn fn) const
iterateSectionsWithType	.\experimental\symbolizer\Elf.h	/^  const ElfW(Shdr)* iterateSectionsWithType(uint32_t type, Fn fn) const;$/;"	p	class:folly::symbolizer::ElfFile	access:public	signature:(uint32_t type, Fn fn) const
iterateTo	.\experimental\EliasFanoCoding.h	/^  void iterateTo(ValueType value) {$/;"	f	class:folly::compression::EliasFanoReader	access:private	signature:(ValueType value)
iterator	.\AtomicHashArray.h	/^  typedef aha_iterator<AtomicHashArray,value_type> iterator;$/;"	t	class:folly::AtomicHashArray	access:public
iterator	.\AtomicHashMap.h	/^    iterator;$/;"	t	class:folly::AtomicHashMap	access:public
iterator	.\ConcurrentSkipList.h	/^  typedef detail::csl_iterator<value_type, NodeType> iterator;$/;"	t	class:folly::ConcurrentSkipList	access:public
iterator	.\ConcurrentSkipList.h	/^  typedef typename SkipListType::iterator iterator;$/;"	t	class:folly::ConcurrentSkipList::Accessor	access:public
iterator	.\EvictingCacheMap.h	/^    TPair, typename NodeList::iterator> iterator;$/;"	t	class:folly::EvictingCacheMap	access:public
iterator	.\FBVector.h	/^  typedef T*                                          iterator;$/;"	t	class:folly::fbvector	access:public
iterator	.\Padded.h	/^  typedef Iterator<typename Container::iterator> iterator;$/;"	t	class:folly::Adaptor	access:public
iterator	.\Range.h	/^  typedef Iter iterator;$/;"	t	class:folly::Range	access:public
iterator	.\io\IOBuf.h	/^  typedef Iterator iterator;$/;"	t	class:folly::IOBuf	access:public
iterator	.\io\RecordIO.h	/^  typedef Iterator iterator;$/;"	t	class:folly::RecordIOReader	access:public
iterator	.\io\TypedIOBuf.h	/^  typedef value_type* iterator;$/;"	t	class:folly::TypedIOBuf	access:public
iterator	.\small_vector.h	/^  typedef value_type*        iterator;$/;"	t	class:folly::small_vector	access:public
iterator	.\sorted_vector_types.h	/^  typedef typename ContainerT::iterator               iterator;$/;"	t	class:folly::sorted_vector_map	access:public
iterator	.\sorted_vector_types.h	/^  typedef typename ContainerT::iterator               iterator;$/;"	t	class:folly::sorted_vector_set	access:public
iterator_base	.\EvictingCacheMap.h	/^    explicit iterator_base(TIterator it)$/;"	f	class:folly::EvictingCacheMap::iterator_base	access:public	signature:(TIterator it)
iterator_base	.\EvictingCacheMap.h	/^    iterator_base() {$/;"	f	class:folly::EvictingCacheMap::iterator_base	access:public	signature:()
iterator_base	.\EvictingCacheMap.h	/^  class iterator_base$/;"	c	class:folly::EvictingCacheMap	inherits:boost::iterator_adaptor	access:public
iters_	.\test\ProducerConsumerQueueBenchmark.cpp	/^  int iters_;$/;"	m	struct:__anon127::LatencyTest	file:	access:public
iters_	.\test\ProducerConsumerQueueBenchmark.cpp	/^  int iters_;$/;"	m	struct:__anon127::ThroughputTest	file:	access:public
j	.\AtomicHashMap.h	/^  struct SimpleRetT { uint32_t i; size_t j; bool success;$/;"	m	struct:folly::AtomicHashMap::SimpleRetT	access:public
javascript_safe	.\json.h	/^    bool javascript_safe;$/;"	m	struct:folly::json::serialization_opts	access:public
jenkins_rev_mix32	.\Hash.h	/^inline uint32_t jenkins_rev_mix32(uint32_t key) {$/;"	f	namespace:folly::hash	signature:(uint32_t key)
jenkins_rev_unmix32	.\Hash.h	/^inline uint32_t jenkins_rev_unmix32(uint32_t key) {$/;"	f	namespace:folly::hash	signature:(uint32_t key)
join	.\String-inl.h	/^void join(const Delim& delimiter,$/;"	f	namespace:folly	signature:(const Delim& delimiter, Iterator begin, Iterator end, String& output)
join	.\String.h	/^std::string join(const Delim& delimiter,$/;"	f	class:folly::UriEscapeMode	access:private	signature:(const Delim& delimiter, const Container& container)
join	.\String.h	/^std::string join(const Delim& delimiter,$/;"	f	class:folly::UriEscapeMode	access:private	signature:(const Delim& delimiter, const std::initializer_list<Value>& values)
join	.\String.h	/^void join(const Delim& delimiter,$/;"	f	class:folly::UriEscapeMode	access:private	signature:(const Delim& delimiter, const Container& container, String& output)
join	.\String.h	/^void join(const Delim& delimiter,$/;"	f	class:folly::UriEscapeMode	access:private	signature:(const Delim& delimiter, const std::initializer_list<Value>& values, String& output)
join	.\String.h	/^void join(const Delim& delimiter,$/;"	p	class:folly::UriEscapeMode	access:private	signature:(const Delim& delimiter, Iterator begin, Iterator end, String& output)
join	.\experimental\wangle\concurrent\ThreadPoolExecutor.cpp	/^void ThreadPoolExecutor::join() {$/;"	f	class:folly::wangle::ThreadPoolExecutor	signature:()
join	.\experimental\wangle\concurrent\ThreadPoolExecutor.h	/^  void join();$/;"	p	class:folly::wangle::ThreadPoolExecutor	access:public	signature:()
join	.\experimental\wangle\concurrent\test\ThreadPoolExecutorTest.cpp	/^static void join() {$/;"	f	file:	signature:()
join	.\test\DeterministicSchedule.cpp	/^DeterministicSchedule::join(std::thread& child) {$/;"	f	class:folly::test::DeterministicSchedule	signature:(std::thread& child)
join	.\test\DeterministicSchedule.h	/^  static void join(std::thread& child);$/;"	p	class:folly::test::DeterministicSchedule	access:public	signature:(std::thread& child)
join	.\test\FileUtilTest.cpp	/^  std::string join() const { return folly::join("", buffers_); }$/;"	f	class:folly::test::IovecBuffers	access:public	signature:() const
json	.\json.cpp	/^namespace json {$/;"	n	namespace:folly	file:
json	.\json.h	/^namespace json {$/;"	n	namespace:folly
jump	.\experimental\EliasFanoCoding.h	/^  ValueType jump(size_t n) {$/;"	f	class:folly::compression::detail::UpperBitsReader	access:public	signature:(size_t n)
jump	.\experimental\EliasFanoCoding.h	/^  bool jump(size_t n) {$/;"	f	class:folly::compression::EliasFanoReader	access:public	signature:(size_t n)
jumpTo	.\experimental\EliasFanoCoding.h	/^  ValueType jumpTo(ValueType value) {$/;"	f	class:folly::compression::EliasFanoReader	access:public	signature:(ValueType value)
jumpToNext	.\experimental\EliasFanoCoding.h	/^  ValueType jumpToNext(ValueType v) {$/;"	f	class:folly::compression::detail::UpperBitsReader	access:public	signature:(ValueType v)
just	.\gen\Base.h	/^detail::Just<Value> just(Value value) {$/;"	f	namespace:folly::gen	signature:(Value value)
k	.\test\AtomicHashMapTest.cpp	/^KeyT k;$/;"	v
k	.\test\FormatTest.cpp	/^  int k;$/;"	m	struct:__anon120::Opaque	file:	access:public
k1M	.\experimental\test\EliasFanoCodingTest.cpp	/^constexpr size_t k1M = 1000000;$/;"	m	namespace:bm	file:
kAdaptationFreq	.\MPMCQueue.h	/^    kAdaptationFreq = 128,$/;"	e	enum:folly::MPMCQueue::__anon80
kAddEpoch	.\experimental\EventCount.h	/^  static constexpr uint64_t kAddEpoch = uint64_t(1) << kEpochShift;$/;"	m	class:folly::EventCount	access:private
kAddWaiter	.\experimental\EventCount.h	/^  static constexpr uint64_t kAddWaiter = uint64_t(1);$/;"	m	class:folly::EventCount	access:private
kAddressColor	.\experimental\symbolizer\Symbolizer.cpp	/^const SymbolizePrinter::Color kAddressColor = SymbolizePrinter::Color::BLUE;$/;"	m	namespace:folly::symbolizer::__anon41	file:
kAlign	.\experimental\io\test\AsyncIOTest.cpp	/^constexpr size_t kAlign = 4096;  \/\/ align reads to 4096 B (for O_DIRECT)$/;"	m	namespace:__anon32	file:
kAmplification	.\MPMCPipeline.h	/^  static constexpr size_t kAmplification =$/;"	m	class:folly::MPMCPipeline	access:private
kAmplification	.\detail\MPMCPipelineDetail.h	/^  static constexpr size_t kAmplification = 1;$/;"	m	struct:folly::detail::PipelineStageInfo	access:public
kAmplification	.\detail\MPMCPipelineDetail.h	/^  static constexpr size_t kAmplification = Amp;$/;"	m	class:folly::MPMCPipelineStage	access:public
kAmplification	.\detail\MPMCPipelineDetail.h	/^  static constexpr size_t kAmplification = Amp;$/;"	m	struct:folly::detail::PipelineStageInfo	access:public
kAnchorMask_	.\AtomicHashArray.h	/^  const size_t  kAnchorMask_;$/;"	m	class:folly::AtomicHashArray	access:private
kAnon	.\MemoryMapping.h	/^    kAnon = 1 << 1,$/;"	e	enum:folly::MemoryMapping::InitFlags
kAnonymous	.\MemoryMapping.h	/^    kAnonymous$/;"	e	enum:folly::MemoryMapping::AnonymousType
kBitsPerBlock	.\AtomicBitSet.h	/^  static constexpr size_t kBitsPerBlock =$/;"	m	class:folly::AtomicBitSet	access:private
kBlockOverhead	.\Arena.h	/^  static constexpr size_t kBlockOverhead = sizeof(Block);$/;"	m	class:folly::Arena	access:public
kBuckets_	.\test\ThreadCachedIntTest.cpp	/^  static const int64_t kBuckets_ = 2048;$/;"	m	struct:ShardedAtomicInt	file:	access:public
kBufferSize	.\experimental\test\BitsBenchmark.cpp	/^const size_t kBufferSize = 1 << 10;$/;"	v
kCBmStringLength	.\test\StringTest.cpp	/^const size_t kCBmStringLength = 64 << 10;$/;"	m	namespace:__anon136	file:
kCPrintablePercentage	.\test\StringTest.cpp	/^const uint32_t kCPrintablePercentage = 90;$/;"	m	namespace:__anon136	file:
kChainLengthNotCached	.\io\IOBufQueue.h	/^  static const size_t kChainLengthNotCached = (size_t)-1;$/;"	m	class:folly::IOBufQueue	access:private
kChildFailure	.\Subprocess.cpp	/^constexpr int kChildFailure = 126;$/;"	v
kColorMap	.\experimental\symbolizer\Symbolizer.cpp	/^const std::map<SymbolizePrinter::Color, std::string> kColorMap = {$/;"	m	namespace:folly::symbolizer::__anon42	file:
kDEFAULT_IDLE_WAIT_USEC	.\io\async\EventBase.h	/^  static const int kDEFAULT_IDLE_WAIT_USEC = 20000; \/\/ 20ms$/;"	m	class:folly::EventBase	access:private
kDefaultBufferSize	.\Random.cpp	/^  static constexpr size_t kDefaultBufferSize = 128;$/;"	m	class:folly::__anon82::BufferedRandomDevice	file:	access:public
kDefaultCapacity	.\experimental\symbolizer\SignalHandler.cpp	/^constexpr size_t kDefaultCapacity = 500;$/;"	m	namespace:folly::symbolizer::__anon36	file:
kDefaultFill	.\FormatArg.h	/^  static constexpr char kDefaultFill = '\\0';$/;"	m	struct:folly::FormatArg	access:public
kDefaultMaxAlign	.\Arena.h	/^  static constexpr size_t kDefaultMaxAlign = alignof(Block);$/;"	m	class:folly::Arena	access:public
kDefaultMaxQueueSize	.\experimental\wangle\concurrent\CPUThreadPoolExecutor.cpp	/^const size_t CPUThreadPoolExecutor::kDefaultMaxQueueSize = 1 << 18;$/;"	m	class:folly::wangle::CPUThreadPoolExecutor	file:
kDefaultMaxQueueSize	.\experimental\wangle\concurrent\CPUThreadPoolExecutor.h	/^  static const size_t kDefaultMaxQueueSize;$/;"	m	class:folly::wangle::CPUThreadPoolExecutor	access:public
kDefaultMinBlockSize	.\Arena.h	/^  static constexpr size_t kDefaultMinBlockSize = 4096 - sizeof(Block);$/;"	m	class:folly::Arena	access:public
kDefaultPrecision	.\FormatArg.h	/^  static constexpr int kDefaultPrecision = -1;$/;"	m	struct:folly::FormatArg	access:public
kDefaultPresentation	.\FormatArg.h	/^  static constexpr char kDefaultPresentation = '\\0';$/;"	m	struct:folly::FormatArg	access:public
kDefaultStackToRetain	.\detail\MemoryIdler.h	/^    kDefaultStackToRetain = 1024,$/;"	e	enum:folly::detail::MemoryIdler::__anon19
kDefaultTypeDescriptorName	.\experimental\Singleton.h	/^const char* const kDefaultTypeDescriptorName = "(default)";$/;"	m	namespace:folly::detail
kDefaultWidth	.\FormatArg.h	/^  static constexpr int kDefaultWidth = -1;$/;"	m	struct:folly::FormatArg	access:public
kDurations	.\test\TimeseriesHistogramTest.cpp	/^  const seconds kDurations[] = {$/;"	m	namespace:IntMHTS	file:
kDurations	.\test\TimeseriesHistogramTest.cpp	/^  const seconds kDurations[] = {$/;"	m	namespace:IntMTMHTS	file:
kElementsPerNode	.\Padded.h	/^  static constexpr size_t kElementsPerNode = Node::kElementCount;$/;"	m	class:folly::Adaptor	access:public
kEmptyKey_	.\AtomicHashArray.h	/^  const KeyT    kEmptyKey_;$/;"	m	class:folly::AtomicHashArray	access:public
kEof	.\experimental\symbolizer\LineReader.h	/^    kEof,$/;"	e	enum:folly::symbolizer::LineReader::State
kEpochOffset	.\experimental\EventCount.h	/^  static constexpr size_t kEpochOffset = 0;  \/\/ in units of sizeof(int)$/;"	m	class:folly::EventCount	access:private
kEpochOffset	.\experimental\EventCount.h	/^  static constexpr size_t kEpochOffset = 1;$/;"	m	class:folly::EventCount	access:private
kEpochShift	.\experimental\EventCount.h	/^  static constexpr size_t  kEpochShift = 32;$/;"	m	class:folly::EventCount	access:private
kErasedKey_	.\AtomicHashArray.h	/^  const KeyT    kErasedKey_;$/;"	m	class:folly::AtomicHashArray	access:public
kError	.\experimental\symbolizer\LineReader.h	/^    kError$/;"	e	enum:folly::symbolizer::LineReader::State
kExecFailure	.\Subprocess.cpp	/^constexpr int kExecFailure = 127;$/;"	v
kExternMask	.\small_vector.h	/^    static SizeType const kExternMask =$/;"	m	struct:folly::detail::IntegralSizePolicy	access:private
kFalseSharingRange	.\detail\CacheLocality.h	/^    kFalseSharingRange = 128$/;"	e	enum:folly::detail::CacheLocality::__anon11
kFatalSignals	.\experimental\symbolizer\SignalHandler.cpp	/^} kFatalSignals[] = {$/;"	m	namespace:folly::symbolizer::__anon36	typeref:struct:folly::symbolizer::__anon36::__anon37	file:
kFib	.\gen\test\ParallelBenchmark.cpp	/^constexpr int kFib = 28;  \/\/ unit of work$/;"	v
kFib	.\gen\test\ParallelMapBenchmark.cpp	/^constexpr int kFib = 35;  \/\/ unit of work$/;"	v
kFileColor	.\experimental\symbolizer\Symbolizer.cpp	/^const SymbolizePrinter::Color kFileColor = SymbolizePrinter::Color::DEFAULT;$/;"	m	namespace:folly::symbolizer::__anon41	file:
kFillObjectSize	.\test\ThreadLocalTest.cpp	/^constexpr size_t kFillObjectSize = 300;$/;"	m	namespace:__anon146	file:
kFullGroupSize	.\detail\GroupVarintDetail.h	/^  enum { kFullGroupSize = kHeaderSize + kGroupSize * sizeof(type) };$/;"	e	enum:folly::detail::GroupVarintBase::__anon18
kFunctionColor	.\experimental\symbolizer\Symbolizer.cpp	/^const SymbolizePrinter::Color kFunctionColor = SymbolizePrinter::Color::PURPLE;$/;"	m	namespace:folly::symbolizer::__anon41	file:
kGroupSize	.\detail\GroupVarintDetail.h	/^    kGroupSize = 4,$/;"	e	enum:folly::detail::GroupVarintTraits::__anon13
kGroupSize	.\detail\GroupVarintDetail.h	/^    kGroupSize = 5,$/;"	e	enum:folly::detail::GroupVarintTraits::__anon14
kGroupSize	.\detail\GroupVarintDetail.h	/^  enum { kGroupSize = Traits::kGroupSize };$/;"	e	enum:folly::detail::GroupVarintBase::__anon16
kGrow	.\MemoryMapping.h	/^    kGrow = 1 << 0,$/;"	e	enum:folly::MemoryMapping::InitFlags
kGrowthFrac_	.\AtomicHashMap.h	/^  const float kGrowthFrac_;  \/\/ How much to grow when we run out of capacity.$/;"	m	class:folly::AtomicHashMap	access:public
kHasInlineCapacity	.\small_vector.h	/^  static bool const kHasInlineCapacity =$/;"	m	class:folly::small_vector	access:private
kHashSeed	.\io\RecordIO.cpp	/^constexpr uint32_t kHashSeed = 0xdeadbeef;  \/\/ for mcurtiss$/;"	m	namespace:folly::recordio_helpers::__anon68	file:
kHeadHeight	.\test\ConcurrentSkipListTest.cpp	/^static const int kHeadHeight = 2;$/;"	m	namespace:__anon114	file:
kHeaderBytes	.\GroupVarint.h	/^  enum { kHeaderBytes = 2 };$/;"	e	enum:folly::GroupVarint::__anon59
kHeaderSize	.\detail\GroupVarintDetail.h	/^    kHeaderSize = 1,$/;"	e	enum:folly::detail::GroupVarintTraits::__anon13
kHeaderSize	.\detail\GroupVarintDetail.h	/^    kHeaderSize = 2,$/;"	e	enum:folly::detail::GroupVarintTraits::__anon14
kHeaderSize	.\detail\GroupVarintDetail.h	/^  enum { kHeaderSize = Traits::kHeaderSize };$/;"	e	enum:folly::detail::GroupVarintBase::__anon15
kHexChars	.\experimental\symbolizer\SignalHandler.cpp	/^const char kHexChars[] = "0123456789abcdef";$/;"	m	namespace:folly::symbolizer::__anon36	file:
kHexChars	.\experimental\symbolizer\Symbolizer.cpp	/^const char kHexChars[] = "0123456789abcdef";$/;"	m	namespace:folly::symbolizer::__anon41	file:
kInitHeadHeight	.\test\ConcurrentSkipListBenchmark.cpp	/^static const int kInitHeadHeight = 10;$/;"	v	file:
kInsertPerThread	.\test\AtomicHashMapTest.cpp	/^const int kInsertPerThread = 100000;$/;"	m	namespace:__anon106	file:
kInvalidElfFile	.\experimental\symbolizer\Elf.h	/^    kInvalidElfFile = -2,$/;"	e	enum:folly::symbolizer::ElfFile::__anon35
kInvalidThreadId	.\experimental\symbolizer\SignalHandler.cpp	/^constexpr pthread_t kInvalidThreadId = 0;$/;"	m	namespace:folly::symbolizer::__anon36	file:
kLine	.\gen\test\StringBenchmark.cpp	/^const char* const kLine = "The quick brown fox jumped over the lazy dog.\\n";$/;"	m	namespace:__anon58	file:
kLineCount	.\gen\test\StringBenchmark.cpp	/^const size_t kLineCount = 10000;$/;"	m	namespace:__anon58	file:
kLockBitMask_	.\SmallLocks.h	/^  static const UIntType kLockBitMask_ = UIntType(1) << Bit;$/;"	m	struct:folly::PicoSpinLock	access:public
kLockedKey_	.\AtomicHashArray.h	/^  const KeyT    kLockedKey_;$/;"	m	class:folly::AtomicHashArray	access:public
kLockedPtr_	.\AtomicHashMap.h	/^  static const uintptr_t kLockedPtr_         = 0x88ul << 48; \/\/ invalid pointer$/;"	m	class:folly::AtomicHashMap	access:private
kMagic	.\io\RecordIO-inl.h	/^  static constexpr uint32_t kMagic = 0xeac313a1;$/;"	m	struct:folly::recordio_helpers::detail::Header	access:public
kMagic	.\test\small_vector_test.cpp	/^const int kMagic = 0xdeadbeef;$/;"	m	namespace:__anon132	file:
kMask	.\GroupVarint.cpp	/^const uint32_t GroupVarint32::kMask[] = {$/;"	m	class:folly::GroupVarint32	file:
kMask	.\GroupVarint.cpp	/^const uint64_t GroupVarint64::kMask[] = {$/;"	m	class:folly::GroupVarint64	file:
kMask	.\GroupVarint.h	/^  static const uint32_t kMask[];$/;"	m	class:folly::GroupVarint	access:private
kMask	.\GroupVarint.h	/^  static const uint64_t kMask[];$/;"	m	class:folly::GroupVarint	access:private
kMaxActiveSpin	.\SmallLocks.h	/^    static const uint32_t kMaxActiveSpin = 4000;$/;"	m	class:folly::detail::Sleeper	access:private
kMaxBinaryLength	.\Format-inl.h	/^const size_t kMaxBinaryLength = 8 * sizeof(uintmax_t);$/;"	m	namespace:folly::detail
kMaxCpus	.\detail\CacheLocality.h	/^  enum { kMaxCpus = 128 };$/;"	e	enum:folly::detail::AccessSpreader::__anon12
kMaxFrames	.\experimental\exception_tracer\StackTrace.h	/^constexpr size_t kMaxFrames = 500;$/;"	m	namespace:folly::exception_tracer
kMaxHeight	.\ConcurrentSkipList-inl.h	/^  enum { kMaxHeight = 64 };$/;"	e	enum:folly::detail::SkipListRandomHeight::__anon6
kMaxHexLength	.\Format-inl.h	/^const size_t kMaxHexLength = 2 * sizeof(uintmax_t);$/;"	m	namespace:folly::detail
kMaxOctalLength	.\Format-inl.h	/^const size_t kMaxOctalLength = 3 * sizeof(uintmax_t);$/;"	m	namespace:folly::detail
kMaxReaders	.\test\RWSpinLockTest.cpp	/^static const int kMaxReaders = 50;$/;"	m	namespace:__anon130	file:
kMaxSize	.\detail\GroupVarintDetail.h	/^  enum { kMaxSize = kHeaderSize + sizeof(type) * kGroupSize };$/;"	e	enum:folly::detail::GroupVarintBase::__anon17
kMaxSize	.\experimental\symbolizer\ElfCache.h	/^    static constexpr size_t kMaxSize = PATH_MAX - 1;$/;"	m	class:folly::symbolizer::SignalSafeElfCache::Path	access:public
kMaxSpins	.\MPMCQueue.h	/^    kMaxSpins = 2000,$/;"	m	struct:folly::detail::TurnSequencer	typeref:enum:folly::detail::TurnSequencer::	access:private
kMaxValue	.\test\ConcurrentSkipListBenchmark.cpp	/^static const int kMaxValue = 0x1000000;$/;"	v	file:
kMaxValue	.\test\ConcurrentSkipListTest.cpp	/^static const int kMaxValue = 5000;$/;"	m	namespace:__anon114	file:
kMaxVarintLength32	.\Varint.h	/^constexpr size_t kMaxVarintLength32 = 5;$/;"	m	namespace:folly
kMaxVarintLength64	.\Varint.h	/^constexpr size_t kMaxVarintLength64 = 10;$/;"	m	namespace:folly
kMinNumIndexBuckets	.\EvictingCacheMap.h	/^  static const std::size_t kMinNumIndexBuckets = 100;$/;"	m	class:folly::EvictingCacheMap	access:private
kMinPageSize	.\Range.cpp	/^constexpr size_t kMinPageSize = 4096;$/;"	m	namespace:folly::__anon83	file:
kMinSpins	.\MPMCQueue.h	/^    kMinSpins = 20,$/;"	m	struct:folly::detail::TurnSequencer	typeref:enum:folly::detail::TurnSequencer::	access:private
kMinuteHourDurations	.\test\TimeseriesTest.cpp	/^  const seconds kMinuteHourDurations[] = {$/;"	m	namespace:IntMHTS	file:
kNoFD	.\io\async\EventBase.cpp	/^const int kNoFD = -1;$/;"	m	namespace:folly	file:
kNoSizeLimit	.\Arena.h	/^  static constexpr size_t kNoSizeLimit = 0;$/;"	m	class:folly::Arena	access:public
kNumInserts	.\test\ThreadCachedIntTest.cpp	/^int kNumInserts = 100000;$/;"	v
kNumSubMapBits_	.\AtomicHashMap.h	/^  static const uint32_t  kNumSubMapBits_     = 4;$/;"	m	class:folly::AtomicHashMap	access:private
kNumSubMaps_	.\AtomicHashMap.h	/^  static const uint32_t  kNumSubMaps_        = 1 << kNumSubMapBits_;$/;"	m	class:folly::AtomicHashMap	access:private
kNumValues	.\test\ThreadCachedArenaTest.cpp	/^static const int kNumValues = 10000;$/;"	m	namespace:__anon144	file:
kNumValues	.\test\VarintTest.cpp	/^constexpr size_t kNumValues = 1000;$/;"	m	namespace:folly::test::__anon149	file:
kOne	.\AtomicBitSet.h	/^  static constexpr BlockType kOne = 1;$/;"	m	class:folly::AtomicBitSet	access:private
kPageSize	.\test\RangeTest.cpp	/^const size_t kPageSize = 4096;$/;"	v
kPrettyBytesBinaryIECSuffixes	.\String.cpp	/^const PrettySuffix kPrettyBytesBinaryIECSuffixes[] = {$/;"	m	namespace:folly::__anon94	file:
kPrettyBytesBinarySuffixes	.\String.cpp	/^const PrettySuffix kPrettyBytesBinarySuffixes[] = {$/;"	m	namespace:folly::__anon94	file:
kPrettyBytesMetricSuffixes	.\String.cpp	/^const PrettySuffix kPrettyBytesMetricSuffixes[] = {$/;"	m	namespace:folly::__anon94	file:
kPrettySISuffixes	.\String.cpp	/^const PrettySuffix kPrettySISuffixes[] = {$/;"	m	namespace:folly::__anon94	file:
kPrettySuffixes	.\String.cpp	/^const PrettySuffix* const kPrettySuffixes[PRETTY_NUM_TYPES] = {$/;"	m	namespace:folly::__anon94	file:
kPrettyTimeSuffixes	.\String.cpp	/^const PrettySuffix kPrettyTimeSuffixes[] = {$/;"	m	namespace:folly::__anon94	file:
kPrettyUnitsBinaryIECSuffixes	.\String.cpp	/^const PrettySuffix kPrettyUnitsBinaryIECSuffixes[] = {$/;"	m	namespace:folly::__anon94	file:
kPrettyUnitsBinarySuffixes	.\String.cpp	/^const PrettySuffix kPrettyUnitsBinarySuffixes[] = {$/;"	m	namespace:folly::__anon94	file:
kPrettyUnitsMetricSuffixes	.\String.cpp	/^const PrettySuffix kPrettyUnitsMetricSuffixes[] = {$/;"	m	namespace:folly::__anon94	file:
kReading	.\experimental\symbolizer\LineReader.h	/^    kReading,$/;"	e	enum:folly::symbolizer::LineReader::State
kSecondaryMapBit_	.\AtomicHashMap.h	/^  static const uint32_t  kSecondaryMapBit_   = 1u << 31; \/\/ Highest bit$/;"	m	class:folly::AtomicHashMap	access:private
kShouldUseHeap	.\small_vector.h	/^    static bool const kShouldUseHeap = ShouldUseHeap;$/;"	m	struct:folly::detail::IntegralSizePolicy	access:protected
kSignal	.\test\SubprocessTestParentDeathHelper.cpp	/^constexpr int kSignal = SIGUSR1;$/;"	m	namespace:__anon142	file:
kSlotPadding	.\MPMCQueue.h	/^    kSlotPadding = (detail::CacheLocality::kFalseSharingRange - 1)$/;"	e	enum:folly::MPMCQueue::__anon80
kSmallLineSize	.\gen\test\StringBenchmark.cpp	/^const size_t kSmallLineSize = 17;$/;"	m	namespace:__anon58	file:
kStringValue	.\experimental\symbolizer\test\ElfTests.cpp	/^const char* kStringValue = "coconuts";$/;"	v
kSubMapIndexMask_	.\AtomicHashMap.h	/^  static const uint32_t  kSubMapIndexMask_   = (1 << kSubMapIndexShift_) - 1;$/;"	m	class:folly::AtomicHashMap	access:private
kSubMapIndexShift_	.\AtomicHashMap.h	/^  static const uint32_t  kSubMapIndexShift_  = 32 - kNumSubMapBits_ - 1;$/;"	m	class:folly::AtomicHashMap	access:private
kSubWaiter	.\experimental\EventCount.h	/^  static constexpr uint64_t kSubWaiter = uint64_t(-1);$/;"	m	class:folly::EventCount	access:private
kSuccess	.\experimental\symbolizer\Elf.h	/^    kSuccess = 0,$/;"	e	enum:folly::symbolizer::ElfFile::__anon35
kSystemError	.\experimental\symbolizer\Elf.h	/^    kSystemError = -1,$/;"	e	enum:folly::symbolizer::ElfFile::__anon35
kTestEraseInsertions	.\test\AtomicHashMapTest.cpp	/^const int kTestEraseInsertions = 200000;$/;"	m	namespace:__anon107	file:
kURIBmStringLength	.\test\StringTest.cpp	/^const size_t kURIBmStringLength = 256;$/;"	m	namespace:__anon136	file:
kURIPassThroughPercentage	.\test\StringTest.cpp	/^const uint32_t kURIPassThroughPercentage = 50;$/;"	m	namespace:__anon136	file:
kVersion	.\experimental\test\EliasFanoCodingTest.cpp	/^constexpr size_t kVersion = 1;$/;"	m	namespace:bm	file:
kVstrSize	.\test\RangeFindBenchmark.cpp	/^constexpr int kVstrSize = 16;$/;"	m	namespace:__anon129	file:
kWaiterMask	.\experimental\EventCount.h	/^  static constexpr uint64_t kWaiterMask = kAddEpoch - 1;$/;"	m	class:folly::EventCount	access:private
kWaitersMask	.\MPMCQueue.h	/^    kWaitersMask = (1 << kTurnShift) - 1,$/;"	m	struct:folly::detail::TurnSequencer	typeref:enum:folly::detail::TurnSequencer::	access:private
key	.\GroupVarint.h	/^  static uint8_t key(uint32_t x) {$/;"	f	class:folly::GroupVarint	access:private	signature:(uint32_t x)
key	.\GroupVarint.h	/^  static uint8_t key(uint64_t x) {$/;"	f	class:folly::GroupVarint	access:private	signature:(uint64_t x)
key	.\test\FormatTest.cpp	/^  std::string key;$/;"	m	struct:__anon119::KeyValue	file:	access:public
keyEmpty	.\FormatArg.h	/^  bool keyEmpty() const {$/;"	f	struct:folly::FormatArg	access:public	signature:() const
keyToAnchorIdx	.\AtomicHashArray.h	/^  inline size_t keyToAnchorIdx(const KeyT k) const {$/;"	f	class:folly::AtomicHashArray	access:private	signature:(const KeyT k) const
keyToIdx	.\AtomicHashMap.h	/^  inline uint32_t keyToIdx(const KeyT k, bool mayInsert = false) {$/;"	f	class:folly::AtomicHashMap	access:public	signature:(const KeyT k, bool mayInsert = false)
key_	.\FormatArg.h	/^  StringPiece key_;$/;"	m	struct:folly::FormatArg	access:private
key_	.\test\ThreadLocalTest.cpp	/^  pthread_key_t key_;$/;"	m	class:PThreadGetSpecific	file:	access:private
key_comp	.\sorted_vector_types.h	/^  key_compare key_comp() const { return m_; }$/;"	f	class:folly::sorted_vector_map	access:public	signature:() const
key_comp	.\sorted_vector_types.h	/^  key_compare key_comp() const { return m_; }$/;"	f	class:folly::sorted_vector_set	access:public	signature:() const
key_compare	.\ConcurrentSkipList.h	/^  typedef Comp key_compare;$/;"	t	class:folly::ConcurrentSkipList::Accessor	access:public
key_compare	.\sorted_vector_types.h	/^  typedef Compare                                   key_compare;$/;"	t	class:folly::sorted_vector_map	access:public
key_compare	.\sorted_vector_types.h	/^  typedef Compare key_compare;$/;"	t	class:folly::sorted_vector_set	access:public
key_eq	.\AtomicHashMap.h	/^  key_equal key_eq() const { return key_equal(); }$/;"	f	class:folly::AtomicHashMap	access:public	signature:() const
key_equal	.\AtomicHashMap.h	/^  typedef EqualFcn            key_equal;$/;"	t	class:folly::AtomicHashMap	access:public
key_type	.\AtomicHashArray.h	/^  typedef KeyT                key_type;$/;"	t	class:folly::AtomicHashArray	access:public
key_type	.\AtomicHashMap.h	/^  typedef KeyT                key_type;$/;"	t	class:folly::AtomicHashMap	access:public
key_type	.\ConcurrentSkipList.h	/^  typedef T key_type;$/;"	t	class:folly::ConcurrentSkipList	access:public
key_type	.\ConcurrentSkipList.h	/^  typedef T key_type;$/;"	t	class:folly::ConcurrentSkipList::Accessor	access:public
key_type	.\sorted_vector_types.h	/^  typedef Key                                       key_type;$/;"	t	class:folly::sorted_vector_map	access:public
key_type	.\sorted_vector_types.h	/^  typedef T       key_type;$/;"	t	class:folly::sorted_vector_set	access:public
keys	.\dynamic-inl.h	/^inline dynamic::IterableProxy<dynamic::const_key_iterator> dynamic::keys()$/;"	f	class:folly::dynamic	signature:() const
keys	.\dynamic.h	/^  IterableProxy<const_key_iterator> keys() const;$/;"	p	struct:folly::dynamic	access:public	signature:() const
kill	.\Subprocess.h	/^  void kill() { sendSignal(SIGKILL); }$/;"	f	class:folly::Subprocess	access:public	signature:()
killSignal	.\Subprocess.cpp	/^int ProcessReturnCode::killSignal() const {$/;"	f	class:folly::ProcessReturnCode	signature:() const
killSignal	.\Subprocess.h	/^  int killSignal() const;$/;"	p	class:folly::ProcessReturnCode	access:public	signature:() const
killed	.\Subprocess.h	/^  bool killed() const { return state() == KILLED; }$/;"	f	class:folly::ProcessReturnCode	access:public	signature:() const
kind_	.\test\DynamicConverterTest.cpp	/^  int kind_;$/;"	m	struct:Token	file:	access:public
kv_	.\test\FormatTest.cpp	/^  const KeyValue& kv_;$/;"	m	class:folly::FormatValue	file:	access:private
languageSpecificData	.\experimental\exception_tracer\ExceptionAbi.h	/^  const char* languageSpecificData;$/;"	m	struct:__cxxabiv1::__cxa_exception	access:public
large	.\gen\test\ParallelBenchmark.cpp	/^auto large = from(v) | take(1 << 18);$/;"	v
last	.\ConcurrentSkipList.h	/^  const key_type *last() const { return sl_->last(); }$/;"	f	class:folly::ConcurrentSkipList::Accessor	access:public	signature:() const
last	.\ConcurrentSkipList.h	/^  const value_type *last() const {$/;"	f	class:folly::ConcurrentSkipList	access:private	signature:() const
lastCount_	.\Padded.h	/^  size_t lastCount_;  \/\/ number of elements in last Node$/;"	m	class:folly::Adaptor	access:private
lastValue_	.\experimental\EliasFanoCoding.h	/^  ValueType lastValue_ = 0;$/;"	m	struct:folly::compression::EliasFanoEncoder	access:private
lastValue_	.\experimental\EliasFanoCoding.h	/^  ValueType lastValue_;$/;"	m	class:folly::compression::EliasFanoReader	access:private
last_element	.\Conv.h	/^struct last_element {$/;"	s	namespace:folly::detail
last_element	.\Conv.h	/^struct last_element<> {$/;"	s	namespace:folly::detail
later	.\wangle\test\LaterTest.cpp	/^  Later<void> later;$/;"	m	struct:LaterFixture	file:	access:public
latestLoopCnt_	.\io\async\EventBase.h	/^  uint64_t latestLoopCnt_;$/;"	m	class:folly::EventBase	access:private
latestTime_	.\stats\BucketedTimeSeries.h	/^  TimeType latestTime_;  \/\/ time of last update()$/;"	m	class:folly::BucketedTimeSeries	access:private
launch	.\wangle\Later-inl.h	/^Future<T> Later<T>::launch() {$/;"	f	class:folly::wangle::Later	signature:()
launch	.\wangle\Later.h	/^  Future<T> launch();$/;"	p	class:folly::wangle::Later	access:public	signature:()
lazy	.\Lazy.h	/^lazy(Func&& fun) {$/;"	f	namespace:folly	signature:(Func&& fun)
lc_counts	.\test\MPMCQueueTest.cpp	/^static FOLLY_TLS int lc_counts[MAX_LIFECYCLE_EVENT];$/;"	v	file:
lc_outstanding	.\test\MPMCQueueTest.cpp	/^static int lc_outstanding() {$/;"	f	file:	signature:()
lc_prev	.\test\MPMCQueueTest.cpp	/^static FOLLY_TLS int lc_prev[MAX_LIFECYCLE_EVENT];$/;"	v	file:
lc_snap	.\test\MPMCQueueTest.cpp	/^static void lc_snap() {$/;"	f	file:	signature:()
lc_step	.\test\MPMCQueueTest.cpp	/^static void lc_step(int lineno, int what = NOTHING, int what2 = NOTHING) {$/;"	f	file:	signature:(int lineno, int what = NOTHING, int what2 = NOTHING)
left	.\test\AtomicStructTest.cpp	/^  uint32_t left;$/;"	m	struct:TwoBy32	file:	access:public
len	.\SocketAddress.h	/^    socklen_t len;$/;"	m	struct:folly::SocketAddress::ExternalUnixAddr	access:public
len	.\gen\test\StringBenchmark.cpp	/^size_t len(folly::StringPiece s) { return s.size(); }$/;"	f	namespace:__anon58	signature:(folly::StringPiece s)
length	.\io\Cursor.h	/^  size_t length() const { return queue_->tailroom(); }$/;"	f	class:folly::io::QueueAppender	access:public	signature:() const
length	.\io\Cursor.h	/^  size_t length() const {$/;"	f	class:folly::io::Appender	access:public	signature:() const
length	.\io\Cursor.h	/^  size_t length() const {$/;"	f	class:folly::io::detail::CursorBase	access:public	signature:() const
length	.\io\IOBuf.h	/^  uint64_t length() const {$/;"	f	class:folly::IOBuf	access:public	signature:() const
length	.\io\TypedIOBuf.h	/^  uint32_t length() const {$/;"	f	class:folly::TypedIOBuf	access:public	signature:() const
length	.\test\ChecksumTest.cpp	/^  size_t length;$/;"	m	struct:__anon112::ExpectedResult	file:	access:public
length_	.\experimental\symbolizer\Elf.cpp	/^    length_(other.length_),$/;"	p	namespace:folly::symbolizer	file:	signature:(other.length_)
length_	.\experimental\symbolizer\Elf.h	/^  size_t length_;  \/\/ mmap() length$/;"	m	class:folly::symbolizer::ElfFile	access:private
less	.\ConcurrentSkipList.h	/^  static bool less(const value_type &data, const NodeType *node) {$/;"	f	class:folly::ConcurrentSkipList	access:private	signature:(const value_type &data, const NodeType *node)
less_invert	.\test\sorted_vector_test.cpp	/^struct less_invert : std::binary_function<T,T,bool> {$/;"	s	namespace:__anon133	file:	inherits:std::binary_function
less_than	.\Traits.h	/^bool less_than(LHS const lhs) {$/;"	f	namespace:folly	signature:(LHS const lhs)
less_than_impl	.\Traits.h	/^bool less_than_impl($/;"	f	namespace:folly::detail	signature:( typename std::enable_if< (rhs <= std::numeric_limits<LHS>::max() && rhs > std::numeric_limits<LHS>::min()), LHS >::type const lhs )
less_than_impl	.\Traits.h	/^bool less_than_impl($/;"	f	namespace:folly::detail	signature:( typename std::enable_if< (rhs <= std::numeric_limits<LHS>::min()), LHS >::type const )
less_than_impl	.\Traits.h	/^bool less_than_impl($/;"	f	namespace:folly::detail	signature:( typename std::enable_if< (rhs > std::numeric_limits<LHS>::max()), LHS >::type const )
level_	.\io\Compression.cpp	/^  int level_;$/;"	m	class:folly::io::__anon64::FOLLY_FINAL	file:	access:private
level_	.\stats\TimeseriesHistogram.h	/^    int level_;$/;"	m	struct:folly::TimeseriesHistogram::AvgFromLevel	access:private
level_	.\stats\TimeseriesHistogram.h	/^    int level_;$/;"	m	struct:folly::TimeseriesHistogram::CountFromLevel	access:private
levels_	.\stats\MultiLevelTimeSeries.h	/^  std::vector<Level> levels_;$/;"	m	class:folly::MultiLevelTimeSeries	access:private
lexeme_	.\test\DynamicConverterTest.cpp	/^  fbstring lexeme_;$/;"	m	struct:Token	file:	access:public
lexicalCastMeasure	.\test\ConvTest.cpp	/^void lexicalCastMeasure(unsigned int n, unsigned int digits) {$/;"	f	signature:(unsigned int n, unsigned int digits)
libeventCallback	.\io\async\AsyncTimeout.cpp	/^void AsyncTimeout::libeventCallback(int fd, short events, void* arg) {$/;"	f	class:folly::AsyncTimeout	signature:(int fd, short events, void* arg)
libeventCallback	.\io\async\AsyncTimeout.h	/^  static void libeventCallback(int fd, short events, void* arg);$/;"	p	class:folly::AsyncTimeout	access:private	signature:(int fd, short events, void* arg)
libeventCallback	.\io\async\EventHandler.cpp	/^void EventHandler::libeventCallback(int fd, short events, void* arg) {$/;"	f	class:folly::EventHandler	signature:(int fd, short events, void* arg)
libeventCallback	.\io\async\EventHandler.h	/^  static void libeventCallback(int fd, short events, void* arg);$/;"	p	class:folly::EventHandler	access:private	signature:(int fd, short events, void* arg)
limit	.\test\ProducerConsumerQueueTest.cpp	/^  T limit() const { return 1 << 24; }$/;"	f	struct:__anon128::TestTraits	access:public	signature:() const
limit	.\test\ProducerConsumerQueueTest.cpp	/^  int limit() const { return 1 << 22; }$/;"	f	struct:__anon128::TestTraits	access:public	signature:() const
limit_	.\GroupVarint.h	/^  const char* limit_;$/;"	m	class:folly::GroupVarintDecoder	access:private
limit_	.\gen\Base-inl.h	/^    off_t limit_; \/\/ -1 for infinite$/;"	m	class:folly::gen::detail::Cycle::Generator	access:private
limit_	.\gen\Base-inl.h	/^  off_t limit_; \/\/ -1 for infinite$/;"	m	class:folly::gen::detail::Cycle	access:private
line	.\experimental\symbolizer\Dwarf.h	/^    uint64_t line;$/;"	m	struct:folly::symbolizer::Dwarf::LocationInfo	access:public
lineBase_	.\experimental\symbolizer\Dwarf.h	/^    int8_t lineBase_;$/;"	m	class:folly::symbolizer::Dwarf::LineNumberVM	access:private
lineNum_	.\json.cpp	/^  unsigned lineNum_;$/;"	m	struct:folly::json::__anon75::Input	file:	access:private
lineRange_	.\experimental\symbolizer\Dwarf.h	/^    uint8_t lineRange_;$/;"	m	class:folly::symbolizer::Dwarf::LineNumberVM	access:private
line_	.\experimental\symbolizer\Dwarf.h	/^    uint64_t line_;$/;"	m	class:folly::symbolizer::Dwarf::LineNumberVM	access:private
line_	.\experimental\symbolizer\Dwarf.h	/^  folly::StringPiece line_;       \/\/ .debug_line$/;"	m	class:folly::symbolizer::Dwarf	access:private
lines	.\gen\String.h	/^S lines(StringPiece source) {$/;"	f	namespace:folly::gen	signature:(StringPiece source)
link	.\Arena.h	/^    BlockLink link;$/;"	m	struct:folly::Arena::Block	access:public
link_mode	.\EvictingCacheMap.h	/^  typedef boost::intrusive::link_mode<boost::intrusive::safe_link> link_mode;$/;"	t	class:folly::EvictingCacheMap	access:private
list	.\Traits.h	/^  class list;$/;"	x
list	.\Traits.h	/^FOLLY_ASSUME_FBVECTOR_COMPATIBLE_2(std::list);$/;"	v
list	.\experimental\io\HugePageUtil.cpp	/^void list() {$/;"	f	namespace:__anon31	signature:()
list	.\experimental\test\EliasFanoCodingTest.cpp	/^typename Encoder::CompressedList list;$/;"	m	namespace:bm	file:
listHook_	.\experimental\wangle\ManagedConnection.h	/^  folly::SafeIntrusiveListHook listHook_;$/;"	m	class:folly::wangle::ManagedConnection	access:private
list_	.\experimental\EliasFanoCoding.h	/^  const EliasFanoCompressedList list_;$/;"	m	class:folly::compression::EliasFanoReader	access:private
livingSingletonCount	.\experimental\Singleton.h	/^  size_t livingSingletonCount() const {$/;"	f	class:folly::SingletonVault	access:public	signature:() const
livingWatchdogCount	.\experimental\test\SingletonTest.cpp	/^  size_t livingWatchdogCount() const { return creation_order.size(); }$/;"	f	struct:Watchdog	access:public	signature:() const
load	.\experimental\Bits.h	/^  load(const UnalignedNoASan<T>& x) { return x.value; }$/;"	f	struct:folly::detail::BitsTraits	access:public	signature:(const UnalignedNoASan<T>& x)
load	.\experimental\Bits.h	/^  static T load(const T& x) { return x; }$/;"	f	struct:folly::detail::BitsTraits	access:public	signature:(const T& x)
load	.\experimental\Bits.h	/^  static T load(const Unaligned<T>& x) { return x.value; }$/;"	f	struct:folly::detail::BitsTraits	access:public	signature:(const Unaligned<T>& x)
loadGlobalAha	.\test\AtomicHashMapTest.cpp	/^void loadGlobalAha() {$/;"	f	namespace:__anon108	signature:()
loadGlobalAhm	.\test\AtomicHashMapTest.cpp	/^void loadGlobalAhm() {$/;"	f	namespace:__anon108	signature:()
loadList	.\experimental\test\CodingTestUtils.h	/^inline std::vector<uint32_t> loadList(const std::string& filename) {$/;"	f	namespace:folly::compression	signature:(const std::string& filename)
loadRMW	.\experimental\Bits.h	/^  loadRMW(const UnalignedNoASan<T>& x) {$/;"	f	struct:folly::detail::BitsTraits	access:public	signature:(const UnalignedNoASan<T>& x)
loadRMW	.\experimental\Bits.h	/^  static T loadRMW(const T& x) {$/;"	f	struct:folly::detail::BitsTraits	access:public	signature:(const T& x)
loadRMW	.\experimental\Bits.h	/^  static T loadRMW(const Unaligned<T>& x) {$/;"	f	struct:folly::detail::BitsTraits	access:public	signature:(const Unaligned<T>& x)
loadVdsoGetcpu	.\detail\CacheLocality.cpp	/^static Getcpu::Func loadVdsoGetcpu() {$/;"	f	namespace:folly::detail	signature:()
load_acquire	.\RWSpinLock.h	/^  template<class T> static T load_acquire(T* addr) {$/;"	f	class:folly::RWTicketSpinLockT	access:private	signature:(T* addr)
localHead	.\IndexedMemPool.h	/^  AtomicStruct<TaggedPtr,Atom>& localHead() {$/;"	f	namespace:folly	signature:()
localInstance	.\Random.cpp	/^ThreadLocalPRNG::localInstance;$/;"	m	class:folly::ThreadLocalPRNG	file:
localInstance	.\Random.h	/^    localInstance;$/;"	m	class:folly::ThreadLocalPRNG	access:private
localNext	.\IndexedMemPool.h	/^    uint32_t localNext;$/;"	m	struct:folly::IndexedMemPool::Slot	access:public
localPop	.\IndexedMemPool.h	/^  uint32_t localPop(AtomicStruct<TaggedPtr,Atom>& head) {$/;"	f	namespace:folly	signature:(AtomicStruct<TaggedPtr,Atom>& head)
localPush	.\IndexedMemPool.h	/^  void localPush(AtomicStruct<TaggedPtr,Atom>& head, uint32_t idx) {$/;"	f	namespace:folly	signature:(AtomicStruct<TaggedPtr,Atom>& head, uint32_t idx)
local_	.\IndexedMemPool.h	/^  LocalList local_[NumLocalLists];$/;"	m	namespace:folly
local_	.\Random.h	/^  LocalInstancePRNG* local_;$/;"	m	class:folly::ThreadLocalPRNG	access:private
localityIndexByCpu	.\detail\CacheLocality.h	/^  std::vector<size_t> localityIndexByCpu;$/;"	m	struct:folly::detail::CacheLocality	access:public
locateElem	.\IndexedMemPool.h	/^  uint32_t locateElem(const T* elem) const {$/;"	f	struct:folly::IndexedMemPool	access:public	signature:(const T* elem) const
location	.\experimental\symbolizer\Symbolizer.h	/^  Dwarf::LocationInfo location;$/;"	m	struct:folly::symbolizer::SymbolizedFrame	access:public
lock	.\File.cpp	/^void File::lock() { doLock(LOCK_EX); }$/;"	f	class:folly::File	signature:()
lock	.\File.h	/^  void lock();$/;"	p	class:folly::File	access:public	signature:()
lock	.\PackedSyncPtr.h	/^  void lock() const { data_.lock(); }$/;"	f	class:folly::PackedSyncPtr	access:public	signature:() const
lock	.\RWSpinLock.h	/^  void lock() {$/;"	f	class:folly::RWSpinLock	access:public	signature:()
lock	.\RWSpinLock.h	/^  void lock() {$/;"	f	class:folly::RWTicketSpinLockT	access:public	signature:()
lock	.\SmallLocks.h	/^    T lock;$/;"	m	struct:folly::SpinLockArray::PaddedSpinLock	access:public
lock	.\SmallLocks.h	/^  void lock() const {$/;"	f	struct:folly::PicoSpinLock	access:public	signature:() const
lock	.\SmallLocks.h	/^  void lock() {$/;"	f	struct:folly::MicroSpinLock	access:public	signature:()
lock	.\io\async\Request.h	/^  folly::RWSpinLock lock;$/;"	m	class:folly::RequestContext	access:private
lock	.\test\PackedSyncPtrTest.cpp	/^  void lock() {$/;"	f	struct:SyncVec	access:public	signature:()
lock	.\test\SmallLocksTest.cpp	/^  MicroSpinLock lock;$/;"	m	struct:__anon131::LockedVal	file:	access:public
lock	.\test\SmallLocksTest.cpp	/^  PicoSpinLock<T> lock;$/;"	m	struct:__anon131::PslTest	file:	access:public
lockInOrder	.\Synchronized.h	/^    friend void lockInOrder(P1& p1, P2& p2);$/;"	p	struct:folly::Synchronized::ConstLockedPtr	access:friend	signature:(P1& p1, P2& p2)
lockInOrder	.\Synchronized.h	/^    friend void lockInOrder(P1& p1, P2& p2);$/;"	p	struct:folly::Synchronized::LockedPtr	access:friend	signature:(P1& p1, P2& p2)
lockInOrder	.\Synchronized.h	/^void lockInOrder(P1& p1, P2& p2) {$/;"	f	namespace:folly	signature:(P1& p1, P2& p2)
lockNodesForChange	.\ConcurrentSkipList.h	/^  bool lockNodesForChange(int nodeHeight,$/;"	f	class:folly::ConcurrentSkipList	access:private	signature:(int nodeHeight, ScopedLocker guards[MAX_HEIGHT], NodeType *preds[MAX_HEIGHT], NodeType *succs[MAX_HEIGHT], bool adding=true)
lock_	.\ConcurrentSkipList-inl.h	/^  MicroSpinLock lock_; \/\/ protects access to *nodes_$/;"	m	class:folly::detail::NodeRecycler	access:private
lock_	.\RWSpinLock.h	/^    RWSpinLock *lock_;$/;"	m	class:folly::RWTicketSpinLockT::ReadHolder	access:private
lock_	.\RWSpinLock.h	/^    RWSpinLock *lock_;$/;"	m	class:folly::RWTicketSpinLockT::WriteHolder	access:private
lock_	.\RWSpinLock.h	/^    RWSpinLock* lock_;$/;"	m	class:folly::RWSpinLock::ReadHolder	access:private
lock_	.\RWSpinLock.h	/^    RWSpinLock* lock_;$/;"	m	class:folly::RWSpinLock::UpgradedHolder	access:private
lock_	.\RWSpinLock.h	/^    RWSpinLock* lock_;$/;"	m	class:folly::RWSpinLock::WriteHolder	access:private
lock_	.\SmallLocks.h	/^  UIntType lock_;$/;"	m	struct:folly::PicoSpinLock	access:public
lock_	.\SmallLocks.h	/^  uint8_t lock_;$/;"	m	struct:folly::MicroSpinLock	access:public
lock_	.\ThreadLocal.h	/^        lock_(other.lock_),$/;"	p	class:folly::ThreadLocalPtr::Accessor	access:public	signature:(other.lock_)
lock_	.\ThreadLocal.h	/^    std::mutex* lock_;$/;"	m	class:folly::ThreadLocalPtr::Accessor	access:private
lock_	.\detail\ThreadLocalDetail.h	/^  std::mutex lock_;$/;"	m	struct:folly::threadlocal_detail::StaticMeta	access:public
lock_	.\test\AHMIntStressTest.cpp	/^  std::mutex lock_;$/;"	m	struct:__anon102::MyObjectDirectory	file:	access:public
lock_	.\test\SmallLocksTest.cpp	/^  MicroSpinLock lock_;$/;"	m	struct:__anon131::TestClobber	file:	access:private
lock_	.\wangle\ManualExecutor.h	/^    std::mutex lock_;$/;"	m	class:folly::wangle::ManualExecutor	access:private
lock_shared	.\File.cpp	/^void File::lock_shared() { doLock(LOCK_SH); }$/;"	f	class:folly::File	signature:()
lock_shared	.\File.h	/^  void lock_shared();$/;"	p	class:folly::File	access:public	signature:()
lock_shared	.\RWSpinLock.h	/^  void lock_shared() {$/;"	f	class:folly::RWSpinLock	access:public	signature:()
lock_shared	.\RWSpinLock.h	/^  void lock_shared() {$/;"	f	class:folly::RWTicketSpinLockT	access:public	signature:()
lock_upgrade	.\RWSpinLock.h	/^  void lock_upgrade() {$/;"	f	class:folly::RWSpinLock	access:public	signature:()
lockedKey	.\AtomicHashArray.h	/^    KeyT   lockedKey;$/;"	m	struct:folly::AtomicHashArray::Config	access:public
locked_	.\MemoryMapping.h	/^  bool locked_ = false;$/;"	m	class:folly::MemoryMapping	access:private
locks_	.\test\ConcurrentSkipListBenchmark.cpp	/^  std::vector<RWSpinLock*> locks_;$/;"	m	class:__anon113::ConcurrentAccessData	file:	access:private
log_value	.\test\HasMemberFnTraitsTest.cpp	/^bool log_value(const char* what, bool result) {$/;"	f	signature:(const char* what, bool result)
longestCommonPrefix	.\IPAddress.cpp	/^IPAddress::longestCommonPrefix(const CIDRNetwork& one, const CIDRNetwork& two) {$/;"	f	class:folly::IPAddress	signature:(const CIDRNetwork& one, const CIDRNetwork& two)
longestCommonPrefix	.\IPAddress.h	/^  static CIDRNetwork longestCommonPrefix(const CIDRNetwork& one,$/;"	p	class:folly::IPAddress	access:public	signature:(const CIDRNetwork& one, const CIDRNetwork& two)
longestCommonPrefix	.\IPAddressV4.h	/^  static CIDRNetworkV4 longestCommonPrefix($/;"	f	class:folly::IPAddressV4	access:public	signature:( const CIDRNetworkV4& one, const CIDRNetworkV4& two)
longestCommonPrefix	.\IPAddressV6.h	/^  static CIDRNetworkV6 longestCommonPrefix(const CIDRNetworkV6& one,$/;"	f	class:folly::IPAddressV6	access:public	signature:(const CIDRNetworkV6& one, const CIDRNetworkV6& two)
longestCommonPrefix	.\detail\IPAddress.h	/^  longestCommonPrefix($/;"	f	struct:folly::detail::Bytes	access:public	signature:( const std::array<uint8_t, N>& one, uint8_t oneMask, const std::array<uint8_t, N>& two, uint8_t twoMask)
lookupTable_	.\ConcurrentSkipList-inl.h	/^  double lookupTable_[kMaxHeight];$/;"	m	class:folly::detail::SkipListRandomHeight	access:private
loop	.\experimental\exception_tracer\ExceptionTracerBenchmark.cpp	/^void loop(int iters) {$/;"	f	signature:(int iters)
loop	.\io\async\EventBase.cpp	/^bool EventBase::loop() {$/;"	f	class:folly::EventBase	signature:()
loop	.\io\async\EventBase.h	/^  bool loop();$/;"	p	class:folly::EventBase	access:public	signature:()
loopBody	.\io\async\EventBase.cpp	/^bool EventBase::loopBody(int flags) {$/;"	f	class:folly::EventBase	signature:(int flags)
loopBody	.\io\async\EventBase.h	/^  bool loopBody(int flags = 0);$/;"	p	class:folly::EventBase	access:private	signature:(int flags = 0)
loopCallbacks_	.\io\async\EventBase.h	/^  LoopCallbackList loopCallbacks_;$/;"	m	class:folly::EventBase	access:private
loopForever	.\io\async\EventBase.cpp	/^void EventBase::loopForever() {$/;"	f	class:folly::EventBase	signature:()
loopForever	.\io\async\EventBase.h	/^  void loopForever();$/;"	p	class:folly::EventBase	access:public	signature:()
loopOnce	.\io\async\EventBase.cpp	/^bool EventBase::loopOnce(int flags) {$/;"	f	class:folly::EventBase	signature:(int flags)
loopOnce	.\io\async\EventBase.h	/^  bool loopOnce(int flags = 0);$/;"	p	class:folly::EventBase	access:public	signature:(int flags = 0)
loopSample	.\io\async\EventBase.h	/^  virtual void loopSample($/;"	p	class:folly::EventBaseObserver	access:public	signature:( int64_t busyTime, int64_t idleTime)
loopThread_	.\io\async\EventBase.h	/^  std::atomic<pthread_t> loopThread_;$/;"	m	class:folly::EventBase	access:private
lower	.\experimental\EliasFanoCoding.h	/^  folly::ByteRange lower;$/;"	m	struct:folly::compression::EliasFanoCompressedList	access:public
lowerMask_	.\experimental\EliasFanoCoding.h	/^  const ValueType lowerMask_;$/;"	m	class:folly::compression::EliasFanoReader	access:private
lower_	.\experimental\EliasFanoCoding.h	/^  unsigned char* lower_ = nullptr;$/;"	m	struct:folly::compression::EliasFanoEncoder	access:private
lower_bound	.\ConcurrentSkipList.h	/^  NodeType* lower_bound(const value_type &data) const {$/;"	f	class:folly::ConcurrentSkipList	access:private	signature:(const value_type &data) const
lower_bound	.\ConcurrentSkipList.h	/^  iterator lower_bound(const key_type &data) const {$/;"	f	class:folly::ConcurrentSkipList::Accessor	access:public	signature:(const key_type &data) const
lower_bound	.\sorted_vector_types.h	/^  const_iterator lower_bound(const key_type& key) const {$/;"	f	class:folly::sorted_vector_map	access:public	signature:(const key_type& key) const
lower_bound	.\sorted_vector_types.h	/^  const_iterator lower_bound(const key_type& key) const {$/;"	f	class:folly::sorted_vector_set	access:public	signature:(const key_type& key) const
lower_bound	.\sorted_vector_types.h	/^  iterator lower_bound(const key_type& key) {$/;"	f	class:folly::sorted_vector_map	access:public	signature:(const key_type& key)
lower_bound	.\sorted_vector_types.h	/^  iterator lower_bound(const key_type& key) {$/;"	f	class:folly::sorted_vector_set	access:public	signature:(const key_type& key)
lruLink	.\experimental\symbolizer\ElfCache.h	/^    LruLink lruLink;$/;"	m	struct:folly::symbolizer::ElfCache::Entry	access:public
lruList_	.\experimental\symbolizer\ElfCache.h	/^  LruList lruList_;$/;"	m	class:folly::symbolizer::ElfCache	access:private
lru_	.\EvictingCacheMap.h	/^  NodeList lru_;$/;"	m	class:folly::EvictingCacheMap	access:private
m_	.\sorted_vector_types.h	/^  } m_;$/;"	m	class:folly::sorted_vector_map	typeref:struct:folly::sorted_vector_map::EBO	access:private
m_	.\sorted_vector_types.h	/^  } m_;$/;"	m	class:folly::sorted_vector_set	typeref:struct:folly::sorted_vector_set::EBO	access:private
m_a	.\test\SpookyHashV1Test.cpp	/^    uint64_t m_a;$/;"	m	class:Random	file:	access:private
m_a	.\test\SpookyHashV2Test.cpp	/^    uint64_t m_a;$/;"	m	class:Random	file:	access:private
m_b	.\test\SpookyHashV1Test.cpp	/^    uint64_t m_b;$/;"	m	class:Random	file:	access:private
m_b	.\test\SpookyHashV2Test.cpp	/^    uint64_t m_b;$/;"	m	class:Random	file:	access:private
m_c	.\test\SpookyHashV1Test.cpp	/^    uint64_t m_c;$/;"	m	class:Random	file:	access:private
m_c	.\test\SpookyHashV2Test.cpp	/^    uint64_t m_c;$/;"	m	class:Random	file:	access:private
m_d	.\test\SpookyHashV1Test.cpp	/^    uint64_t m_d;$/;"	m	class:Random	file:	access:private
m_d	.\test\SpookyHashV2Test.cpp	/^    uint64_t m_d;$/;"	m	class:Random	file:	access:private
m_data	.\SpookyHashV1.h	/^    uint64_t m_data[2*sc_numVars];  \/\/ unhashed data, for partial messages$/;"	m	class:folly::hash::SpookyHashV1	access:private
m_data	.\SpookyHashV2.h	/^    uint64_t m_data[2*sc_numVars];   \/\/ unhashed data, for partial messages$/;"	m	class:folly::hash::SpookyHashV2	access:private
m_length	.\SpookyHashV1.h	/^    size_t m_length;                \/\/ total length of the input so far$/;"	m	class:folly::hash::SpookyHashV1	access:private
m_length	.\SpookyHashV2.h	/^    size_t m_length;             \/\/ total length of the input so far$/;"	m	class:folly::hash::SpookyHashV2	access:private
m_remainder	.\SpookyHashV1.h	/^    uint8_t  m_remainder;           \/\/ length of unhashed data stashed in m_data$/;"	m	class:folly::hash::SpookyHashV1	access:private
m_remainder	.\SpookyHashV2.h	/^    uint8_t  m_remainder;          \/\/ length of unhashed data stashed in m_data$/;"	m	class:folly::hash::SpookyHashV2	access:private
m_state	.\SpookyHashV1.h	/^    uint64_t m_state[sc_numVars];   \/\/ internal state of the hash$/;"	m	class:folly::hash::SpookyHashV1	access:private
m_state	.\SpookyHashV2.h	/^    uint64_t m_state[sc_numVars];  \/\/ internal state of the hash$/;"	m	class:folly::hash::SpookyHashV2	access:private
magic	.\io\IOBuf.cpp	/^  uint16_t magic;$/;"	m	struct:folly::IOBuf::HeapPrefix	file:	access:public
magic	.\io\RecordIO-inl.h	/^  uint32_t magic;$/;"	m	struct:folly::recordio_helpers::detail::Header	access:public
magic	.\test\small_vector_test.cpp	/^  int magic;$/;"	m	struct:__anon132::Thrower	file:	access:public
main	.\build\GenerateFingerprintTables.cpp	/^int main(int argc, char *argv[]) {$/;"	f	signature:(int argc, char *argv[])
main	.\build\generate_escape_tables.py	/^def main():$/;"	f	access:public
main	.\build\generate_format_tables.py	/^def main():$/;"	f	access:public
main	.\build\generate_varint_tables.py	/^def main():$/;"	f	access:public
main	.\experimental\exception_tracer\ExceptionTracerBenchmark.cpp	/^int main(int argc, char* argv[]) {$/;"	f	signature:(int argc, char* argv[])
main	.\experimental\exception_tracer\ExceptionTracerTest.cpp	/^int main(int argc, char *argv[]) {$/;"	f	signature:(int argc, char *argv[])
main	.\experimental\io\HugePageUtil.cpp	/^int main(int argc, char *argv[]) {$/;"	f	signature:(int argc, char *argv[])
main	.\experimental\symbolizer\ElfUtil.cpp	/^int main(int argc, char *argv[]) {$/;"	f	signature:(int argc, char *argv[])
main	.\experimental\symbolizer\test\Crash.cpp	/^int main() {$/;"	f	signature:()
main	.\experimental\symbolizer\test\ElfTests.cpp	/^int main(int argc, char** argv) {$/;"	f	signature:(int argc, char** argv)
main	.\experimental\symbolizer\test\StackTraceTest.cpp	/^int main(int argc, char *argv[]) {$/;"	f	signature:(int argc, char *argv[])
main	.\experimental\test\BitsBenchmark.cpp	/^int main(int argc, char *argv[]) {$/;"	f	signature:(int argc, char *argv[])
main	.\experimental\test\BitsTest.cpp	/^int main(int argc, char *argv[]) {$/;"	f	signature:(int argc, char *argv[])
main	.\experimental\test\EliasFanoCodingTest.cpp	/^int main(int argc, char** argv) {$/;"	f	signature:(int argc, char** argv)
main	.\experimental\test\SingletonTest.cpp	/^int main(int argc, char* argv[]) {$/;"	f	signature:(int argc, char* argv[])
main	.\experimental\test\TestUtilTest.cpp	/^int main(int argc, char *argv[]) {$/;"	f	signature:(int argc, char *argv[])
main	.\gen\test\BaseBenchmark.cpp	/^int main(int argc, char *argv[]) {$/;"	f	signature:(int argc, char *argv[])
main	.\gen\test\BaseTest.cpp	/^int main(int argc, char *argv[]) {$/;"	f	signature:(int argc, char *argv[])
main	.\gen\test\CombineTest.cpp	/^int main(int argc, char *argv[]) {$/;"	f	signature:(int argc, char *argv[])
main	.\gen\test\FileBenchmark.cpp	/^int main(int argc, char *argv[]) {$/;"	f	signature:(int argc, char *argv[])
main	.\gen\test\FileTest.cpp	/^int main(int argc, char *argv[]) {$/;"	f	signature:(int argc, char *argv[])
main	.\gen\test\ParallelBenchmark.cpp	/^int main(int argc, char *argv[]) {$/;"	f	signature:(int argc, char *argv[])
main	.\gen\test\ParallelMapBenchmark.cpp	/^int main(int argc, char *argv[]) {$/;"	f	signature:(int argc, char *argv[])
main	.\gen\test\ParallelMapTest.cpp	/^int main(int argc, char *argv[]) {$/;"	f	signature:(int argc, char *argv[])
main	.\gen\test\ParallelTest.cpp	/^int main(int argc, char *argv[]) {$/;"	f	signature:(int argc, char *argv[])
main	.\gen\test\StringBenchmark.cpp	/^int main(int argc, char *argv[]) {$/;"	f	signature:(int argc, char *argv[])
main	.\gen\test\StringTest.cpp	/^int main(int argc, char *argv[]) {$/;"	f	signature:(int argc, char *argv[])
main	.\io\test\CompressionTest.cpp	/^int main(int argc, char *argv[]) {$/;"	f	signature:(int argc, char *argv[])
main	.\io\test\IOBufCursorTest.cpp	/^int main(int argc, char** argv) {$/;"	f	signature:(int argc, char** argv)
main	.\io\test\IOBufQueueTest.cpp	/^int main(int argc, char** argv) {$/;"	f	signature:(int argc, char** argv)
main	.\io\test\IOBufTest.cpp	/^int main(int argc, char** argv) {$/;"	f	signature:(int argc, char** argv)
main	.\io\test\NetworkBenchmark.cpp	/^int main(int argc, char** argv) {$/;"	f	signature:(int argc, char** argv)
main	.\io\test\RecordIOTest.cpp	/^int main(int argc, char *argv[]) {$/;"	f	signature:(int argc, char *argv[])
main	.\test\ArenaSmartPtrTest.cpp	/^int main(int argc, char *argv[]) {$/;"	f	signature:(int argc, char *argv[])
main	.\test\ArenaTest.cpp	/^int main(int argc, char *argv[]) {$/;"	f	signature:(int argc, char *argv[])
main	.\test\AsciiCaseInsensitiveBenchmark.cpp	/^int main(int argc, char** argv) {$/;"	f	signature:(int argc, char** argv)
main	.\test\AsciiCaseInsensitiveTest.cpp	/^int main(int argc, char** argv) {$/;"	f	signature:(int argc, char** argv)
main	.\test\AtomicBitSetTest.cpp	/^int main(int argc, char *argv[]) {$/;"	f	signature:(int argc, char *argv[])
main	.\test\AtomicHashMapTest.cpp	/^int main(int argc, char** argv) {$/;"	f	signature:(int argc, char** argv)
main	.\test\AtomicStructTest.cpp	/^int main(int argc, char** argv) {$/;"	f	signature:(int argc, char** argv)
main	.\test\BatonTest.cpp	/^int main(int argc, char** argv) {$/;"	f	signature:(int argc, char** argv)
main	.\test\BenchmarkTest.cpp	/^int main(int argc, char** argv) {$/;"	f	signature:(int argc, char** argv)
main	.\test\BitIteratorTest.cpp	/^int main(int argc, char** argv) {$/;"	f	signature:(int argc, char** argv)
main	.\test\BitsTest.cpp	/^int main(int argc, char** argv) {$/;"	f	signature:(int argc, char** argv)
main	.\test\CacheLocalityTest.cpp	/^int main(int argc, char** argv) {$/;"	f	signature:(int argc, char** argv)
main	.\test\ChecksumTest.cpp	/^int main(int argc, char** argv) {$/;"	f	signature:(int argc, char** argv)
main	.\test\ConcurrentSkipListBenchmark.cpp	/^int main(int argc, char** argv) {$/;"	f	signature:(int argc, char** argv)
main	.\test\ConcurrentSkipListTest.cpp	/^int main(int argc, char* argv[]) {$/;"	f	signature:(int argc, char* argv[])
main	.\test\ConvTest.cpp	/^int main(int argc, char** argv) {$/;"	f	signature:(int argc, char** argv)
main	.\test\DeterministicScheduleTest.cpp	/^int main(int argc, char** argv) {$/;"	f	signature:(int argc, char** argv)
main	.\test\DynamicConverterTest.cpp	/^int main(int argc, char ** argv) {$/;"	f	signature:(int argc, char ** argv)
main	.\test\DynamicTest.cpp	/^int main(int argc, char** argv) {$/;"	f	signature:(int argc, char** argv)
main	.\test\ExceptionTest.cpp	/^int main(int argc, char *argv[]) {$/;"	f	signature:(int argc, char *argv[])
main	.\test\ExceptionWrapperBenchmark.cpp	/^int main(int argc, char *argv[]) {$/;"	f	signature:(int argc, char *argv[])
main	.\test\FBStringBenchmark.cpp	/^int main(int argc, char** argv) {$/;"	f	signature:(int argc, char** argv)
main	.\test\FBStringTest.cpp	/^int main(int argc, char** argv) {$/;"	f	signature:(int argc, char** argv)
main	.\test\FBVectorBenchmark.cpp	/^int main(int argc, char** argv) {$/;"	f	signature:(int argc, char** argv)
main	.\test\FBVectorTest.cpp	/^int main(int argc, char** argv) {$/;"	f	signature:(int argc, char** argv)
main	.\test\FileTestLockHelper.cpp	/^int main(int argc, char *argv[]) {$/;"	f	signature:(int argc, char *argv[])
main	.\test\FileUtilTest.cpp	/^int main(int argc, char *argv[]) {$/;"	f	signature:(int argc, char *argv[])
main	.\test\FingerprintTest.cpp	/^int main(int argc, char *argv[]) {$/;"	f	signature:(int argc, char *argv[])
main	.\test\ForeachTest.cpp	/^int main(int argc, char** argv) {$/;"	f	signature:(int argc, char** argv)
main	.\test\FormatBenchmark.cpp	/^int main(int argc, char *argv[]) {$/;"	f	signature:(int argc, char *argv[])
main	.\test\FormatTest.cpp	/^int main(int argc, char *argv[]) {$/;"	f	signature:(int argc, char *argv[])
main	.\test\FutexTest.cpp	/^int main(int argc, char ** argv) {$/;"	f	signature:(int argc, char ** argv)
main	.\test\HasMemberFnTraitsTest.cpp	/^int main(int argc, char *argv[]) {$/;"	f	signature:(int argc, char *argv[])
main	.\test\HistogramBenchmark.cpp	/^int main(int argc, char *argv[]) {$/;"	f	signature:(int argc, char *argv[])
main	.\test\IPAddressBenchmark.cpp	/^int main(int argc, char *argv[]) {$/;"	f	signature:(int argc, char *argv[])
main	.\test\IndexedMemPoolTest.cpp	/^int main(int argc, char** argv) {$/;"	f	signature:(int argc, char** argv)
main	.\test\JsonTest.cpp	/^int main(int argc, char** argv) {$/;"	f	signature:(int argc, char** argv)
main	.\test\LifoSemTests.cpp	/^int main(int argc, char ** argv) {$/;"	f	signature:(int argc, char ** argv)
main	.\test\LoggingTest.cpp	/^int main(int argc, char** argv) {$/;"	f	signature:(int argc, char** argv)
main	.\test\MPMCPipelineTest.cpp	/^int main(int argc, char *argv[]) {$/;"	f	signature:(int argc, char *argv[])
main	.\test\MemoryIdlerTest.cpp	/^int main(int argc, char** argv) {$/;"	f	signature:(int argc, char** argv)
main	.\test\MemoryTest.cpp	/^int main(int argc, char **argv) {$/;"	f	signature:(int argc, char **argv)
main	.\test\ProducerConsumerQueueBenchmark.cpp	/^int main(int argc, char** argv) {$/;"	f	signature:(int argc, char** argv)
main	.\test\RWSpinLockTest.cpp	/^int main(int argc, char** argv) {$/;"	f	signature:(int argc, char** argv)
main	.\test\RandomTest.cpp	/^int main(int argc, char** argv) {$/;"	f	signature:(int argc, char** argv)
main	.\test\RangeFindBenchmark.cpp	/^int main(int argc, char** argv) {$/;"	f	signature:(int argc, char** argv)
main	.\test\ScopeGuardTest.cpp	/^int main(int argc, char** argv) {$/;"	f	signature:(int argc, char** argv)
main	.\test\SpookyHashV1Test.cpp	/^int main(int argc, const char **argv)$/;"	f	signature:(int argc, const char **argv)
main	.\test\SpookyHashV2Test.cpp	/^int main(int argc, const char **argv)$/;"	f	signature:(int argc, const char **argv)
main	.\test\StringBenchmark.cpp	/^int main(int argc, char** argv) {$/;"	f	signature:(int argc, char** argv)
main	.\test\StringTest.cpp	/^int main(int argc, char *argv[]) {$/;"	f	signature:(int argc, char *argv[])
main	.\test\SubprocessTestParentDeathHelper.cpp	/^int main(int argc, char *argv[]) {$/;"	f	signature:(int argc, char *argv[])
main	.\test\ThreadCachedArenaTest.cpp	/^int main(int argc, char *argv[]) {$/;"	f	signature:(int argc, char *argv[])
main	.\test\ThreadCachedIntTest.cpp	/^int main(int argc, char** argv) {$/;"	f	signature:(int argc, char** argv)
main	.\test\ThreadLocalTest.cpp	/^int main(int argc, char** argv) {$/;"	f	signature:(int argc, char** argv)
main	.\test\TimeseriesBenchmark.cpp	/^int main(int argc, char *argv[]) {$/;"	f	signature:(int argc, char *argv[])
main	.\test\TraitsTest.cpp	/^int main(int argc, char ** argv) {$/;"	f	signature:(int argc, char ** argv)
main	.\test\VarintTest.cpp	/^int main(int argc, char *argv[]) {$/;"	f	signature:(int argc, char *argv[])
main	.\test\function_benchmark\main.cpp	/^int main(int argc, char** argv) {$/;"	f	signature:(int argc, char** argv)
main	.\test\stl_tests\StlVectorTest.cpp	/^int main(int argc, char** argv) {$/;"	f	signature:(int argc, char** argv)
main	.\wangle\test\main.cpp	/^int main(int argc, char** argv) {$/;"	f	signature:(int argc, char** argv)
mainFile	.\experimental\symbolizer\Dwarf.h	/^    Path mainFile;$/;"	m	struct:folly::symbolizer::Dwarf::LocationInfo	access:public
make128	.\RWSpinLock.h	/^  static __m128i make128(const uint16_t v[4]) {$/;"	f	struct:folly::detail::RWTicketIntTrait	access:public	signature:(const uint16_t v[4])
make128	.\RWSpinLock.h	/^  static __m128i make128(const uint8_t v[4]) {$/;"	f	struct:folly::detail::RWTicketIntTrait	access:public	signature:(const uint8_t v[4])
makeBuf	.\io\test\IOBufTest.cpp	/^  std::unique_ptr<IOBuf> makeBuf() {$/;"	f	class:MoveToFbStringTest	access:protected	signature:()
makeCallable	.\ApplyTuple.h	/^template<class F> F& makeCallable(F& f) { return f; }$/;"	f	namespace:folly::detail	signature:(F& f)
makeForwardIterator	.\test\stl_tests\StlVectorTest.cpp	/^Transformer<It, forward_iterator_tag> makeForwardIterator(const It& it) {$/;"	f	signature:(const It& it)
makeFunc	.\test\ApplyTupleTest.cpp	/^std::function<void (int, int, double)> makeFunc() {$/;"	f	namespace:__anon104	signature:()
makeFuture	.\wangle\Future-inl.h	/^Future<T> makeFuture(Try<T>&& t) {$/;"	f	namespace:folly::wangle	signature:(Try<T>&& t)
makeFuture	.\wangle\Future-inl.h	/^Future<T> makeFuture(std::exception_ptr const& e) {$/;"	f	namespace:folly::wangle	signature:(std::exception_ptr const& e)
makeFuture	.\wangle\Future-inl.h	/^Future<typename std::decay<T>::type> makeFuture(T&& t) {$/;"	f	namespace:folly::wangle	signature:(T&& t)
makeFuture	.\wangle\Future-inl.h	/^Future<void> makeFuture() {$/;"	f	namespace:folly::wangle	signature:()
makeFuture	.\wangle\Future-inl.h	/^inline Future<void> makeFuture(Try<void>&& t) {$/;"	f	namespace:folly::wangle	signature:(Try<void>&& t)
makeFuture	.\wangle\Future-inl.h	/^makeFuture(E const& e) {$/;"	f	namespace:folly::wangle	signature:(E const& e)
makeFuture	.\wangle\Future.h	/^Future<T> makeFuture(Try<T>&& t);$/;"	p	namespace:folly::wangle	signature:(Try<T>&& t)
makeFuture	.\wangle\Future.h	/^Future<T> makeFuture(std::exception_ptr const& e);$/;"	p	namespace:folly::wangle	signature:(std::exception_ptr const& e)
makeFuture	.\wangle\Future.h	/^Future<typename std::decay<T>::type> makeFuture(T&& t);$/;"	p	namespace:folly::wangle	signature:(T&& t)
makeFuture	.\wangle\Future.h	/^Future<void> makeFuture();$/;"	p	namespace:folly::wangle	signature:()
makeFuture	.\wangle\Future.h	/^makeFuture(E const& e);$/;"	p	namespace:folly::wangle	signature:(E const& e)
makeGuard	.\ScopeGuard.h	/^makeGuard(FunctionType&& fn) {$/;"	f	namespace:folly	signature:(FunctionType&& fn)
makeInputIterator	.\test\stl_tests\StlVectorTest.cpp	/^Transformer<It, input_iterator_tag> makeInputIterator(const It& it) {$/;"	f	signature:(const It& it)
makeIter	.\AtomicHashArray.h	/^  const_iterator makeIter(size_t idx) const {$/;"	f	class:folly::AtomicHashArray	access:public	signature:(size_t idx) const
makeIter	.\AtomicHashArray.h	/^  iterator makeIter(size_t idx) { return iterator(this, idx); }$/;"	f	class:folly::AtomicHashArray	access:public	signature:(size_t idx)
makeMoveWrapper	.\MoveWrapper.h	/^MoveWrapper<T> makeMoveWrapper(T&& t) {$/;"	f	namespace:folly	signature:(T&& t)
makeProgress	.\wangle\GenericThreadGate.h	/^  virtual void makeProgress() {$/;"	f	class:folly::wangle::GenericThreadGate	access:public	signature:()
makeProgress	.\wangle\ManualExecutor.h	/^    void makeProgress() {$/;"	f	class:folly::wangle::ManualExecutor	access:public	signature:()
makeProgress	.\wangle\ThreadGate.cpp	/^void ThreadGate::makeProgress()$/;"	f	class:folly::wangle::ThreadGate	signature:()
makeProgress	.\wangle\ThreadGate.h	/^  virtual void makeProgress();$/;"	p	class:folly::wangle::ThreadGate	access:public	signature:()
makeProgress	.\wangle\test\LaterTest.cpp	/^  void makeProgress() {$/;"	f	struct:ManualWaiter	access:public	signature:()
makeProgress	.\wangle\test\ThreadGateTest.cpp	/^  void makeProgress() {$/;"	f	struct:ManualWaiter	access:public	signature:()
makeProgress_	.\wangle\GenericThreadGate.h	/^  void makeProgress_(std::false_type const&) {$/;"	f	class:folly::wangle::GenericThreadGate	access:private	signature:(std::false_type const&)
makeProgress_	.\wangle\GenericThreadGate.h	/^  void makeProgress_(std::true_type const&) {$/;"	f	class:folly::wangle::GenericThreadGate	access:private	signature:(std::true_type const&)
makeRandomeString	.\test\ConcurrentSkipListTest.cpp	/^static std::string makeRandomeString(int len) {$/;"	f	namespace:__anon114	signature:(int len)
makeSize	.\small_vector.h	/^  void makeSize(size_type size, value_type* v = nullptr) {$/;"	f	class:folly::small_vector	access:private	signature:(size_type size, value_type* v = nullptr)
makeSize	.\small_vector.h	/^  void makeSize(size_type size, value_type* v, size_type pos) {$/;"	f	class:folly::small_vector	access:private	signature:(size_type size, value_type* v, size_type pos)
makeThread	.\experimental\wangle\concurrent\IOThreadPoolExecutor.cpp	/^IOThreadPoolExecutor::makeThread() {$/;"	f	class:folly::wangle::IOThreadPoolExecutor	signature:()
makeThread	.\experimental\wangle\concurrent\ThreadPoolExecutor.h	/^  virtual ThreadPtr makeThread() {$/;"	f	class:folly::wangle::ThreadPoolExecutor	access:protected	signature:()
makeTlp	.\ThreadLocal.h	/^  T* makeTlp() const {$/;"	f	class:folly::ThreadLocal	access:private	signature:() const
makeTryFunction	.\wangle\Try-inl.h	/^makeTryFunction(F&& f) {$/;"	f	namespace:folly::wangle	signature:(F&& f)
makeTryFunction	.\wangle\Try.h	/^makeTryFunction(F&& f);$/;"	p	namespace:folly::wangle	signature:(F&& f)
makeUnique	.\experimental\wangle\ConnectionManager.h	/^  static UniquePtr makeUnique(Args&&... args) {$/;"	f	class:folly::wangle::ConnectionManager	access:public	signature:(Args&&.... args)
makeUnique	.\gen\test\ParallelTest.cpp	/^} makeUnique;$/;"	v	typeref:struct:__anon57
make_exception_wrapper	.\ExceptionWrapper.h	/^  friend exception_wrapper make_exception_wrapper(Args&&... args);$/;"	p	class:folly::exception_wrapper	access:friend	signature:(Args&&.... args)
make_exception_wrapper	.\ExceptionWrapper.h	/^exception_wrapper make_exception_wrapper(Args&&... args) {$/;"	f	namespace:folly	signature:(Args&&.... args)
make_optional	.\Optional.h	/^Opt make_optional(T&& v) {$/;"	f	namespace:folly	signature:(T&& v)
make_stl_allocator	.\Memory.h	/^>::type make_stl_allocator(Allocator&& allocator) {$/;"	f	namespace:folly	signature:(Allocator&& allocator)
make_unique	.\Memory.h	/^make_unique(Args&&... args) {$/;"	f	namespace:folly	signature:(Args&&.... args)
make_unique	.\Memory.h	/^make_unique(Args&&...) = delete;$/;"	p	namespace:folly	signature:(Args&&....)
make_unique	.\Memory.h	/^make_unique(const size_t n) {$/;"	f	namespace:folly	signature:(const size_t n)
make_window	.\FBVector.h	/^  void make_window(iterator position, size_type n) {$/;"	f	signature:(iterator position, size_type n)
mallctl	.\detail\Malloc.h	/^extern int (*mallctl)(const char*, void*, size_t*, void*, size_t);$/;"	x
mallctl	.\detail\Malloc.h	/^int mallctl(const char*, void*, size_t*, void*, size_t) __attribute__((__weak__));$/;"	p	signature:(const char*, void*, size_t*, void*, size_t)
mallctl	.\detail\MallocImpl.cpp	/^int (*mallctl)(const char*, void*, size_t*, void*, size_t) = nullptr;$/;"	v
mallctl	.\detail\MemoryIdler.cpp	/^extern "C" int mallctl(const char *name, void *oldp, size_t *oldlenp,$/;"	p	file:	signature:(const char *name, void *oldp, size_t *oldlenp, void *newp, size_t newlen)
mallctlWrapper	.\detail\MemoryIdler.cpp	/^static unsigned mallctlWrapper(const char* cmd, const unsigned* in,$/;"	f	namespace:folly::detail	signature:(const char* cmd, const unsigned* in, unsigned* out)
malloc_usable_size	.\small_vector.h	65;"	d
malloc_usable_size	.\small_vector.h	68;"	d
mallocx	.\detail\Malloc.h	/^extern void* (*mallocx)(size_t, int);$/;"	x
mallocx	.\detail\Malloc.h	/^void* mallocx(size_t, int) __attribute__((__weak__));$/;"	p	signature:(size_t, int)
mallocx	.\detail\MallocImpl.cpp	/^void* (*mallocx)(size_t, int) = nullptr;$/;"	v
manager_	.\experimental\wangle\ConnectionManager.h	/^    ConnectionManager* manager_;$/;"	m	class:folly::wangle::ConnectionManager::CloseIdleConnsCallback	access:private
map	.\Traits.h	/^  class map;$/;"	x
map	.\gen\Base.h	/^Map map(Predicate pred = Predicate()) {$/;"	f	namespace:folly::gen	signature:(Predicate pred = Predicate())
map	.\test\PackedSyncPtrTest.cpp	/^static Map map(mapCap);$/;"	p	file:	signature:(mapCap)
mapCap	.\test\PackedSyncPtrTest.cpp	/^const int mapCap = 1317;$/;"	v
mapColon	.\json.cpp	/^  void mapColon() const {$/;"	f	struct:folly::json::__anon75::Printer	file:	access:private	signature:() const
mapLength_	.\MemoryMapping.h	/^  off_t mapLength_ = 0;$/;"	m	class:folly::MemoryMapping	access:private
mapOp	.\gen\Base.h	/^Map mapOp(Operator op) {$/;"	f	namespace:folly::gen	signature:(Operator op)
mapProvider	.\test\IPAddressTest.cpp	/^static vector<pair<string, string> > mapProvider = {$/;"	v	file:
mapStart_	.\MemoryMapping.h	/^  void* mapStart_ = nullptr;$/;"	m	class:folly::MemoryMapping	access:private
mapToIPv6	.\SocketAddress.cpp	/^bool SocketAddress::mapToIPv6() {$/;"	f	class:folly::SocketAddress	signature:()
mapToIPv6	.\SocketAddress.h	/^  bool mapToIPv6();$/;"	p	class:folly::SocketAddress	access:public	signature:()
map_	.\experimental\symbolizer\ElfCache.h	/^  boost::container::flat_map<Path, int> map_;$/;"	m	class:folly::symbolizer::SignalSafeElfCache	access:private
map_	.\io\RecordIO.h	/^  MemoryMapping map_;$/;"	m	class:folly::RecordIOReader	access:private
mapped	.\gen\Base.h	/^Map mapped(Predicate pred = Predicate()) {$/;"	f	namespace:folly::gen	signature:(Predicate pred = Predicate())
mapped_type	.\AtomicHashArray.h	/^  typedef ValueT              mapped_type;$/;"	t	class:folly::AtomicHashArray	access:public
mapped_type	.\AtomicHashMap.h	/^  typedef ValueT              mapped_type;$/;"	t	class:folly::AtomicHashMap	access:public
mapped_type	.\sorted_vector_types.h	/^  typedef Value                                     mapped_type;$/;"	t	class:folly::sorted_vector_map	access:public
markInstalled	.\experimental\symbolizer\SignalHandler.cpp	/^  void markInstalled();$/;"	p	class:folly::symbolizer::__anon36::FatalSignalCallbackRegistry	file:	access:public	signature:()
markInstalled	.\experimental\symbolizer\SignalHandler.cpp	/^void FatalSignalCallbackRegistry::markInstalled() {$/;"	f	class:folly::symbolizer::__anon36::FatalSignalCallbackRegistry	signature:()
markPrepended	.\io\IOBufQueue.cpp	/^IOBufQueue::markPrepended(uint64_t n) {$/;"	f	class:folly::IOBufQueue	signature:(uint64_t n)
markPrepended	.\io\IOBufQueue.h	/^  void markPrepended(uint64_t n);$/;"	p	class:folly::IOBufQueue	access:public	signature:(uint64_t n)
markedForRemoval	.\ConcurrentSkipList-inl.h	/^  bool markedForRemoval() const { return getFlags() & MARKED_FOR_REMOVAL; }$/;"	f	class:folly::detail::SkipListNode	access:public	signature:() const
mask	.\IPAddress.h	/^  IPAddress mask(uint8_t numBits) const {$/;"	f	class:folly::IPAddress	access:public	signature:(uint8_t numBits) const
mask	.\IPAddressV4.cpp	/^IPAddressV4 IPAddressV4::mask(size_t numBits) const {$/;"	f	class:folly::IPAddressV4	signature:(size_t numBits) const
mask	.\IPAddressV4.h	/^  IPAddressV4 mask(size_t numBits) const;$/;"	p	class:folly::IPAddressV4	access:public	signature:(size_t numBits) const
mask	.\IPAddressV6.cpp	/^IPAddressV6 IPAddressV6::mask(size_t numBits) const {$/;"	f	class:folly::IPAddressV6	signature:(size_t numBits) const
mask	.\IPAddressV6.h	/^  IPAddressV6 mask(size_t numBits) const;$/;"	p	class:folly::IPAddressV6	access:public	signature:(size_t numBits) const
mask	.\detail\IPAddress.h	/^  static std::array<uint8_t, N> mask(const std::array<uint8_t, N>& a,$/;"	f	struct:folly::detail::Bytes	access:public	signature:(const std::array<uint8_t, N>& a, const std::array<uint8_t, N>& b)
mask	.\test\IPAddressTest.h	/^  uint8_t mask;$/;"	m	struct:folly::MaskData	access:public
maskBoundaryProvider	.\test\IPAddressTest.cpp	/^static vector<MaskBoundaryData> maskBoundaryProvider = {$/;"	v	file:
masksProvider	.\test\IPAddressTest.cpp	/^static vector<MaskData> masksProvider = {$/;"	v	file:
masks_	.\IPAddressV4.cpp	/^const std::array<ByteArray4, 33> IPAddressV4::masks_ = {{$/;"	m	class:folly::IPAddressV4	file:
masks_	.\IPAddressV4.h	/^  static const std::array<ByteArray4, 33> masks_;$/;"	m	class:folly::IPAddressV4	access:private
masks_	.\IPAddressV6.cpp	/^const std::array<ByteArray16, 129> IPAddressV6::masks_ = {{$/;"	m	class:folly::IPAddressV6	file:
masks_	.\IPAddressV6.h	/^  static const std::array<ByteArray16, 129> masks_;$/;"	m	class:folly::IPAddressV6	access:private
max	.\Random.h	/^  static constexpr result_type max() {$/;"	f	class:folly::ThreadLocalPRNG	access:public	signature:()
max	.\gen\Base-inl.h	/^    static_assert(Random::max() >= std::numeric_limits<int32_t>::max() - 1,$/;"	p	class:folly::gen::detail::Sample::Generator	access:private	signature:()
max	.\gen\Base-inl.h	/^static const detail::Min<Identity, Greater> max;$/;"	m	namespace:folly::gen
maxAlign_	.\Arena.h	/^  const size_t maxAlign_;$/;"	m	class:folly::Arena	access:private
maxAlign_	.\ThreadCachedArena.h	/^  const size_t maxAlign_;$/;"	m	class:folly::ThreadCachedArena	access:private
maxBMElements	.\test\AtomicHashMapTest.cpp	/^const int maxBMElements = int(FLAGS_numBMElements * LF); \/\/ hit our target LF.$/;"	v
maxBy	.\gen\Base.h	/^MaxBy maxBy(Selector selector = Selector()) {$/;"	f	namespace:folly::gen	signature:(Selector selector = Selector())
maxEntries_	.\AtomicHashArray.h	/^  const size_t  maxEntries_;$/;"	m	class:folly::AtomicHashArray	access:public
maxIndexForCapacity	.\IndexedMemPool.h	/^  static constexpr uint32_t maxIndexForCapacity(uint32_t capacity) {$/;"	f	struct:folly::IndexedMemPool	access:public	signature:(uint32_t capacity)
maxLatencyCob_	.\io\async\EventBase.h	/^  Cob maxLatencyCob_;$/;"	m	class:folly::EventBase	access:private
maxLatencyLoopTime_	.\io\async\EventBase.h	/^  SmoothLoopTime maxLatencyLoopTime_;$/;"	m	class:folly::EventBase	access:private
maxLatency_	.\io\async\EventBase.h	/^  int64_t maxLatency_;$/;"	m	class:folly::EventBase	access:private
maxLayer	.\ConcurrentSkipList-inl.h	/^  int maxLayer() const { return height_ - 1; }$/;"	f	class:folly::detail::SkipListNode	access:public	signature:() const
maxLayer	.\ConcurrentSkipList.h	/^  int maxLayer() const { return headHeight_ - 1; }$/;"	f	class:folly::ConcurrentSkipList::Skipper	access:public	signature:() const
maxLayer	.\ConcurrentSkipList.h	/^  int maxLayer() const { return height() - 1; }$/;"	f	class:folly::ConcurrentSkipList	access:private	signature:() const
maxLength_	.\gen\String.h	/^  uint64_t maxLength_;  \/\/ The callback never gets more chars than this$/;"	m	class:folly::gen::StreamSplitter	access:private
maxLineLength_	.\Subprocess.h	/^    const uint64_t maxLineLength_;$/;"	m	class:folly::Subprocess::ReadLinesCallback	access:private
maxLoadFactor	.\AtomicHashArray.h	/^    double maxLoadFactor;$/;"	m	struct:folly::AtomicHashArray::Config	access:public
maxLoadFactor	.\AtomicHashArray.h	/^  double maxLoadFactor() const { return ((double) maxEntries_) \/ capacity_; }$/;"	f	class:folly::AtomicHashArray	access:public	signature:() const
maxReadAtOnce_	.\io\async\NotificationQueue.h	/^    uint32_t maxReadAtOnce_;$/;"	m	class:folly::NotificationQueue::Consumer	access:private
maxSize	.\detail\GroupVarintDetail.h	/^  static size_t maxSize(size_t n) {$/;"	f	class:folly::detail::GroupVarintBase	access:public	signature:(size_t n)
maxSize_	.\EvictingCacheMap.h	/^  std::size_t maxSize_;$/;"	m	class:folly::EvictingCacheMap	access:private
maxString	.\test\FBStringBenchmark.cpp	/^static const size_t maxString = 100;$/;"	v	file:
maxString	.\test\FBStringTest.cpp	/^static const size_t maxString = 100;$/;"	v	file:
maxString	.\test\FBVectorBenchmark.cpp	/^static const size_t maxString = 100;$/;"	v	file:
maxString	.\test\FBVectorTest.cpp	/^static const size_t maxString = 100;$/;"	v	file:
maxUncompressedLength	.\io\Compression.cpp	/^uint64_t Codec::maxUncompressedLength() const {$/;"	f	class:folly::io::Codec	signature:() const
maxUncompressedLength	.\io\Compression.h	/^  uint64_t maxUncompressedLength() const;$/;"	p	class:folly::io::Codec	access:public	signature:() const
max_	.\stats\Histogram.h	/^  ValueType max_;$/;"	m	class:folly::detail::HistogramBuckets	access:private
max_size	.\ConcurrentSkipList.h	/^  size_type max_size() const { return std::numeric_limits<size_type>::max(); }$/;"	f	class:folly::ConcurrentSkipList::Accessor	access:public	signature:() const
max_size	.\Memory.h	/^  size_t max_size() const {$/;"	f	class:folly::StlAllocator	access:public	signature:() const
max_size	.\Padded.h	/^  size_type max_size() const {$/;"	f	class:folly::Adaptor	access:public	signature:() const
max_size	.\small_vector.h	/^  static constexpr size_type max_size() {$/;"	f	class:folly::small_vector	access:public	signature:()
max_size	.\sorted_vector_types.h	/^  size_type max_size() const    { return m_.cont_.max_size(); }$/;"	f	class:folly::sorted_vector_map	access:public	signature:() const
max_size	.\sorted_vector_types.h	/^  size_type max_size() const    { return m_.cont_.max_size(); }$/;"	f	class:folly::sorted_vector_set	access:public	signature:() const
max_size	.\test\AtomicHashArrayTest.cpp	/^  size_t max_size() const {$/;"	f	class:MmapAllocator	access:public	signature:() const
mayInitTestData	.\test\ConcurrentSkipListBenchmark.cpp	/^static ConcurrentAccessData *mayInitTestData(int size) {$/;"	f	namespace:__anon113	signature:(int size)
maybeCallback	.\wangle\detail\State.h	/^  void maybeCallback() {$/;"	f	class:folly::wangle::detail::State	access:private	signature:()
maybeCopyBuffer	.\io\IOBuf.h	/^  static std::unique_ptr<IOBuf> maybeCopyBuffer(const std::string& buf,$/;"	p	class:folly::IOBuf	access:public	signature:(const std::string& buf, uint64_t headroom=0, uint64_t minTailroom=0)
maybeCopyBuffer	.\io\IOBuf.h	/^inline std::unique_ptr<IOBuf> IOBuf::maybeCopyBuffer(const std::string& buf,$/;"	f	class:folly::IOBuf	signature:(const std::string& buf, uint64_t headroom, uint64_t minTailroom)
maybeDequeue	.\experimental\io\AsyncIO.cpp	/^void AsyncIOQueue::maybeDequeue() {$/;"	f	class:folly::AsyncIOQueue	signature:()
maybeDequeue	.\experimental\io\AsyncIO.h	/^  void maybeDequeue();$/;"	p	class:folly::AsyncIOQueue	access:private	signature:()
maybeHandleSingleUniqueValue	.\stats\TimeseriesHistogram-defs.h	/^void TimeseriesHistogram<T, TT, C>::maybeHandleSingleUniqueValue($/;"	f	class:folly::TimeseriesHistogram	signature:( const ValueType& value)
maybeHandleSingleUniqueValue	.\stats\TimeseriesHistogram.h	/^  void maybeHandleSingleUniqueValue(const ValueType& value);$/;"	p	class:folly::TimeseriesHistogram	access:private	signature:(const ValueType& value)
maybeShared_	.\io\Cursor.h	/^  bool maybeShared_;$/;"	m	class:folly::io::RWCursor	access:private
maybeUnshare	.\io\Cursor.h	/^  void maybeUnshare() {$/;"	f	class:folly::io::RWCursor	access:private	signature:()
meanVariance	.\Benchmark.cpp	/^meanVariance(const double * begin, const double *const end) {$/;"	f	namespace:folly	signature:(const double * begin, const double *const end)
medium	.\gen\test\ParallelBenchmark.cpp	/^auto medium = from(v) | take(1 << 14);$/;"	v
memOpChunkSize	.\MemoryMapping.cpp	/^off_t memOpChunkSize(off_t length, off_t pageSize) {$/;"	f	namespace:folly::__anon78	signature:(off_t length, off_t pageSize)
memOpInChunks	.\MemoryMapping.cpp	/^bool memOpInChunks(std::function<int(void*, size_t)> op,$/;"	f	namespace:folly::__anon78	signature:(std::function<int(void*, size_t)> op, void* mem, size_t bufSize, off_t pageSize, size_t& amountSucceeded)
mem_fn	.\ApplyTuple.h	/^auto makeCallable(R (C::*d)(A...)) -> decltype(std::mem_fn(d)) {$/;"	f	namespace:folly::detail	signature:(d)
member_	.\gen\Base.h	/^  MemberPtr member_;$/;"	m	class:folly::gen::ConstMemberFunction	access:private
member_	.\gen\Base.h	/^  MemberPtr member_;$/;"	m	class:folly::gen::MemberFunction	access:private
merge	.\Arena-inl.h	/^void Arena<Alloc>::merge(Arena<Alloc>&& other) {$/;"	f	class:folly::Arena	signature:(Arena<Alloc>&& other)
merge	.\Arena.h	/^  void merge(Arena&& other);$/;"	p	class:folly::Arena	access:public	signature:(Arena&& other)
merge	.\Merge.h	/^OutputIt merge(InputIt1 first1, InputIt1 last1,$/;"	f	namespace:folly	signature:(InputIt1 first1, InputIt1 last1, InputIt2 first2, InputIt2 last2, OutputIt d_first)
merge	.\Merge.h	/^OutputIt merge(InputIt1 first1, InputIt1 last1,$/;"	f	namespace:folly	signature:(InputIt1 first1, InputIt1 last1, InputIt2 first2, InputIt2 last2, OutputIt d_first, Compare comp)
merge	.\stats\Histogram.h	/^  void merge(const Histogram &hist) {$/;"	f	class:folly::Histogram	access:public	signature:(const Histogram &hist)
merge	.\test\ThreadCachedArenaTest.cpp	/^  void merge(ArenaTester&& other);$/;"	p	class:__anon143::ArenaTester	file:	access:public	signature:(ArenaTester&& other)
merge	.\test\ThreadCachedArenaTest.cpp	/^void ArenaTester::merge(ArenaTester&& other) {$/;"	f	class:__anon143::ArenaTester	signature:(ArenaTester&& other)
mergeMutex_	.\test\ThreadCachedArenaTest.cpp	/^  std::mutex mergeMutex_;$/;"	m	class:__anon143::ArenaTester	file:	access:private
message	.\wangle\WangleException.h	/^    std::string message;$/;"	m	class:folly::wangle::WangleException	access:protected
messageAvailable	.\io\async\EventBase.cpp	/^  void messageAvailable(std::pair<void (*)(void*), void*>&& msg) {$/;"	f	class:folly::EventBase::FunctionRunner	access:public	signature:(std::pair<void (*)(void*), void*>&& msg)
messageAvailable	.\io\async\NotificationQueue.h	/^    virtual void messageAvailable(MessageT&& message) = 0;$/;"	p	class:folly::NotificationQueue::Consumer	access:public	signature:(MessageT&& message)
meta_	.\ThreadLocal.h	/^      : meta_(other.meta_),$/;"	p	class:folly::ThreadLocalPtr::Accessor	access:public	signature:(other.meta_)
meta_	.\ThreadLocal.h	/^    threadlocal_detail::StaticMeta<Tag>& meta_;$/;"	m	class:folly::ThreadLocalPtr::Accessor	access:private
metricReadable	.\Benchmark.cpp	/^static string metricReadable(double n, unsigned int decimals) {$/;"	f	namespace:folly	signature:(double n, unsigned int decimals)
min	.\Random.h	/^  static constexpr result_type min() {$/;"	f	class:folly::ThreadLocalPRNG	access:public	signature:()
min	.\gen\Base-inl.h	/^static const detail::Min<Identity, Less> min;$/;"	m	namespace:folly::gen
minBlockSize	.\Arena.h	/^    size_t minBlockSize;$/;"	m	struct:folly::Arena::AllocAndSize	access:public
minBlockSize	.\Arena.h	/^  size_t minBlockSize() const {$/;"	f	class:folly::Arena	access:private	signature:() const
minBlockSize_	.\ThreadCachedArena.h	/^  const size_t minBlockSize_;$/;"	m	class:folly::ThreadCachedArena	access:private
minBy	.\gen\Base.h	/^Min minBy(Selector selector = Selector()) {$/;"	f	namespace:folly::gen	signature:(Selector selector = Selector())
minLength_	.\experimental\symbolizer\Dwarf.h	/^    uint8_t minLength_;$/;"	m	class:folly::symbolizer::Dwarf::LineNumberVM	access:private
min_	.\stats\Histogram.h	/^  ValueType min_;$/;"	m	class:folly::detail::HistogramBuckets	access:private
mkAddress4	.\detail\IPAddress.h	/^  static inline in_addr mkAddress4(const uint8_t* src) {$/;"	f	struct:folly::detail::Bytes	access:public	signature:(const uint8_t* src)
mkAddress6	.\detail\IPAddress.h	/^  static inline in6_addr mkAddress6(const uint8_t* src) {$/;"	f	struct:folly::detail::Bytes	access:public	signature:(const uint8_t* src)
mlock	.\MemoryMapping.cpp	/^bool MemoryMapping::mlock(LockMode lock) {$/;"	f	class:folly::MemoryMapping	signature:(LockMode lock)
mlock	.\MemoryMapping.h	/^  bool mlock(LockMode lock);$/;"	p	class:folly::MemoryMapping	access:public	signature:(LockMode lock)
mlocked	.\MemoryMapping.h	/^  bool mlocked() const {$/;"	f	class:folly::MemoryMapping	access:public	signature:() const
mmapFileCopy	.\MemoryMapping.cpp	/^void mmapFileCopy(const char* src, const char* dest, mode_t mode) {$/;"	f	namespace:folly	signature:(const char* src, const char* dest, mode_t mode)
mmapFileCopy	.\MemoryMapping.h	/^void mmapFileCopy(const char* src, const char* dest, mode_t mode = 0666);$/;"	p	namespace:folly	signature:(const char* src, const char* dest, mode_t mode = 0666)
mmapLength_	.\IndexedMemPool.h	/^  size_t mmapLength_;$/;"	m	namespace:folly
mod7	.\gen\test\ParallelBenchmark.cpp	/^static auto mod7 = [](int i) { return i % 7; };$/;"	v	file:
mode	.\Benchmark.cpp	/^static double mode(const double * begin, const double *const end) {$/;"	f	namespace:folly	signature:(const double * begin, const double *const end)
mountPoint	.\experimental\io\HugePages.h	/^  fs::path mountPoint;$/;"	m	struct:folly::HugePageSize	access:public
move	.\FBVector.h	/^  fbvector(fbvector&& other) noexcept : impl_(std::move(other.impl_)) {}$/;"	f	signature:(other.impl_)
move	.\Padded.h	/^  std::pair<Container, size_t> move() {$/;"	f	class:folly::Adaptor	access:public	signature:()
move	.\gen\Base-inl.h	/^      : wrapper_(std::move(source.wrapper_)) {}$/;"	f	class:folly::gen::VirtualGen	access:public	signature:(source.wrapper_)
move	.\gen\Base-inl.h	/^static const detail::Map<Move> move;$/;"	m	namespace:folly::gen
move	.\gen\Base.h	/^  decltype(std::move(std::forward<Value>(value))) {$/;"	f	class:folly::gen::Move	access:public	signature:(std::forward<Value>(
move	.\gen\Combine-inl.h	/^                        std::move(t2))) {$/;"	f	class:folly::gen::detail::std	signature:(t2)
move	.\io\IOBufQueue.h	/^  std::unique_ptr<folly::IOBuf> move() {$/;"	f	class:folly::IOBufQueue	access:public	signature:()
moveFbString	.\experimental\symbolizer\Symbolizer.h	/^  fbstring moveFbString() { return std::move(buf_); }$/;"	f	class:folly::symbolizer::StringSymbolizePrinter	access:public	signature:()
moveFrom	.\FBVector.h	/^  moveFrom(fbvector&& other, std::true_type) {$/;"	f	signature:(fbvector&& other, std::true_type)
moveFrom	.\FBVector.h	/^  void moveFrom(fbvector&& other, std::false_type) {$/;"	f	signature:(fbvector&& other, std::false_type)
moveFromTry	.\wangle\Try-inl.h	/^inline T moveFromTry(wangle::Try<T>&& t) {$/;"	f	namespace:folly::wangle	signature:(wangle::Try<T>&& t)
moveFromTry	.\wangle\Try-inl.h	/^inline void moveFromTry(wangle::Try<void>&& t) {$/;"	f	namespace:folly::wangle	signature:(wangle::Try<void>&& t)
moveFromTry	.\wangle\Try.h	/^T moveFromTry(wangle::Try<T>&& t);$/;"	p	namespace:folly::wangle	signature:(wangle::Try<T>&& t)
moveFromTry	.\wangle\Try.h	/^void moveFromTry(wangle::Try<void>&& t);$/;"	p	namespace:folly::wangle	signature:(wangle::Try<void>&& t)
moveObjectsRight	.\small_vector.h	/^  moveObjectsRight(T* first, T* lastConstructed, T* realLast) {$/;"	f	namespace:folly::detail	signature:(T* first, T* lastConstructed, T* realLast)
moveToFbString	.\io\IOBuf.cpp	/^fbstring IOBuf::moveToFbString() {$/;"	f	class:folly::IOBuf	signature:()
moveToFbString	.\io\IOBuf.h	/^  fbstring moveToFbString();$/;"	p	class:folly::IOBuf	access:public	signature:()
moveToUninitialized	.\small_vector.h	/^  moveToUninitialized(T* first, T* last, T* out) {$/;"	f	namespace:folly::detail	signature:(T* first, T* last, T* out)
moveTopException	.\experimental\exception_tracer\ExceptionTracerLib.cpp	/^void moveTopException(StackTraceStack& from, StackTraceStack& to) {$/;"	f	namespace:__anon26	signature:(StackTraceStack& from, StackTraceStack& to)
moveTopFrom	.\experimental\exception_tracer\StackTrace.cpp	/^bool StackTraceStack::moveTopFrom(StackTraceStack& other) {$/;"	f	class:folly::exception_tracer::StackTraceStack	signature:(StackTraceStack& other)
moveTopFrom	.\experimental\exception_tracer\StackTrace.h	/^  bool moveTopFrom(StackTraceStack& other);$/;"	p	class:folly::exception_tracer::StackTraceStack	access:public	signature:(StackTraceStack& other)
move_only_func	.\test\ApplyTupleTest.cpp	/^void move_only_func(Mover&&) {}$/;"	f	namespace:__anon104	signature:(Mover&&)
moves	.\gen\test\BaseTest.cpp	/^  int moves;$/;"	m	struct:CopyCounter	file:	access:public
mpl	.\small_vector.h	/^  namespace mpl = boost::mpl;$/;"	x
msg_	.\IPAddressException.h	/^  const std::string msg_;$/;"	m	class:folly::IPAddressFormatException	access:private
msl	.\test\SmallLocksTest.cpp	/^struct ignore1 { MicroSpinLock msl; int16_t foo; } FOLLY_PACK_ATTR;$/;"	m	struct:__anon131::ignore1	file:	access:public
mulX	.\detail\FingerprintPolynomial.h	/^  void mulX() {$/;"	f	class:folly::detail::FingerprintPolynomial	access:public	signature:()
mulXkmod	.\detail\FingerprintPolynomial.h	/^  void mulXkmod(int k, const FingerprintPolynomial<DEG>& p) {$/;"	f	class:folly::detail::FingerprintPolynomial	access:public	signature:(int k, const FingerprintPolynomial<DEG>& p)
mulXmod	.\detail\FingerprintPolynomial.h	/^  void mulXmod(const FingerprintPolynomial<DEG>& p) {$/;"	f	class:folly::detail::FingerprintPolynomial	access:public	signature:(const FingerprintPolynomial<DEG>& p)
multiply	.\gen\test\BaseBenchmark.cpp	/^auto multiply = [](int a, int b) { return a * b; };$/;"	v
multiply	.\gen\test\BaseTest.cpp	/^auto multiply = [](int a, int b) { return a * b; };$/;"	v
munlock	.\MemoryMapping.cpp	/^void MemoryMapping::munlock(bool dontneed) {$/;"	f	class:folly::MemoryMapping	signature:(bool dontneed)
munlock	.\MemoryMapping.h	/^  void munlock(bool dontneed = false);$/;"	p	class:folly::MemoryMapping	access:public	signature:(bool dontneed = false)
mutate	.\test\stl_tests\StlVectorTest.cpp	/^void mutate(Data<f, pad>& ds) {$/;"	f	signature:(Data<f, pad>& ds)
mutate	.\test\stl_tests\StlVectorTest.cpp	/^void mutate(int& i) {$/;"	f	signature:(int& i)
mutate	.\test\stl_tests\StlVectorTest.cpp	/^void mutate(uint64_t& i) {$/;"	f	signature:(uint64_t& i)
mutex	.\experimental\Singleton.h	/^    std::mutex mutex;$/;"	m	struct:folly::SingletonVault::SingletonEntry	access:public
mutex_	.\Synchronized.h	/^  mutable Mutex mutex_;$/;"	m	struct:folly::Synchronized	access:private
mutex_	.\experimental\Singleton.h	/^  mutable std::mutex mutex_;$/;"	m	class:folly::SingletonVault	access:private
mutex_	.\experimental\symbolizer\ElfCache.h	/^  std::mutex mutex_;$/;"	m	class:folly::symbolizer::ElfCache	access:private
mutex_	.\experimental\symbolizer\SignalHandler.cpp	/^  std::mutex mutex_;$/;"	m	class:folly::symbolizer::__anon36::FatalSignalCallbackRegistry	file:	access:private
mutex_	.\experimental\wangle\concurrent\ThreadPoolExecutor.h	/^    std::mutex mutex_;$/;"	m	class:folly::wangle::ThreadPoolExecutor::StoppedThreadQueue	access:private
mutex_	.\wangle\detail\State.h	/^  std::recursive_mutex mutex_;$/;"	m	class:folly::wangle::detail::State	access:private
my_strlcpy	.\Demangle.cpp	/^size_t my_strlcpy(char* dest, const char* src, size_t size) {$/;"	f	namespace:__anon9	signature:(char* dest, const char* src, size_t size)
nIndexBuckets_	.\EvictingCacheMap.h	/^  std::size_t nIndexBuckets_;$/;"	m	class:folly::EvictingCacheMap	access:private
nSizes	.\test\stl_tests\StlVectorTest.cpp	/^static const vector<int> nSizes = { 0, 1, 2, 9, 10, 11 };$/;"	v	file:
nThreads_	.\gen\ParallelMap-inl.h	/^    const size_t nThreads_;$/;"	m	class:folly::gen::detail::PMap::Generator	access:private
nThreads_	.\gen\ParallelMap-inl.h	/^  size_t nThreads_;$/;"	m	class:folly::gen::detail::PMap	access:private
n_	.\test\PaddedTest.cpp	/^  int n_;$/;"	m	class:IntPaddedTestBase	file:	access:protected
n_	.\test\PaddedTest.cpp	/^  int n_;$/;"	m	class:StructPaddedTestBase	file:	access:protected
nallocx	.\detail\Malloc.h	/^extern size_t (*nallocx)(size_t, int);$/;"	x
nallocx	.\detail\Malloc.h	/^size_t nallocx(size_t, int) __attribute__((__weak__));$/;"	p	signature:(size_t, int)
nallocx	.\detail\MallocImpl.cpp	/^size_t (*nallocx)(size_t, int) = nullptr;$/;"	v
name	.\dynamic-inl.h	/^  static char const name[];$/;"	m	struct:folly::dynamic::TypeInfo	access:public
name	.\experimental\Singleton.h	/^  std::string name() const {$/;"	f	class:folly::detail::TypeDescriptor	access:public	signature:() const
name	.\experimental\symbolizer\Dwarf.h	/^      uint64_t name;$/;"	m	struct:folly::symbolizer::Dwarf::DIEAbbreviation::Attribute	access:public
name	.\experimental\symbolizer\SignalHandler.cpp	/^  const char* name;$/;"	m	struct:folly::symbolizer::__anon36::__anon37	file:	access:public
name	.\experimental\symbolizer\Symbolizer.h	/^  const char* name;$/;"	m	struct:folly::symbolizer::SymbolizedFrame	access:public
name_	.\experimental\Singleton.h	/^  const std::string name_;$/;"	m	class:folly::detail::TypeDescriptor	access:private
name_	.\io\async\EventBase.h	/^  std::string name_;$/;"	m	class:folly::EventBase	access:private
needle	.\test\AsciiCaseInsensitiveBenchmark.cpp	/^string needle = "commodo";$/;"	v
needle_	.\gen\Base-inl.h	/^  Needle needle_;$/;"	m	class:folly::gen::detail::Contains	access:private
needsUncompressedLength	.\io\Compression.cpp	/^bool Codec::needsUncompressedLength() const {$/;"	f	class:folly::io::Codec	signature:() const
needsUncompressedLength	.\io\Compression.h	/^  bool needsUncompressedLength() const;$/;"	p	class:folly::io::Codec	access:public	signature:() const
needy_vault	.\experimental\test\SingletonTest.cpp	/^SingletonVault needy_vault;$/;"	v
networkToString	.\IPAddress.h	/^  static std::string networkToString(const CIDRNetwork& network) {$/;"	f	class:folly::IPAddress	access:public	signature:(const CIDRNetwork& network)
newMap	.\test\AHMIntStressTest.cpp	/^std::unique_ptr<MyMap> newMap() { return folly::make_unique<MyMap>(100); }$/;"	f	namespace:__anon102	signature:()
newThread	.\experimental\wangle\concurrent\ThreadFactory.h	/^  virtual std::thread newThread(Func&& func) = 0;$/;"	p	class:folly::wangle::ThreadFactory	access:public	signature:(Func&& func)
newline	.\json.cpp	/^  void newline() const {$/;"	f	struct:folly::json::__anon75::Printer	file:	access:private	signature:() const
next	.\ConcurrentSkipList-inl.h	/^  SkipListNode* next() {$/;"	f	class:folly::detail::SkipListNode	access:public	signature:()
next	.\GroupVarint.h	/^  bool next(type* val) {$/;"	f	class:folly::GroupVarintDecoder	access:public	signature:(type* val)
next	.\LifoSem.h	/^  uint32_t next;$/;"	m	struct:folly::detail::LifoSemRawNode	access:public
next	.\detail\ThreadLocalDetail.h	/^  ThreadEntry* next;$/;"	m	struct:folly::threadlocal_detail::ThreadEntry	access:public
next	.\experimental\EliasFanoCoding.h	/^  ValueType next() {$/;"	f	class:folly::compression::detail::UpperBitsReader	access:public	signature:()
next	.\experimental\EliasFanoCoding.h	/^  bool next() {$/;"	f	class:folly::compression::EliasFanoReader	access:public	signature:()
next	.\experimental\exception_tracer\StackTrace.cpp	/^  Node* next;$/;"	m	class:folly::exception_tracer::StackTraceStack::Node	file:	access:public
next	.\experimental\exception_tracer\StackTrace.cpp	/^StackTrace* StackTraceStack::next(StackTrace* p) {$/;"	f	class:folly::exception_tracer::StackTraceStack	signature:(StackTrace* p)
next	.\experimental\exception_tracer\StackTrace.h	/^  StackTrace* next(StackTrace* p);$/;"	p	class:folly::exception_tracer::StackTraceStack	access:public	signature:(StackTrace* p)
next	.\experimental\symbolizer\Dwarf.cpp	/^bool Dwarf::LineNumberVM::next(folly::StringPiece& program) {$/;"	f	class:folly::symbolizer::Dwarf::LineNumberVM	signature:(folly::StringPiece& program)
next	.\experimental\symbolizer\Dwarf.cpp	/^bool Dwarf::Section::next(folly::StringPiece& chunk) {$/;"	f	class:folly::symbolizer::Dwarf::Section	signature:(folly::StringPiece& chunk)
next	.\experimental\symbolizer\Dwarf.h	/^    bool next(folly::StringPiece& chunk);$/;"	p	class:folly::symbolizer::Dwarf::Section	access:public	signature:(folly::StringPiece& chunk)
next	.\experimental\symbolizer\Dwarf.h	/^    bool next(folly::StringPiece& program);$/;"	p	class:folly::symbolizer::Dwarf::LineNumberVM	access:private	signature:(folly::StringPiece& program)
next	.\io\IOBuf.h	/^  IOBuf* next() {$/;"	f	class:folly::IOBuf	access:public	signature:()
next	.\io\IOBuf.h	/^  const IOBuf* next() const {$/;"	f	class:folly::IOBuf	access:public	signature:() const
nextAlignedIndex	.\Range.cpp	/^inline size_t nextAlignedIndex(const char* arr) {$/;"	f	namespace:folly::__anon83	signature:(const char* arr)
nextDefineFile	.\experimental\symbolizer\Dwarf.cpp	/^bool Dwarf::LineNumberVM::nextDefineFile(folly::StringPiece& program,$/;"	f	class:folly::symbolizer::Dwarf::LineNumberVM	signature:(folly::StringPiece& program, FileName& fn) const
nextDefineFile	.\experimental\symbolizer\Dwarf.h	/^    bool nextDefineFile(folly::StringPiece& program, FileName& fn) const;$/;"	p	class:folly::symbolizer::Dwarf::LineNumberVM	access:private	signature:(folly::StringPiece& program, FileName& fn) const
nextException	.\experimental\exception_tracer\ExceptionAbi.h	/^  __cxa_exception* nextException;$/;"	m	struct:__cxxabiv1::__cxa_exception	access:public
nextExpiration	.\TimeoutQueue.cpp	/^int64_t TimeoutQueue::nextExpiration() const {$/;"	f	class:folly::TimeoutQueue	signature:() const
nextExpiration	.\TimeoutQueue.h	/^  int64_t nextExpiration() const;$/;"	p	class:folly::TimeoutQueue	access:public	signature:() const
nextId	.\experimental\wangle\concurrent\ThreadPoolExecutor.h	/^    static std::atomic<uint64_t> nextId;$/;"	m	struct:folly::wangle::ThreadPoolExecutor::Thread	access:public
nextId_	.\TimeoutQueue.h	/^  Id nextId_;$/;"	m	class:folly::TimeoutQueue	access:private
nextId_	.\detail\ThreadLocalDetail.h	/^  int nextId_;$/;"	m	struct:folly::threadlocal_detail::StaticMeta	access:public
nextIntKey_	.\FormatArg.h	/^  int nextIntKey_;$/;"	m	struct:folly::FormatArg	access:private
nextKeyMode_	.\FormatArg.h	/^  NextKeyMode nextKeyMode_;$/;"	m	struct:folly::FormatArg	access:private
nextKey_	.\FormatArg.h	/^  StringPiece nextKey_;$/;"	m	struct:folly::FormatArg	access:private
nextLoopCnt_	.\io\async\EventBase.h	/^  uint64_t nextLoopCnt_;$/;"	m	class:folly::EventBase	access:private
nextSize	.\test\FileUtilTest.cpp	/^  ssize_t nextSize();$/;"	p	class:folly::test::__anon117::Reader	file:	access:private	signature:()
nextSize	.\test\FileUtilTest.cpp	/^ssize_t Reader::nextSize() {$/;"	f	class:folly::test::__anon117::Reader	signature:()
nextThread_	.\experimental\wangle\concurrent\IOThreadPoolExecutor.h	/^  size_t nextThread_;$/;"	m	class:folly::wangle::IOThreadPoolExecutor	access:private
nextTick_	.\io\async\HHWheelTimer.h	/^  int64_t nextTick_;$/;"	m	class:folly::HHWheelTimer	access:private
nodeSize	.\ConcurrentSkipList.h	/^  size_t nodeSize() const {$/;"	f	class:folly::detail::csl_iterator	access:public	signature:() const
nodeToIdx	.\LifoSem.h	/^  static uint32_t nodeToIdx(const LifoSemNode<Handoff, Atom>& node) {$/;"	f	struct:folly::detail::LifoSemBase	access:private	signature:(const LifoSemNode<Handoff, Atom>& node)
node_	.\ConcurrentSkipList.h	/^  NodeT* node_;$/;"	m	class:folly::detail::csl_iterator	access:private
nodes_	.\ConcurrentSkipList-inl.h	/^  std::unique_ptr<std::vector<NodeType*>> nodes_;$/;"	m	class:folly::detail::NodeRecycler	access:private
noexcept	.\FBVector.h	/^    Impl(Impl&& other) noexcept$/;"	m	struct:folly::fbvector::Impl	access:public
noexcept	.\LifoSem.h	/^  virtual ~ShutdownSemError() noexcept;$/;"	m	struct:folly::ShutdownSemError	access:public
noexcept	.\MPMCQueue.h	/^  explicit TurnSequencer(const uint32_t firstTurn = 0) noexcept$/;"	m	struct:folly::detail::TurnSequencer	access:public
noexcept	.\Optional.h	/^    noexcept (std::is_nothrow_copy_assignable<Value>::value) {$/;"	f	class:folly::Optional	access:public	signature:(std::is_nothrow_copy_assignable<Value>::value)
noexcept	.\Optional.h	/^    noexcept (std::is_nothrow_move_assignable<Value>::value) {$/;"	f	class:folly::Optional	access:public	signature:(std::is_nothrow_move_assignable<Value>::value)
noexcept	.\Optional.h	/^    noexcept(std::is_nothrow_copy_constructible<Value>::value) {$/;"	f	class:folly::Optional	access:public	signature:(std::is_nothrow_copy_constructible<Value>::value)
noexcept	.\Optional.h	/^    noexcept(std::is_nothrow_move_constructible<Value>::value) {$/;"	f	class:folly::Optional	access:public	signature:(std::is_nothrow_move_constructible<Value>::value)
noexcept	.\ScopeGuard.h	/^  ~ScopeGuardForNewException() noexcept(executeOnException) {$/;"	f	class:folly::detail::ScopeGuardForNewException	access:public	signature:(executeOnException)
noexcept	.\Synchronized.h	/^               const Guard& \/*guard*\/) noexcept(nxCopyCtor)$/;"	f	struct:folly::Synchronized	access:private	signature:(nxCopyCtor)
noexcept	.\Synchronized.h	/^  Synchronized(Synchronized&& rhs) noexcept(nxMoveCtor)$/;"	f	struct:folly::Synchronized	access:public	signature:(nxMoveCtor)
noexcept	.\Synchronized.h	/^  Synchronized(Synchronized&& rhs, const Guard& \/*guard*\/) noexcept(nxMoveCtor)$/;"	f	struct:folly::Synchronized	access:private	signature:(nxMoveCtor)
noexcept	.\Synchronized.h	/^  Synchronized(const Synchronized& rhs) noexcept(nxCopyCtor)$/;"	f	struct:folly::Synchronized	access:public	signature:(nxCopyCtor)
noexcept	.\Synchronized.h	/^  explicit Synchronized(T&& rhs) noexcept(nxMoveCtor)$/;"	f	struct:folly::Synchronized	access:public	signature:(nxMoveCtor)
noexcept	.\Synchronized.h	/^  explicit Synchronized(const T& rhs) noexcept(nxCopyCtor) : datum_(rhs) {}$/;"	f	struct:folly::Synchronized	access:public	signature:(nxCopyCtor)
noexcept	.\detail\UncaughtExceptionCounter.h	/^  int getUncaughtExceptionCount() noexcept;$/;"	m	class:folly::detail::UncaughtExceptionCounter	access:private
noexcept	.\detail\UncaughtExceptionCounter.h	/^extern "C" __cxa_eh_globals* __cxa_get_globals() noexcept;$/;"	m	namespace:__cxxabiv1
noexcept	.\experimental\EventCount.h	/^  Key prepareWait() noexcept;$/;"	m	class:folly::EventCount	access:public
noexcept	.\experimental\EventCount.h	/^  void cancelWait() noexcept;$/;"	m	class:folly::EventCount	access:public
noexcept	.\experimental\EventCount.h	/^  void doNotify(int n) noexcept;$/;"	m	class:folly::EventCount	access:private
noexcept	.\experimental\EventCount.h	/^  void notify() noexcept;$/;"	m	class:folly::EventCount	access:public
noexcept	.\experimental\EventCount.h	/^  void notifyAll() noexcept;$/;"	m	class:folly::EventCount	access:public
noexcept	.\experimental\EventCount.h	/^  void wait(Key key) noexcept;$/;"	m	class:folly::EventCount	access:public
noexcept	.\experimental\symbolizer\Elf.h	/^                  const char** msg=nullptr) noexcept;$/;"	m	class:folly::symbolizer::ElfFile	access:public
noexcept	.\experimental\symbolizer\Elf.h	/^  ElfFile() noexcept;$/;"	m	class:folly::symbolizer::ElfFile	access:public
noexcept	.\experimental\symbolizer\Elf.h	/^  ElfFile(ElfFile&& other) noexcept;$/;"	m	class:folly::symbolizer::ElfFile	access:public
noexcept	.\experimental\test\SingletonTest.cpp	/^  Watchdog(Watchdog&&) noexcept = default;$/;"	m	struct:Watchdog	file:	access:public
noexcept	.\experimental\wangle\ManagedConnection.h	/^  virtual void timeoutExpired() noexcept = 0;$/;"	m	class:folly::wangle::ManagedConnection	access:public
noexcept	.\experimental\wangle\concurrent\CPUThreadPoolExecutor.h	/^    Task(Task&& o) noexcept : func(std::move(o.func)), poison(o.poison) {}$/;"	m	struct:folly::wangle::CPUThreadPoolExecutor::Task	access:public
noexcept	.\gen\Core-inl.h	/^  Operator& operator=(Operator&&) noexcept = default;$/;"	m	class:folly::gen::Operator	access:protected
noexcept	.\gen\Core-inl.h	/^  Operator(Operator&&) noexcept = default;$/;"	m	class:folly::gen::Operator	access:protected
noexcept	.\gen\test\BaseTest.cpp	/^  TestIntSeq& operator=(TestIntSeq&&) noexcept = default;$/;"	m	class:__anon56::TestIntSeq	file:	access:public
noexcept	.\gen\test\BaseTest.cpp	/^  TestIntSeq(TestIntSeq&&) noexcept = default;$/;"	m	class:__anon56::TestIntSeq	file:	access:public
noexcept	.\io\IOBuf.h	/^  IOBuf& operator=(IOBuf&& other) noexcept;$/;"	m	class:folly::IOBuf	access:public
noexcept	.\io\IOBuf.h	/^  IOBuf() noexcept;$/;"	m	class:folly::IOBuf	access:public
noexcept	.\io\IOBuf.h	/^  IOBuf(IOBuf&& other) noexcept;$/;"	m	class:folly::IOBuf	access:public
noexcept	.\io\async\AsyncTimeout.h	/^  virtual void timeoutExpired() noexcept = 0;$/;"	m	class:folly::AsyncTimeout	access:public
noexcept	.\io\async\EventBase.h	/^    virtual void runLoopCallback() noexcept = 0;$/;"	m	class:folly::EventBase::LoopCallback	access:public
noexcept	.\io\async\EventBase.h	/^    virtual void timeoutExpired() noexcept;$/;"	m	class:folly::EventBase::CobTimeout	access:public
noexcept	.\io\async\EventBase.h	/^    void runLoopCallback() noexcept;$/;"	m	class:folly::EventBase::RunInLoopCallback	access:public
noexcept	.\io\async\EventHandler.h	/^  virtual void handlerReady(uint16_t events) noexcept = 0;$/;"	m	class:folly::EventHandler	access:public
noexcept	.\io\async\HHWheelTimer.h	/^    virtual void timeoutExpired() noexcept = 0;$/;"	m	class:folly::HHWheelTimer::Callback	access:public
noexcept	.\io\async\HHWheelTimer.h	/^  virtual void timeoutExpired() noexcept;$/;"	m	class:folly::HHWheelTimer	access:private
noexcept	.\io\async\NotificationQueue.h	/^    virtual void handlerReady(uint16_t events) noexcept;$/;"	m	class:folly::NotificationQueue::Consumer	access:public
noexcept	.\test\DeterministicSchedule.h	/^  constexpr \/* implicit *\/ DeterministicAtomic(T v) noexcept : data(v) {}$/;"	m	struct:folly::test::DeterministicAtomic	access:public
noexcept	.\test\MPMCQueueTest.cpp	/^  Lifecycle() noexcept : constructed(true) {$/;"	m	struct:Lifecycle	file:	access:public
noexcept	.\test\stl_tests\StlVectorTest.cpp	/^  DataTicker() noexcept(f & DC_NOEXCEPT) {$/;"	f	struct:DataTicker	access:public	signature:(f & DC_NOEXCEPT)
noexcept	.\test\stl_tests\StlVectorTest.cpp	/^  DataTicker(DataTicker&&) noexcept(f & MC_NOEXCEPT) {$/;"	f	struct:DataTicker	access:public	signature:(f & MC_NOEXCEPT)
noexcept	.\test\stl_tests\StlVectorTest.cpp	/^  DataTicker(const DataTicker&) noexcept(f & CC_NOEXCEPT) {$/;"	f	struct:DataTicker	access:public	signature:(f & CC_NOEXCEPT)
noexcept	.\test\stl_tests\StlVectorTest.cpp	/^  DataTracker() noexcept : Tracker(this, UID++) {$/;"	m	struct:DataTracker	file:	access:public
noexcept	.\test\stl_tests\StlVectorTest.cpp	/^  DataTracker(DataTracker&& o) noexcept : Tracker(this, o.uid) {$/;"	m	struct:DataTracker	file:	access:public
noexcept	.\test\stl_tests\StlVectorTest.cpp	/^  DataTracker(const DataTracker& o) noexcept : Tracker(this, o.uid) {$/;"	m	struct:DataTracker	file:	access:public
noexcept	.\test\stl_tests\StlVectorTest.cpp	/^  explicit DataTicker(std::nullptr_t) noexcept(f & OC_NOEXCEPT) {$/;"	f	struct:DataTicker	access:public	signature:(f & OC_NOEXCEPT)
noexcept	.\test\stl_tests\StlVectorTest.cpp	/^  explicit DataTracker(int uid) noexcept : Tracker(this, uid) {$/;"	m	struct:DataTracker	file:	access:public
noexcept	.\test\stl_tests\StlVectorTest.cpp	/^  void operator=(DataTicker&&) noexcept(f & MA_NOEXCEPT) {$/;"	f	struct:DataTicker	access:public	signature:(f & MA_NOEXCEPT)
noexcept	.\test\stl_tests\StlVectorTest.cpp	/^  void operator=(const DataTicker&) noexcept(f & CA_NOEXCEPT) {$/;"	f	struct:DataTicker	access:public	signature:(f & CA_NOEXCEPT)
noexcept	.\wangle\Future.h	/^  Future(Future&&) noexcept;$/;"	m	class:folly::wangle::Future	access:public
noexcept	.\wangle\detail\State.h	/^  State(State&&) noexcept = delete;$/;"	m	class:folly::wangle::detail::State	access:public
nonUniformExampleLocality	.\test\CacheLocalityTest.cpp	/^static const CacheLocality nonUniformExampleLocality = {$/;"	v	file:
none	.\Optional.h	/^const None none = nullptr;$/;"	m	namespace:folly
normal_singleton_value	.\experimental\test\SingletonTest.cpp	/^int normal_singleton_value = 0;$/;"	v
notStarted	.\Subprocess.h	/^  bool notStarted() const { return state() == NOT_STARTED; }$/;"	f	class:folly::ProcessReturnCode	access:public	signature:() const
notThereYet	.\Foreach.h	/^notThereYet(T& iter, const U& end) {$/;"	f	namespace:folly::detail	signature:(T& iter, const U& end)
nothingHandledYet	.\io\async\EventBase.cpp	/^bool EventBase::nothingHandledYet() {$/;"	f	class:folly::EventBase	signature:()
nothingHandledYet	.\io\async\EventBase.h	/^  bool nothingHandledYet();$/;"	p	class:folly::EventBase	access:private	signature:()
notificationCallback	.\experimental\io\AsyncIO.h	/^  const NotificationCallback& notificationCallback() const { return cb_; }$/;"	f	class:folly::AsyncIOOp	access:public	signature:() const
notificationsEnabled	.\Subprocess.cpp	/^bool Subprocess::notificationsEnabled(int childFd) const {$/;"	f	class:folly::Subprocess	signature:(int childFd) const
notificationsEnabled	.\Subprocess.h	/^  bool notificationsEnabled(int childFd) const;$/;"	p	class:folly::Subprocess	access:public	signature:(int childFd) const
notifyPendingShutdown	.\experimental\wangle\ManagedConnection.h	/^  virtual void notifyPendingShutdown() = 0;$/;"	p	class:folly::wangle::ManagedConnection	access:public	signature:()
now	.\test\MemoryIdlerTest.cpp	/^  static time_point now() {$/;"	f	struct:MockClock	access:public	signature:()
now	.\wangle\Executor.h	/^     virtual TimePoint now() {$/;"	f	class:folly::wangle::Executor	access:public	signature:()
nowInUsec	.\test\AtomicHashMapTest.cpp	/^static int64_t nowInUsec() {$/;"	f	file:	signature:()
nowMicro	.\test\MPMCQueueTest.cpp	/^uint64_t nowMicro() {$/;"	f	signature:()
now_	.\io\async\HHWheelTimer.h	/^  std::chrono::milliseconds now_;$/;"	m	class:folly::HHWheelTimer	access:private
now_	.\wangle\ManualExecutor.h	/^    TimePoint now_ = now_.min();$/;"	m	class:folly::wangle::ManualExecutor	access:private
npos	.\Range.h	/^  static const size_type npos;$/;"	m	class:folly::Range	access:public
npos	.\Range.h	/^const typename Range<Iter>::size_type Range<Iter>::npos = std::string::npos;$/;"	m	class:folly::Range
nsSpent	.\Benchmark.cpp	/^BenchmarkSuspender::NanosecondsSpent BenchmarkSuspender::nsSpent;$/;"	m	class:folly::BenchmarkSuspender	file:
nsSpent	.\Benchmark.h	/^  static NanosecondsSpent nsSpent;$/;"	m	struct:folly::BenchmarkSuspender	access:public
nthrs	.\test\PackedSyncPtrTest.cpp	/^const int nthrs = 297;$/;"	v
nul	.\dynamic.h	/^    void* nul;$/;"	m	union:folly::dynamic::Data	access:public
numBuckets	.\stats\BucketedTimeSeries.h	/^  size_t numBuckets() const {$/;"	f	class:folly::BucketedTimeSeries	access:public	signature:() const
numBuckets	.\stats\MultiLevelTimeSeries.h	/^  size_t numBuckets() const {$/;"	f	class:folly::MultiLevelTimeSeries	access:public	signature:() const
numBuckets	.\test\TimeseriesTest.cpp	/^  size_t numBuckets;$/;"	m	struct:TestData	file:	access:public
numCachesByLevel	.\detail\CacheLocality.h	/^  std::vector<size_t> numCachesByLevel;$/;"	m	struct:folly::detail::CacheLocality	access:public
numCpus	.\detail\CacheLocality.h	/^  size_t numCpus;$/;"	m	struct:folly::detail::CacheLocality	access:public
numEntries_	.\AtomicHashArray.h	/^  ThreadCachedInt<int64_t> numEntries_;  \/\/ Successful key inserts$/;"	m	class:folly::AtomicHashArray	access:private
numErases_	.\AtomicHashArray.h	/^  std::atomic<int64_t> numErases_;   \/\/ Successful key erases$/;"	m	class:folly::AtomicHashArray	access:private
numInstances	.\test\ProducerConsumerQueueTest.cpp	/^  static int numInstances;$/;"	m	struct:__anon128::DtorChecker	file:	access:public
numInstances	.\test\ProducerConsumerQueueTest.cpp	/^int DtorChecker::numInstances = 0;$/;"	m	class:__anon128::DtorChecker	file:
numLevels	.\stats\MultiLevelTimeSeries.h	/^  size_t numLevels() const { return levels_.size(); }$/;"	f	class:folly::MultiLevelTimeSeries	access:public	signature:() const
numLowerBits	.\experimental\EliasFanoCoding.h	/^  uint8_t numLowerBits = 0;$/;"	m	struct:folly::compression::EliasFanoCompressedList	access:public
numMapsAllocated_	.\AtomicHashMap.h	/^  std::atomic<uint32_t> numMapsAllocated_;$/;"	m	class:folly::AtomicHashMap	access:private
numOpsPerThread	.\test\AtomicHashMapTest.cpp	/^int numOpsPerThread = 0;$/;"	m	namespace:__anon105	file:
numPendingEntries_	.\AtomicHashArray.h	/^  ThreadCachedInt<int64_t> numPendingEntries_; \/\/ Used by insertInternal$/;"	m	class:folly::AtomicHashArray	access:private
numStripes	.\detail\CacheLocality.h	/^  size_t numStripes() const {$/;"	f	struct:folly::detail::AccessSpreader	access:public	signature:() const
numStripes_	.\detail\CacheLocality.h	/^  size_t numStripes_;$/;"	m	struct:folly::detail::AccessSpreader	access:private
numSubMaps	.\AtomicHashMap.h	/^  int numSubMaps() const {$/;"	f	class:folly::AtomicHashMap	access:public	signature:() const
numThreads	.\experimental\wangle\concurrent\ThreadPoolExecutor.cpp	/^size_t ThreadPoolExecutor::numThreads() {$/;"	f	class:folly::wangle::ThreadPoolExecutor	signature:()
numThreads	.\experimental\wangle\concurrent\ThreadPoolExecutor.h	/^  size_t numThreads();$/;"	p	class:folly::wangle::ThreadPoolExecutor	access:public	signature:()
numUpdates_	.\ThreadCachedInt.h	/^    mutable uint32_t numUpdates_;$/;"	m	struct:folly::ThreadCachedInt::IntCache	access:public
num_bufs	.\io\test\NetworkBenchmark.cpp	/^size_t num_bufs = 0;$/;"	v
number	.\experimental\symbolizer\SignalHandler.cpp	/^  int number;$/;"	m	struct:folly::symbolizer::__anon36::__anon37	file:	access:public
numericOp	.\dynamic-inl.h	/^  dynamic numericOp(dynamic const& a, dynamic const& b) {$/;"	f	namespace:folly::detail	signature:(dynamic const& a, dynamic const& b)
o_	.\dynamic-inl.h	/^  const dynamic::ObjectImpl* o_;$/;"	m	struct:folly::dynamic::IterableProxy	access:private
obj_	.\wangle\OpaqueCallbackShunt.h	/^  T obj_;$/;"	m	class:folly::wangle::OpaqueCallbackLaterShunt	access:private
obj_	.\wangle\OpaqueCallbackShunt.h	/^  T obj_;$/;"	m	class:folly::wangle::OpaqueCallbackShunt	access:private
object	.\dynamic-inl.h	/^dynamic::object(dynamic const& a, dynamic const& b) {$/;"	f	class:folly::dynamic	signature:(dynamic const& a, dynamic const& b)
object	.\dynamic-inl.h	/^inline dynamic::ObjectMaker dynamic::object() { return ObjectMaker(); }$/;"	f	class:folly::dynamic	signature:()
object	.\dynamic-inl.h	/^inline dynamic::ObjectMaker dynamic::object(dynamic const& a, dynamic&& b) {$/;"	f	class:folly::dynamic	signature:(dynamic const& a, dynamic&& b)
object	.\dynamic-inl.h	/^inline dynamic::ObjectMaker dynamic::object(dynamic&& a, dynamic const& b) {$/;"	f	class:folly::dynamic	signature:(dynamic&& a, dynamic const& b)
object	.\dynamic-inl.h	/^inline dynamic::ObjectMaker dynamic::object(dynamic&& a, dynamic&& b) {$/;"	f	class:folly::dynamic	signature:(dynamic&& a, dynamic&& b)
object	.\dynamic.h	/^  static ObjectMaker object();$/;"	p	struct:folly::dynamic	access:public	signature:()
object	.\dynamic.h	/^  static ObjectMaker object(dynamic const&, dynamic const&);$/;"	p	struct:folly::dynamic	access:public	signature:(dynamic const&, dynamic const&)
object	.\dynamic.h	/^  static ObjectMaker object(dynamic const&, dynamic&&);$/;"	p	struct:folly::dynamic	access:public	signature:(dynamic const&, dynamic&&)
object	.\dynamic.h	/^  static ObjectMaker object(dynamic&&, dynamic const&);$/;"	p	struct:folly::dynamic	access:public	signature:(dynamic&&, dynamic const&)
object	.\dynamic.h	/^  static ObjectMaker object(dynamic&&, dynamic&&);$/;"	p	struct:folly::dynamic	access:public	signature:(dynamic&&, dynamic&&)
objectBuffer	.\dynamic.h	/^    >::type objectBuffer;$/;"	m	union:folly::dynamic::Data	access:public
observerSampleCount_	.\io\async\EventBase.h	/^  uint32_t observerSampleCount_;$/;"	m	class:folly::EventBase	access:private
observer_	.\io\async\EventBase.h	/^  std::shared_ptr<EventBaseObserver> observer_;$/;"	m	class:folly::EventBase	access:private
octal_values	.\build\generate_format_tables.py	/^def octal_values():$/;"	f	access:public
odd	.\gen\test\CombineTest.cpp	/^auto odd = [](int i) -> bool { return i % 2 == 1; };$/;"	v
offset	.\test\ChecksumTest.cpp	/^  size_t offset;$/;"	m	struct:__anon112::ExpectedResult	file:	access:public
offset_	.\AtomicHashArray-inl.h	/^  size_t offset_;$/;"	m	struct:folly::AtomicHashArray::aha_iterator	access:private
offset_	.\io\Cursor.h	/^  size_t offset_;$/;"	m	class:folly::io::detail::CursorBase	access:protected
offset_	.\test\FileUtilTest.cpp	/^  off_t offset_;$/;"	m	class:folly::test::__anon117::Reader	file:	access:private
okToDelete	.\ConcurrentSkipList.h	/^  static bool okToDelete(NodeType *candidate, int layer) {$/;"	f	class:folly::ConcurrentSkipList	access:private	signature:(NodeType *candidate, int layer)
oldAction	.\experimental\symbolizer\SignalHandler.cpp	/^  struct sigaction oldAction;$/;"	m	struct:folly::symbolizer::__anon36::__anon37	typeref:struct:folly::symbolizer::__anon36::__anon37::sigaction	file:	access:public
oldBusyLeftover_	.\io\async\EventBase.h	/^    int64_t oldBusyLeftover_;$/;"	m	class:folly::EventBase::SmoothLoopTime	access:private
oldctx_	.\io\async\Request.h	/^  std::shared_ptr<RequestContext> oldctx_;$/;"	m	class:folly::RequestContextGuard	access:private
onCompleted	.\experimental\io\AsyncIO.cpp	/^void AsyncIOQueue::onCompleted(AsyncIOOp* op) {$/;"	f	class:folly::AsyncIOQueue	signature:(AsyncIOOp* op)
onCompleted	.\experimental\io\AsyncIO.h	/^  void onCompleted(AsyncIOOp* op);$/;"	p	class:folly::AsyncIOQueue	access:private	signature:(AsyncIOOp* op)
onConnectionAdded	.\experimental\wangle\ConnectionManager.h	/^    virtual void onConnectionAdded(const ConnectionManager& cm) = 0;$/;"	p	class:folly::wangle::ConnectionManager::Callback	access:public	signature:(const ConnectionManager& cm)
onConnectionRemoved	.\experimental\wangle\ConnectionManager.h	/^    virtual void onConnectionRemoved(const ConnectionManager& cm) = 0;$/;"	p	class:folly::wangle::ConnectionManager::Callback	access:public	signature:(const ConnectionManager& cm)
onDestructionCallbacks_	.\io\async\EventBase.h	/^  LoopCallbackList onDestructionCallbacks_;$/;"	m	class:folly::EventBase	access:private
onEmpty	.\experimental\wangle\ConnectionManager.h	/^    virtual void onEmpty(const ConnectionManager& cm) = 0;$/;"	p	class:folly::wangle::ConnectionManager::Callback	access:public	signature:(const ConnectionManager& cm)
onForkChild	.\detail\ThreadLocalDetail.h	/^  static void onForkChild(void) {$/;"	f	struct:folly::threadlocal_detail::StaticMeta	access:public	signature:(void)
onForkParent	.\detail\ThreadLocalDetail.h	/^  static void onForkParent(void) {$/;"	f	struct:folly::threadlocal_detail::StaticMeta	access:public	signature:(void)
onThreadExit	.\detail\ThreadLocalDetail.h	/^  static void onThreadExit(void* ptr) {$/;"	f	struct:folly::threadlocal_detail::StaticMeta	access:public	signature:(void* ptr)
one	.\experimental\Bits.h	/^  static constexpr UnderlyingType one = UnderlyingType(1);$/;"	m	struct:folly::Bits	access:private
oneIn	.\Random.h	/^  static bool oneIn(uint32_t n, ValidRNG<RNG> rng = RNG()) {$/;"	f	class:folly::Random	access:public	signature:(uint32_t n, ValidRNG<RNG> rng = RNG())
one_	.\detail\BitIteratorDetail.h	/^  const static Value one_ = 1;$/;"	m	class:folly::bititerator_detail::BitReference	access:private
ones	.\experimental\Bits.h	/^  static constexpr UnderlyingType ones(size_t count) {$/;"	f	struct:folly::Bits	access:private	signature:(size_t count)
op_	.\gen\Base-inl.h	/^  Operators op_;$/;"	m	class:folly::gen::detail::Composer	access:private
opcodeBase_	.\experimental\symbolizer\Dwarf.h	/^    uint8_t opcodeBase_;$/;"	m	class:folly::symbolizer::Dwarf::LineNumberVM	access:private
open	.\experimental\symbolizer\Elf.cpp	/^void ElfFile::open(const char* name, bool readOnly) {$/;"	f	class:folly::symbolizer::ElfFile	signature:(const char* name, bool readOnly)
open	.\experimental\symbolizer\Elf.h	/^  void open(const char* name, bool readOnly=true);$/;"	p	class:folly::symbolizer::ElfFile	access:public	signature:(const char* name, bool readOnly=true)
openConsumer	.\gen\Parallel-inl.h	/^  void openConsumer() { ++consumers_; }$/;"	f	class:folly::gen::detail::ClosableMPMCQueue	access:public	signature:()
openNoInt	.\FileUtil.cpp	/^int openNoInt(const char* name, int flags, mode_t mode) {$/;"	f	namespace:folly	signature:(const char* name, int flags, mode_t mode)
openNoInt	.\FileUtil.h	/^int openNoInt(const char* name, int flags, mode_t mode = 0666);$/;"	p	namespace:folly	signature:(const char* name, int flags, mode_t mode = 0666)
openProducer	.\gen\Parallel-inl.h	/^  void openProducer() { ++producers_; }$/;"	f	class:folly::gen::detail::ClosableMPMCQueue	access:public	signature:()
operator !=	.\ExceptionWrapper.h	/^  bool operator!=(const exception_wrapper& a) const {$/;"	f	class:folly::exception_wrapper	access:public	signature:(const exception_wrapper& a) const
operator !=	.\LifoSem.h	/^  inline constexpr bool operator!= (const LifoSemHead& rhs) const {$/;"	f	class:folly::detail::LifoSemHead	access:public	signature:(const LifoSemHead& rhs) const
operator !=	.\Memory.h	/^  bool operator!=(const StlAllocator<Alloc, T>& other) const {$/;"	f	class:folly::StlAllocator	access:public	signature:(const StlAllocator<Alloc, T>& other) const
operator !=	.\Memory.h	/^  bool operator!=(const StlAllocator<Alloc, void>& other) const {$/;"	f	class:folly::StlAllocator	access:public	signature:(const StlAllocator<Alloc, void>& other) const
operator !=	.\Optional.h	/^bool operator!=(const Optional<V>& a, const Optional<V>& b) {$/;"	f	namespace:folly	signature:(const Optional<V>& a, const Optional<V>& b)
operator !=	.\Optional.h	/^template<class V> bool operator!=(const Optional<V>&, const V& other) = delete;$/;"	p	namespace:folly	signature:(const Optional<V>&, const V& other)
operator !=	.\Optional.h	/^template<class V> bool operator!=(const V& other, const Optional<V>&) = delete;$/;"	p	namespace:folly	signature:(const V& other, const Optional<V>&)
operator !=	.\SocketAddress.h	/^  bool operator!=(const SocketAddress& other) const {$/;"	f	class:folly::SocketAddress	access:public	signature:(const SocketAddress& other) const
operator !=	.\io\Cursor.h	/^  bool operator!=(const Derived& other) const {$/;"	f	class:folly::io::detail::CursorBase	access:public	signature:(const Derived& other) const
operator !=	.\test\AtomicHashArrayTest.cpp	/^  bool operator!=(const MmapAllocator<T>& other) const {$/;"	f	class:MmapAllocator	access:public	signature:(const MmapAllocator<T>& other) const
operator !=	.\test\stl_tests\StlVectorTest.cpp	/^  bool operator!=(const Alloc& o) const { return !(*this == o); }$/;"	f	struct:Alloc	access:public	signature:(const Alloc& o) const
operator !=	.\wangle\WangleException.h	/^  bool operator!=(const WangleException &other) const{$/;"	f	class:folly::wangle::WangleException	access:public	signature:(const WangleException &other) const
operator %=	.\dynamic.h	/^  dynamic& operator%=(dynamic const&);$/;"	p	struct:folly::dynamic	access:public	signature:(dynamic const&)
operator &	.\test\stl_tests\StlVectorTest.cpp	/^  int operator&() const;$/;"	p	struct:Data	file:	access:private	signature:() const
operator &=	.\dynamic.h	/^  dynamic& operator&=(dynamic const&);$/;"	p	struct:folly::dynamic	access:public	signature:(dynamic const&)
operator ()	.\AtomicHashArray.h	/^    void operator()(AtomicHashArray* ptr) {$/;"	f	struct:folly::AtomicHashArray::Deleter	access:public	signature:(AtomicHashArray* ptr)
operator ()	.\EvictingCacheMap.h	/^    bool operator()(const Node& lhs, const TKey& rhs) {$/;"	f	struct:folly::EvictingCacheMap::KeyValueEqual	access:public	signature:(const Node& lhs, const TKey& rhs)
operator ()	.\EvictingCacheMap.h	/^    bool operator()(const TKey& lhs, const Node& rhs) {$/;"	f	struct:folly::EvictingCacheMap::KeyValueEqual	access:public	signature:(const TKey& lhs, const Node& rhs)
operator ()	.\EvictingCacheMap.h	/^    std::size_t operator()(const Node& node) {$/;"	f	struct:folly::EvictingCacheMap::KeyHasher	access:public	signature:(const Node& node)
operator ()	.\EvictingCacheMap.h	/^    std::size_t operator()(const TKey& key) {$/;"	f	struct:folly::EvictingCacheMap::KeyHasher	access:public	signature:(const TKey& key)
operator ()	.\Format-inl.h	/^void BaseFormatter<Derived, containerMode, Args...>::operator()(Output& out)$/;"	f	class:folly::BaseFormatter	signature:(Output& out) const
operator ()	.\Format.h	/^  void operator()(Output& out) const;$/;"	p	class:folly::BaseFormatter	access:public	signature:(Output& out) const
operator ()	.\Hash.h	/^    size_t operator()(const std::pair<T1, T2>& x) const {$/;"	f	struct:std::hash	access:public	signature:(const std::pair<T1, T2>& x) const
operator ()	.\Hash.h	/^    size_t operator()(std::tuple<Ts...> const& key) const {$/;"	f	struct:std::hash	access:public	signature:(std::tuple<Ts...> const& key) const
operator ()	.\Hash.h	/^  size_t operator()(int32_t key) const {$/;"	f	struct:folly::hasher	access:public	signature:(int32_t key) const
operator ()	.\Hash.h	/^  size_t operator()(int64_t key) const {$/;"	f	struct:folly::hasher	access:public	signature:(int64_t key) const
operator ()	.\Hash.h	/^  size_t operator()(std::tuple<Ts...> const& key) const {$/;"	f	struct:folly::TupleHasher	access:public	signature:(std::tuple<Ts...> const& key) const
operator ()	.\Hash.h	/^  size_t operator()(uint32_t key) const {$/;"	f	struct:folly::hasher	access:public	signature:(uint32_t key) const
operator ()	.\Hash.h	/^  size_t operator()(uint64_t key) const {$/;"	f	struct:folly::hasher	access:public	signature:(uint64_t key) const
operator ()	.\IPAddress.h	/^  size_t operator()(const folly::IPAddress& addr) const {$/;"	f	struct:std::hash	access:public	signature:(const folly::IPAddress& addr) const
operator ()	.\IPAddressV4.h	/^  size_t operator()(const folly::IPAddressV4 addr) const {$/;"	f	struct:std::hash	access:public	signature:(const folly::IPAddressV4 addr) const
operator ()	.\IPAddressV6.h	/^  size_t operator()(const folly::IPAddressV6& addr) const {$/;"	f	struct:std::hash	access:public	signature:(const folly::IPAddressV6& addr) const
operator ()	.\IndexedMemPool.h	/^  void operator()(typename Pool::value_type* elem) const {$/;"	f	struct:detail::IndexedMemPoolRecycler	access:public	signature:(typename Pool::value_type* elem) const
operator ()	.\Lazy.h	/^  const result_type& operator()() const {$/;"	f	struct:folly::detail::Lazy	access:public	signature:() const
operator ()	.\Lazy.h	/^  result_type& operator()() {$/;"	f	struct:folly::detail::Lazy	access:public	signature:()
operator ()	.\LifoSem.h	/^  void operator()(LifoSemNode<Handoff,Atom>* elem) const {$/;"	f	struct:folly::detail::LifoSemNodeRecycler	access:public	signature:(LifoSemNode<Handoff,Atom>* elem) const
operator ()	.\Memory.h	/^  void operator()(pointer p) const {$/;"	f	class:folly::allocator_delete	access:public	signature:(pointer p) const
operator ()	.\Random.h	/^  uint32_t operator()() {$/;"	f	class:folly::ThreadLocalPRNG	access:public	signature:()
operator ()	.\Range.h	/^  bool operator()(char lhs, char rhs) const {$/;"	f	struct:folly::AsciiCaseInsensitive	access:public	signature:(char lhs, char rhs) const
operator ()	.\Range.h	/^  bool operator()(char lhs, char rhs) const {$/;"	f	struct:folly::AsciiCaseSensitive	access:public	signature:(char lhs, char rhs) const
operator ()	.\Range.h	/^  std::size_t operator()(const StringPiece& str) const {$/;"	f	struct:folly::StringPieceHash	access:public	signature:(const StringPiece& str) const
operator ()	.\SocketAddress.h	/^  size_t operator()($/;"	f	struct:std::hash	access:public	signature:( const folly::SocketAddress& addr) const
operator ()	.\String-inl.h	/^  StringPiece operator()(StringPiece sp) const { return sp; }$/;"	f	struct:folly::detail::OutputConverter	access:public	signature:(StringPiece sp) const
operator ()	.\String-inl.h	/^  fbstring operator()(StringPiece sp) const {$/;"	f	struct:folly::detail::OutputConverter	access:public	signature:(StringPiece sp) const
operator ()	.\String-inl.h	/^  std::string operator()(StringPiece sp) const {$/;"	f	struct:folly::detail::OutputConverter	access:public	signature:(StringPiece sp) const
operator ()	.\Subprocess.h	/^      bool operator()(StringPiece s) { return !cb_(fd_, s); }$/;"	f	struct:folly::Subprocess::ReadLinesCallback::StreamSplitterCallback	access:public	signature:(StringPiece s)
operator ()	.\Subprocess.h	/^    bool operator()(int pfd, int cfd) {$/;"	f	class:folly::Subprocess::ReadLinesCallback	access:public	signature:(int pfd, int cfd)
operator ()	.\detail\DiscriminatedPtrDetail.h	/^  R operator()(size_t index, V&& visitor, void* ptr) const {$/;"	f	struct:folly::dptr_detail::ApplyConstVisitor1	access:public	signature:(size_t index, V&& visitor, void* ptr) const
operator ()	.\detail\DiscriminatedPtrDetail.h	/^  R operator()(size_t index, V&& visitor, void* ptr) const {$/;"	f	struct:folly::dptr_detail::ApplyVisitor1	access:public	signature:(size_t index, V&& visitor, void* ptr) const
operator ()	.\dynamic-inl.h	/^  ObjectMaker&& operator()(dynamic const& key, dynamic val) {$/;"	f	struct:folly::dynamic::ObjectMaker	access:public	signature:(dynamic const& key, dynamic val)
operator ()	.\dynamic-inl.h	/^  ObjectMaker&& operator()(dynamic&& key, dynamic val) {$/;"	f	struct:folly::dynamic::ObjectMaker	access:public	signature:(dynamic&& key, dynamic val)
operator ()	.\dynamic-inl.h	/^  size_t operator()(::folly::dynamic const& d) const {$/;"	f	struct:std::hash	access:public	signature:(::folly::dynamic const& d) const
operator ()	.\experimental\Singleton.h	/^  size_t operator()(const TypeDescriptor& ti) const {$/;"	f	class:folly::detail::TypeDescriptorHasher	access:public	signature:(const TypeDescriptor& ti) const
operator ()	.\gen\Base-inl.h	/^  Composed operator()(Predicate pred) const {$/;"	f	class:folly::gen::detail::Any	access:public	signature:(Predicate pred) const
operator ()	.\gen\Base-inl.h	/^  Cycle operator()(off_t limit) const {$/;"	f	class:folly::gen::detail::Cycle	access:public	signature:(off_t limit) const
operator ()	.\gen\Base-inl.h	/^  Ret operator()(Source&& source) const {$/;"	f	class:folly::gen::detail::Composer	access:public	signature:(Source&& source) const
operator ()	.\gen\Base.h	/^  Dest operator()(Value&& value) const {$/;"	f	class:folly::gen::Cast	access:public	signature:(Value&& value) const
operator ()	.\gen\Base.h	/^  Dest operator()(Value&& value) const {$/;"	f	class:folly::gen::To	access:public	signature:(Value&& value) const
operator ()	.\gen\Base.h	/^  FieldType& operator()(Class& x) const {$/;"	f	class:folly::gen::Field	access:public	signature:(Class& x) const
operator ()	.\gen\Base.h	/^  FieldType& operator()(Class* x) const {$/;"	f	class:folly::gen::Field	access:public	signature:(Class* x) const
operator ()	.\gen\Base.h	/^  FieldType&& operator()(Class&& x) const {$/;"	f	class:folly::gen::Field	access:public	signature:(Class&& x) const
operator ()	.\gen\Base.h	/^  Result operator()(Class& x) const {$/;"	f	class:folly::gen::MemberFunction	access:public	signature:(Class& x) const
operator ()	.\gen\Base.h	/^  Result operator()(Class&& x) const {$/;"	f	class:folly::gen::MemberFunction	access:public	signature:(Class&& x) const
operator ()	.\gen\Base.h	/^  Result operator()(Class* x) const {$/;"	f	class:folly::gen::MemberFunction	access:public	signature:(Class* x) const
operator ()	.\gen\Base.h	/^  Result operator()(const Class& x) const {$/;"	f	class:folly::gen::ConstMemberFunction	access:public	signature:(const Class& x) const
operator ()	.\gen\Base.h	/^  Result operator()(const Class* x) const {$/;"	f	class:folly::gen::ConstMemberFunction	access:public	signature:(const Class* x) const
operator ()	.\gen\Base.h	/^  StringPiece operator()(StringPiece src) const {$/;"	f	class:folly::gen::To	access:public	signature:(StringPiece src) const
operator ()	.\gen\Base.h	/^  const FieldType& operator()(const Class& x) const {$/;"	f	class:folly::gen::Field	access:public	signature:(const Class& x) const
operator ()	.\gen\Base.h	/^  const FieldType& operator()(const Class* x) const {$/;"	f	class:folly::gen::Field	access:public	signature:(const Class* x) const
operator ()	.\gen\String-inl.h	/^  TargetContainer operator()(StringPiece line) const {$/;"	f	class:folly::gen::detail::SplitTo	access:public	signature:(StringPiece line) const
operator ()	.\gen\String-inl.h	/^bool StreamSplitter<Callback>::operator()(StringPiece in) {$/;"	f	class:folly::gen::StreamSplitter	signature:(StringPiece in)
operator ()	.\gen\String.h	/^  bool operator()(StringPiece in);$/;"	p	class:folly::gen::StreamSplitter	access:public	signature:(StringPiece in)
operator ()	.\gen\test\BaseBenchmark.cpp	/^  void operator()(Yield&& yield) const {$/;"	f	struct:FibYielder	access:public	signature:(Yield&& yield) const
operator ()	.\gen\test\ParallelTest.cpp	/^  std::unique_ptr<T> operator()(T t) const {$/;"	f	struct:__anon57	access:public	signature:(T t) const
operator ()	.\io\IOBuf.cpp	/^bool IOBufEqual::operator()(const IOBuf& a, const IOBuf& b) const {$/;"	f	class:folly::IOBufEqual	signature:(const IOBuf& a, const IOBuf& b) const
operator ()	.\io\IOBuf.cpp	/^size_t IOBufHash::operator()(const IOBuf& buf) const {$/;"	f	class:folly::IOBufHash	signature:(const IOBuf& buf) const
operator ()	.\io\IOBuf.h	/^  bool operator()(const IOBuf& a, const IOBuf& b) const;$/;"	p	struct:folly::IOBufEqual	access:public	signature:(const IOBuf& a, const IOBuf& b) const
operator ()	.\io\IOBuf.h	/^  bool operator()(const std::unique_ptr<IOBuf>& a,$/;"	f	struct:folly::IOBufEqual	access:public	signature:(const std::unique_ptr<IOBuf>& a, const std::unique_ptr<IOBuf>& b) const
operator ()	.\io\IOBuf.h	/^  size_t operator()(const IOBuf& buf) const;$/;"	p	struct:folly::IOBufHash	access:public	signature:(const IOBuf& buf) const
operator ()	.\io\IOBuf.h	/^  size_t operator()(const std::unique_ptr<IOBuf>& buf) const {$/;"	f	struct:folly::IOBufHash	access:public	signature:(const std::unique_ptr<IOBuf>& buf) const
operator ()	.\io\async\DelayedDestruction.h	/^    void operator()(DelayedDestruction* dd) const {$/;"	f	class:folly::DelayedDestruction::Destructor	access:public	signature:(DelayedDestruction* dd) const
operator ()	.\json.cpp	/^  void operator()(dynamic const& v) const {$/;"	f	struct:folly::json::__anon75::Printer	access:public	signature:(dynamic const& v) const
operator ()	.\sorted_vector_types.h	/^    bool operator()(const value_type& a, const value_type& b) const {$/;"	f	struct:folly::sorted_vector_map::value_compare	access:public	signature:(const value_type& a, const value_type& b) const
operator ()	.\stats\Histogram.h	/^    ValueType operator()(const Bucket& bucket) const {$/;"	f	struct:folly::Histogram::AvgFromBucket	access:public	signature:(const Bucket& bucket) const
operator ()	.\stats\Histogram.h	/^    uint64_t operator()(const Bucket& bucket) const {$/;"	f	struct:folly::Histogram::CountFromBucket	access:public	signature:(const Bucket& bucket) const
operator ()	.\stats\TimeseriesHistogram.h	/^    ReturnType operator()(const ContainerType& bucket) const {$/;"	f	struct:folly::TimeseriesHistogram::AvgFromInterval	access:public	signature:(const ContainerType& bucket) const
operator ()	.\stats\TimeseriesHistogram.h	/^    ValueType operator()(const ContainerType& bucket) const {$/;"	f	struct:folly::TimeseriesHistogram::AvgFromLevel	access:public	signature:(const ContainerType& bucket) const
operator ()	.\stats\TimeseriesHistogram.h	/^    uint64_t operator()(const ContainerType& bucket) const {$/;"	f	struct:folly::TimeseriesHistogram::CountFromInterval	access:public	signature:(const ContainerType& bucket) const
operator ()	.\stats\TimeseriesHistogram.h	/^    uint64_t operator()(const ContainerType& bucket) const {$/;"	f	struct:folly::TimeseriesHistogram::CountFromLevel	access:public	signature:(const ContainerType& bucket) const
operator ()	.\test\ApplyTupleTest.cpp	/^  int operator()() const {$/;"	f	struct:__anon104::Func	access:public	signature:() const
operator ()	.\test\AsciiCaseInsensitiveBenchmark.cpp	/^  bool operator()(char lhs, char rhs) const {$/;"	f	struct:AsciiCaseInsensitiveLegacy	access:public	signature:(char lhs, char rhs) const
operator ()	.\test\ConcurrentSkipListTest.cpp	/^  bool operator ()($/;"	f	struct:__anon114::UniquePtrComp	access:public	signature:( const std::unique_ptr<int> &x, const std::unique_ptr<int> &y) const
operator ()	.\test\ConvTest.cpp	/^  void operator()(unsigned int n, size_t len) const {$/;"	f	struct:StringIdenticalToBM	access:public	signature:(unsigned int n, size_t len) const
operator ()	.\test\ConvTest.cpp	/^  void operator()(unsigned int n, size_t len) const {$/;"	f	struct:StringVariadicToBM	access:public	signature:(unsigned int n, size_t len) const
operator ()	.\test\DeterministicSchedule.cpp	/^  int operator()(int numActive) {$/;"	f	struct:folly::test::UniformSubset	access:public	signature:(int numActive)
operator ()	.\test\FileUtilTest.cpp	/^  ssize_t operator()(int fd, const iovec* iov, int count);$/;"	p	class:folly::test::__anon117::Reader	file:	access:public	signature:(int fd, const iovec* iov, int count)
operator ()	.\test\FileUtilTest.cpp	/^  ssize_t operator()(int fd, const iovec* iov, int count, off_t offset);$/;"	p	class:folly::test::__anon117::Reader	file:	access:public	signature:(int fd, const iovec* iov, int count, off_t offset)
operator ()	.\test\FileUtilTest.cpp	/^  ssize_t operator()(int fd, void* buf, size_t count);$/;"	p	class:folly::test::__anon117::Reader	file:	access:public	signature:(int fd, void* buf, size_t count)
operator ()	.\test\FileUtilTest.cpp	/^  ssize_t operator()(int fd, void* buf, size_t count, off_t offset);$/;"	p	class:folly::test::__anon117::Reader	file:	access:public	signature:(int fd, void* buf, size_t count, off_t offset)
operator ()	.\test\FileUtilTest.cpp	/^ssize_t Reader::operator()(int fd, const iovec* iov, int count) {$/;"	f	class:folly::test::__anon117::Reader	signature:(int fd, const iovec* iov, int count)
operator ()	.\test\FileUtilTest.cpp	/^ssize_t Reader::operator()(int fd, const iovec* iov, int count, off_t offset) {$/;"	f	class:folly::test::__anon117::Reader	signature:(int fd, const iovec* iov, int count, off_t offset)
operator ()	.\test\FileUtilTest.cpp	/^ssize_t Reader::operator()(int fd, void* buf, size_t count) {$/;"	f	class:folly::test::__anon117::Reader	signature:(int fd, void* buf, size_t count)
operator ()	.\test\FileUtilTest.cpp	/^ssize_t Reader::operator()(int fd, void* buf, size_t count, off_t offset) {$/;"	f	class:folly::test::__anon117::Reader	signature:(int fd, void* buf, size_t count, off_t offset)
operator ()	.\test\GroupVarintTest.cpp	/^  void operator()(StringPiece sp) {$/;"	f	class:__anon121::StringAppender	access:public	signature:(StringPiece sp)
operator ()	.\test\LazyTest.cpp	/^  bool operator()() const { return true ; }$/;"	f	struct:folly::CopyCount	access:public	signature:() const
operator ()	.\test\ProducerConsumerQueueTest.cpp	/^  void operator()() {$/;"	f	struct:__anon128::CorrectnessTest	access:public	signature:()
operator ()	.\test\ProducerConsumerQueueTest.cpp	/^  void operator()() {$/;"	f	struct:__anon128::PerfTest	access:public	signature:()
operator ()	.\test\ScopeGuardTest.cpp	/^  void operator()() {$/;"	f	class:MyFunctor	access:public	signature:()
operator ()	.\test\small_vector_test.cpp	/^  void operator()(int insertCount, Operation const& op) {$/;"	f	struct:__anon132::TestBasicGuarantee	access:public	signature:(int insertCount, Operation const& op)
operator ()	.\test\sorted_vector_test.cpp	/^  bool operator()(const T& a, const T& b) const {$/;"	f	struct:__anon133::less_invert	access:public	signature:(const T& a, const T& b) const
operator ()	.\test\stl_tests\StlVectorTest.cpp	/^  string operator()() {$/;"	f	struct:PrettyType	access:public	signature:()
operator *	.\ConcurrentSkipList.h	/^  value_type &operator *() const {$/;"	f	class:folly::ConcurrentSkipList::Skipper	access:public	signature:() const
operator *	.\MoveWrapper.h	/^        T& operator*()       { return value; }$/;"	f	class:folly::MoveWrapper	access:public	signature:()
operator *	.\MoveWrapper.h	/^  const T& operator*() const { return value; }$/;"	f	class:folly::MoveWrapper	access:public	signature:() const
operator *	.\Optional.h	/^        Value& operator*()       { return value(); }$/;"	f	class:folly::Optional	access:public	signature:()
operator *	.\Optional.h	/^  const Value& operator*() const { return value(); }$/;"	f	class:folly::Optional	access:public	signature:() const
operator *	.\PackedSyncPtr.h	/^  reference operator*() const { return *get(); }$/;"	f	class:folly::PackedSyncPtr	access:public	signature:() const
operator *	.\ThreadLocal.h	/^  T& operator*() const {$/;"	f	class:folly::ThreadLocal	access:public	signature:() const
operator *	.\ThreadLocal.h	/^  T& operator*() const {$/;"	f	class:folly::ThreadLocalPtr	access:public	signature:() const
operator *	.\experimental\Singleton.h	/^  T& operator*() { return *ptr(); }$/;"	f	class:folly::Singleton	access:public	signature:()
operator *	.\json.cpp	/^  int operator*() const {$/;"	f	struct:folly::json::__anon75::Input	access:public	signature:() const
operator *	.\wangle\Try.h	/^        T& operator*()       { return value(); }$/;"	f	class:folly::wangle::Try	access:public	signature:()
operator *	.\wangle\Try.h	/^  const T& operator*() const { return value(); }$/;"	f	class:folly::wangle::Try	access:public	signature:() const
operator *	.\wangle\Try.h	/^  void operator*() const { return value(); }$/;"	f	class:folly::wangle::Try	access:public	signature:() const
operator *=	.\dynamic-inl.h	/^inline dynamic& dynamic::operator*=(dynamic const& o) {$/;"	f	class:folly::dynamic	signature:(dynamic const& o)
operator *=	.\dynamic.h	/^  dynamic& operator*=(dynamic const&);$/;"	p	struct:folly::dynamic	access:public	signature:(dynamic const&)
operator +	.\ScopeGuard.h	/^operator+(ScopeGuardOnSuccess, FunctionType&& fn) {$/;"	f	namespace:folly::detail	signature:(ScopeGuardOnSuccess, FunctionType&& fn)
operator +	.\ScopeGuard.h	/^operator+(detail::ScopeGuardOnExit, FunctionType&& fn) {$/;"	f	namespace:folly::detail	signature:(detail::ScopeGuardOnExit, FunctionType&& fn)
operator +	.\ScopeGuard.h	/^operator+(detail::ScopeGuardOnFail, FunctionType&& fn) {$/;"	f	namespace:folly::detail	signature:(detail::ScopeGuardOnFail, FunctionType&& fn)
operator +	.\gen\Base-inl.h	/^  Yield operator+(Source&& source) {$/;"	f	struct:folly::gen::detail::GeneratorBuilder	access:public	signature:(Source&& source)
operator +	.\gen\Core-inl.h	/^Chain operator+(GenImpl<LeftValue, Left>&& left,$/;"	f	namespace:folly::gen	signature:(GenImpl<LeftValue, Left>&& left, GenImpl<RightValue, Right>&& right)
operator +	.\gen\Core-inl.h	/^Chain operator+(GenImpl<LeftValue, Left>&& left,$/;"	f	namespace:folly::gen	signature:(GenImpl<LeftValue, Left>&& left, const GenImpl<RightValue, Right>& right)
operator +	.\gen\Core-inl.h	/^Chain operator+(const GenImpl<LeftValue, Left>& left,$/;"	f	namespace:folly::gen	signature:(const GenImpl<LeftValue, Left>& left, GenImpl<RightValue, Right>&& right)
operator +	.\gen\Core-inl.h	/^Chain operator+(const GenImpl<LeftValue, Left>& left,$/;"	f	namespace:folly::gen	signature:(const GenImpl<LeftValue, Left>& left, const GenImpl<RightValue, Right>& right)
operator +	.\io\Cursor.h	/^  Derived operator+(size_t offset) const {$/;"	f	class:folly::io::detail::CursorBase	access:public	signature:(size_t offset) const
operator ++	.\ConcurrentSkipList.h	/^  Skipper& operator ++() {$/;"	f	class:folly::ConcurrentSkipList::Skipper	access:public	signature:()
operator ++	.\ThreadCachedInt.h	/^  ThreadCachedInt& operator++() { increment(1); return *this; }$/;"	f	class:folly::ThreadCachedInt	access:public	signature:()
operator ++	.\dynamic-inl.h	/^inline dynamic& dynamic::operator++() {$/;"	f	class:folly::dynamic	signature:()
operator ++	.\dynamic.h	/^  dynamic& operator++();$/;"	p	struct:folly::dynamic	access:public	signature:()
operator ++	.\json.cpp	/^  void operator++() {$/;"	f	struct:folly::json::__anon75::Input	access:public	signature:()
operator +=	.\ThreadCachedInt.h	/^  ThreadCachedInt& operator+=(IntT inc) { increment(inc); return *this; }$/;"	f	class:folly::ThreadCachedInt	access:public	signature:(IntT inc)
operator +=	.\detail\Stats.h	/^  Bucket& operator+=(const Bucket& o) {$/;"	f	struct:folly::detail::Bucket	access:public	signature:(const Bucket& o)
operator +=	.\dynamic-inl.h	/^inline dynamic& dynamic::operator+=(dynamic const& o) {$/;"	f	class:folly::dynamic	signature:(dynamic const& o)
operator +=	.\dynamic.h	/^  dynamic& operator+=(dynamic const&);$/;"	p	struct:folly::dynamic	access:public	signature:(dynamic const&)
operator +=	.\io\Cursor.h	/^  Derived& operator+=(size_t offset) {$/;"	f	class:folly::io::detail::CursorBase	access:public	signature:(size_t offset)
operator -	.\io\Cursor.h	/^  size_t operator-(const BufType* buf) const {$/;"	f	class:folly::io::detail::CursorBase	access:public	signature:(const BufType* buf) const
operator -	.\io\Cursor.h	/^  size_t operator-(const CursorBase& other) const {$/;"	f	class:folly::io::detail::CursorBase	access:public	signature:(const CursorBase& other) const
operator --	.\ThreadCachedInt.h	/^  ThreadCachedInt& operator--() { increment(-1); return *this; }$/;"	f	class:folly::ThreadCachedInt	access:public	signature:()
operator --	.\dynamic-inl.h	/^inline dynamic& dynamic::operator--() {$/;"	f	class:folly::dynamic	signature:()
operator --	.\dynamic.h	/^  dynamic& operator--();$/;"	p	struct:folly::dynamic	access:public	signature:()
operator -=	.\ThreadCachedInt.h	/^  ThreadCachedInt& operator-=(IntT inc) { increment(-inc); return *this; }$/;"	f	class:folly::ThreadCachedInt	access:public	signature:(IntT inc)
operator -=	.\detail\Stats.h	/^  Bucket& operator-=(const Bucket& o) {$/;"	f	struct:folly::detail::Bucket	access:public	signature:(const Bucket& o)
operator -=	.\dynamic-inl.h	/^inline dynamic& dynamic::operator-=(dynamic const& o) {$/;"	f	class:folly::dynamic	signature:(dynamic const& o)
operator -=	.\dynamic.h	/^  dynamic& operator-=(dynamic const&);$/;"	p	struct:folly::dynamic	access:public	signature:(dynamic const&)
operator ->	.\ConcurrentSkipList.h	/^  value_type *operator->() {$/;"	f	class:folly::ConcurrentSkipList::Skipper	access:public	signature:()
operator ->	.\MoveWrapper.h	/^        T* operator->()       { return &value; }$/;"	f	class:folly::MoveWrapper	access:public	signature:()
operator ->	.\MoveWrapper.h	/^  const T* operator->() const { return &value; }$/;"	f	class:folly::MoveWrapper	access:public	signature:() const
operator ->	.\Optional.h	/^        Value* operator->()       { return &value(); }$/;"	f	class:folly::Optional	access:public	signature:()
operator ->	.\Optional.h	/^  const Value* operator->() const { return &value(); }$/;"	f	class:folly::Optional	access:public	signature:() const
operator ->	.\PackedSyncPtr.h	/^  T* operator->() const { return get(); }$/;"	f	class:folly::PackedSyncPtr	access:public	signature:() const
operator ->	.\Synchronized.h	/^      ConstLockedPtr* operator->() const {$/;"	f	struct:folly::Synchronized::ConstLockedPtr::Unsynchronizer	access:public	signature:() const
operator ->	.\Synchronized.h	/^      LockedPtr* operator->() const {$/;"	f	struct:folly::Synchronized::LockedPtr::Unsynchronizer	access:public	signature:() const
operator ->	.\Synchronized.h	/^    T* operator->() {$/;"	f	struct:folly::Synchronized::LockedPtr	access:public	signature:()
operator ->	.\Synchronized.h	/^    const T* operator->() const {$/;"	f	struct:folly::Synchronized::ConstLockedPtr	access:public	signature:() const
operator ->	.\Synchronized.h	/^  ConstLockedPtr operator->() const {$/;"	f	struct:folly::Synchronized	access:public	signature:() const
operator ->	.\Synchronized.h	/^  LockedPtr operator->() {$/;"	f	struct:folly::Synchronized	access:public	signature:()
operator ->	.\ThreadLocal.h	/^  T* operator->() const {$/;"	f	class:folly::ThreadLocal	access:public	signature:() const
operator ->	.\ThreadLocal.h	/^  T* operator->() const {$/;"	f	class:folly::ThreadLocalPtr	access:public	signature:() const
operator ->	.\experimental\Singleton.h	/^  T* operator->() { return ptr(); }$/;"	f	class:folly::Singleton	access:public	signature:()
operator ->	.\wangle\Try.h	/^        T* operator->()       { return &value(); }$/;"	f	class:folly::wangle::Try	access:public	signature:()
operator ->	.\wangle\Try.h	/^  const T* operator->() const { return &value(); }$/;"	f	class:folly::wangle::Try	access:public	signature:() const
operator /=	.\dynamic-inl.h	/^inline dynamic& dynamic::operator\/=(dynamic const& o) {$/;"	f	class:folly::dynamic	signature:(dynamic const& o)
operator /=	.\dynamic.h	/^  dynamic& operator\/=(dynamic const&);$/;"	p	struct:folly::dynamic	access:public	signature:(dynamic const&)
operator <	.\FBVector.h	/^  bool operator<(const fbvector& other) const {$/;"	f	signature:(const fbvector& other) const
operator <	.\IPAddress.cpp	/^bool operator<(const IPAddress& addr1, const IPAddress& addr2) {$/;"	f	namespace:folly	signature:(const IPAddress& addr1, const IPAddress& addr2)
operator <	.\IPAddress.h	/^bool operator<(const IPAddress& addr1, const IPAddress& addr2);$/;"	p	namespace:folly	signature:(const IPAddress& addr1, const IPAddress& addr2)
operator <	.\IPAddressV4.h	/^inline bool operator<(const IPAddressV4& addr1, const IPAddressV4& addr2) {$/;"	f	namespace:folly	signature:(const IPAddressV4& addr1, const IPAddressV4& addr2)
operator <	.\IPAddressV6.h	/^inline bool operator<(const IPAddressV6& addr1, const IPAddressV6& addr2) {$/;"	f	namespace:folly	signature:(const IPAddressV6& addr1, const IPAddressV6& addr2)
operator <	.\MacAddress.h	/^  bool operator<(const MacAddress& other) const {$/;"	f	class:folly::MacAddress	access:public	signature:(const MacAddress& other) const
operator <	.\Optional.h	/^bool operator< (const Optional<V>& a, const Optional<V>& b) {$/;"	f	namespace:folly	signature:(const Optional<V>& a, const Optional<V>& b)
operator <	.\Optional.h	/^template<class V> bool operator< (const Optional<V>&, const V& other) = delete;$/;"	p	namespace:folly	signature:(const Optional<V>&, const V& other)
operator <	.\Optional.h	/^template<class V> bool operator< (const V& other, const Optional<V>&) = delete;$/;"	p	namespace:folly	signature:(const V& other, const Optional<V>&)
operator <	.\Range.h	/^inline bool operator<(const Range<T>& lhs, const Range<T>& rhs) {$/;"	f	namespace:folly	signature:(const Range<T>& lhs, const Range<T>& rhs)
operator <	.\Range.h	/^operator<(const T& lhs, const U& rhs) {$/;"	f	namespace:folly	signature:(const T& lhs, const U& rhs)
operator <	.\SocketAddress.cpp	/^bool SocketAddress::operator<(const SocketAddress& other) const {$/;"	f	class:folly::SocketAddress	signature:(const SocketAddress& other) const
operator <	.\SocketAddress.h	/^  bool operator<(const SocketAddress& other) const;$/;"	p	class:folly::SocketAddress	access:public	signature:(const SocketAddress& other) const
operator <	.\Subprocess.h	/^    bool operator<(const PipeInfo& other) const {$/;"	f	struct:folly::Subprocess::PipeInfo	access:public	signature:(const PipeInfo& other) const
operator <	.\dynamic-inl.h	/^inline bool dynamic::operator<(dynamic const& o) const {$/;"	f	class:folly::dynamic	signature:(dynamic const& o) const
operator <	.\dynamic.h	/^  bool operator<(dynamic const& o) const;$/;"	p	struct:folly::dynamic	access:public	signature:(dynamic const& o) const
operator <	.\experimental\io\HugePages.h	/^inline bool operator<(const HugePageSize& a, const HugePageSize& b) {$/;"	f	namespace:folly	signature:(const HugePageSize& a, const HugePageSize& b)
operator <	.\experimental\symbolizer\ElfCache.h	/^    bool operator<(const Path& other) const {$/;"	f	class:folly::symbolizer::SignalSafeElfCache::Path	access:public	signature:(const Path& other) const
operator <	.\small_vector.h	/^  bool operator<(small_vector const& o) const {$/;"	f	class:folly::small_vector	access:public	signature:(small_vector const& o) const
operator <	.\sorted_vector_types.h	/^  bool operator<(const sorted_vector_map& other) const {$/;"	f	class:folly::sorted_vector_map	access:public	signature:(const sorted_vector_map& other) const
operator <	.\sorted_vector_types.h	/^  bool operator<(const sorted_vector_set& other) const {$/;"	f	class:folly::sorted_vector_set	access:public	signature:(const sorted_vector_set& other) const
operator <	.\test\sorted_vector_test.cpp	/^  bool operator<(const CountCopyCtor& o) const {$/;"	f	struct:__anon133::CountCopyCtor	access:public	signature:(const CountCopyCtor& o) const
operator <	.\wangle\ManualExecutor.h	/^      bool operator<(ScheduledAction const& b) const {$/;"	f	struct:folly::wangle::ManualExecutor::ScheduledAction	access:public	signature:(ScheduledAction const& b) const
operator <<	.\IPAddress.cpp	/^ostream& operator<<(ostream& os, const IPAddress& addr) {$/;"	f	namespace:folly	signature:(ostream& os, const IPAddress& addr)
operator <<	.\IPAddress.h	/^std::ostream& operator<<(std::ostream& os, const IPAddress& addr);$/;"	p	namespace:folly	signature:(std::ostream& os, const IPAddress& addr)
operator <<	.\IPAddressV4.cpp	/^ostream& operator<<(ostream& os, const IPAddressV4& addr) {$/;"	f	namespace:folly	signature:(ostream& os, const IPAddressV4& addr)
operator <<	.\IPAddressV4.h	/^std::ostream& operator<<(std::ostream& os, const IPAddressV4& addr);$/;"	p	namespace:folly	signature:(std::ostream& os, const IPAddressV4& addr)
operator <<	.\IPAddressV6.cpp	/^ostream& operator<<(ostream& os, const IPAddressV6& addr) {$/;"	f	namespace:folly	signature:(ostream& os, const IPAddressV6& addr)
operator <<	.\IPAddressV6.h	/^std::ostream& operator<<(std::ostream& os, const IPAddressV6& addr);$/;"	p	namespace:folly	signature:(std::ostream& os, const IPAddressV6& addr)
operator <<	.\MacAddress.cpp	/^std::ostream& operator<<(std::ostream& os, MacAddress address) {$/;"	f	namespace:folly	signature:(std::ostream& os, MacAddress address)
operator <<	.\MacAddress.h	/^std::ostream& operator<<(std::ostream& os, MacAddress address);$/;"	p	namespace:folly	signature:(std::ostream& os, MacAddress address)
operator <<	.\Range.cpp	/^std::ostream& operator<<(std::ostream& os, const MutableStringPiece& piece) {$/;"	f	namespace:folly	signature:(std::ostream& os, const MutableStringPiece& piece)
operator <<	.\Range.cpp	/^std::ostream& operator<<(std::ostream& os, const StringPiece& piece) {$/;"	f	namespace:folly	signature:(std::ostream& os, const StringPiece& piece)
operator <<	.\Range.h	/^std::ostream& operator<<(std::ostream& os, const MutableStringPiece& piece);$/;"	p	namespace:folly	signature:(std::ostream& os, const MutableStringPiece& piece)
operator <<	.\Range.h	/^std::ostream& operator<<(std::ostream& os, const StringPiece& piece);$/;"	p	namespace:folly	signature:(std::ostream& os, const StringPiece& piece)
operator <<	.\SocketAddress.cpp	/^std::ostream& operator<<(std::ostream& os, const SocketAddress& addr) {$/;"	f	namespace:folly	signature:(std::ostream& os, const SocketAddress& addr)
operator <<	.\SocketAddress.h	/^std::ostream& operator<<(std::ostream& os, const SocketAddress& addr);$/;"	p	namespace:folly	signature:(std::ostream& os, const SocketAddress& addr)
operator <<	.\dynamic-inl.h	/^inline std::ostream& operator<<(std::ostream& out, dynamic const& d) {$/;"	f	namespace:folly	signature:(std::ostream& out, dynamic const& d)
operator <<	.\dynamic.h	/^  friend std::ostream& operator<<(std::ostream&, dynamic const&);$/;"	p	struct:folly::dynamic	access:friend	signature:(std::ostream&, dynamic const&)
operator <<	.\experimental\exception_tracer\ExceptionTracer.cpp	/^std::ostream& operator<<(std::ostream& out, const ExceptionInfo& info) {$/;"	f	namespace:folly::exception_tracer	signature:(std::ostream& out, const ExceptionInfo& info)
operator <<	.\experimental\exception_tracer\ExceptionTracer.h	/^std::ostream& operator<<(std::ostream& out, const ExceptionInfo& info);$/;"	p	namespace:folly::exception_tracer	signature:(std::ostream& out, const ExceptionInfo& info)
operator <<	.\experimental\io\AsyncIO.cpp	/^std::ostream& operator<<(std::ostream& os, AsyncIOOp::State state) {$/;"	f	namespace:folly	signature:(std::ostream& os, AsyncIOOp::State state)
operator <<	.\experimental\io\AsyncIO.cpp	/^std::ostream& operator<<(std::ostream& os, const AsyncIOOp& op) {$/;"	f	namespace:folly	signature:(std::ostream& os, const AsyncIOOp& op)
operator <<	.\experimental\io\AsyncIO.cpp	/^std::ostream& operator<<(std::ostream& os, const iocb& cb) {$/;"	f	namespace:folly::__anon28	signature:(std::ostream& os, const iocb& cb)
operator <<	.\experimental\io\AsyncIO.h	/^  friend std::ostream& operator<<(std::ostream& stream, const AsyncIOOp& o);$/;"	p	class:folly::AsyncIOOp	access:friend	signature:(std::ostream& stream, const AsyncIOOp& o)
operator <<	.\experimental\io\AsyncIO.h	/^std::ostream& operator<<(std::ostream& stream, AsyncIOOp::State state);$/;"	p	namespace:folly	signature:(std::ostream& stream, AsyncIOOp::State state)
operator <<	.\experimental\io\AsyncIO.h	/^std::ostream& operator<<(std::ostream& stream, const AsyncIOOp& o);$/;"	p	namespace:folly	signature:(std::ostream& stream, const AsyncIOOp& o)
operator <<	.\experimental\symbolizer\Dwarf.h	/^inline std::ostream& operator<<(std::ostream& out, const Dwarf::Path& path) {$/;"	f	namespace:folly::symbolizer	signature:(std::ostream& out, const Dwarf::Path& path)
operator <<	.\experimental\wangle\ManagedConnection.cpp	/^operator<<(std::ostream& os, const ManagedConnection& conn) {$/;"	f	namespace:folly::wangle	signature:(std::ostream& os, const ManagedConnection& conn)
operator <<	.\experimental\wangle\ManagedConnection.h	/^std::ostream& operator<<(std::ostream& os, const ManagedConnection& conn);$/;"	p	namespace:folly::wangle	signature:(std::ostream& os, const ManagedConnection& conn)
operator <<	.\gen\test\BaseTest.cpp	/^ostream& operator<<(ostream& os, const pair<A, B>& pair) {$/;"	f	signature:(ostream& os, const pair<A, B>& pair)
operator <<	.\gen\test\BaseTest.cpp	/^ostream& operator<<(ostream& os, const set<T>& values) {$/;"	f	signature:(ostream& os, const set<T>& values)
operator <<	.\gen\test\BaseTest.cpp	/^ostream& operator<<(ostream& os, const vector<T>& values) {$/;"	f	signature:(ostream& os, const vector<T>& values)
operator <<	.\test\OptionalTest.cpp	/^std::ostream& operator<<(std::ostream& os, const Optional<V>& v) {$/;"	f	namespace:folly	signature:(std::ostream& os, const Optional<V>& v)
operator <=	.\Optional.h	/^bool operator<=(const Optional<V>& a, const Optional<V>& b) {$/;"	f	namespace:folly	signature:(const Optional<V>& a, const Optional<V>& b)
operator <=	.\Optional.h	/^template<class V> bool operator<=(const Optional<V>&, const V& other) = delete;$/;"	p	namespace:folly	signature:(const Optional<V>&, const V& other)
operator <=	.\Optional.h	/^template<class V> bool operator<=(const V& other, const Optional<V>&) = delete;$/;"	p	namespace:folly	signature:(const V& other, const Optional<V>&)
operator <=	.\Range.h	/^operator<=(const T& lhs, const U& rhs) {$/;"	f	namespace:folly	signature:(const T& lhs, const U& rhs)
operator =	.\Arena.h	/^  Arena& operator=(Arena&&) = default;$/;"	p	class:folly::Arena	access:private	signature:(Arena&&)
operator =	.\Arena.h	/^  Arena& operator=(const Arena&) = delete;$/;"	p	class:folly::Arena	access:private	signature:(const Arena&)
operator =	.\AtomicStruct.h	/^  AtomicStruct<T>& operator= (AtomicStruct<T> const &) = delete;$/;"	p	class:folly::AtomicStruct	access:public	signature:(AtomicStruct<T> const &)
operator =	.\Benchmark.h	/^  BenchmarkSuspender& operator=(BenchmarkSuspender && rhs) {$/;"	f	struct:folly::BenchmarkSuspender	access:public	signature:(BenchmarkSuspender && rhs)
operator =	.\Benchmark.h	/^  BenchmarkSuspender& operator=(const BenchmarkSuspender &) = delete;$/;"	p	struct:folly::BenchmarkSuspender	access:public	signature:(const BenchmarkSuspender &)
operator =	.\ConcurrentSkipList.h	/^  Accessor& operator=(const Accessor &accessor) {$/;"	f	class:folly::ConcurrentSkipList::Accessor	access:public	signature:(const Accessor &accessor)
operator =	.\DiscriminatedPtr.h	/^  DiscriminatedPtr& operator=(T* ptr) {$/;"	f	class:folly::DiscriminatedPtr	access:public	signature:(T* ptr)
operator =	.\FBVector.h	/^  fbvector& operator=(const fbvector& other) {$/;"	f	signature:(const fbvector& other)
operator =	.\FBVector.h	/^  fbvector& operator=(fbvector&& other) {$/;"	f	signature:(fbvector&& other)
operator =	.\FBVector.h	/^  fbvector& operator=(std::initializer_list<T> il) {$/;"	f	signature:(std::initializer_list<T> il)
operator =	.\File.cpp	/^File& File::operator=(File&& other) {$/;"	f	class:folly::File	signature:(File&& other)
operator =	.\File.h	/^  File& operator=(File&&);$/;"	p	class:folly::File	access:public	signature:(File&&)
operator =	.\File.h	/^  File& operator=(const File&) = delete;$/;"	p	class:folly::File	access:private	signature:(const File&)
operator =	.\Format.h	/^  BaseFormatter& operator=(BaseFormatter&&) = default;$/;"	p	signature:(BaseFormatter&&)
operator =	.\Format.h	/^  BaseFormatter& operator=(const BaseFormatter&) = delete;$/;"	p	signature:(const BaseFormatter&)
operator =	.\IPAddress.cpp	/^IPAddress& IPAddress::operator=(const IPAddressV4& ipv4_addr) {$/;"	f	class:folly::IPAddress	signature:(const IPAddressV4& ipv4_addr)
operator =	.\IPAddress.cpp	/^IPAddress& IPAddress::operator=(const IPAddressV6& ipv6_addr) {$/;"	f	class:folly::IPAddress	signature:(const IPAddressV6& ipv6_addr)
operator =	.\IPAddress.h	/^  IPAddress& operator=(const IPAddressV4& ipV4Addr);$/;"	p	class:folly::IPAddress	access:public	signature:(const IPAddressV4& ipV4Addr)
operator =	.\IPAddress.h	/^  IPAddress& operator=(const IPAddressV6& ipV6Addr);$/;"	p	class:folly::IPAddress	access:public	signature:(const IPAddressV6& ipV6Addr)
operator =	.\Lazy.h	/^  Lazy& operator=(Lazy&&) = delete;$/;"	p	struct:folly::detail::Lazy	access:public	signature:(Lazy&&)
operator =	.\Lazy.h	/^  Lazy& operator=(const Lazy&) = delete;$/;"	p	struct:folly::detail::Lazy	access:public	signature:(const Lazy&)
operator =	.\MPMCQueue.h	/^  MPMCQueue<T,Atom> const& operator= (MPMCQueue<T,Atom>&& rhs) {$/;"	f	class:folly::MPMCQueue	access:public	signature:(MPMCQueue<T,Atom>&& rhs)
operator =	.\MemoryMapping.cpp	/^MemoryMapping& MemoryMapping::operator=(MemoryMapping other) {$/;"	f	class:folly::MemoryMapping	signature:(MemoryMapping other)
operator =	.\MemoryMapping.h	/^  MemoryMapping& operator=(MemoryMapping);$/;"	p	class:folly::MemoryMapping	access:public	signature:(MemoryMapping)
operator =	.\MoveWrapper.h	/^  MoveWrapper& operator=(MoveWrapper const&) = delete;$/;"	p	class:folly::MoveWrapper	access:public	signature:(MoveWrapper const&)
operator =	.\MoveWrapper.h	/^  MoveWrapper& operator=(MoveWrapper&&) = delete;$/;"	p	class:folly::MoveWrapper	access:public	signature:(MoveWrapper&&)
operator =	.\Optional.h	/^  Optional& operator=(Arg&& arg) {$/;"	f	class:folly::Optional	access:public	signature:(Arg&& arg)
operator =	.\Padded.h	/^  Adaptor& operator=(Adaptor&& other) {$/;"	f	class:folly::Adaptor	access:public	signature:(Adaptor&& other)
operator =	.\Padded.h	/^  Adaptor& operator=(const Adaptor&) = default;$/;"	p	class:folly::Adaptor	access:public	signature:(const Adaptor&)
operator =	.\RWSpinLock.h	/^    ReadHolder& operator=(ReadHolder&& other) {$/;"	f	class:folly::RWSpinLock::ReadHolder	access:public	signature:(ReadHolder&& other)
operator =	.\RWSpinLock.h	/^    UpgradedHolder& operator =(UpgradedHolder&& other) {$/;"	f	class:folly::RWSpinLock::UpgradedHolder	access:public	signature:(UpgradedHolder&& other)
operator =	.\RWSpinLock.h	/^    WriteHolder& operator =(WriteHolder&& other) {$/;"	f	class:folly::RWSpinLock::WriteHolder	access:public	signature:(WriteHolder&& other)
operator =	.\SocketAddress.h	/^  SocketAddress& operator=(SocketAddress&& addr) {$/;"	f	class:folly::SocketAddress	access:public	signature:(SocketAddress&& addr)
operator =	.\SocketAddress.h	/^  SocketAddress& operator=(const SocketAddress& addr) {$/;"	f	class:folly::SocketAddress	access:public	signature:(const SocketAddress& addr)
operator =	.\Synchronized.h	/^      Unsynchronizer& operator=(const Unsynchronizer&) = delete;$/;"	p	struct:folly::Synchronized::ConstLockedPtr::Unsynchronizer	access:public	signature:(const Unsynchronizer&)
operator =	.\Synchronized.h	/^      Unsynchronizer& operator=(const Unsynchronizer&) = delete;$/;"	p	struct:folly::Synchronized::LockedPtr::Unsynchronizer	access:public	signature:(const Unsynchronizer&)
operator =	.\Synchronized.h	/^    ConstLockedPtr& operator=(const ConstLockedPtr& rhs) {$/;"	f	struct:folly::Synchronized::ConstLockedPtr	access:public	signature:(const ConstLockedPtr& rhs)
operator =	.\Synchronized.h	/^    LockedPtr& operator=(const LockedPtr& rhs) {$/;"	f	struct:folly::Synchronized::LockedPtr	access:public	signature:(const LockedPtr& rhs)
operator =	.\Synchronized.h	/^  Synchronized& operator=(Synchronized&& rhs) {$/;"	f	struct:folly::Synchronized	access:public	signature:(Synchronized&& rhs)
operator =	.\Synchronized.h	/^  Synchronized& operator=(T&& rhs) {$/;"	f	struct:folly::Synchronized	access:public	signature:(T&& rhs)
operator =	.\Synchronized.h	/^  Synchronized& operator=(const Synchronized& rhs) {$/;"	f	struct:folly::Synchronized	access:public	signature:(const Synchronized& rhs)
operator =	.\Synchronized.h	/^  Synchronized& operator=(const T& rhs) {$/;"	f	struct:folly::Synchronized	access:public	signature:(const T& rhs)
operator =	.\ThreadCachedArena.h	/^  ThreadCachedArena& operator=(ThreadCachedArena&&) = delete;$/;"	p	class:folly::ThreadCachedArena	access:private	signature:(ThreadCachedArena&&)
operator =	.\ThreadCachedArena.h	/^  ThreadCachedArena& operator=(const ThreadCachedArena&) = delete;$/;"	p	class:folly::ThreadCachedArena	access:private	signature:(const ThreadCachedArena&)
operator =	.\ThreadLocal.h	/^    Accessor& operator=(const Accessor&) = delete;$/;"	p	class:folly::ThreadLocalPtr::Accessor	access:public	signature:(const Accessor&)
operator =	.\ThreadLocal.h	/^  ThreadLocal& operator=(ThreadLocal&&) = default;$/;"	p	class:folly::ThreadLocal	access:public	signature:(ThreadLocal&&)
operator =	.\ThreadLocal.h	/^  ThreadLocal& operator=(const ThreadLocal&) = delete;$/;"	p	class:folly::ThreadLocal	access:private	signature:(const ThreadLocal&)
operator =	.\ThreadLocal.h	/^  ThreadLocalPtr& operator=(ThreadLocalPtr&& other) {$/;"	f	class:folly::ThreadLocalPtr	access:public	signature:(ThreadLocalPtr&& other)
operator =	.\ThreadLocal.h	/^  ThreadLocalPtr& operator=(const ThreadLocalPtr&) = delete;$/;"	p	class:folly::ThreadLocalPtr	access:private	signature:(const ThreadLocalPtr&)
operator =	.\TimeoutQueue.h	/^  TimeoutQueue& operator=(const TimeoutQueue&) = delete;$/;"	p	class:folly::TimeoutQueue	access:private	signature:(const TimeoutQueue&)
operator =	.\detail\BitIteratorDetail.h	/^  BitReference& operator=(bool b) {$/;"	f	class:folly::bititerator_detail::BitReference	access:public	signature:(bool b)
operator =	.\dynamic-inl.h	/^  ObjectMaker& operator=(ObjectMaker const&) = delete;$/;"	p	struct:folly::dynamic::ObjectMaker	access:public	signature:(ObjectMaker const&)
operator =	.\dynamic-inl.h	/^  ObjectMaker& operator=(ObjectMaker&&) = delete;$/;"	p	struct:folly::dynamic::ObjectMaker	access:public	signature:(ObjectMaker&&)
operator =	.\dynamic-inl.h	/^inline dynamic& dynamic::operator=(dynamic const& o) {$/;"	f	class:folly::dynamic	signature:(dynamic const& o)
operator =	.\dynamic-inl.h	/^inline dynamic& dynamic::operator=(dynamic&& o) {$/;"	f	class:folly::dynamic	signature:(dynamic&& o)
operator =	.\dynamic.h	/^  dynamic& operator=(dynamic const&);$/;"	p	struct:folly::dynamic	access:public	signature:(dynamic const&)
operator =	.\dynamic.h	/^  dynamic& operator=(dynamic&&);$/;"	p	struct:folly::dynamic	access:public	signature:(dynamic&&)
operator =	.\experimental\EventCount.h	/^  EventCount& operator=(EventCount&&) = delete;$/;"	p	class:folly::EventCount	access:private	signature:(EventCount&&)
operator =	.\experimental\EventCount.h	/^  EventCount& operator=(const EventCount&) = delete;$/;"	p	class:folly::EventCount	access:private	signature:(const EventCount&)
operator =	.\experimental\Singleton.h	/^    SingletonEntry& operator=(SingletonEntry&&) = delete;$/;"	p	struct:folly::SingletonVault::SingletonEntry	access:public	signature:(SingletonEntry&&)
operator =	.\experimental\Singleton.h	/^    SingletonEntry& operator=(const SingletonEntry&) = delete;$/;"	p	struct:folly::SingletonVault::SingletonEntry	access:public	signature:(const SingletonEntry&)
operator =	.\experimental\symbolizer\Elf.cpp	/^ElfFile& ElfFile::operator=(ElfFile&& other) {$/;"	f	class:folly::symbolizer::ElfFile	signature:(ElfFile&& other)
operator =	.\experimental\symbolizer\Elf.h	/^  ElfFile& operator=(ElfFile&& other);$/;"	p	class:folly::symbolizer::ElfFile	access:public	signature:(ElfFile&& other)
operator =	.\experimental\symbolizer\Elf.h	/^  ElfFile& operator=(const ElfFile&) = delete;$/;"	p	class:folly::symbolizer::ElfFile	access:private	signature:(const ElfFile&)
operator =	.\experimental\test\SingletonTest.cpp	/^  Watchdog& operator=(const Watchdog&) = delete;$/;"	p	struct:Watchdog	file:	access:public	signature:(const Watchdog&)
operator =	.\experimental\wangle\ConnectionManager.h	/^  ConnectionManager& operator=(ConnectionManager&) = delete;$/;"	p	class:folly::wangle::ConnectionManager	access:private	signature:(ConnectionManager&)
operator =	.\experimental\wangle\concurrent\CPUThreadPoolExecutor.h	/^    Task& operator=(const Task&) = default;$/;"	p	struct:folly::wangle::CPUThreadPoolExecutor::Task	access:public	signature:(const Task&)
operator =	.\gen\Base-inl.h	/^  VirtualGen& operator=(const VirtualGen& source) {$/;"	f	class:folly::gen::VirtualGen	access:public	signature:(const VirtualGen& source)
operator =	.\gen\Core-inl.h	/^  GenImpl& operator=(GenImpl&&) = default;$/;"	p	class:folly::gen::GenImpl	access:protected	signature:(GenImpl&&)
operator =	.\gen\Core-inl.h	/^  GenImpl& operator=(const GenImpl&) = default;$/;"	p	class:folly::gen::GenImpl	access:protected	signature:(const GenImpl&)
operator =	.\gen\Core-inl.h	/^  Operator& operator=(const Operator&) = default;$/;"	p	class:folly::gen::Operator	access:protected	signature:(const Operator&)
operator =	.\gen\test\BaseTest.cpp	/^  CopyCounter& operator=(CopyCounter&& source) {$/;"	f	struct:CopyCounter	access:public	signature:(CopyCounter&& source)
operator =	.\gen\test\BaseTest.cpp	/^  CopyCounter& operator=(const CopyCounter& source) {$/;"	f	struct:CopyCounter	access:public	signature:(const CopyCounter& source)
operator =	.\gen\test\BaseTest.cpp	/^  TestIntSeq& operator=(const TestIntSeq&) = delete;$/;"	p	class:__anon56::TestIntSeq	file:	access:public	signature:(const TestIntSeq&)
operator =	.\io\IOBuf.h	/^  IOBuf& operator=(IOBuf const &);$/;"	p	class:folly::IOBuf	access:private	signature:(IOBuf const &)
operator =	.\io\IOBufQueue.cpp	/^IOBufQueue& IOBufQueue::operator=(IOBufQueue&& other) {$/;"	f	class:folly::IOBufQueue	signature:(IOBufQueue&& other)
operator =	.\io\IOBufQueue.h	/^  IOBufQueue& operator=(IOBufQueue&&);$/;"	p	class:folly::IOBufQueue	access:public	signature:(IOBufQueue&&)
operator =	.\io\IOBufQueue.h	/^  IOBufQueue& operator=(const IOBufQueue&) = delete;$/;"	p	class:folly::IOBufQueue	access:private	signature:(const IOBufQueue&)
operator =	.\io\TypedIOBuf.h	/^  TypedIOBuf& operator=(TypedIOBuf&&) = default;$/;"	p	class:folly::TypedIOBuf	access:public	signature:(TypedIOBuf&&)
operator =	.\io\TypedIOBuf.h	/^  TypedIOBuf& operator=(const TypedIOBuf&) = delete;$/;"	p	class:folly::TypedIOBuf	access:private	signature:(const TypedIOBuf&)
operator =	.\io\async\HHWheelTimer.h	/^  HHWheelTimer& operator=(HHWheelTimer const &) = delete;$/;"	p	class:folly::HHWheelTimer	access:private	signature:(HHWheelTimer const &)
operator =	.\io\async\NotificationQueue.h	/^  NotificationQueue& operator=(NotificationQueue const &) = delete;$/;"	p	class:folly::NotificationQueue	access:private	signature:(NotificationQueue const &)
operator =	.\json.cpp	/^  Input& operator=(Input const&) = delete;$/;"	p	struct:folly::json::__anon75::Input	file:	access:public	signature:(Input const&)
operator =	.\small_vector.h	/^  small_vector& operator=(small_vector const& o) {$/;"	f	class:folly::small_vector	access:public	signature:(small_vector const& o)
operator =	.\small_vector.h	/^  small_vector& operator=(small_vector&& o) {$/;"	f	class:folly::small_vector	access:public	signature:(small_vector&& o)
operator =	.\test\ApplyTupleTest.cpp	/^  GuardObj& operator=(const GuardObj&) = delete;$/;"	p	struct:__anon104::GuardObj	file:	access:public	signature:(const GuardObj&)
operator =	.\test\ApplyTupleTest.cpp	/^  GuardObjBase& operator=(GuardObjBase const&) = delete;$/;"	p	struct:__anon104::GuardObjBase	file:	access:public	signature:(GuardObjBase const&)
operator =	.\test\ApplyTupleTest.cpp	/^  Mover& operator=(const Mover&) = delete;$/;"	p	struct:__anon104::Mover	file:	access:public	signature:(const Mover&)
operator =	.\test\AtomicHashMapTest.cpp	/^  Integer& operator=(const Integer& a) {$/;"	f	class:Integer	access:public	signature:(const Integer& a)
operator =	.\test\DeterministicSchedule.h	/^  DeterministicAtomic<T>& operator= (DeterministicAtomic<T> const &) = delete;$/;"	p	struct:folly::test::DeterministicAtomic	access:public	signature:(DeterministicAtomic<T> const &)
operator =	.\test\OptionalTest.cpp	/^  MoveTester& operator=(MoveTester&&) = default;$/;"	p	class:folly::MoveTester	file:	access:public	signature:(MoveTester&&)
operator =	.\test\OptionalTest.cpp	/^  MoveTester& operator=(const MoveTester&) = default;$/;"	p	class:folly::MoveTester	file:	access:public	signature:(const MoveTester&)
operator =	.\test\small_vector_test.cpp	/^  NoncopyableCounter& operator=(NoncopyableCounter const&) const = delete;$/;"	p	struct:__anon132::NoncopyableCounter	file:	access:public	signature:(NoncopyableCounter const&) const
operator =	.\test\small_vector_test.cpp	/^  NoncopyableCounter& operator=(NoncopyableCounter&&) { return *this; }$/;"	f	struct:__anon132::NoncopyableCounter	access:public	signature:(NoncopyableCounter&&)
operator =	.\test\small_vector_test.cpp	/^  NontrivialType& operator=(NontrivialType const& o) {$/;"	f	struct:__anon132::NontrivialType	access:public	signature:(NontrivialType const& o)
operator =	.\test\small_vector_test.cpp	/^  Thrower& operator=(Thrower const& other) {$/;"	f	struct:__anon132::Thrower	access:public	signature:(Thrower const& other)
operator =	.\test\stl_tests\StlVectorTest.cpp	/^  Alloc& operator=(Alloc&&) = default;$/;"	p	struct:Alloc	file:	access:public	signature:(Alloc&&)
operator =	.\test\stl_tests\StlVectorTest.cpp	/^  Alloc& operator=(const Alloc&) = default;$/;"	p	struct:Alloc	file:	access:public	signature:(const Alloc&)
operator =	.\test\stl_tests\StlVectorTest.cpp	/^  D0& operator=(D0&&) = default;$/;"	p	struct:D0	file:	access:public	signature:(D0&&)
operator =	.\test\stl_tests\StlVectorTest.cpp	/^  D0& operator=(const D0&) = default;$/;"	p	struct:D0	file:	access:public	signature:(const D0&)
operator =	.\test\stl_tests\StlVectorTest.cpp	/^  D1& operator=(D1&&) = default;$/;"	p	struct:D1	file:	access:public	signature:(D1&&)
operator =	.\test\stl_tests\StlVectorTest.cpp	/^  D1& operator=(const D1&) = default;$/;"	p	struct:D1	file:	access:public	signature:(const D1&)
operator =	.\test\stl_tests\StlVectorTest.cpp	/^  D2& operator=(D2&&) = default;$/;"	p	struct:D2	file:	access:public	signature:(D2&&)
operator =	.\test\stl_tests\StlVectorTest.cpp	/^  D2& operator=(const D2&) = default;$/;"	p	struct:D2	file:	access:public	signature:(const D2&)
operator =	.\test\stl_tests\StlVectorTest.cpp	/^  D3& operator=(D3&&) = default;$/;"	p	struct:D3	file:	access:public	signature:(D3&&)
operator =	.\test\stl_tests\StlVectorTest.cpp	/^  D3& operator=(const D3&) = default;$/;"	p	struct:D3	file:	access:public	signature:(const D3&)
operator =	.\test\stl_tests\StlVectorTest.cpp	/^  D3& operator=(const D3&) = delete;$/;"	p	struct:D3	file:	access:public	signature:(const D3&)
operator =	.\test\stl_tests\StlVectorTest.cpp	/^  D4& operator=(D4&&) = default;$/;"	p	struct:D4	file:	access:public	signature:(D4&&)
operator =	.\test\stl_tests\StlVectorTest.cpp	/^  D4& operator=(D4&&) = delete;$/;"	p	struct:D4	file:	access:public	signature:(D4&&)
operator =	.\test\stl_tests\StlVectorTest.cpp	/^  D4& operator=(const D4&) = default;$/;"	p	struct:D4	file:	access:public	signature:(const D4&)
operator =	.\test\stl_tests\StlVectorTest.cpp	/^  Data& operator=(Data&&) = default;$/;"	p	struct:Data	file:	access:public	signature:(Data&&)
operator =	.\test\stl_tests\StlVectorTest.cpp	/^  Data& operator=(const Data&) = default;$/;"	p	struct:Data	file:	access:public	signature:(const Data&)
operator =	.\test\stl_tests\StlVectorTest.cpp	/^  Delete& operator=(Delete&&) = default;$/;"	p	struct:Delete	file:	access:public	signature:(Delete&&)
operator =	.\test\stl_tests\StlVectorTest.cpp	/^  Delete& operator=(const Delete&) = default;$/;"	p	struct:Delete	file:	access:public	signature:(const Delete&)
operator =	.\wangle\Future-inl.h	/^Future<T>& Future<T>::operator=(Future<T>&& other) {$/;"	f	class:folly::wangle::Future	signature:(Future<T>&& other)
operator =	.\wangle\Future.h	/^  Future& operator=(Future const&) = delete;$/;"	p	class:folly::wangle::Future	access:public	signature:(Future const&)
operator =	.\wangle\Future.h	/^  Future& operator=(Future&&);$/;"	p	class:folly::wangle::Future	access:public	signature:(Future&&)
operator =	.\wangle\Promise-inl.h	/^Promise<T>& Promise<T>::operator=(Promise<T>&& other) {$/;"	f	class:folly::wangle::Promise	signature:(Promise<T>&& other)
operator =	.\wangle\Promise.h	/^  Promise& operator=(Promise const&) = delete;$/;"	p	class:folly::wangle::Promise	access:public	signature:(Promise const&)
operator =	.\wangle\Promise.h	/^  Promise& operator=(Promise<T>&&);$/;"	p	class:folly::wangle::Promise	access:public	signature:(Promise<T>&&)
operator =	.\wangle\Try-inl.h	/^Try<T>& Try<T>::operator=(Try<T>&& t) {$/;"	f	class:folly::wangle::Try	signature:(Try<T>&& t)
operator =	.\wangle\Try.h	/^  Try& operator=(Try<T>&& t);$/;"	p	class:folly::wangle::Try	access:public	signature:(Try<T>&& t)
operator =	.\wangle\detail\State.h	/^  State& operator=(State const&) = delete;$/;"	p	class:folly::wangle::detail::State	access:public	signature:(State const&)
operator =	.\wangle\detail\State.h	/^  State& operator=(State&&) = delete;$/;"	p	class:folly::wangle::detail::State	access:public	signature:(State&&)
operator ==	.\EvictingCacheMap.h	/^    friend bool operator==(const Node& lhs, const Node& rhs) {$/;"	f	struct:folly::EvictingCacheMap::Node	access:friend	signature:(const Node& lhs, const Node& rhs)
operator ==	.\ExceptionWrapper.h	/^  bool operator==(const exception_wrapper& a) const {$/;"	f	class:folly::exception_wrapper	access:public	signature:(const exception_wrapper& a) const
operator ==	.\FBVector.h	/^  bool operator==(const fbvector& other) const {$/;"	f	signature:(const fbvector& other) const
operator ==	.\IPAddress.cpp	/^bool operator==(const IPAddress& addr1, const IPAddress& addr2) {$/;"	f	namespace:folly	signature:(const IPAddress& addr1, const IPAddress& addr2)
operator ==	.\IPAddress.h	/^bool operator==(const IPAddress& addr1, const IPAddress& addr2);$/;"	p	namespace:folly	signature:(const IPAddress& addr1, const IPAddress& addr2)
operator ==	.\IPAddressV4.h	/^inline bool operator==(const IPAddressV4& addr1, const IPAddressV4& addr2) {$/;"	f	namespace:folly	signature:(const IPAddressV4& addr1, const IPAddressV4& addr2)
operator ==	.\IPAddressV6.h	/^inline bool operator==(const IPAddressV6& addr1, const IPAddressV6& addr2) {$/;"	f	namespace:folly	signature:(const IPAddressV6& addr1, const IPAddressV6& addr2)
operator ==	.\LifoSem.h	/^  inline constexpr bool operator== (const LifoSemHead& rhs) const {$/;"	f	class:folly::detail::LifoSemHead	access:public	signature:(const LifoSemHead& rhs) const
operator ==	.\MacAddress.h	/^  bool operator==(const MacAddress& other) const {$/;"	f	class:folly::MacAddress	access:public	signature:(const MacAddress& other) const
operator ==	.\Memory.h	/^  bool operator==(const StlAllocator<Alloc, T>& other) const {$/;"	f	class:folly::StlAllocator	access:public	signature:(const StlAllocator<Alloc, T>& other) const
operator ==	.\Memory.h	/^  bool operator==(const StlAllocator<Alloc, void>& other) const {$/;"	f	class:folly::StlAllocator	access:public	signature:(const StlAllocator<Alloc, void>& other) const
operator ==	.\Optional.h	/^bool operator==(const Optional<V>& a, const Optional<V>& b) {$/;"	f	namespace:folly	signature:(const Optional<V>& a, const Optional<V>& b)
operator ==	.\Optional.h	/^template<class V> bool operator==(const Optional<V>&, const V& other) = delete;$/;"	p	namespace:folly	signature:(const Optional<V>&, const V& other)
operator ==	.\Optional.h	/^template<class V> bool operator==(const V& other, const Optional<V>&) = delete;$/;"	p	namespace:folly	signature:(const V& other, const Optional<V>&)
operator ==	.\Range.h	/^inline bool operator==(const Range<T>& lhs, const Range<T>& rhs) {$/;"	f	namespace:folly	signature:(const Range<T>& lhs, const Range<T>& rhs)
operator ==	.\Range.h	/^operator==(const T& lhs, const U& rhs) {$/;"	f	namespace:folly	signature:(const T& lhs, const U& rhs)
operator ==	.\SocketAddress.cpp	/^bool SocketAddress::operator==(const SocketAddress& other) const {$/;"	f	class:folly::SocketAddress	signature:(const SocketAddress& other) const
operator ==	.\SocketAddress.h	/^  bool operator==(const SocketAddress& other) const;$/;"	p	class:folly::SocketAddress	access:public	signature:(const SocketAddress& other) const
operator ==	.\Subprocess.h	/^    bool operator==(const PipeInfo& other) const {$/;"	f	struct:folly::Subprocess::PipeInfo	access:public	signature:(const PipeInfo& other) const
operator ==	.\dynamic-inl.h	/^inline bool dynamic::operator==(dynamic const& o) const {$/;"	f	class:folly::dynamic	signature:(dynamic const& o) const
operator ==	.\dynamic.h	/^  bool operator==(dynamic const& o) const;$/;"	p	struct:folly::dynamic	access:public	signature:(dynamic const& o) const
operator ==	.\experimental\Singleton.h	/^  bool operator==(const TypeDescriptor& other) const {$/;"	f	class:folly::detail::TypeDescriptor	access:public	signature:(const TypeDescriptor& other) const
operator ==	.\experimental\io\HugePages.h	/^inline bool operator==(const HugePageSize& a, const HugePageSize& b) {$/;"	f	namespace:folly	signature:(const HugePageSize& a, const HugePageSize& b)
operator ==	.\experimental\symbolizer\ElfCache.h	/^    bool operator==(const Path& other) const {$/;"	f	class:folly::symbolizer::SignalSafeElfCache::Path	access:public	signature:(const Path& other) const
operator ==	.\io\Cursor.h	/^  bool operator==(const Derived& other) const {$/;"	f	class:folly::io::detail::CursorBase	access:public	signature:(const Derived& other) const
operator ==	.\small_vector.h	/^  bool operator==(small_vector const& o) const {$/;"	f	class:folly::small_vector	access:public	signature:(small_vector const& o) const
operator ==	.\sorted_vector_types.h	/^  bool operator==(const sorted_vector_map& other) const {$/;"	f	class:folly::sorted_vector_map	access:public	signature:(const sorted_vector_map& other) const
operator ==	.\sorted_vector_types.h	/^  bool operator==(const sorted_vector_set& other) const {$/;"	f	class:folly::sorted_vector_set	access:public	signature:(const sorted_vector_set& other) const
operator ==	.\test\AtomicHashArrayTest.cpp	/^  bool operator==(const MmapAllocator<T>& other) const {$/;"	f	class:MmapAllocator	access:public	signature:(const MmapAllocator<T>& other) const
operator ==	.\test\AtomicHashMapTest.cpp	/^  bool operator==(const Integer& a) const { return v_ == a.v_; }$/;"	f	class:Integer	access:public	signature:(const Integer& a) const
operator ==	.\test\DynamicConverterTest.cpp	/^  bool operator==(const A & o) const { return i == o.i; }$/;"	f	struct:A	access:public	signature:(const A & o) const
operator ==	.\test\OptionalTest.cpp	/^  friend bool operator==(const MoveTester& o1, const MoveTester& o2);$/;"	p	class:folly::MoveTester	file:	access:friend	signature:(const MoveTester& o1, const MoveTester& o2)
operator ==	.\test\OptionalTest.cpp	/^bool operator==(const MoveTester& o1, const MoveTester& o2) {$/;"	f	namespace:folly	signature:(const MoveTester& o1, const MoveTester& o2)
operator ==	.\test\RangeTest.cpp	/^bool operator==(MutableStringPiece mp, StringPiece sp) {$/;"	f	namespace:folly	signature:(MutableStringPiece mp, StringPiece sp)
operator ==	.\test\RangeTest.cpp	/^bool operator==(StringPiece sp, MutableStringPiece mp) {$/;"	f	namespace:folly	signature:(StringPiece sp, MutableStringPiece mp)
operator ==	.\test\stl_tests\StlVectorTest.cpp	/^  bool operator==(const Alloc& o) const { return a == o.a && id == o.id; }$/;"	f	struct:Alloc	access:public	signature:(const Alloc& o) const
operator ==	.\test\stl_tests\StlVectorTest.cpp	/^  bool operator==(const DataState& o) const {$/;"	f	class:DataState	access:public	signature:(const DataState& o) const
operator ==	.\wangle\WangleException.h	/^  bool operator==(const WangleException &other) const{$/;"	f	class:folly::wangle::WangleException	access:public	signature:(const WangleException &other) const
operator >	.\Optional.h	/^bool operator> (const Optional<V>& a, const Optional<V>& b) {$/;"	f	namespace:folly	signature:(const Optional<V>& a, const Optional<V>& b)
operator >	.\Optional.h	/^template<class V> bool operator> (const Optional<V>&, const V& other) = delete;$/;"	p	namespace:folly	signature:(const Optional<V>&, const V& other)
operator >	.\Optional.h	/^template<class V> bool operator> (const V& other, const Optional<V>&) = delete;$/;"	p	namespace:folly	signature:(const V& other, const Optional<V>&)
operator >	.\Range.h	/^operator>(const T& lhs, const U& rhs) {$/;"	f	namespace:folly	signature:(const T& lhs, const U& rhs)
operator >=	.\Optional.h	/^bool operator>=(const Optional<V>& a, const Optional<V>& b) {$/;"	f	namespace:folly	signature:(const Optional<V>& a, const Optional<V>& b)
operator >=	.\Optional.h	/^template<class V> bool operator>=(const Optional<V>&, const V& other) = delete;$/;"	p	namespace:folly	signature:(const Optional<V>&, const V& other)
operator >=	.\Optional.h	/^template<class V> bool operator>=(const V& other, const Optional<V>&) = delete;$/;"	p	namespace:folly	signature:(const V& other, const Optional<V>&)
operator >=	.\Range.h	/^operator>=(const T& lhs, const U& rhs) {$/;"	f	namespace:folly	signature:(const T& lhs, const U& rhs)
operator []	.\AtomicBitSet.h	/^  bool operator[](size_t idx) const;$/;"	p	class:folly::AtomicBitSet	access:public	signature:(size_t idx) const
operator []	.\AtomicBitSet.h	/^inline bool AtomicBitSet<N>::operator[](size_t index) const {$/;"	f	class:folly::AtomicBitSet	signature:(size_t index) const
operator []	.\FBVector.h	/^  const_reference operator[](size_type n) const {$/;"	f	signature:(size_type n) const
operator []	.\FBVector.h	/^  reference operator[](size_type n) {$/;"	f	signature:(size_type n)
operator []	.\IndexedMemPool.h	/^  T& operator[](uint32_t idx) {$/;"	f	struct:folly::IndexedMemPool	access:public	signature:(uint32_t idx)
operator []	.\IndexedMemPool.h	/^  const T& operator[](uint32_t idx) const {$/;"	f	struct:folly::IndexedMemPool	access:public	signature:(uint32_t idx) const
operator []	.\PackedSyncPtr.h	/^  reference operator[](std::ptrdiff_t i) const { return get()[i]; }$/;"	f	class:folly::PackedSyncPtr	access:public	signature:(std::ptrdiff_t i) const
operator []	.\Padded.h	/^  const value_type& operator[](size_type idx) const {$/;"	f	class:folly::Adaptor	access:public	signature:(size_type idx) const
operator []	.\Padded.h	/^  value_type& operator[](size_type idx) {$/;"	f	class:folly::Adaptor	access:public	signature:(size_type idx)
operator []	.\Range.h	/^  const value_type& operator[](size_t i) const {$/;"	f	class:folly::Range	access:public	signature:(size_t i) const
operator []	.\Range.h	/^  value_type& operator[](size_t i) {$/;"	f	class:folly::Range	access:public	signature:(size_t i)
operator []	.\SmallLocks.h	/^  T& operator[](size_t i) {$/;"	f	struct:folly::SpinLockArray	access:public	signature:(size_t i)
operator []	.\SmallLocks.h	/^  const T& operator[](size_t i) const {$/;"	f	struct:folly::SpinLockArray	access:public	signature:(size_t i) const
operator []	.\detail\CacheLocality.h	/^  AccessSpreader<Atom> const& operator[] (size_t index) const {$/;"	f	struct:folly::detail::AccessSpreaderArray	access:public	signature:(size_t index) const
operator []	.\dynamic-inl.h	/^inline dynamic const& dynamic::operator[](dynamic const& idx) const {$/;"	f	class:folly::dynamic	signature:(dynamic const& idx) const
operator []	.\dynamic-inl.h	/^inline dynamic& dynamic::operator[](dynamic const& k) {$/;"	f	class:folly::dynamic	signature:(dynamic const& k)
operator []	.\dynamic.h	/^  dynamic const& operator[](dynamic const&) const;$/;"	p	struct:folly::dynamic	access:public	signature:(dynamic const&) const
operator []	.\dynamic.h	/^  dynamic&       operator[](dynamic const&);$/;"	p	struct:folly::dynamic	access:public	signature:(dynamic const&)
operator []	.\io\TypedIOBuf.h	/^  T& operator[](ssize_t idx) {$/;"	f	class:folly::TypedIOBuf	access:public	signature:(ssize_t idx)
operator []	.\io\TypedIOBuf.h	/^  const T& operator[](ssize_t idx) const {$/;"	f	class:folly::TypedIOBuf	access:public	signature:(ssize_t idx) const
operator []	.\small_vector.h	/^  const_reference operator[](size_type i) const {$/;"	f	class:folly::small_vector	access:public	signature:(size_type i) const
operator []	.\small_vector.h	/^  reference operator[](size_type i) {$/;"	f	class:folly::small_vector	access:public	signature:(size_type i)
operator []	.\sorted_vector_types.h	/^  mapped_type& operator[](const key_type& key) {$/;"	f	class:folly::sorted_vector_map	access:public	signature:(const key_type& key)
operator []	.\test\stl_tests\StlVectorTest.cpp	/^  int operator[](size_type i) {$/;"	f	class:DataState	access:public	signature:(size_type i)
operator ^=	.\dynamic.h	/^  dynamic& operator^=(dynamic const&);$/;"	p	struct:folly::dynamic	access:public	signature:(dynamic const&)
operator bool	.\ExceptionWrapper.h	/^  explicit operator bool() const {$/;"	f	class:folly::exception_wrapper	access:public	signature:() const
operator bool	.\File.h	/^  explicit operator bool() const {$/;"	f	class:folly::File	access:public	signature:() const
operator bool	.\IPAddress.h	/^  explicit operator bool() const { return !empty(); }$/;"	f	class:folly::IPAddress	access:public	signature:() const
operator bool	.\Optional.h	/^  explicit operator bool() const {$/;"	f	class:folly::Optional	access:public	signature:() const
operator bool	.\ThreadLocal.h	/^  explicit operator bool() const {$/;"	f	class:folly::ThreadLocalPtr	access:public	signature:() const
operator bool	.\detail\BitIteratorDetail.h	/^  operator bool() const {$/;"	f	class:folly::bititerator_detail::BitReference	access:public	signature:() const
operator delete	.\io\IOBuf.cpp	/^void IOBuf::operator delete(void* ptr) {$/;"	f	class:folly::IOBuf	signature:(void* ptr)
operator delete	.\io\IOBuf.h	/^  void operator delete(void* ptr);$/;"	p	class:folly::IOBuf	access:public	signature:(void* ptr)
operator int BenchmarkSuspender::*	.\Benchmark.h	/^  operator int BenchmarkSuspender::*() const {$/;"	f	struct:folly::BenchmarkSuspender	access:public	signature:() const
operator new	.\io\IOBuf.cpp	/^void* IOBuf::operator new(size_t size) {$/;"	f	class:folly::IOBuf	signature:(size_t size)
operator new	.\io\IOBuf.cpp	/^void* IOBuf::operator new(size_t size, void* ptr) {$/;"	f	class:folly::IOBuf	signature:(size_t size, void* ptr)
operator new	.\io\IOBuf.h	/^  void* operator new(size_t size);$/;"	p	class:folly::IOBuf	access:public	signature:(size_t size)
operator new	.\io\IOBuf.h	/^  void* operator new(size_t size, void* ptr);$/;"	p	class:folly::IOBuf	access:public	signature:(size_t size, void* ptr)
operator |	.\gen\Base-inl.h	/^    VectorType operator|(const Collect<VectorType>&) const {$/;"	f	class:folly::gen::detail::Order::Generator	access:public	signature:(const Collect<VectorType>&) const
operator |	.\gen\Base-inl.h	/^    VectorType operator|(const CollectTemplate<std::vector>&) const {$/;"	f	class:folly::gen::detail::Order::Generator	access:public	signature:(const CollectTemplate<std::vector>&) const
operator |	.\gen\Core-inl.h	/^Composed operator|(Operator<Left>&& left,$/;"	f	namespace:folly::gen	signature:(Operator<Left>&& left, Operator<Right>&& right)
operator |	.\gen\Core-inl.h	/^Composed operator|(Operator<Left>&& left,$/;"	f	namespace:folly::gen	signature:(Operator<Left>&& left, const Operator<Right>& right)
operator |	.\gen\Core-inl.h	/^Composed operator|(const Operator<Left>& left,$/;"	f	namespace:folly::gen	signature:(const Operator<Left>& left, Operator<Right>&& right)
operator |	.\gen\Core-inl.h	/^Composed operator|(const Operator<Left>& left,$/;"	f	namespace:folly::gen	signature:(const Operator<Left>& left, const Operator<Right>& right)
operator |	.\gen\Core-inl.h	/^operator|(const GenImpl<Value, Gen>& gen, Handler&& handler) {$/;"	f	namespace:folly::gen	signature:(const GenImpl<Value, Gen>& gen, Handler&& handler)
operator |=	.\Subprocess.h	/^    Options& operator|=(const Options& other);$/;"	p	class:folly::Subprocess::Options	access:public	signature:(const Options& other)
operator |=	.\Subprocess.h	/^inline Subprocess::Options& Subprocess::Options::operator|=($/;"	f	class:folly::Subprocess::Options	signature:( const Subprocess::Options& other)
operator |=	.\dynamic.h	/^  dynamic& operator|=(dynamic const&);$/;"	p	struct:folly::dynamic	access:public	signature:(dynamic const&)
ops_	.\gen\Parallel-inl.h	/^      const Ops* ops_;$/;"	m	class:folly::gen::detail::Parallel::Generator::Executor	access:private
ops_	.\gen\Parallel-inl.h	/^    const Ops ops_;$/;"	m	class:folly::gen::detail::Parallel::Generator	access:private
ops_	.\gen\Parallel-inl.h	/^  Ops ops_;$/;"	m	class:folly::gen::detail::Parallel	access:private
opt_	.\test\OptionalTest.cpp	/^  Optional<int> opt_;$/;"	m	class:folly::ContainsOptional	file:	access:private
optimize	.\ExceptionWrapper.h	/^  struct optimize {$/;"	s	class:folly::try_and_catch	access:protected
options	.\io\IOBufQueue.h	/^  const Options& options() const {$/;"	f	class:folly::IOBufQueue	access:public	signature:() const
options_	.\MemoryMapping.h	/^  Options options_;$/;"	m	class:folly::MemoryMapping	access:private
options_	.\experimental\symbolizer\Symbolizer.h	/^  const int options_;$/;"	m	class:folly::symbolizer::SymbolizePrinter	access:protected
options_	.\io\IOBufQueue.h	/^  Options options_;$/;"	m	class:folly::IOBufQueue	access:private
opts_	.\json.cpp	/^  json::serialization_opts const& opts_;$/;"	m	class:folly::json::__anon75::Input::json	file:	access:private
opts_	.\json.cpp	/^  serialization_opts const& opts_;$/;"	m	struct:folly::json::__anon75::Printer	file:	access:private
order	.\experimental\test\EliasFanoCodingTest.cpp	/^std::vector<size_t> order;$/;"	m	namespace:bm	file:
order	.\gen\Base-inl.h	/^static const detail::Order<Identity> order;$/;"	m	namespace:folly::gen
orderBy	.\gen\Base.h	/^Order orderBy(Selector selector = Identity(),$/;"	f	namespace:folly::gen	signature:(Selector selector = Identity(), Comparer comparer = Comparer())
orderByDescending	.\gen\Base.h	/^Order orderByDescending(Selector selector = Identity()) {$/;"	f	namespace:folly::gen	signature:(Selector selector = Identity())
ordinal	.\wangle\ManualExecutor.h	/^      size_t ordinal;$/;"	m	struct:folly::wangle::ManualExecutor::ScheduledAction	access:public
origTerminate	.\experimental\exception_tracer\ExceptionTracer.cpp	/^std::terminate_handler origTerminate = abort;$/;"	m	namespace:folly::exception_tracer::__anon24	file:
origUnexpected	.\experimental\exception_tracer\ExceptionTracer.cpp	/^std::unexpected_handler origUnexpected = abort;$/;"	m	namespace:folly::exception_tracer::__anon24	file:
orig_cxa_begin_catch	.\experimental\exception_tracer\ExceptionTracerLib.cpp	/^CxaBeginCatchType orig_cxa_begin_catch;$/;"	v
orig_cxa_end_catch	.\experimental\exception_tracer\ExceptionTracerLib.cpp	/^CxaEndCatchType orig_cxa_end_catch;$/;"	v
orig_cxa_rethrow	.\experimental\exception_tracer\ExceptionTracerLib.cpp	/^CxaRethrowType orig_cxa_rethrow;$/;"	v
orig_cxa_throw	.\experimental\exception_tracer\ExceptionTracerLib.cpp	/^CxaThrowType orig_cxa_throw;$/;"	v
orig_rethrow_exception	.\experimental\exception_tracer\ExceptionTracerLib.cpp	/^RethrowExceptionType orig_rethrow_exception;$/;"	m	namespace:__anon25	file:
os	.\build\generate_escape_tables.py	/^import os$/;"	i
os	.\build\generate_format_tables.py	/^import os$/;"	i
os	.\build\generate_varint_tables.py	/^import os$/;"	i
other	.\Memory.h	/^    typedef StlAllocator<Alloc, U> other;$/;"	t	struct:folly::StlAllocator::rebind	access:public
other	.\RWSpinLock.h	/^    ReadHolder& operator=(const ReadHolder& other) = delete;$/;"	m	class:folly::RWSpinLock::ReadHolder	access:public
other	.\RWSpinLock.h	/^    ReadHolder(const ReadHolder& other) = delete;$/;"	m	class:folly::RWSpinLock::ReadHolder	access:public
other	.\RWSpinLock.h	/^    UpgradedHolder& operator =(const UpgradedHolder& other) = delete;$/;"	m	class:folly::RWSpinLock::UpgradedHolder	access:public
other	.\RWSpinLock.h	/^    UpgradedHolder(const UpgradedHolder& other) = delete;$/;"	m	class:folly::RWSpinLock::UpgradedHolder	access:public
other	.\RWSpinLock.h	/^    WriteHolder& operator =(const WriteHolder& other) = delete;$/;"	m	class:folly::RWSpinLock::WriteHolder	access:public
other	.\RWSpinLock.h	/^    WriteHolder(const WriteHolder& other) = delete;$/;"	m	class:folly::RWSpinLock::WriteHolder	access:public
other	.\ScopeGuard.h	/^  ScopeGuardForNewException(const ScopeGuardForNewException& other) = delete;$/;"	m	class:folly::detail::ScopeGuardForNewException	access:private
other	.\test\AtomicHashArrayTest.cpp	/^    typedef MmapAllocator<U> other;$/;"	t	struct:MmapAllocator::rebind	file:	access:public
other	.\test\OptionalTest.cpp	/^  ContainsOptional& operator=(ContainsOptional &&other) = default;$/;"	m	class:folly::ContainsOptional	file:	access:public
other	.\test\OptionalTest.cpp	/^  ContainsOptional& operator=(const ContainsOptional &other) = default;$/;"	m	class:folly::ContainsOptional	file:	access:public
other	.\test\OptionalTest.cpp	/^  ContainsOptional(ContainsOptional &&other) = default;$/;"	m	class:folly::ContainsOptional	file:	access:public
other	.\test\OptionalTest.cpp	/^  ContainsOptional(const ContainsOptional &other) = default;$/;"	m	class:folly::ContainsOptional	file:	access:public
otherString	.\test\ConvTest.cpp	/^static char otherString[] = "this is a long string, so it's not so nice";$/;"	v	file:
our_bswap16	.\Bits.h	299;"	d
outQueue_	.\gen\Parallel-inl.h	/^      OutQueue outQueue_;$/;"	m	class:folly::gen::detail::Parallel::Generator::Executor	access:private
out_	.\GroupVarint.h	/^  Output out_;$/;"	m	class:folly::GroupVarintEncoder	access:private
out_	.\experimental\symbolizer\Symbolizer.h	/^  std::ostream& out_;$/;"	m	class:folly::symbolizer::OStreamSymbolizePrinter	access:private
out_	.\json.cpp	/^  fbstring& out_;$/;"	m	struct:folly::json::__anon75::Printer	file:	access:private
outdent	.\json.cpp	/^  void outdent() const {$/;"	f	struct:folly::json::__anon75::Printer	file:	access:private	signature:() const
outer_	.\experimental\EliasFanoCoding.h	/^  size_t outer_;  \/\/ Outer offset: number of consumed bytes in upper.$/;"	m	class:folly::compression::detail::UpperBitsReader	access:private
output	.\GroupVarint.h	/^  Output& output() {$/;"	f	class:folly::GroupVarintEncoder	access:public	signature:()
output	.\GroupVarint.h	/^  const Output& output() const {$/;"	f	class:folly::GroupVarintEncoder	access:public	signature:() const
outputBuffer_	.\gen\String-inl.h	/^  OutputBuffer* outputBuffer_;$/;"	m	class:folly::gen::detail::UnsplitBuffer	access:private
outstandingTasks	.\experimental\wangle\concurrent\IOThreadPoolExecutor.h	/^    std::atomic<size_t> outstandingTasks;$/;"	m	struct:folly::wangle::IOThreadPoolExecutor::IOThread	access:public
override	.\experimental\symbolizer\ElfCache.h	/^  std::shared_ptr<ElfFile> getFile(StringPiece path) override;$/;"	m	class:folly::symbolizer::ElfCache	access:public
override	.\experimental\symbolizer\ElfCache.h	/^  std::shared_ptr<ElfFile> getFile(StringPiece path) override;$/;"	m	class:folly::symbolizer::SignalSafeElfCache	access:public
override	.\experimental\symbolizer\Symbolizer.h	/^  void doPrint(StringPiece sp) override;$/;"	m	class:folly::symbolizer::FDSymbolizePrinter	access:private
override	.\experimental\symbolizer\Symbolizer.h	/^  void doPrint(StringPiece sp) override;$/;"	m	class:folly::symbolizer::FILESymbolizePrinter	access:private
override	.\experimental\symbolizer\Symbolizer.h	/^  void doPrint(StringPiece sp) override;$/;"	m	class:folly::symbolizer::OStreamSymbolizePrinter	access:private
override	.\experimental\symbolizer\Symbolizer.h	/^  void doPrint(StringPiece sp) override;$/;"	m	class:folly::symbolizer::StringSymbolizePrinter	access:private
override	.\experimental\wangle\concurrent\CPUThreadPoolExecutor.h	/^  void add(Func func) override;$/;"	m	class:folly::wangle::CPUThreadPoolExecutor	access:public
override	.\experimental\wangle\concurrent\CPUThreadPoolExecutor.h	/^  void stopThreads(size_t n) override;$/;"	m	class:folly::wangle::CPUThreadPoolExecutor	access:private
override	.\experimental\wangle\concurrent\CPUThreadPoolExecutor.h	/^  void threadRun(ThreadPtr thread) override;$/;"	m	class:folly::wangle::CPUThreadPoolExecutor	access:private
override	.\experimental\wangle\concurrent\IOThreadPoolExecutor.h	/^  ThreadPtr makeThread() override;$/;"	m	class:folly::wangle::IOThreadPoolExecutor	access:private
override	.\experimental\wangle\concurrent\IOThreadPoolExecutor.h	/^  void add(Func func) override;$/;"	m	class:folly::wangle::IOThreadPoolExecutor	access:public
override	.\experimental\wangle\concurrent\IOThreadPoolExecutor.h	/^  void stopThreads(size_t n) override;$/;"	m	class:folly::wangle::IOThreadPoolExecutor	access:private
override	.\experimental\wangle\concurrent\IOThreadPoolExecutor.h	/^  void threadRun(ThreadPtr thread) override;$/;"	m	class:folly::wangle::IOThreadPoolExecutor	access:private
override	.\experimental\wangle\concurrent\ThreadPoolExecutor.h	/^    ThreadPtr take() override;$/;"	m	class:folly::wangle::ThreadPoolExecutor::StoppedThreadQueue	access:public
override	.\experimental\wangle\concurrent\ThreadPoolExecutor.h	/^    size_t size() override;$/;"	m	class:folly::wangle::ThreadPoolExecutor::StoppedThreadQueue	access:public
override	.\experimental\wangle\concurrent\ThreadPoolExecutor.h	/^    void add(ThreadPtr item) override;$/;"	m	class:folly::wangle::ThreadPoolExecutor::StoppedThreadQueue	access:public
override	.\wangle\ManualExecutor.h	/^    void add(Action&&) override;$/;"	m	class:folly::wangle::ManualExecutor	access:public
override	.\wangle\QueuedImmediateExecutor.h	/^  void add(Action&&) override;$/;"	m	class:folly::wangle::QueuedImmediateExecutor	access:public
ownedBuffers_	.\io\test\IOBufTest.cpp	/^  std::vector<std::unique_ptr<uint8_t[]>> ownedBuffers_;$/;"	m	class:MoveToFbStringTest	file:	access:protected
owner_	.\MPMCPipeline.h	/^        owner_(other.owner_),$/;"	p	class:folly::MPMCPipeline::Ticket	access:public	signature:(other.owner_)
owner_	.\MPMCPipeline.h	/^        owner_(owner),$/;"	p	class:folly::MPMCPipeline::Ticket	access:private	signature:(owner)
owner_	.\MPMCPipeline.h	/^      : owner_(nullptr),$/;"	p	class:folly::MPMCPipeline::Ticket	access:public	signature:(nullptr)
owner_	.\MPMCPipeline.h	/^    MPMCPipeline* owner_;$/;"	m	class:folly::MPMCPipeline::Ticket	access:private
ownsDeleter	.\detail\ThreadLocalDetail.h	/^  bool ownsDeleter;$/;"	m	struct:folly::threadlocal_detail::ElementWrapper	access:public
ownsFd_	.\File.h	/^  bool ownsFd_;$/;"	m	class:folly::File	access:private
p	.\wangle\detail\State.h	/^  Promise<std::pair<size_t, Try<T>>> p;$/;"	m	struct:folly::wangle::detail::WhenAnyContext	access:public
p	.\wangle\detail\State.h	/^  Promise<std::tuple<Try<Ts>... > > p;$/;"	m	struct:folly::wangle::detail::VariadicContext	access:public
p	.\wangle\detail\State.h	/^  Promise<std::vector<Try<T> > > p;$/;"	m	struct:folly::wangle::detail::WhenAllContext	access:public
p_	.\GroupVarint.h	/^  const char* p_;$/;"	m	class:folly::GroupVarintDecoder	access:private
packFlagsAndSharedInfo	.\io\IOBuf.h	/^  static inline uintptr_t packFlagsAndSharedInfo(uintptr_t flags,$/;"	f	class:folly::IOBuf	access:private	signature:(uintptr_t flags, SharedInfo* info)
packedBytes	.\MacAddress.h	/^  uint64_t packedBytes() const {$/;"	f	class:folly::MacAddress	access:private	signature:() const
padToFullNode	.\Padded.h	/^  void padToFullNode(const value_type& padValue) {$/;"	f	class:folly::Adaptor	access:public	signature:(const value_type& padValue)
padded	.\Padded.h	/^namespace padded {$/;"	n	namespace:folly
padding	.\SmallLocks.h	/^    char padding[FOLLY_CACHE_LINE_SIZE - sizeof(T)];$/;"	m	struct:folly::SpinLockArray::PaddedSpinLock	access:public
padding_	.\LifoSem.h	/^  char padding_[folly::detail::CacheLocality::kFalseSharingRange -$/;"	m	struct:folly::detail::LifoSemBase	access:private
padding_	.\MPMCQueue.h	/^  char padding_[detail::CacheLocality::kFalseSharingRange - sizeof(Atom<int>)];$/;"	m	class:folly::MPMCQueue	access:private
padding_	.\SmallLocks.h	/^  char padding_[FOLLY_CACHE_LINE_SIZE];$/;"	m	struct:folly::SpinLockArray	access:private
pageSize	.\MemoryMapping.h	/^    off_t pageSize = 0;$/;"	m	struct:folly::MemoryMapping::Options	access:public
pair	.\Traits.h	/^  struct pair;$/;"	x
parallel	.\gen\Parallel.h	/^Parallel parallel(Ops ops, size_t threads = 0) {$/;"	f	namespace:folly::gen	signature:(Ops ops, size_t threads = 0)
paramMulti	.\test\BenchmarkTest.cpp	/^unsigned paramMulti(unsigned iter, unsigned num) {$/;"	f	signature:(unsigned iter, unsigned num)
paramMultiRel	.\test\BenchmarkTest.cpp	/^unsigned paramMultiRel(unsigned iter, unsigned num) {$/;"	f	signature:(unsigned iter, unsigned num)
parentDeathSignal	.\Subprocess.h	/^    Options& parentDeathSignal(int sig) {$/;"	f	class:folly::Subprocess::Options	access:public	signature:(int sig)
parentFd	.\Subprocess.h	/^    int parentFd = -1;$/;"	m	struct:folly::Subprocess::PipeInfo	access:public
parentFd	.\Subprocess.h	/^  int parentFd(int childFd) const {$/;"	f	class:folly::Subprocess	access:public	signature:(int childFd) const
parent_	.\Synchronized.h	/^      ConstLockedPtr* parent_;$/;"	m	struct:folly::Synchronized::ConstLockedPtr::Unsynchronizer	access:private
parent_	.\Synchronized.h	/^      LockedPtr* parent_;$/;"	m	struct:folly::Synchronized::LockedPtr::Unsynchronizer	access:private
parent_	.\Synchronized.h	/^    Synchronized* parent_;$/;"	m	struct:folly::Synchronized::LockedPtr	access:private
parent_	.\Synchronized.h	/^    const Synchronized* parent_;$/;"	m	struct:folly::Synchronized::ConstLockedPtr	access:private
parent_	.\ThreadCachedInt.h	/^    ThreadCachedInt* parent_;$/;"	m	struct:folly::ThreadCachedInt::IntCache	access:public
parse	.\MacAddress.cpp	/^void MacAddress::parse(StringPiece str) {$/;"	f	class:folly::MacAddress	signature:(StringPiece str)
parse	.\MacAddress.h	/^  void parse(StringPiece str);$/;"	p	class:folly::MacAddress	access:public	signature:(StringPiece str)
parseAddress4	.\test\IPAddressTest.h	/^  static in_addr parseAddress4(const std::string& src) {$/;"	f	struct:folly::AddressData	access:public	signature:(const std::string& src)
parseAddress6	.\test\IPAddressTest.h	/^  static in6_addr parseAddress6(const std::string& src) {$/;"	f	struct:folly::AddressData	access:public	signature:(const std::string& src)
parseArray	.\json.cpp	/^dynamic parseArray(Input& in) {$/;"	f	namespace:folly::json::__anon75	signature:(Input& in)
parseJson	.\json.cpp	/^dynamic parseJson($/;"	f	namespace:folly	signature:( StringPiece range, json::serialization_opts const& opts)
parseJson	.\json.cpp	/^dynamic parseJson(StringPiece range) {$/;"	f	namespace:folly	signature:(StringPiece range)
parseJson	.\json.h	/^dynamic parseJson(StringPiece);$/;"	p	namespace:folly	signature:(StringPiece)
parseLeadingNumber	.\detail\CacheLocality.cpp	/^static ssize_t parseLeadingNumber(const std::string& line) {$/;"	f	namespace:folly::detail	signature:(const std::string& line)
parseNumber	.\json.cpp	/^dynamic parseNumber(Input& in) {$/;"	f	namespace:folly::json::__anon75	signature:(Input& in)
parseNumber	.\json.cpp	/^dynamic parseNumber(Input& in);$/;"	p	namespace:folly::json::__anon75	file:	signature:(Input& in)
parseObject	.\json.cpp	/^dynamic parseObject(Input& in) {$/;"	f	namespace:folly::json::__anon75	signature:(Input& in)
parsePageSizeValue	.\experimental\io\HugePages.cpp	/^size_t parsePageSizeValue(StringPiece value) {$/;"	f	namespace:folly::__anon30	signature:(StringPiece value)
parseProcMapsLine	.\experimental\symbolizer\Symbolizer.cpp	/^bool parseProcMapsLine(StringPiece line,$/;"	f	namespace:folly::symbolizer::__anon40	signature:(StringPiece line, uintptr_t& from, uintptr_t& to, StringPiece& fileName)
parseString	.\json.cpp	/^fbstring parseString(Input& in) {$/;"	f	namespace:folly::json::__anon75	signature:(Input& in)
parseString	.\json.cpp	/^fbstring parseString(Input& in);$/;"	p	namespace:folly::json::__anon75	file:	signature:(Input& in)
parseValue	.\json.cpp	/^dynamic parseValue(Input& in) {$/;"	f	namespace:folly::json::__anon75	signature:(Input& in)
parseValue	.\json.cpp	/^dynamic parseValue(Input& in);$/;"	p	namespace:folly::json::__anon75	file:	signature:(Input& in)
partialCount	.\GroupVarint.h	/^  static size_t partialCount(const char* p, size_t size) {$/;"	f	class:folly::GroupVarint	access:public	signature:(const char* p, size_t size)
partialSize	.\GroupVarint.h	/^  static size_t partialSize(const type* p, size_t count) {$/;"	f	class:folly::GroupVarint	access:public	signature:(const type* p, size_t count)
passthrough	.\gen\String-inl.h	/^inline Target passthrough(Target target) { return target; }$/;"	f	namespace:folly::gen::detail	signature:(Target target)
password	.\Uri.h	/^  const fbstring& password() const { return password_; }$/;"	f	class:folly::Uri	access:public	signature:() const
password_	.\Uri.h	/^  fbstring password_;$/;"	m	class:folly::Uri	access:private
path	.\Uri.h	/^  const fbstring& path() const { return path_; }$/;"	f	class:folly::Uri	access:public	signature:() const
path	.\experimental\TestUtil.cpp	/^const fs::path& TemporaryFile::path() const {$/;"	f	class:folly::test::TemporaryFile	signature:() const
path	.\experimental\TestUtil.h	/^  const fs::path& path() const { return path_; }$/;"	f	class:folly::test::TemporaryDirectory	access:public	signature:() const
path	.\experimental\TestUtil.h	/^  const fs::path& path() const;$/;"	p	class:folly::test::TemporaryFile	access:public	signature:() const
path	.\experimental\io\test\AsyncIOTest.cpp	/^  const fs::path path() const { return path_; }$/;"	f	class:__anon32::TemporaryFile	access:public	signature:() const
path	.\experimental\symbolizer\ElfCache.h	/^    std::string path;$/;"	m	struct:folly::symbolizer::ElfCache::Entry	access:public
pathLength	.\SocketAddress.h	/^    socklen_t pathLength() const {$/;"	f	struct:folly::SocketAddress::ExternalUnixAddr	access:public	signature:() const
path_	.\Uri.h	/^  fbstring path_;$/;"	m	class:folly::Uri	access:private
path_	.\experimental\TestUtil.h	/^  fs::path path_;$/;"	m	class:folly::test::TemporaryDirectory	access:private
path_	.\experimental\TestUtil.h	/^  fs::path path_;$/;"	m	class:folly::test::TemporaryFile	access:private
path_	.\experimental\io\test\AsyncIOTest.cpp	/^  fs::path path_;$/;"	m	class:__anon32::TemporaryFile	file:	access:private
pc1	.\test\ConvTest.cpp	/^static StringPiece pc1 = "1234567890123456789";$/;"	v	file:
peek	.\Padded.h	/^  std::pair<const Container&, size_t> peek() const {$/;"	f	class:folly::Adaptor	access:public	signature:() const
peek	.\io\Cursor.h	/^  std::pair<const uint8_t*, size_t> peek() {$/;"	f	class:folly::io::detail::CursorBase	access:public	signature:()
pending	.\experimental\io\AsyncIO.h	/^  size_t pending() const { return pending_; }$/;"	f	class:folly::AsyncIO	access:public	signature:() const
pendingCobTimeouts_	.\io\async\EventBase.h	/^  CobTimeout::List pendingCobTimeouts_;$/;"	m	class:folly::EventBase	access:private
pending_	.\experimental\io\AsyncIO.h	/^  std::atomic<size_t> pending_;$/;"	m	class:folly::AsyncIO	access:private
perfTestType	.\test\ProducerConsumerQueueTest.cpp	/^void perfTestType(const char* type) {$/;"	f	namespace:__anon128	signature:(const char* type)
perm_	.\test\DeterministicSchedule.cpp	/^  std::vector<int> perm_;$/;"	m	struct:folly::test::UniformSubset	file:	access:private
pickGetcpuFunc	.\detail\CacheLocality.cpp	/^Getcpu::Func AccessSpreader<std::atomic>::pickGetcpuFunc(size_t numStripes) {$/;"	f	class:folly::detail::AccessSpreader	signature:(size_t numStripes)
pickGetcpuFunc	.\detail\CacheLocality.h	/^  static Getcpu::Func pickGetcpuFunc(size_t numStripes);$/;"	p	struct:folly::detail::AccessSpreader	access:private	signature:(size_t numStripes)
pickGetcpuFunc	.\test\DeterministicSchedule.cpp	/^AccessSpreader<test::DeterministicAtomic>::pickGetcpuFunc(size_t numStripes) {$/;"	f	class:folly::detail::AccessSpreader	signature:(size_t numStripes)
pid	.\Subprocess.cpp	/^pid_t Subprocess::pid() const {$/;"	f	class:folly::Subprocess	signature:() const
pid	.\Subprocess.h	/^  pid_t pid() const;$/;"	p	class:folly::Subprocess	access:public	signature:() const
pid_	.\Subprocess.h	/^  pid_t pid_;$/;"	m	class:folly::Subprocess	access:private
pid_	.\io\async\NotificationQueue.h	/^  pid_t pid_;$/;"	m	class:folly::NotificationQueue	access:private
pieceCb_	.\gen\String.h	/^  Callback pieceCb_;$/;"	m	class:folly::gen::StreamSplitter	access:private
piecesTest	.\test\StringTest.cpp	/^void piecesTest() {$/;"	f	namespace:__anon138	signature:()
pipeFds_	.\io\async\NotificationQueue.h	/^  int pipeFds_[2]; \/\/ to fallback to on older\/non-linux systems$/;"	m	class:folly::NotificationQueue	access:private
pipeStderr	.\Subprocess.h	/^    Options& pipeStderr() { return fd(STDERR_FILENO, PIPE_OUT); }$/;"	f	class:folly::Subprocess::Options	access:public	signature:()
pipeStderr	.\Subprocess.h	/^  static Options pipeStderr() { return Options().stderr(PIPE); }$/;"	f	class:folly::Subprocess	access:public	signature:()
pipeStdin	.\Subprocess.h	/^    Options& pipeStdin() { return fd(STDIN_FILENO, PIPE_IN); }$/;"	f	class:folly::Subprocess::Options	access:public	signature:()
pipeStdin	.\Subprocess.h	/^  static Options pipeStdin() { return Options().stdin(PIPE); }$/;"	f	class:folly::Subprocess	access:public	signature:()
pipeStdout	.\Subprocess.h	/^    Options& pipeStdout() { return fd(STDOUT_FILENO, PIPE_OUT); }$/;"	f	class:folly::Subprocess::Options	access:public	signature:()
pipeStdout	.\Subprocess.h	/^  static Options pipeStdout() { return Options().stdout(PIPE); }$/;"	f	class:folly::Subprocess	access:public	signature:()
pipeline_	.\gen\ParallelMap-inl.h	/^      MPMCPipeline<Input, Output> pipeline_;$/;"	m	class:folly::gen::detail::PMap::Generator::ExecutionPipeline	access:private
pipes_	.\Subprocess.h	/^  std::vector<PipeInfo> pipes_;$/;"	m	class:folly::Subprocess	access:private
pmap	.\gen\ParallelMap.h	/^  PMap pmap(Predicate pred = Predicate(), size_t nThreads = 0) {$/;"	f	namespace:folly::gen	signature:(Predicate pred = Predicate(), size_t nThreads = 0)
pointer	.\AtomicHashArray.h	/^  typedef value_type*         pointer;$/;"	t	class:folly::AtomicHashArray	access:public
pointer	.\AtomicHashMap.h	/^  typedef value_type*         pointer;$/;"	t	class:folly::AtomicHashMap	access:public
pointer	.\ConcurrentSkipList.h	/^  typedef T* pointer;$/;"	t	class:folly::ConcurrentSkipList::Accessor	access:public
pointer	.\ConcurrentSkipList.h	/^  typedef T* pointer;$/;"	t	class:folly::ConcurrentSkipList::Skipper	access:public
pointer	.\ConcurrentSkipList.h	/^  typedef value_type* pointer;$/;"	t	class:folly::detail::csl_iterator	access:public
pointer	.\FBVector.h	/^    typedef typename A::pointer pointer;$/;"	t	struct:folly::fbvector::Impl	access:public
pointer	.\FBVector.h	/^  typedef typename A::pointer                         pointer;$/;"	t	class:folly::fbvector	access:public
pointer	.\Memory.h	/^  typedef T* pointer;$/;"	t	class:folly::StlAllocator	access:public
pointer	.\Memory.h	/^  typedef typename Allocator::pointer pointer;$/;"	t	class:folly::allocator_delete	access:public
pointer	.\Memory.h	/^  typedef value_type* pointer;$/;"	t	class:folly::is_simple_allocator	access:private
pointer	.\Memory.h	/^  typedef void* pointer;$/;"	t	class:folly::StlAllocator	access:public
pointer	.\sorted_vector_types.h	/^  typedef typename ContainerT::pointer                pointer;$/;"	t	class:folly::sorted_vector_map	access:public
pointer	.\sorted_vector_types.h	/^  typedef typename ContainerT::pointer                pointer;$/;"	t	class:folly::sorted_vector_set	access:public
pointer	.\test\AtomicHashArrayTest.cpp	/^  typedef T* pointer;$/;"	t	class:MmapAllocator	file:	access:public
pointer	.\test\stl_tests\StlVectorTest.cpp	/^  typedef typename std::allocator<T>::pointer pointer;$/;"	t	struct:Alloc	file:	access:public
pointerFlagClear	.\small_vector.h	/^  T* pointerFlagClear(T* p) {$/;"	f	namespace:folly::detail	signature:(T* p)
pointerFlagGet	.\small_vector.h	/^  bool pointerFlagGet(T* p) {$/;"	f	namespace:folly::detail	signature:(T* p)
pointerFlagSet	.\small_vector.h	/^  T* pointerFlagSet(T* p) {$/;"	f	namespace:folly::detail	signature:(T* p)
poison	.\experimental\wangle\concurrent\CPUThreadPoolExecutor.h	/^    Task(Task&& o) noexcept : func(std::move(o.func)), poison(o.poison) {}$/;"	f	struct:folly::wangle::CPUThreadPoolExecutor::Task	access:public	signature:(o.poison)
poison	.\experimental\wangle\concurrent\CPUThreadPoolExecutor.h	/^    bool poison;$/;"	m	struct:folly::wangle::CPUThreadPoolExecutor::Task	access:public
policyMaxSize	.\small_vector.h	/^    static constexpr std::size_t policyMaxSize() {$/;"	f	struct:folly::detail::IntegralSizePolicy	access:protected	signature:()
poll	.\Subprocess.cpp	/^ProcessReturnCode Subprocess::poll() {$/;"	f	class:folly::Subprocess	signature:()
poll	.\Subprocess.h	/^  ProcessReturnCode poll();$/;"	p	class:folly::Subprocess	access:public	signature:()
pollChecked	.\Subprocess.cpp	/^bool Subprocess::pollChecked() {$/;"	f	class:folly::Subprocess	signature:()
pollChecked	.\Subprocess.h	/^  bool pollChecked();$/;"	p	class:folly::Subprocess	access:public	signature:()
pollCompleted	.\experimental\io\AsyncIO.cpp	/^Range<AsyncIO::Op**> AsyncIO::pollCompleted() {$/;"	f	class:folly::AsyncIO	signature:()
pollCompleted	.\experimental\io\AsyncIO.h	/^  Range<Op**> pollCompleted();$/;"	p	class:folly::AsyncIO	access:public	signature:()
pollFd	.\experimental\io\AsyncIO.h	/^  int pollFd() const { return pollFd_; }$/;"	f	class:folly::AsyncIO	access:public	signature:() const
pollFd_	.\experimental\io\AsyncIO.h	/^  int pollFd_;$/;"	m	class:folly::AsyncIO	access:private
poly	.\Fingerprint.h	/^  static const uint64_t poly[1 + (BITS-1)\/64];$/;"	m	struct:folly::detail::FingerprintTable	access:public
poly_	.\detail\SlowFingerprint.h	/^  const FingerprintPolynomial<BITS-1> poly_;$/;"	m	class:folly::detail::SlowFingerprint	access:private
pool	.\IndexedMemPool.h	/^  Pool* pool;$/;"	m	struct:detail::IndexedMemPoolRecycler	access:public
pool	.\LifoSem.h	/^  static Pool pool;$/;"	m	struct:folly::detail::LifoSemRawNode	access:public
poolGetIOBuf	.\io\test\NetworkBenchmark.cpp	/^inline unique_ptr<IOBuf> poolGetIOBuf() {$/;"	f	signature:()
poolPutIOBuf	.\io\test\NetworkBenchmark.cpp	/^inline void poolPutIOBuf(unique_ptr<IOBuf>&& buf) {$/;"	f	signature:(unique_ptr<IOBuf>&& buf)
pop	.\experimental\exception_tracer\StackTrace.cpp	/^bool StackTraceStack::pop() {$/;"	f	class:folly::exception_tracer::StackTraceStack	signature:()
pop	.\experimental\exception_tracer\StackTrace.h	/^  bool pop();$/;"	p	class:folly::exception_tracer::StackTraceStack	access:public	signature:()
pop	.\io\IOBuf.h	/^  std::unique_ptr<IOBuf> pop() {$/;"	f	class:folly::IOBuf	access:public	signature:()
popFront	.\ProducerConsumerQueue.h	/^  void popFront() {$/;"	f	struct:folly::ProducerConsumerQueue	access:public	signature:()
popSpinCutoff_	.\MPMCQueue.h	/^    , popSpinCutoff_(rhs.popSpinCutoff_.load(std::memory_order_relaxed))$/;"	f	class:folly::MPMCQueue	access:public	signature:(rhs.popSpinCutoff_.load(std::memory_order_relaxed))
popSpinCutoff_	.\MPMCQueue.h	/^  Atom<int> FOLLY_ALIGN_TO_AVOID_FALSE_SHARING popSpinCutoff_;$/;"	m	class:folly::MPMCQueue	access:private
popTicket_	.\MPMCQueue.h	/^    , popTicket_(rhs.popTicket_.load(std::memory_order_relaxed))$/;"	p	class:folly::MPMCQueue	access:public	signature:(rhs.popTicket_.load(std::memory_order_relaxed))
popTicket_	.\MPMCQueue.h	/^  Atom<uint64_t> FOLLY_ALIGN_TO_AVOID_FALSE_SHARING popTicket_;$/;"	m	class:folly::MPMCQueue	access:private
pop_back	.\ConcurrentSkipList.h	/^  bool pop_back() {$/;"	f	class:folly::ConcurrentSkipList::Accessor	access:public	signature:()
pop_back	.\FBVector.h	/^  void pop_back() {$/;"	f	signature:()
pop_back	.\Padded.h	/^  void pop_back() {$/;"	f	class:folly::Adaptor	access:public	signature:()
pop_back	.\Range.h	/^  void pop_back() {$/;"	f	class:folly::Range	access:public	signature:()
pop_back	.\dynamic-inl.h	/^inline void dynamic::pop_back() {$/;"	f	class:folly::dynamic	signature:()
pop_back	.\dynamic.h	/^  void pop_back();$/;"	p	struct:folly::dynamic	access:public	signature:()
pop_back	.\small_vector.h	/^  void pop_back() {$/;"	f	class:folly::small_vector	access:public	signature:()
pop_front	.\Range.h	/^  void pop_front() {$/;"	f	class:folly::Range	access:public	signature:()
pop_front	.\io\IOBufQueue.cpp	/^std::unique_ptr<folly::IOBuf> IOBufQueue::pop_front() {$/;"	f	class:folly::IOBufQueue	signature:()
pop_front	.\io\IOBufQueue.h	/^  std::unique_ptr<folly::IOBuf> pop_front();$/;"	p	class:folly::IOBufQueue	access:public	signature:()
popcount	.\Bits.cpp	/^int popcount(unsigned int x)$/;"	p	namespace:folly::detail	file:	signature:(unsigned int x)
popcount	.\detail\BitsDetail.h	/^inline int popcount(unsigned int x) {$/;"	f	namespace:folly::detail	signature:(unsigned int x)
popcount	.\experimental\EliasFanoCoding.h	/^  static inline uint64_t popcount(uint64_t value) {$/;"	f	struct:folly::compression::instructions::Default	access:public	signature:(uint64_t value)
popcount	.\experimental\EliasFanoCoding.h	/^  static inline uint64_t popcount(uint64_t value) {$/;"	f	struct:folly::compression::instructions::Fast	access:public	signature:(uint64_t value)
popcount_builtin	.\Bits.cpp	/^int popcount_builtin(unsigned int x) {$/;"	f	namespace:__anon3	signature:(unsigned int x)
popcount_inst	.\Bits.cpp	/^int popcount_inst(unsigned int x) {$/;"	f	namespace:__anon3	signature:(unsigned int x)
popcountll	.\Bits.cpp	/^int popcountll(unsigned long long x)$/;"	p	namespace:folly::detail	file:	signature:(unsigned long long x)
popcountll	.\detail\BitsDetail.h	/^inline int popcountll(unsigned long long x) {$/;"	f	namespace:folly::detail	signature:(unsigned long long x)
popcountll_builtin	.\Bits.cpp	/^int popcountll_builtin(unsigned long long x) {$/;"	f	namespace:__anon3	signature:(unsigned long long x)
popcountll_inst	.\Bits.cpp	/^int popcountll_inst(unsigned long long x) {$/;"	f	namespace:__anon3	signature:(unsigned long long x)
populate	.\test\stl_tests\StlVectorTest.cpp	/^void populate(Vector& v, const pair<int, int>& ss) {$/;"	f	signature:(Vector& v, const pair<int, int>& ss)
populateIndex	.\test\stl_tests\StlVectorTest.cpp	/^int populateIndex = 1426;$/;"	v
populateMemForward	.\small_vector.h	/^  void populateMemForward(T* mem, std::size_t n, Function const& op) {$/;"	f	namespace:folly::detail	signature:(T* mem, std::size_t n, Function const& op)
port	.\SocketAddress.cpp	/^  const char* port;$/;"	m	struct:__anon90::HostAndPort	file:	access:public
port	.\Uri.h	/^  uint16_t port() const { return port_; }$/;"	f	class:folly::Uri	access:public	signature:() const
port_	.\SocketAddress.h	/^  uint16_t port_;$/;"	m	class:folly::SocketAddress	access:private
port_	.\Uri.h	/^  uint16_t port_;$/;"	m	class:folly::Uri	access:private
pos	.\Padded.h	/^  size_t pos() const { return pos_; }$/;"	f	namespace:folly::padded	signature:() const
pos_	.\GroupVarint.h	/^  size_t pos_;$/;"	m	class:folly::GroupVarintDecoder	access:private
pos_	.\Padded.h	/^  ssize_t pos_;  \/\/ signed for easier advance() implementation$/;"	m	namespace:folly::padded	access:private
pos_	.\io\IOBuf.h	/^  const IOBuf* pos_;$/;"	m	class:folly::IOBuf::Iterator	access:private
position	.\experimental\EliasFanoCoding.h	/^  size_t position() const { return position_; }$/;"	f	class:folly::compression::detail::UpperBitsReader	access:public	signature:() const
position	.\experimental\EliasFanoCoding.h	/^  size_t position() const { return progress_ - 1; }$/;"	f	class:folly::compression::EliasFanoReader	access:public	signature:() const
position_	.\experimental\EliasFanoCoding.h	/^  size_t position_;  \/\/ Index of current value (= #reads - 1).$/;"	m	class:folly::compression::detail::UpperBitsReader	access:private
post	.\Baton.h	/^  void post() {$/;"	f	struct:folly::Baton	access:public	signature:()
post	.\LifoSem.h	/^  void post() {$/;"	f	struct:folly::detail::LifoSemBase	access:public	signature:()
post	.\LifoSem.h	/^  void post(uint32_t n) {$/;"	f	struct:folly::detail::LifoSemBase	access:public	signature:(uint32_t n)
post	.\test\DeterministicSchedule.cpp	/^DeterministicSchedule::post(sem_t* sem) {$/;"	f	class:folly::test::DeterministicSchedule	signature:(sem_t* sem)
post	.\test\DeterministicSchedule.h	/^  static void post(sem_t* sem);$/;"	p	class:folly::test::DeterministicSchedule	access:public	signature:(sem_t* sem)
postallocate	.\io\IOBufQueue.h	/^  void postallocate(uint64_t n) {$/;"	f	class:folly::IOBufQueue	access:public	signature:(uint64_t n)
pow2	.\test\StringTest.cpp	/^double pow2(int exponent) {$/;"	f	namespace:__anon137	signature:(int exponent)
pr	.\EvictingCacheMap.h	/^    TPair pr;$/;"	m	struct:folly::EvictingCacheMap::Node	access:public
preFork	.\detail\ThreadLocalDetail.h	/^  static void preFork(void) {$/;"	f	struct:folly::threadlocal_detail::StaticMeta	access:public	signature:(void)
pread	.\experimental\io\AsyncIO.cpp	/^void AsyncIOOp::pread(int fd, Range<unsigned char*> range, off_t start) {$/;"	f	class:folly::AsyncIOOp	signature:(int fd, Range<unsigned char*> range, off_t start)
pread	.\experimental\io\AsyncIO.cpp	/^void AsyncIOOp::pread(int fd, void* buf, size_t size, off_t start) {$/;"	f	class:folly::AsyncIOOp	signature:(int fd, void* buf, size_t size, off_t start)
pread	.\experimental\io\AsyncIO.h	/^  void pread(int fd, Range<unsigned char*> range, off_t start);$/;"	p	class:folly::AsyncIOOp	access:public	signature:(int fd, Range<unsigned char*> range, off_t start)
pread	.\experimental\io\AsyncIO.h	/^  void pread(int fd, void* buf, size_t size, off_t start);$/;"	p	class:folly::AsyncIOOp	access:public	signature:(int fd, void* buf, size_t size, off_t start)
preadFull	.\FileUtil.cpp	/^ssize_t preadFull(int fd, void* buf, size_t count, off_t offset) {$/;"	f	namespace:folly	signature:(int fd, void* buf, size_t count, off_t offset)
preadFull	.\FileUtil.h	/^ssize_t preadFull(int fd, void* buf, size_t n, off_t offset);$/;"	p	namespace:folly	signature:(int fd, void* buf, size_t n, off_t offset)
preadNoInt	.\FileUtil.cpp	/^ssize_t preadNoInt(int fd, void* buf, size_t count, off_t offset) {$/;"	f	namespace:folly	signature:(int fd, void* buf, size_t count, off_t offset)
preadNoInt	.\FileUtil.h	/^ssize_t preadNoInt(int fd, void* buf, size_t n, off_t offset);$/;"	p	namespace:folly	signature:(int fd, void* buf, size_t n, off_t offset)
preadv	.\experimental\io\AsyncIO.cpp	/^void AsyncIOOp::preadv(int fd, const iovec* iov, int iovcnt, off_t start) {$/;"	f	class:folly::AsyncIOOp	signature:(int fd, const iovec* iov, int iovcnt, off_t start)
preadv	.\experimental\io\AsyncIO.h	/^  void preadv(int fd, const iovec* iov, int iovcnt, off_t start);$/;"	p	class:folly::AsyncIOOp	access:public	signature:(int fd, const iovec* iov, int iovcnt, off_t start)
preadvFull	.\FileUtil.cpp	/^ssize_t preadvFull(int fd, iovec* iov, int count, off_t offset) {$/;"	f	namespace:folly	signature:(int fd, iovec* iov, int count, off_t offset)
preadvFull	.\FileUtil.h	/^ssize_t preadvFull(int fd, iovec* iov, int count, off_t offset);$/;"	p	namespace:folly	signature:(int fd, iovec* iov, int count, off_t offset)
preallocate	.\io\IOBufQueue.h	/^  std::pair<void*,uint64_t> preallocate($/;"	f	class:folly::IOBufQueue	access:public	signature:( uint64_t min, uint64_t newAllocationSize, uint64_t max = std::numeric_limits<uint64_t>::max())
preallocateSlow	.\io\IOBufQueue.cpp	/^IOBufQueue::preallocateSlow(uint64_t min, uint64_t newAllocationSize,$/;"	f	class:folly::IOBufQueue	signature:(uint64_t min, uint64_t newAllocationSize, uint64_t max)
preallocateSlow	.\io\IOBufQueue.h	/^  std::pair<void*,uint64_t> preallocateSlow($/;"	p	class:folly::IOBufQueue	access:private	signature:( uint64_t min, uint64_t newAllocationSize, uint64_t max)
precision	.\FormatArg.h	/^  int precision;$/;"	m	struct:folly::FormatArg	access:public
predApplier	.\gen\ParallelMap-inl.h	/^      void predApplier() {$/;"	f	class:folly::gen::detail::PMap::Generator::ExecutionPipeline	access:private	signature:()
pred_	.\gen\Base-inl.h	/^    Predicate pred_;$/;"	m	class:folly::gen::detail::Filter::Generator	access:private
pred_	.\gen\Base-inl.h	/^    Predicate pred_;$/;"	m	class:folly::gen::detail::Map::Generator	access:private
pred_	.\gen\Base-inl.h	/^    Predicate pred_;$/;"	m	class:folly::gen::detail::Until::Generator	access:private
pred_	.\gen\Base-inl.h	/^  Predicate pred_;$/;"	m	class:folly::gen::detail::All	access:private
pred_	.\gen\Base-inl.h	/^  Predicate pred_;$/;"	m	class:folly::gen::detail::Filter	access:private
pred_	.\gen\Base-inl.h	/^  Predicate pred_;$/;"	m	class:folly::gen::detail::Map	access:private
pred_	.\gen\Base-inl.h	/^  Predicate pred_;$/;"	m	class:folly::gen::detail::Until	access:private
pred_	.\gen\ParallelMap-inl.h	/^      const Predicate& pred_;$/;"	m	class:folly::gen::detail::PMap::Generator::ExecutionPipeline	access:private
pred_	.\gen\ParallelMap-inl.h	/^    Predicate pred_;$/;"	m	class:folly::gen::detail::PMap::Generator	access:private
pred_	.\gen\ParallelMap-inl.h	/^  Predicate pred_;$/;"	m	class:folly::gen::detail::PMap	access:private
preds_	.\ConcurrentSkipList.h	/^  NodeType *succs_[MAX_HEIGHT], *preds_[MAX_HEIGHT];$/;"	m	class:folly::ConcurrentSkipList::Skipper	access:private
prefault	.\MemoryMapping.h	/^    bool prefault = false;$/;"	m	struct:folly::MemoryMapping::Options	access:public
prefix	.\io\IOBuf.cpp	/^  HeapPrefix prefix;$/;"	m	struct:folly::IOBuf::HeapStorage	file:	access:public
prefixMatch	.\SocketAddress.cpp	/^bool SocketAddress::prefixMatch(const SocketAddress& other,$/;"	f	class:folly::SocketAddress	signature:(const SocketAddress& other, unsigned prefixLength) const
prefixMatch	.\SocketAddress.h	/^  bool prefixMatch(const SocketAddress& other, unsigned prefixLength) const;$/;"	p	class:folly::SocketAddress	access:public	signature:(const SocketAddress& other, unsigned prefixLength) const
prefix_	.\experimental\wangle\concurrent\NamedThreadFactory.h	/^  folly::StringPiece prefix_;$/;"	m	class:folly::wangle::NamedThreadFactory	access:private
prepFamilyChange	.\SocketAddress.h	/^  void prepFamilyChange(sa_family_t newFamily) {$/;"	f	class:folly::SocketAddress	access:private	signature:(sa_family_t newFamily)
prepareChild	.\Subprocess.cpp	/^int Subprocess::prepareChild(const Options& options,$/;"	f	class:folly::Subprocess	signature:(const Options& options, const sigset_t* sigmask, const char* childDir) const
prepareChild	.\Subprocess.h	/^  int prepareChild(const Options& options,$/;"	p	class:folly::Subprocess	access:private	signature:(const Options& options, const sigset_t* sigmask, const char* childDir) const
prepareDelim	.\String-inl.h	/^inline char prepareDelim(char c) { return c; }$/;"	f	namespace:folly::detail	signature:(char c)
prepareDelim	.\String-inl.h	/^template<class String> StringPiece prepareDelim(const String& s) {$/;"	f	namespace:folly::detail	signature:(const String& s)
prepend	.\io\IOBuf.h	/^  void prepend(uint64_t amount) {$/;"	f	class:folly::IOBuf	access:public	signature:(uint64_t amount)
prepend	.\io\IOBufQueue.cpp	/^IOBufQueue::prepend(const void* buf, uint64_t n) {$/;"	f	class:folly::IOBufQueue	signature:(const void* buf, uint64_t n)
prepend	.\io\IOBufQueue.h	/^  void prepend(const void* buf, uint64_t n);$/;"	p	class:folly::IOBufQueue	access:public	signature:(const void* buf, uint64_t n)
prepend	.\io\TypedIOBuf.h	/^  void prepend(uint32_t n) {$/;"	f	class:folly::TypedIOBuf	access:public	signature:(uint32_t n)
prepend	.\io\test\IOBufTest.cpp	/^void prepend(std::unique_ptr<IOBuf>& buf, StringPiece str) {$/;"	f	signature:(std::unique_ptr<IOBuf>& buf, StringPiece str)
prependChain	.\io\IOBuf.cpp	/^void IOBuf::prependChain(unique_ptr<IOBuf>&& iobuf) {$/;"	f	class:folly::IOBuf	signature:(unique_ptr<IOBuf>&& iobuf)
prependChain	.\io\IOBuf.h	/^  void prependChain(std::unique_ptr<IOBuf>&& iobuf);$/;"	p	class:folly::IOBuf	access:public	signature:(std::unique_ptr<IOBuf>&& iobuf)
prependHeader	.\io\RecordIO.cpp	/^size_t prependHeader(std::unique_ptr<IOBuf>& buf, uint32_t fileId) {$/;"	f	namespace:folly::recordio_helpers	signature:(std::unique_ptr<IOBuf>& buf, uint32_t fileId)
prependHeader	.\io\RecordIO.h	/^size_t prependHeader(std::unique_ptr<IOBuf>& buf, uint32_t fileId = 1);$/;"	p	namespace:folly::recordio_helpers	signature:(std::unique_ptr<IOBuf>& buf, uint32_t fileId = 1)
prepopulate	.\test\small_vector_test.cpp	/^  int const prepopulate;$/;"	m	struct:__anon132::TestBasicGuarantee	file:	access:public
presentation	.\FormatArg.h	/^  char presentation;$/;"	m	struct:folly::FormatArg	access:public
prettyPrint	.\String.cpp	/^std::string prettyPrint(double val, PrettyType type, bool addSpace) {$/;"	f	namespace:folly	signature:(double val, PrettyType type, bool addSpace)
prettyPrint	.\String.h	/^std::string prettyPrint(double val, PrettyType, bool addSpace = true);$/;"	p	class:folly::UriEscapeMode	access:private	signature:(double val, PrettyType, bool addSpace = true)
prettyString	.\test\StringTest.cpp	/^  std::string prettyString;$/;"	m	struct:PrettyTestCase	file:	access:public
prettyTestCases	.\test\StringTest.cpp	/^PrettyTestCase prettyTestCases[] =$/;"	v
prettyToDouble	.\String.cpp	/^double prettyToDouble(folly::StringPiece *const prettyString,$/;"	f	namespace:folly	signature:(folly::StringPiece *const prettyString, const PrettyType type)
prettyToDouble	.\String.cpp	/^double prettyToDouble(folly::StringPiece prettyString, const PrettyType type){$/;"	f	namespace:folly	signature:(folly::StringPiece prettyString, const PrettyType type)
prettyToDouble	.\String.h	/^double prettyToDouble(folly::StringPiece *const prettyString,$/;"	p	class:folly::UriEscapeMode	access:private	signature:(folly::StringPiece *const prettyString, const PrettyType type)
prettyToDouble	.\String.h	/^double prettyToDouble(folly::StringPiece prettyString, const PrettyType type);$/;"	p	class:folly::UriEscapeMode	access:private	signature:(folly::StringPiece prettyString, const PrettyType type)
prettyType	.\test\StringTest.cpp	/^  PrettyType prettyType;$/;"	m	struct:PrettyTestCase	file:	access:public
pretty_formatting	.\json.h	/^    bool pretty_formatting;$/;"	m	struct:folly::json::serialization_opts	access:public
prev	.\detail\ThreadLocalDetail.h	/^  ThreadEntry* prev;$/;"	m	struct:folly::threadlocal_detail::ThreadEntry	access:public
prev	.\io\IOBuf.h	/^  IOBuf* prev() {$/;"	f	class:folly::IOBuf	access:public	signature:()
prev	.\io\IOBuf.h	/^  const IOBuf* prev() const {$/;"	f	class:folly::IOBuf	access:public	signature:() const
prevId	.\detail\CacheLocality.h	/^  static Atom<size_t> prevId;$/;"	m	struct:folly::detail::SequentialThreadId	access:private
prev_	.\test\AHMIntStressTest.cpp	/^  std::shared_ptr<MyMap> prev_;$/;"	m	struct:__anon102::MyObjectDirectory	file:	access:public
primeFactors	.\gen\test\ParallelTest.cpp	/^static auto primeFactors = [](int n) {$/;"	v	file:
primes	.\gen\test\ParallelBenchmark.cpp	/^static auto primes =$/;"	v	file:
primes	.\gen\test\ParallelTest.cpp	/^static auto primes = seq(1, 1 << 14)$/;"	v	file:
print	.\dynamic-inl.h	/^  static void print(dynamic const& d,$/;"	f	struct:folly::dynamic::PrintImpl	access:public	signature:(dynamic const& d, std::ostream& out, dynamic::Array const&)
print	.\dynamic-inl.h	/^  static void print(dynamic const& d,$/;"	f	struct:folly::dynamic::PrintImpl	access:public	signature:(dynamic const& d, std::ostream& out, dynamic::ObjectImpl const&)
print	.\dynamic-inl.h	/^  static void print(dynamic const&, std::ostream& out, T const& t) {$/;"	f	struct:folly::dynamic::PrintImpl	access:public	signature:(dynamic const&, std::ostream& out, T const& t)
print	.\dynamic-inl.h	/^inline void dynamic::print(std::ostream& out) const {$/;"	f	class:folly::dynamic	signature:(std::ostream& out) const
print	.\dynamic.h	/^  void print(std::ostream&) const;$/;"	p	struct:folly::dynamic	access:private	signature:(std::ostream&) const
print	.\experimental\symbolizer\SignalHandler.cpp	/^void print(StringPiece sp) {$/;"	f	namespace:folly::symbolizer::__anon36	signature:(StringPiece sp)
print	.\experimental\symbolizer\Symbolizer.cpp	/^void SymbolizePrinter::print(uintptr_t address, const SymbolizedFrame& frame) {$/;"	f	class:folly::symbolizer::SymbolizePrinter	signature:(uintptr_t address, const SymbolizedFrame& frame)
print	.\experimental\symbolizer\Symbolizer.h	/^  void print(StringPiece sp) { doPrint(sp); }$/;"	f	class:folly::symbolizer::SymbolizePrinter	access:public	signature:(StringPiece sp)
print	.\experimental\symbolizer\Symbolizer.h	/^  void print(uintptr_t address, const SymbolizedFrame& frame);$/;"	p	class:folly::symbolizer::SymbolizePrinter	access:public	signature:(uintptr_t address, const SymbolizedFrame& frame)
print	.\experimental\symbolizer\test\SignalHandlerTest.cpp	/^void print(StringPiece sp) {$/;"	f	namespace:folly::symbolizer::test::__anon44	signature:(StringPiece sp)
print	.\test\stl_tests\StlVectorTest.cpp	/^  void print(const std::string& fun) {$/;"	f	struct:DataTracker	access:public	signature:(const std::string& fun)
printArray	.\json.cpp	/^  void printArray(dynamic const& a) const {$/;"	f	struct:folly::json::__anon75::Printer	file:	access:private	signature:(dynamic const& a) const
printBenchmarkResults	.\Benchmark.cpp	/^static void printBenchmarkResults($/;"	f	namespace:folly	signature:( const vector<tuple<const char*, const char*, double> >& data)
printBenchmarkResultsAsJson	.\Benchmark.cpp	/^static void printBenchmarkResultsAsJson($/;"	f	namespace:folly	signature:( const vector<tuple<const char*, const char*, double> >& data)
printBenchmarkResultsAsTable	.\Benchmark.cpp	/^static void printBenchmarkResultsAsTable($/;"	f	namespace:folly	signature:( const vector<tuple<const char*, const char*, double> >& data)
printDec	.\experimental\symbolizer\SignalHandler.cpp	/^void printDec(uint64_t val) {$/;"	f	namespace:folly::symbolizer::__anon36	signature:(uint64_t val)
printHex	.\experimental\symbolizer\SignalHandler.cpp	/^void printHex(uint64_t val) {$/;"	f	namespace:folly::symbolizer::__anon36	signature:(uint64_t val)
printHistogram	.\test\ProducerConsumerQueueBenchmark.cpp	/^  void printHistogram() {$/;"	f	struct:__anon127::LatencyTest	access:public	signature:()
printKV	.\json.cpp	/^  void printKV(const std::pair<const dynamic, dynamic>& p) const {$/;"	f	struct:folly::json::__anon75::Printer	file:	access:private	signature:(const std::pair<const dynamic, dynamic>& p) const
printKVPairs	.\json.cpp	/^  void printKVPairs(Iterator begin, Iterator end) const {$/;"	f	struct:folly::json::__anon75::Printer	file:	access:private	signature:(Iterator begin, Iterator end) const
printObject	.\json.cpp	/^  void printObject(dynamic const& o) const {$/;"	f	struct:folly::json::__anon75::Printer	file:	access:private	signature:(dynamic const& o) const
printTerse	.\experimental\symbolizer\Symbolizer.cpp	/^void SymbolizePrinter::printTerse(uintptr_t address,$/;"	f	class:folly::symbolizer::SymbolizePrinter	signature:(uintptr_t address, const SymbolizedFrame& frame)
printTerse	.\experimental\symbolizer\Symbolizer.h	/^  void printTerse(uintptr_t address, const SymbolizedFrame& frame);$/;"	p	class:folly::symbolizer::SymbolizePrinter	access:private	signature:(uintptr_t address, const SymbolizedFrame& frame)
print_as_pseudo_json	.\dynamic.h	/^  void print_as_pseudo_json(std::ostream&) const; \/\/ see json.cpp$/;"	p	struct:folly::dynamic	access:private	signature:(std::ostream&) const
print_as_pseudo_json	.\json.cpp	/^void dynamic::print_as_pseudo_json(std::ostream& out) const {$/;"	f	class:folly::dynamic	signature:(std::ostream& out) const
println	.\experimental\symbolizer\Symbolizer.cpp	/^void SymbolizePrinter::println(const uintptr_t* addresses,$/;"	f	class:folly::symbolizer::SymbolizePrinter	signature:(const uintptr_t* addresses, const SymbolizedFrame* frames, size_t frameCount)
println	.\experimental\symbolizer\Symbolizer.cpp	/^void SymbolizePrinter::println(uintptr_t address,$/;"	f	class:folly::symbolizer::SymbolizePrinter	signature:(uintptr_t address, const SymbolizedFrame& frame)
println	.\experimental\symbolizer\Symbolizer.h	/^  void println(const FrameArray<N>& fa, size_t skip=0) {$/;"	f	class:folly::symbolizer::SymbolizePrinter	access:public	signature:(const FrameArray<N>& fa, size_t skip=0)
println	.\experimental\symbolizer\Symbolizer.h	/^  void println(const uintptr_t* addresses,$/;"	p	class:folly::symbolizer::SymbolizePrinter	access:public	signature:(const uintptr_t* addresses, const SymbolizedFrame* frames, size_t frameCount)
println	.\experimental\symbolizer\Symbolizer.h	/^  void println(uintptr_t address, const SymbolizedFrame& frame);$/;"	p	class:folly::symbolizer::SymbolizePrinter	access:public	signature:(uintptr_t address, const SymbolizedFrame& frame)
probeNext	.\AtomicHashArray.h	/^  inline size_t probeNext(size_t idx, size_t numProbes) {$/;"	f	class:folly::AtomicHashArray	access:private	signature:(size_t idx, size_t numProbes)
producer	.\test\ProducerConsumerQueueBenchmark.cpp	/^  void producer() {$/;"	f	struct:__anon127::LatencyTest	access:public	signature:()
producer	.\test\ProducerConsumerQueueBenchmark.cpp	/^  void producer() {$/;"	f	struct:__anon127::ThroughputTest	access:public	signature:()
producer	.\test\ProducerConsumerQueueTest.cpp	/^  void producer() {$/;"	f	struct:__anon128::CorrectnessTest	access:public	signature:()
producer	.\test\ProducerConsumerQueueTest.cpp	/^  void producer() {$/;"	f	struct:__anon128::PerfTest	access:public	signature:()
producerConsumerBench	.\test\MPMCQueueTest.cpp	/^std::string producerConsumerBench(Q&& queue, std::string qName,$/;"	f	signature:(Q&& queue, std::string qName, int numProducers, int numConsumers, int numOps, bool ignoreContents = false)
producers	.\gen\Parallel-inl.h	/^  size_t producers() const {$/;"	f	class:folly::gen::detail::ClosableMPMCQueue	access:public	signature:() const
product	.\gen\test\BaseTest.cpp	/^auto product = foldl(1, multiply);$/;"	v
progress_	.\experimental\EliasFanoCoding.h	/^  size_t progress_ = 0;$/;"	m	class:folly::compression::EliasFanoReader	access:private
prologueEnd_	.\experimental\symbolizer\Dwarf.h	/^    bool prologueEnd_;$/;"	m	class:folly::symbolizer::Dwarf::LineNumberVM	access:private
promise_	.\wangle\OpaqueCallbackShunt.h	/^  folly::wangle::Promise<T> promise_;$/;"	m	class:folly::wangle::OpaqueCallbackShunt	access:public
propagate_on_container_copy_assignment	.\test\stl_tests\StlVectorTest.cpp	/^  typedef isPropCopy<T> propagate_on_container_copy_assignment;$/;"	t	struct:Alloc	file:	access:public
propagate_on_container_move_assignment	.\test\stl_tests\StlVectorTest.cpp	/^  typedef isPropMove<T> propagate_on_container_move_assignment;$/;"	t	struct:Alloc	file:	access:public
propagate_on_container_swap	.\test\stl_tests\StlVectorTest.cpp	/^  typedef isPropSwap<T> propagate_on_container_swap;$/;"	t	struct:Alloc	file:	access:public
provideBinary16Bytes	.\test\IPAddressTest.cpp	/^static vector<pair<string, vector<uint8_t> > > provideBinary16Bytes = {$/;"	v	file:
provideToLong	.\test\IPAddressTest.cpp	/^static vector<pair<string, uint32_t> > provideToLong = {$/;"	v	file:
prune	.\EvictingCacheMap.h	/^  void prune(std::size_t pruneSize, PruneHookCall pruneHook = nullptr) {$/;"	f	class:folly::EvictingCacheMap	access:public	signature:(std::size_t pruneSize, PruneHookCall pruneHook = nullptr)
pruneHook_	.\EvictingCacheMap.h	/^  PruneHookCall pruneHook_;$/;"	m	class:folly::EvictingCacheMap	access:private
pruneWithFailSafeOption	.\EvictingCacheMap.h	/^  void pruneWithFailSafeOption(std::size_t pruneSize,$/;"	f	class:folly::EvictingCacheMap	access:private	signature:(std::size_t pruneSize, PruneHookCall pruneHook, bool failSafe)
psl	.\test\SmallLocksTest.cpp	/^struct ignore2 { PicoSpinLock<uint32_t> psl; int16_t foo; }$/;"	m	struct:__anon131::ignore2	file:	access:public
pthreadKey_	.\detail\ThreadLocalDetail.h	/^  pthread_key_t pthreadKey_;$/;"	m	struct:folly::threadlocal_detail::StaticMeta	access:public
pthread_get_specific	.\test\ThreadLocalTest.cpp	/^PThreadGetSpecific<int> pthread_get_specific;$/;"	v
pthread_get_specific	.\test\ThreadLocalTest.cpp	/^REG(pthread_get_specific);$/;"	v
pthread_yield	.\Portability.h	37;"	d
ptr	.\DiscriminatedPtr.h	/^  void* ptr() const {$/;"	f	class:folly::DiscriminatedPtr	access:private	signature:() const
ptr	.\detail\ThreadLocalDetail.h	/^  void* ptr;$/;"	m	struct:folly::threadlocal_detail::ElementWrapper	access:public
ptr	.\experimental\Singleton.h	/^  T* ptr() { return get_ptr(type_descriptor_, vault_); }$/;"	f	class:folly::Singleton	access:public	signature:()
ptr	.\test\ThreadLocalTest.cpp	/^ThreadLocal<HoldsOne, HoldsOneTag> ptr;$/;"	m	namespace:__anon147	file:
ptr_	.\Arena.h	/^  char* ptr_;$/;"	m	class:folly::Arena	access:private
ptr_	.\Random.cpp	/^  unsigned char* ptr_;$/;"	m	class:folly::__anon82::BufferedRandomDevice	file:	access:private
ptr_	.\test\ScopeGuardTest.cpp	/^  int* ptr_;$/;"	m	class:MyFunctor	file:	access:private
pull	.\io\Cursor.h	/^  void pull(void* buf, size_t len) {$/;"	f	class:folly::io::detail::CursorBase	access:public	signature:(void* buf, size_t len)
pullAtMost	.\io\Cursor.h	/^  size_t pullAtMost(void* buf, size_t len) {$/;"	f	class:folly::io::detail::CursorBase	access:public	signature:(void* buf, size_t len)
puller_	.\gen\Parallel-inl.h	/^      Puller puller_;$/;"	m	class:folly::gen::detail::Parallel::Generator::Executor	access:private
push	.\io\Cursor.h	/^  void push(const uint8_t* buf, size_t len) {$/;"	f	class:folly::io::detail::Writable	access:public	signature:(const uint8_t* buf, size_t len)
push	.\io\TypedIOBuf.h	/^  void push(IT begin, IT end) {$/;"	f	class:folly::TypedIOBuf	access:public	signature:(IT begin, IT end)
push	.\io\TypedIOBuf.h	/^  void push(const T& data) {$/;"	f	class:folly::TypedIOBuf	access:public	signature:(const T& data)
pushAtMost	.\io\Cursor.h	/^  size_t pushAtMost(const uint8_t* buf, size_t len) {$/;"	f	class:folly::io::Appender	access:public	signature:(const uint8_t* buf, size_t len)
pushAtMost	.\io\Cursor.h	/^  size_t pushAtMost(const uint8_t* buf, size_t len) {$/;"	f	class:folly::io::QueueAppender	access:public	signature:(const uint8_t* buf, size_t len)
pushAtMost	.\io\Cursor.h	/^  size_t pushAtMost(const uint8_t* buf, size_t len) {$/;"	f	class:folly::io::RWCursor	access:public	signature:(const uint8_t* buf, size_t len)
pushBack	.\test\FBVectorTestBenchmarks.cpp.h	/^void BENCHFUN(pushBack)(int iters, int size) {$/;"	f	signature:(int iters, int size)
pushCurrent	.\experimental\exception_tracer\StackTrace.cpp	/^bool StackTraceStack::pushCurrent() {$/;"	f	class:folly::exception_tracer::StackTraceStack	signature:()
pushCurrent	.\experimental\exception_tracer\StackTrace.h	/^  bool pushCurrent();$/;"	p	class:folly::exception_tracer::StackTraceStack	access:public	signature:()
pushSpinCutoff_	.\MPMCQueue.h	/^    , pushSpinCutoff_(rhs.pushSpinCutoff_.load(std::memory_order_relaxed))$/;"	p	class:folly::MPMCQueue	access:public	signature:(rhs.pushSpinCutoff_.load(std::memory_order_relaxed))
pushSpinCutoff_	.\MPMCQueue.h	/^  Atom<int> FOLLY_ALIGN_TO_AVOID_FALSE_SHARING pushSpinCutoff_;$/;"	m	class:folly::MPMCQueue	access:private
pushTicket_	.\MPMCQueue.h	/^    , pushTicket_(rhs.pushTicket_.load(std::memory_order_relaxed))$/;"	p	class:folly::MPMCQueue	access:public	signature:(rhs.pushTicket_.load(std::memory_order_relaxed))
pushTicket_	.\MPMCQueue.h	/^  Atom<uint64_t> FOLLY_ALIGN_TO_AVOID_FALSE_SHARING pushTicket_;$/;"	m	class:folly::MPMCQueue	access:private
push_back	.\FBVector.h	/^  push_back(T&& value) {$/;"	f	signature:(T&& value)
push_back	.\FBVector.h	/^  push_back(const T& value) {$/;"	f	signature:(const T& value)
push_back	.\Padded.h	/^  void push_back(value_type x) {$/;"	f	class:folly::Adaptor	access:public	signature:(value_type x)
push_back	.\detail\ThreadLocalDetail.h	/^  void push_back(ThreadEntry* t) {$/;"	f	struct:folly::threadlocal_detail::StaticMeta	access:public	signature:(ThreadEntry* t)
push_back	.\dynamic-inl.h	/^inline void dynamic::push_back(dynamic const& v) {$/;"	f	class:folly::dynamic	signature:(dynamic const& v)
push_back	.\dynamic-inl.h	/^inline void dynamic::push_back(dynamic&& v) {$/;"	f	class:folly::dynamic	signature:(dynamic&& v)
push_back	.\dynamic.h	/^  void push_back(dynamic const&);$/;"	p	struct:folly::dynamic	access:public	signature:(dynamic const&)
push_back	.\dynamic.h	/^  void push_back(dynamic&&);$/;"	p	struct:folly::dynamic	access:public	signature:(dynamic&&)
push_back	.\io\TypedIOBuf.h	/^  void push_back(const T& data) { push(data); }$/;"	f	class:folly::TypedIOBuf	access:public	signature:(const T& data)
push_back	.\small_vector.h	/^  void push_back(value_type const& t) {$/;"	f	class:folly::small_vector	access:public	signature:(value_type const& t)
push_back	.\small_vector.h	/^  void push_back(value_type&& t) {$/;"	f	class:folly::small_vector	access:public	signature:(value_type&& t)
push_back	.\test\FBStringTestBenchmarks.cpp.h	/^void BENCHFUN(push_back)(int iters, int arg) {$/;"	f	signature:(int iters, int arg)
push_back	.\test\PackedSyncPtrTest.cpp	/^  void push_back(const T& t) {$/;"	f	struct:SyncVec	access:public	signature:(const T& t)
pusher_	.\gen\Parallel-inl.h	/^      Pusher<all> pusher_;$/;"	m	class:folly::gen::detail::Parallel::Generator::Executor	access:private
putMessage	.\io\async\NotificationQueue.h	/^  void putMessage(MessageT&& message) {$/;"	f	class:folly::NotificationQueue	access:public	signature:(MessageT&& message)
putMessage	.\io\async\NotificationQueue.h	/^  void putMessage(const MessageT& message) {$/;"	f	class:folly::NotificationQueue	access:public	signature:(const MessageT& message)
putMessageImpl	.\io\async\NotificationQueue.h	/^  bool putMessageImpl($/;"	f	class:folly::NotificationQueue	access:private	signature:( const MessageT& message, size_t maxSize, bool throws=true)
putMessageImpl	.\io\async\NotificationQueue.h	/^  bool putMessageImpl(MessageT&& message, size_t maxSize, bool throws=true) {$/;"	f	class:folly::NotificationQueue	access:private	signature:(MessageT&& message, size_t maxSize, bool throws=true)
putMessages	.\io\async\NotificationQueue.h	/^  void putMessages(InputIteratorT first, InputIteratorT last) {$/;"	f	class:folly::NotificationQueue	access:public	signature:(InputIteratorT first, InputIteratorT last)
putMessagesImpl	.\io\async\NotificationQueue.h	/^  void putMessagesImpl(InputIteratorT first, InputIteratorT last,$/;"	f	class:folly::NotificationQueue	access:private	signature:(InputIteratorT first, InputIteratorT last, std::input_iterator_tag)
pwrite	.\experimental\io\AsyncIO.cpp	/^void AsyncIOOp::pwrite(int fd, Range<const unsigned char*> range, off_t start) {$/;"	f	class:folly::AsyncIOOp	signature:(int fd, Range<const unsigned char*> range, off_t start)
pwrite	.\experimental\io\AsyncIO.cpp	/^void AsyncIOOp::pwrite(int fd, const void* buf, size_t size, off_t start) {$/;"	f	class:folly::AsyncIOOp	signature:(int fd, const void* buf, size_t size, off_t start)
pwrite	.\experimental\io\AsyncIO.h	/^  void pwrite(int fd, Range<const unsigned char*> range, off_t start);$/;"	p	class:folly::AsyncIOOp	access:public	signature:(int fd, Range<const unsigned char*> range, off_t start)
pwrite	.\experimental\io\AsyncIO.h	/^  void pwrite(int fd, const void* buf, size_t size, off_t start);$/;"	p	class:folly::AsyncIOOp	access:public	signature:(int fd, const void* buf, size_t size, off_t start)
pwriteFull	.\FileUtil.cpp	/^ssize_t pwriteFull(int fd, const void* buf, size_t count, off_t offset) {$/;"	f	namespace:folly	signature:(int fd, const void* buf, size_t count, off_t offset)
pwriteFull	.\FileUtil.h	/^ssize_t pwriteFull(int fd, const void* buf, size_t n, off_t offset);$/;"	p	namespace:folly	signature:(int fd, const void* buf, size_t n, off_t offset)
pwriteNoInt	.\FileUtil.cpp	/^ssize_t pwriteNoInt(int fd, const void* buf, size_t count, off_t offset) {$/;"	f	namespace:folly	signature:(int fd, const void* buf, size_t count, off_t offset)
pwriteNoInt	.\FileUtil.h	/^ssize_t pwriteNoInt(int fd, const void* buf, size_t n, off_t offset);$/;"	p	namespace:folly	signature:(int fd, const void* buf, size_t n, off_t offset)
pwritev	.\experimental\io\AsyncIO.cpp	/^void AsyncIOOp::pwritev(int fd, const iovec* iov, int iovcnt, off_t start) {$/;"	f	class:folly::AsyncIOOp	signature:(int fd, const iovec* iov, int iovcnt, off_t start)
pwritev	.\experimental\io\AsyncIO.h	/^  void pwritev(int fd, const iovec* iov, int iovcnt, off_t start);$/;"	p	class:folly::AsyncIOOp	access:public	signature:(int fd, const iovec* iov, int iovcnt, off_t start)
pwritevFull	.\FileUtil.cpp	/^ssize_t pwritevFull(int fd, iovec* iov, int count, off_t offset) {$/;"	f	namespace:folly	signature:(int fd, iovec* iov, int count, off_t offset)
pwritevFull	.\FileUtil.h	/^ssize_t pwritevFull(int fd, iovec* iov, int count, off_t offset);$/;"	p	namespace:folly	signature:(int fd, iovec* iov, int count, off_t offset)
qfind	.\Range.h	/^inline size_t qfind(const Range<T> & haystack,$/;"	p	namespace:folly	signature:(const Range<T> & haystack, const Range<T> & needle, Comp eq = Comp())
qfind	.\Range.h	/^inline size_t qfind(const Range<const char*>& haystack, const char& needle) {$/;"	f	namespace:folly	signature:(const Range<const char*>& haystack, const char& needle)
qfind	.\Range.h	/^inline size_t qfind(const Range<const unsigned char*>& haystack,$/;"	f	namespace:folly	signature:(const Range<const unsigned char*>& haystack, const unsigned char& needle)
qfind	.\Range.h	/^size_t qfind(const Range<T> & haystack,$/;"	p	namespace:folly	signature:(const Range<T> & haystack, const typename Range<T>::value_type& needle)
qfind	.\Range.h	/^size_t qfind(const Range<T>& haystack,$/;"	f	namespace:folly	signature:(const Range<T>& haystack, const Range<T>& needle, Comp eq)
qfind	.\Range.h	/^size_t qfind(const Range<T>& haystack,$/;"	f	namespace:folly	signature:(const Range<T>& haystack, const typename Range<T>::value_type& needle)
qfind_first_byte_of	.\Range.h	/^inline size_t qfind_first_byte_of(const StringPiece& haystack,$/;"	f	namespace:folly::detail	signature:(const StringPiece& haystack, const StringPiece& needles)
qfind_first_byte_of_byteset	.\Range.cpp	/^size_t qfind_first_byte_of_byteset(const StringPiece& haystack,$/;"	f	namespace:folly::detail	signature:(const StringPiece& haystack, const StringPiece& needles)
qfind_first_byte_of_byteset	.\test\RangeFindBenchmark.cpp	/^size_t qfind_first_byte_of_byteset(const StringPiece& haystack,$/;"	p	namespace:folly::detail	file:	signature:(const StringPiece& haystack, const StringPiece& needles)
qfind_first_byte_of_byteset	.\test\RangeTest.cpp	/^size_t qfind_first_byte_of_byteset(const StringPiece& haystack,$/;"	p	namespace:folly::detail	file:	signature:(const StringPiece& haystack, const StringPiece& needles)
qfind_first_byte_of_memchr	.\Range.cpp	/^size_t qfind_first_byte_of_memchr(const StringPiece& haystack,$/;"	f	namespace:folly::detail	signature:(const StringPiece& haystack, const StringPiece& needles)
qfind_first_byte_of_memchr	.\test\RangeFindBenchmark.cpp	/^size_t qfind_first_byte_of_memchr(const StringPiece& haystack,$/;"	p	namespace:folly::detail	file:	signature:(const StringPiece& haystack, const StringPiece& needles)
qfind_first_byte_of_memchr	.\test\RangeTest.cpp	/^size_t qfind_first_byte_of_memchr(const StringPiece& haystack,$/;"	p	namespace:folly::detail	file:	signature:(const StringPiece& haystack, const StringPiece& needles)
qfind_first_byte_of_needles16	.\Range.cpp	/^size_t qfind_first_byte_of_needles16(const StringPiece& haystack,$/;"	f	namespace:folly::__anon83	signature:(const StringPiece& haystack, const StringPiece& needles)
qfind_first_byte_of_nosse	.\Range.cpp	/^size_t qfind_first_byte_of_nosse(const StringPiece& haystack,$/;"	f	namespace:folly::detail	signature:(const StringPiece& haystack, const StringPiece& needles)
qfind_first_byte_of_nosse	.\Range.h	/^size_t qfind_first_byte_of_nosse(const StringPiece& haystack,$/;"	p	namespace:folly::detail	signature:(const StringPiece& haystack, const StringPiece& needles)
qfind_first_byte_of_nosse	.\test\RangeFindBenchmark.cpp	/^size_t qfind_first_byte_of_nosse(const StringPiece& haystack,$/;"	p	namespace:folly::detail	file:	signature:(const StringPiece& haystack, const StringPiece& needles)
qfind_first_byte_of_sse42	.\Range.cpp	/^size_t qfind_first_byte_of_sse42(const StringPiece& haystack,$/;"	f	namespace:folly::detail	signature:(const StringPiece& haystack, const StringPiece& needles)
qfind_first_byte_of_sse42	.\Range.cpp	/^size_t qfind_first_byte_of_sse42(const StringPiece& haystack,$/;"	p	namespace:folly::detail	file:	signature:(const StringPiece& haystack, const StringPiece& needles)
qfind_first_byte_of_sse42	.\Range.h	/^size_t qfind_first_byte_of_sse42(const StringPiece& haystack,$/;"	p	namespace:folly::detail	signature:(const StringPiece& haystack, const StringPiece& needles)
qfind_first_byte_of_std	.\test\RangeFindBenchmark.cpp	/^inline size_t qfind_first_byte_of_std(const StringPiece& haystack,$/;"	f	signature:(const StringPiece& haystack, const StringPiece& needles)
qfind_first_of	.\Range.h	/^inline size_t qfind_first_of(const Range<T> & haystack,$/;"	p	namespace:folly	signature:(const Range<T> & haystack, const Range<T> & needle)
qfind_first_of	.\Range.h	/^inline size_t qfind_first_of(const Range<const char*>& haystack,$/;"	f	namespace:folly	signature:(const Range<const char*>& haystack, const Range<const char*>& needles)
qfind_first_of	.\Range.h	/^inline size_t qfind_first_of(const Range<const unsigned char*>& haystack,$/;"	f	namespace:folly	signature:(const Range<const unsigned char*>& haystack, const Range<const unsigned char*>& needles)
qfind_first_of	.\Range.h	/^size_t qfind_first_of(const Range<T> & haystack,$/;"	f	namespace:folly	signature:(const Range<T> & haystack, const Range<T> & needles, Comp eq)
qfind_first_of	.\Range.h	/^size_t qfind_first_of(const Range<T>& haystack,$/;"	f	namespace:folly	signature:(const Range<T>& haystack, const Range<T>& needles)
query	.\Uri.h	/^  const fbstring& query() const { return query_; }$/;"	f	class:folly::Uri	access:public	signature:() const
queryParams_	.\Uri.h	/^  std::vector<std::pair<fbstring, fbstring>> queryParams_;$/;"	m	class:folly::Uri	access:private
query_	.\Uri.h	/^  fbstring query_;$/;"	m	class:folly::Uri	access:private
queueFront	.\Subprocess.cpp	/^std::pair<const uint8_t*, size_t> queueFront(const IOBufQueue& queue) {$/;"	f	namespace:folly::__anon99	signature:(const IOBufQueue& queue)
queue_	.\detail\MPMCPipelineDetail.h	/^  MPMCQueue<T> queue_;$/;"	m	class:folly::detail::MPMCPipelineStageImpl	access:private
queue_	.\experimental\io\AsyncIO.h	/^  std::deque<OpFactory> queue_;$/;"	m	class:folly::AsyncIOQueue	access:private
queue_	.\experimental\wangle\concurrent\LifoSemMPMCQueue.h	/^  MPMCQueue<T> queue_;$/;"	m	class:folly::wangle::LifoSemMPMCQueue	access:private
queue_	.\experimental\wangle\concurrent\ThreadPoolExecutor.h	/^    std::queue<ThreadPtr> queue_;$/;"	m	class:folly::wangle::ThreadPoolExecutor::StoppedThreadQueue	access:private
queue_	.\gen\Parallel-inl.h	/^      InQueue* queue_;$/;"	m	class:folly::gen::detail::Parallel::Generator::Puller	access:private
queue_	.\gen\Parallel-inl.h	/^      OutQueue* queue_;$/;"	m	class:folly::gen::detail::Parallel::Generator::Pusher	access:private
queue_	.\gen\Parallel-inl.h	/^  MPMCQueue<T> queue_;$/;"	m	class:folly::gen::detail::ClosableMPMCQueue	access:private
queue_	.\io\Cursor.h	/^  folly::IOBufQueue* queue_;$/;"	m	class:folly::io::QueueAppender	access:private
queue_	.\io\async\EventBase.h	/^  std::unique_ptr<NotificationQueue<std::pair<void (*)(void*), void*>>> queue_;$/;"	m	class:folly::EventBase	access:private
queue_	.\io\async\NotificationQueue.h	/^      queue_() {$/;"	f	class:folly::NotificationQueue	access:public	signature:()
queue_	.\io\async\NotificationQueue.h	/^    NotificationQueue* queue_;$/;"	m	class:folly::NotificationQueue::Consumer	access:private
queue_	.\io\async\NotificationQueue.h	/^  std::deque<std::pair<MessageT, std::shared_ptr<RequestContext>>> queue_;$/;"	m	class:folly::NotificationQueue	access:private
queue_	.\test\ProducerConsumerQueueBenchmark.cpp	/^  QueueType queue_;$/;"	m	struct:__anon127::LatencyTest	file:	access:public
queue_	.\test\ProducerConsumerQueueBenchmark.cpp	/^  QueueType queue_;$/;"	m	struct:__anon127::ThroughputTest	file:	access:public
queue_	.\test\ProducerConsumerQueueTest.cpp	/^  QueueType queue_;$/;"	m	struct:__anon128::CorrectnessTest	file:	access:public
queue_	.\test\ProducerConsumerQueueTest.cpp	/^  QueueType queue_;$/;"	m	struct:__anon128::PerfTest	file:	access:public
queued	.\experimental\io\AsyncIO.h	/^  size_t queued() const { return queue_.size(); }$/;"	f	class:folly::AsyncIOQueue	access:public	signature:() const
raceFinalSizeEstimate	.\test\AtomicHashMapTest.cpp	/^int raceFinalSizeEstimate;$/;"	m	namespace:__anon106	file:
raceInsertRandomThread	.\test\AtomicHashMapTest.cpp	/^void* raceInsertRandomThread(void* jj) {$/;"	f	namespace:__anon106	signature:(void* jj)
raceIterateThread	.\test\AtomicHashMapTest.cpp	/^void* raceIterateThread(void* jj) {$/;"	f	namespace:__anon106	signature:(void* jj)
rallocx	.\detail\Malloc.h	/^extern void* (*rallocx)(void*, size_t, int);$/;"	x
rallocx	.\detail\Malloc.h	/^void* rallocx(void*, size_t, int) __attribute__((__weak__));$/;"	p	signature:(void*, size_t, int)
rallocx	.\detail\MallocImpl.cpp	/^void* (*rallocx)(void*, size_t, int) = nullptr;$/;"	v
rand32	.\Random.h	/^  static uint32_t rand32(ValidRNG<RNG> rng = RNG()) {$/;"	f	class:folly::Random	access:public	signature:(ValidRNG<RNG> rng = RNG())
rand32	.\Random.h	/^  static uint32_t rand32(uint32_t max, ValidRNG<RNG> rng = RNG()) {$/;"	f	class:folly::Random	access:public	signature:(uint32_t max, ValidRNG<RNG> rng = RNG())
rand32	.\Random.h	/^  static uint32_t rand32(uint32_t min,$/;"	f	class:folly::Random	access:public	signature:(uint32_t min, uint32_t max, ValidRNG<RNG> rng = RNG())
rand64	.\Random.h	/^  static uint64_t rand64(ValidRNG<RNG> rng = RNG()) {$/;"	f	class:folly::Random	access:public	signature:(ValidRNG<RNG> rng = RNG())
rand64	.\Random.h	/^  static uint64_t rand64(uint64_t max, ValidRNG<RNG> rng = RNG()) {$/;"	f	class:folly::Random	access:public	signature:(uint64_t max, ValidRNG<RNG> rng = RNG())
rand64	.\Random.h	/^  static uint64_t rand64(uint64_t min,$/;"	f	class:folly::Random	access:public	signature:(uint64_t min, uint64_t max, ValidRNG<RNG> rng = RNG())
randDouble	.\Random.h	/^  static double randDouble(double min, double max, ValidRNG<RNG> rng = RNG()) {$/;"	f	class:folly::Random	access:public	signature:(double min, double max, ValidRNG<RNG> rng = RNG())
randDouble01	.\Random.h	/^  static double randDouble01(ValidRNG<RNG> rng = RNG()) {$/;"	f	class:folly::Random	access:public	signature:(ValidRNG<RNG> rng = RNG())
random	.\test\FBStringBenchmark.cpp	/^Integral2 random(Integral1 low, Integral2 up) {$/;"	f	signature:(Integral1 low, Integral2 up)
random	.\test\FBStringTest.cpp	/^Integral2 random(Integral1 low, Integral2 up) {$/;"	f	signature:(Integral1 low, Integral2 up)
random	.\test\FBVectorBenchmark.cpp	/^Integral2 random(Integral1 low, Integral2 up) {$/;"	f	signature:(Integral1 low, Integral2 up)
random	.\test\FBVectorTest.cpp	/^Integral2 random(Integral1 low, Integral2 up) {$/;"	f	signature:(Integral1 low, Integral2 up)
random	.\test\SynchronizedTestLib-inl.h	/^Integral2 random(Integral1 low, Integral2 up) {$/;"	f	signature:(Integral1 low, Integral2 up)
randomAdding	.\test\ConcurrentSkipListTest.cpp	/^static void randomAdding(int size,$/;"	f	namespace:__anon114	signature:(int size, SkipListAccessor skipList, SetType *verifier, int maxValue = kMaxValue)
randomBinaryString	.\test\FBStringBenchmark.cpp	/^void randomBinaryString(String* toFill, unsigned int maxSize = 1000) {$/;"	f	signature:(String* toFill, unsigned int maxSize = 1000)
randomDataHolder	.\io\test\CompressionTest.cpp	/^RandomDataHolder randomDataHolder(dataSizeLog2);$/;"	p	namespace:folly::io::test	file:	signature:(dataSizeLog2)
randomNumberSeed	.\Random.h	/^inline uint32_t randomNumberSeed() {$/;"	f	namespace:folly	signature:()
randomObject	.\test\FBVectorBenchmark.cpp	/^template<> folly::fbstring randomObject<folly::fbstring>() {$/;"	f	signature:()
randomObject	.\test\FBVectorBenchmark.cpp	/^template<> int randomObject<int>() {$/;"	f	signature:()
randomObject	.\test\FBVectorBenchmark.cpp	/^template<class T> T randomObject();$/;"	p	file:	signature:()
randomObject	.\test\FBVectorTest.cpp	/^template<> folly::fbstring randomObject<folly::fbstring>() {$/;"	f	signature:()
randomObject	.\test\FBVectorTest.cpp	/^template<> int randomObject<int>() {$/;"	f	signature:()
randomObject	.\test\FBVectorTest.cpp	/^template<class T> T randomObject();$/;"	p	file:	signature:()
randomPartition	.\experimental\test\EventCountTest.cpp	/^void randomPartition(Random& random, T key, int n,$/;"	f	namespace:__anon46	signature:(Random& random, T key, int n, std::vector<std::pair<T, int>>& out)
randomProb	.\ConcurrentSkipList-inl.h	/^  static double randomProb() {$/;"	f	class:folly::detail::SkipListRandomHeight	access:private	signature:()
randomRemoval	.\test\ConcurrentSkipListTest.cpp	/^static void randomRemoval(int size,$/;"	f	namespace:__anon114	signature:(int size, SkipListAccessor skipList, SetType *verifier, int maxValue=kMaxValue)
randomString	.\test\FBStringBenchmark.cpp	/^void randomString(String* toFill, unsigned int maxSize = 1000) {$/;"	f	signature:(String* toFill, unsigned int maxSize = 1000)
randomString	.\test\FBStringTest.cpp	/^void randomString(String* toFill, unsigned int maxSize = 1000) {$/;"	f	signature:(String* toFill, unsigned int maxSize = 1000)
randomString	.\test\FBVectorBenchmark.cpp	/^void randomString(String* toFill, unsigned int maxSize = 1000) {$/;"	f	signature:(String* toFill, unsigned int maxSize = 1000)
randomString	.\test\FBVectorTest.cpp	/^void randomString(String* toFill, unsigned int maxSize = 1000) {$/;"	f	signature:(String* toFill, unsigned int maxSize = 1000)
randomizeKey	.\test\AtomicHashMapTest.cpp	/^inline KeyT randomizeKey(int key) {$/;"	f	namespace:__anon105	signature:(int key)
range	.\MemoryMapping.h	/^  ByteRange range() const {$/;"	f	class:folly::MemoryMapping	access:public	signature:() const
range	.\Range.h	/^Range<Iter> range(Iter first, Iter last) {$/;"	f	namespace:folly	signature:(Iter first, Iter last)
range	.\Range.h	/^Range<T*> range(Collection&& v) {$/;"	f	namespace:folly	signature:(Collection&& v)
range	.\gen\Base.h	/^Gen range(Value begin, Value end) {$/;"	f	namespace:folly::gen	signature:(Value begin, Value end)
range	.\gen\Base.h	/^Gen range(Value begin, Value end, Distance step) {$/;"	f	namespace:folly::gen	signature:(Value begin, Value end, Distance step)
rangeAdjust	.\stats\BucketedTimeSeries-defs.h	/^VT BucketedTimeSeries<VT, TT>::rangeAdjust($/;"	f	class:folly::BucketedTimeSeries	signature:( TimeType bucketStart, TimeType nextBucketStart, TimeType start, TimeType end, ValueType input) const
rangeAdjust	.\stats\BucketedTimeSeries.h	/^  ValueType rangeAdjust(TimeType bucketStart, TimeType nextBucketStart,$/;"	p	class:folly::BucketedTimeSeries	access:private	signature:(TimeType bucketStart, TimeType nextBucketStart, TimeType start, TimeType end, ValueType input) const
range_	.\gen\Base-inl.h	/^  Range<Iterator> range_;$/;"	m	class:folly::gen::detail::RangeSource	access:private
range_	.\gen\Parallel-inl.h	/^  Range<Iterator> range_;$/;"	m	class:folly::gen::detail::ChunkedRangeSource	access:private
range_	.\io\RecordIO-inl.h	/^  ByteRange range_;$/;"	m	class:folly::RecordIOReader::Iterator	access:private
range_	.\json.cpp	/^  StringPiece range_;$/;"	m	struct:folly::json::__anon75::Input	file:	access:private
rate	.\stats\BucketedTimeSeries.h	/^  ReturnType rate() const {$/;"	f	class:folly::BucketedTimeSeries	access:public	signature:() const
rate	.\stats\BucketedTimeSeries.h	/^  ReturnType rate(TimeType start, TimeType end) const {$/;"	f	class:folly::BucketedTimeSeries	access:public	signature:(TimeType start, TimeType end) const
rate	.\stats\MultiLevelTimeSeries.h	/^  ReturnType rate(TimeType start, TimeType end) const {$/;"	f	class:folly::MultiLevelTimeSeries	access:public	signature:(TimeType start, TimeType end) const
rate	.\stats\MultiLevelTimeSeries.h	/^  ValueType rate(int level) const {$/;"	f	class:folly::MultiLevelTimeSeries	access:public	signature:(int level) const
rate	.\stats\TimeseriesHistogram-defs.h	/^ReturnType TimeseriesHistogram<T, TT, C>::rate(TimeType start,$/;"	f	class:folly::TimeseriesHistogram	signature:(TimeType start, TimeType end) const
rate	.\stats\TimeseriesHistogram-defs.h	/^T TimeseriesHistogram<T, TT, C>::rate(int level) const {$/;"	f	class:folly::TimeseriesHistogram	signature:(int level) const
rate	.\stats\TimeseriesHistogram.h	/^  ReturnType rate(TimeType start, TimeType end) const;$/;"	p	class:folly::TimeseriesHistogram	access:public	signature:(TimeType start, TimeType end) const
rate	.\stats\TimeseriesHistogram.h	/^  ValueType rate(int level) const;$/;"	p	class:folly::TimeseriesHistogram	access:public	signature:(int level) const
rateHelper	.\detail\Stats.h	/^ReturnType rateHelper(ReturnType count, TimeType elapsed) {$/;"	f	namespace:folly::detail	signature:(ReturnType count, TimeType elapsed)
rateHelper	.\stats\BucketedTimeSeries.h	/^  ReturnType rateHelper(ReturnType numerator, TimeType elapsedTime) const {$/;"	f	class:folly::BucketedTimeSeries	access:private	signature:(ReturnType numerator, TimeType elapsedTime) const
raw	.\LifoSem.h	/^  std::aligned_storage<sizeof(void*),alignof(void*)>::type raw;$/;"	m	struct:folly::detail::LifoSemRawNode	access:public
raw	.\detail\CacheLocality.h	/^      raw[kMaxStripe + 1];$/;"	m	struct:folly::detail::AccessSpreaderArray	access:private
rawStatus_	.\Subprocess.h	/^  int rawStatus_;$/;"	m	class:folly::ProcessReturnCode	access:private
rbegin	.\EvictingCacheMap.h	/^  const_reverse_iterator rbegin() const {$/;"	f	class:folly::EvictingCacheMap	access:public	signature:() const
rbegin	.\EvictingCacheMap.h	/^  reverse_iterator rbegin() {$/;"	f	class:folly::EvictingCacheMap	access:public	signature:()
rbegin	.\small_vector.h	/^  const_reverse_iterator rbegin() const {$/;"	f	class:folly::small_vector	access:public	signature:() const
rbegin	.\small_vector.h	/^  reverse_iterator       rbegin()        { return reverse_iterator(end()); }$/;"	f	class:folly::small_vector	access:public	signature:()
rbegin	.\sorted_vector_types.h	/^  const_reverse_iterator rbegin() const { return m_.cont_.rbegin(); }$/;"	f	class:folly::sorted_vector_map	access:public	signature:() const
rbegin	.\sorted_vector_types.h	/^  const_reverse_iterator rbegin() const { return m_.cont_.rbegin(); }$/;"	f	class:folly::sorted_vector_set	access:public	signature:() const
rbegin	.\sorted_vector_types.h	/^  reverse_iterator rbegin()             { return m_.cont_.rbegin(); }$/;"	f	class:folly::sorted_vector_map	access:public	signature:()
rbegin	.\sorted_vector_types.h	/^  reverse_iterator rbegin()             { return m_.cont_.rbegin(); }$/;"	f	class:folly::sorted_vector_set	access:public	signature:()
rc	.\test\MPMCQueueTest.cpp	/^  mutable std::atomic<int> rc;$/;"	m	struct:RefCounted	file:	access:public
rconcat	.\gen\Base-inl.h	/^static const detail::RangeConcat rconcat;$/;"	m	namespace:folly::gen
rd	.\experimental\test\BitsBenchmark.cpp	/^std::random_device rd;$/;"	v
read	.\MPMCPipeline.h	/^  bool read($/;"	f	class:folly::MPMCPipeline	access:public	signature:( typename std::tuple_element< sizeof...(Stages), StageTuple>::type::value_type& elem)
read	.\ProducerConsumerQueue.h	/^  bool read(T& record) {$/;"	f	struct:folly::ProducerConsumerQueue	access:public	signature:(T& record)
read	.\RWSpinLock.h	/^      QuarterInt read;$/;"	m	struct:folly::RWTicketSpinLockT::RWTicket::__anon85	access:public
read	.\experimental\symbolizer\Dwarf.cpp	/^read(folly::StringPiece& sp) {$/;"	f	namespace:folly::symbolizer::__anon34	signature:(folly::StringPiece& sp)
read	.\gen\ParallelMap-inl.h	/^      bool read(Output& out) {$/;"	f	class:folly::gen::detail::PMap::Generator::ExecutionPipeline	access:public	signature:(Output& out)
read	.\io\Cursor.h	/^  read() {$/;"	f	class:folly::io::detail::CursorBase	access:public	signature:()
read	.\test\ThreadLocalTest.cpp	/^  int read() {$/;"	f	class:SimpleThreadCachedInt	access:public	signature:()
readAbbreviation	.\experimental\symbolizer\Dwarf.cpp	/^bool Dwarf::readAbbreviation(folly::StringPiece& section,$/;"	f	class:folly::symbolizer::Dwarf	signature:(folly::StringPiece& section, DIEAbbreviation& abbr)
readAbbreviation	.\experimental\symbolizer\Dwarf.h	/^  static bool readAbbreviation(folly::StringPiece& sp, DIEAbbreviation& abbr);$/;"	p	class:folly::symbolizer::Dwarf	access:private	signature:(folly::StringPiece& sp, DIEAbbreviation& abbr)
readAttribute	.\experimental\symbolizer\Dwarf.cpp	/^Dwarf::DIEAbbreviation::Attribute Dwarf::readAttribute($/;"	f	class:folly::symbolizer::Dwarf	signature:( folly::StringPiece& sp)
readAttribute	.\experimental\symbolizer\Dwarf.h	/^  static DIEAbbreviation::Attribute readAttribute(folly::StringPiece& sp);$/;"	p	class:folly::symbolizer::Dwarf	access:private	signature:(folly::StringPiece& sp)
readAttributeValue	.\experimental\symbolizer\Dwarf.cpp	/^Dwarf::AttributeValue Dwarf::readAttributeValue($/;"	f	class:folly::symbolizer::Dwarf	signature:( folly::StringPiece& sp, uint64_t form, bool is64Bit) const
readAttributeValue	.\experimental\symbolizer\Dwarf.h	/^  AttributeValue readAttributeValue($/;"	p	class:folly::symbolizer::Dwarf	access:private	signature:( folly::StringPiece& sp, uint64_t form, bool is64Bit) const
readBE	.\io\Cursor.h	/^  T readBE() {$/;"	f	class:folly::io::detail::CursorBase	access:public	signature:()
readBytes	.\experimental\symbolizer\Dwarf.cpp	/^folly::StringPiece readBytes(folly::StringPiece& sp, uint64_t len) {$/;"	f	namespace:folly::symbolizer::__anon34	signature:(folly::StringPiece& sp, uint64_t len)
readChildErrorPipe	.\Subprocess.cpp	/^void Subprocess::readChildErrorPipe(int pfd, const char* executable) {$/;"	f	class:folly::Subprocess	signature:(int pfd, const char* executable)
readChildErrorPipe	.\Subprocess.h	/^  void readChildErrorPipe(int pfd, const char* executable);$/;"	p	class:folly::Subprocess	access:private	signature:(int pfd, const char* executable)
readFast	.\ThreadCachedInt.h	/^  IntT readFast() const {$/;"	f	class:folly::ThreadCachedInt	access:public	signature:() const
readFast	.\test\ThreadCachedIntTest.cpp	/^  int64_t readFast() {$/;"	f	struct:ShardedAtomicInt	access:public	signature:()
readFastAndReset	.\ThreadCachedInt.h	/^  IntT readFastAndReset() {$/;"	f	class:folly::ThreadCachedInt	access:public	signature:()
readFile	.\FileUtil.h	/^bool readFile(const char* file_name, Container& out,$/;"	f	namespace:folly	signature:(const char* file_name, Container& out, size_t num_bytes = std::numeric_limits<size_t>::max())
readFileName	.\experimental\symbolizer\Dwarf.cpp	/^bool Dwarf::LineNumberVM::readFileName(folly::StringPiece& program,$/;"	f	class:folly::symbolizer::Dwarf::LineNumberVM	signature:(folly::StringPiece& program, FileName& fn)
readFileName	.\experimental\symbolizer\Dwarf.h	/^    static bool readFileName(folly::StringPiece& sp, FileName& fn);$/;"	p	class:folly::symbolizer::Dwarf::LineNumberVM	access:private	signature:(folly::StringPiece& sp, FileName& fn)
readFixedString	.\io\Cursor.h	/^  std::string readFixedString(size_t len) {$/;"	f	class:folly::io::detail::CursorBase	access:public	signature:(size_t len)
readFromSysfs	.\detail\CacheLocality.cpp	/^CacheLocality CacheLocality::readFromSysfs() {$/;"	f	class:folly::detail::CacheLocality	signature:()
readFromSysfs	.\detail\CacheLocality.h	/^  static CacheLocality readFromSysfs();$/;"	p	struct:folly::detail::CacheLocality	access:public	signature:()
readFromSysfsTree	.\detail\CacheLocality.cpp	/^CacheLocality CacheLocality::readFromSysfsTree($/;"	f	class:folly::detail::CacheLocality	signature:( const std::function<std::string(std::string)>& mapping)
readFromSysfsTree	.\detail\CacheLocality.h	/^  static CacheLocality readFromSysfsTree($/;"	p	struct:folly::detail::CacheLocality	access:public	signature:( const std::function<std::string(std::string)>& mapping)
readFull	.\FileUtil.cpp	/^ssize_t readFull(int fd, void* buf, size_t count) {$/;"	f	namespace:folly	signature:(int fd, void* buf, size_t count)
readFull	.\FileUtil.h	/^ssize_t readFull(int fd, void* buf, size_t n);$/;"	p	namespace:folly	signature:(int fd, void* buf, size_t n)
readFull	.\ThreadCachedInt.h	/^  IntT readFull() const {$/;"	f	class:folly::ThreadCachedInt	access:public	signature:() const
readFull	.\test\ThreadCachedIntTest.cpp	/^  int64_t readFull() {$/;"	f	struct:ShardedAtomicInt	access:public	signature:()
readFullAndReset	.\ThreadCachedInt.h	/^  IntT readFullAndReset() {$/;"	f	class:folly::ThreadCachedInt	access:public	signature:()
readHex	.\experimental\symbolizer\Symbolizer.cpp	/^uintptr_t readHex(StringPiece& sp) {$/;"	f	namespace:folly::symbolizer::__anon40	signature:(StringPiece& sp)
readHugePageSizes	.\experimental\io\HugePages.cpp	/^HugePageSizeVec readHugePageSizes() {$/;"	f	namespace:folly::__anon30	signature:()
readIndex_	.\ProducerConsumerQueue.h	/^  std::atomic<int> readIndex_;$/;"	m	struct:folly::ProducerConsumerQueue	access:private
readLE	.\io\Cursor.h	/^  T readLE() {$/;"	f	class:folly::io::detail::CursorBase	access:public	signature:()
readLine	.\experimental\symbolizer\LineReader.cpp	/^LineReader::State LineReader::readLine(StringPiece& line) {$/;"	f	class:folly::symbolizer::LineReader	signature:(StringPiece& line)
readLine	.\experimental\symbolizer\LineReader.h	/^  State readLine(StringPiece& line);$/;"	p	class:folly::symbolizer::LineReader	access:public	signature:(StringPiece& line)
readLinesCallback	.\Subprocess.h	/^  static ReadLinesCallback<Callback> readLinesCallback($/;"	f	class:folly::Subprocess	access:public	signature:( Callback&& fdLineCb, uint64_t maxLineLength = 0, char delimiter = , uint64_t bufSize = 1024)
readLowerPart	.\experimental\EliasFanoCoding.h	/^  ValueType readLowerPart(size_t i) const {$/;"	f	class:folly::compression::EliasFanoReader	access:private	signature:(size_t i) const
readNoInt	.\FileUtil.cpp	/^ssize_t readNoInt(int fd, void* buf, size_t count) {$/;"	f	namespace:folly	signature:(int fd, void* buf, size_t count)
readNoInt	.\FileUtil.h	/^ssize_t readNoInt(int fd, void* buf, size_t n);$/;"	p	namespace:folly	signature:(int fd, void* buf, size_t n)
readNullTerminated	.\experimental\symbolizer\Dwarf.cpp	/^folly::StringPiece readNullTerminated(folly::StringPiece& sp) {$/;"	f	namespace:folly::symbolizer::__anon34	signature:(folly::StringPiece& sp)
readOffset	.\experimental\symbolizer\Dwarf.cpp	/^uint64_t readOffset(folly::StringPiece& sp, bool is64Bit) {$/;"	f	namespace:folly::symbolizer::__anon34	signature:(folly::StringPiece& sp, bool is64Bit)
readRandomDevice	.\Random.cpp	/^void readRandomDevice(void* data, size_t size) {$/;"	f	namespace:folly::__anon82	signature:(void* data, size_t size)
readRawHugePageSizes	.\experimental\io\HugePages.cpp	/^HugePageSizeVec readRawHugePageSizes() {$/;"	f	namespace:folly::__anon30	signature:()
readSLEB	.\experimental\symbolizer\Dwarf.cpp	/^int64_t readSLEB(folly::StringPiece& sp) {$/;"	f	namespace:folly::symbolizer::__anon34	signature:(folly::StringPiece& sp)
readStage	.\MPMCPipeline.h	/^  bool readStage($/;"	f	class:folly::MPMCPipeline	access:public	signature:( Ticket<Stage>& ticket, typename std::tuple_element<Stage, StageTuple>::type::value_type& elem)
readTerminatedString	.\io\Cursor.h	/^  std::string readTerminatedString($/;"	f	class:folly::io::detail::CursorBase	access:public	signature:( char termChar = , size_t maxLength = std::numeric_limits<size_t>::max())
readToString	.\test\SubprocessTest.cpp	/^bool readToString(int fd, std::string& buf, size_t maxSize) {$/;"	f	namespace:__anon141	signature:(int fd, std::string& buf, size_t maxSize)
readULEB	.\experimental\symbolizer\Dwarf.cpp	/^uint64_t readULEB(folly::StringPiece& sp) {$/;"	f	namespace:folly::symbolizer::__anon34	signature:(folly::StringPiece& sp)
readULEB	.\experimental\symbolizer\Dwarf.cpp	/^uint64_t readULEB(folly::StringPiece& sp, uint8_t& shift, uint8_t& val) {$/;"	f	namespace:folly::symbolizer::__anon34	signature:(folly::StringPiece& sp, uint8_t& shift, uint8_t& val)
readUnlessClosed	.\gen\Parallel-inl.h	/^      bool readUnlessClosed(OutputDecayed& output) {$/;"	f	class:folly::gen::detail::Parallel::Generator::Executor	access:public	signature:(OutputDecayed& output)
readUnlessClosed	.\gen\Parallel-inl.h	/^  bool readUnlessClosed(T& out) {$/;"	f	class:folly::gen::detail::ClosableMPMCQueue	access:public	signature:(T& out)
readUnlessEmpty	.\gen\Parallel-inl.h	/^      bool readUnlessEmpty(OutputDecayed& output) {$/;"	f	class:folly::gen::detail::Parallel::Generator::Executor	access:public	signature:(OutputDecayed& output)
readUnlessEmpty	.\gen\Parallel-inl.h	/^  bool readUnlessEmpty(T& out) {$/;"	f	class:folly::gen::detail::ClosableMPMCQueue	access:public	signature:(T& out)
readValues_	.\test\ConcurrentSkipListBenchmark.cpp	/^  std::vector<ValueType> readValues_;$/;"	m	class:__anon113::ConcurrentAccessData	file:	access:private
readWrite	.\RWSpinLock.h	/^    HalfInt readWrite;$/;"	m	union:folly::RWTicketSpinLockT::RWTicket	access:public
readable	.\MemoryMapping.h	/^    bool readable = true;$/;"	m	struct:folly::MemoryMapping::Options	access:public
readableTime	.\Benchmark.cpp	/^static string readableTime(double n, unsigned int decimals) {$/;"	f	namespace:folly	signature:(double n, unsigned int decimals)
reader	.\test\FileUtilTest.cpp	/^  Reader reader(std::deque<ssize_t> spec);$/;"	p	class:folly::test::FileUtilTest	file:	access:protected	signature:(std::deque<ssize_t> spec)
reader	.\test\FileUtilTest.cpp	/^Reader FileUtilTest::reader(std::deque<ssize_t> spec) {$/;"	f	class:folly::test::FileUtilTest	signature:(std::deque<ssize_t> spec)
readerWait	.\experimental\io\test\AsyncIOTest.cpp	/^folly::Range<AsyncIO::Op**> readerWait(AsyncIO* reader) {$/;"	f	namespace:__anon32	signature:(AsyncIO* reader)
readers_	.\test\FileUtilTest.cpp	/^  std::vector<std::pair<size_t, Reader>> readers_;$/;"	m	class:folly::test::FileUtilTest	file:	access:protected
readvFull	.\FileUtil.cpp	/^ssize_t readvFull(int fd, iovec* iov, int count) {$/;"	f	namespace:folly	signature:(int fd, iovec* iov, int count)
readvFull	.\FileUtil.h	/^ssize_t readvFull(int fd, iovec* iov, int count);$/;"	p	namespace:folly	signature:(int fd, iovec* iov, int count)
readvNoInt	.\FileUtil.cpp	/^ssize_t readvNoInt(int fd, const iovec* iov, int count) {$/;"	f	namespace:folly	signature:(int fd, const iovec* iov, int count)
readvNoInt	.\FileUtil.h	/^ssize_t readvNoInt(int fd, const iovec* iov, int count);$/;"	p	namespace:folly	signature:(int fd, const iovec* iov, int count)
ready	.\wangle\detail\State.h	/^  bool ready() const {$/;"	f	class:folly::wangle::detail::State	access:public	signature:() const
realValue	.\test\StringTest.cpp	/^  double realValue;$/;"	m	struct:PrettyTestCase	file:	access:public
reallyShort	.\test\ConvTest.cpp	/^static char reallyShort[] = "meh";$/;"	v	file:
rebind	.\Memory.h	/^  template <class U> struct rebind {$/;"	s	class:folly::StlAllocator	access:public
rebind	.\test\AtomicHashArrayTest.cpp	/^  template <class U> struct rebind {$/;"	s	class:MmapAllocator	file:	access:public
rebind_allocator	.\Memory.h	/^typename Allocator::template rebind<T>::other rebind_allocator($/;"	f	namespace:folly	signature:( Allocator const& allocator )
recToIdx	.\AtomicHashMap.h	/^  inline uint32_t recToIdx(const value_type& r, bool mayInsert = true) {$/;"	f	class:folly::AtomicHashMap	access:public	signature:(const value_type& r, bool mayInsert = true)
recToIdx	.\AtomicHashMap.h	/^  inline uint32_t recToIdx(key_type k, const mapped_type& v,$/;"	f	class:folly::AtomicHashMap	access:public	signature:(key_type k, const mapped_type& v, bool mayInsert = true)
recToIdx	.\AtomicHashMap.h	/^  inline uint32_t recToIdx(key_type k, mapped_type&& v, bool mayInsert = true) {$/;"	f	class:folly::AtomicHashMap	access:public	signature:(key_type k, mapped_type&& v, bool mayInsert = true)
recToIdx	.\AtomicHashMap.h	/^  inline uint32_t recToIdx(value_type&& r, bool mayInsert = true) {$/;"	f	class:folly::AtomicHashMap	access:public	signature:(value_type&& r, bool mayInsert = true)
record	.\io\RecordIO.h	/^  ByteRange record;$/;"	m	struct:folly::recordio_helpers::RecordInfo	access:public
recordAndPos_	.\io\RecordIO-inl.h	/^  std::pair<ByteRange, off_t> recordAndPos_;$/;"	m	class:folly::RecordIOReader::Iterator	access:private
recordio_helpers	.\io\RecordIO-inl.h	/^namespace recordio_helpers {$/;"	n	namespace:folly
recordio_helpers	.\io\RecordIO.cpp	/^namespace recordio_helpers {$/;"	n	namespace:folly	file:
recordio_helpers	.\io\RecordIO.h	/^namespace recordio_helpers {$/;"	n	namespace:folly
records	.\gen\test\StringBenchmark.cpp	/^fbstring records$/;"	v
records_	.\ProducerConsumerQueue.h	/^  T* const records_;$/;"	m	struct:folly::ProducerConsumerQueue	access:private
recurse	.\experimental\exception_tracer\ExceptionTracerBenchmark.cpp	/^void recurse(int level) {$/;"	f	signature:(int level)
recycle	.\ConcurrentSkipList.h	/^  void recycle(NodeType *node) {$/;"	f	class:folly::ConcurrentSkipList	access:private	signature:(NodeType *node)
recycleIndex	.\IndexedMemPool.h	/^  void recycleIndex(uint32_t idx) {$/;"	f	struct:folly::IndexedMemPool	access:public	signature:(uint32_t idx)
recycler_	.\ConcurrentSkipList.h	/^  detail::NodeRecycler<NodeType, NodeAlloc> recycler_;$/;"	m	class:folly::ConcurrentSkipList	access:private
reduce	.\gen\Base.h	/^Reduce reduce(Reducer reducer = Reducer()) {$/;"	f	namespace:folly::gen	signature:(Reducer reducer = Reducer())
reducer_	.\gen\Base-inl.h	/^  Reducer reducer_;$/;"	m	class:folly::gen::detail::Reduce	access:private
ref_	.\detail\BitIteratorDetail.h	/^  Ref ref_;$/;"	m	class:folly::bititerator_detail::BitReference	access:private
ref_count	.\wangle\detail\State.h	/^  std::atomic<size_t> ref_count;$/;"	m	struct:folly::wangle::detail::WhenAnyContext	access:public
refcount	.\io\IOBuf.h	/^    std::atomic<uint32_t> refcount;$/;"	m	struct:folly::IOBuf::SharedInfo	access:public
reference	.\AtomicHashArray.h	/^  typedef value_type&         reference;$/;"	t	class:folly::AtomicHashArray	access:public
reference	.\AtomicHashMap.h	/^  typedef value_type&         reference;$/;"	t	class:folly::AtomicHashMap	access:public
reference	.\ConcurrentSkipList.h	/^  typedef T& reference;$/;"	t	class:folly::ConcurrentSkipList::Accessor	access:public
reference	.\ConcurrentSkipList.h	/^  typedef T& reference;$/;"	t	class:folly::ConcurrentSkipList::Skipper	access:public
reference	.\ConcurrentSkipList.h	/^  typedef value_type& reference;$/;"	t	class:folly::detail::csl_iterator	access:public
reference	.\FBVector.h	/^  typedef value_type&                                 reference;$/;"	t	class:folly::fbvector	access:public
reference	.\Memory.h	/^  typedef T& reference;$/;"	t	class:folly::StlAllocator	access:public
reference	.\PackedSyncPtr.h	/^  typedef typename std::add_lvalue_reference<T>::type reference;$/;"	t	class:folly::PackedSyncPtr	access:private
reference	.\Padded.h	/^  typedef value_type& reference;$/;"	t	class:folly::Adaptor	access:public
reference	.\Range.h	/^  typedef typename std::iterator_traits<Iter>::reference reference;$/;"	t	class:folly::Range	access:public
reference	.\io\RecordIO.h	/^  typedef value_type& reference;$/;"	t	class:folly::RecordIOReader	access:public
reference	.\io\TypedIOBuf.h	/^  typedef value_type& reference;$/;"	t	class:folly::TypedIOBuf	access:public
reference	.\small_vector.h	/^  typedef value_type&        reference;$/;"	t	class:folly::small_vector	access:public
reference	.\sorted_vector_types.h	/^  typedef typename ContainerT::reference              reference;$/;"	t	class:folly::sorted_vector_map	access:public
reference	.\sorted_vector_types.h	/^  typedef typename ContainerT::reference              reference;$/;"	t	class:folly::sorted_vector_set	access:public
reference	.\test\AtomicHashArrayTest.cpp	/^  typedef T& reference;$/;"	t	class:MmapAllocator	file:	access:public
refs	.\ConcurrentSkipList-inl.h	/^  int refs() const {$/;"	f	class:folly::detail::NodeRecycler	access:private	signature:() const
refs_	.\ConcurrentSkipList-inl.h	/^  std::atomic<int32_t> refs_; \/\/ current number of visitors to the list$/;"	m	class:folly::detail::NodeRecycler	access:private
registerHandler	.\io\async\EventHandler.h	/^  bool registerHandler(uint16_t events) {$/;"	f	class:folly::EventHandler	access:public	signature:(uint16_t events)
registerImpl	.\io\async\EventHandler.cpp	/^bool EventHandler::registerImpl(uint16_t events, bool internal) {$/;"	f	class:folly::EventHandler	signature:(uint16_t events, bool internal)
registerImpl	.\io\async\EventHandler.h	/^  bool registerImpl(uint16_t events, bool internal);$/;"	p	class:folly::EventHandler	access:private	signature:(uint16_t events, bool internal)
registerInternalHandler	.\io\async\EventHandler.h	/^  bool registerInternalHandler(uint16_t events) {$/;"	f	class:folly::EventHandler	access:public	signature:(uint16_t events)
registerSingleton	.\experimental\Singleton.h	/^  void registerSingleton(detail::TypeDescriptor type,$/;"	f	class:folly::SingletonVault	access:public	signature:(detail::TypeDescriptor type, CreateFunc create, TeardownFunc teardown)
registeredSingletonCount	.\experimental\Singleton.h	/^  size_t registeredSingletonCount() const {$/;"	f	class:folly::SingletonVault	access:public	signature:() const
registrationComplete	.\experimental\Singleton.h	/^  void registrationComplete() {$/;"	f	class:folly::SingletonVault	access:public	signature:()
rehire	.\Benchmark.h	/^  void rehire() {$/;"	f	struct:folly::BenchmarkSuspender	access:public	signature:()
relativeName	.\experimental\symbolizer\Dwarf.h	/^      folly::StringPiece relativeName;$/;"	m	struct:folly::symbolizer::Dwarf::LineNumberVM::FileName	access:public
relaxedLoadKey	.\AtomicHashArray.h	/^  static KeyT relaxedLoadKey(const value_type& r) {$/;"	f	class:folly::AtomicHashArray	access:private	signature:(const value_type& r)
release	.\File.cpp	/^int File::release() {$/;"	f	class:folly::File	signature:()
release	.\File.h	/^  int release();$/;"	p	class:folly::File	access:public	signature:()
release	.\ThreadLocal.h	/^    void release() {$/;"	f	class:folly::ThreadLocalPtr::Accessor	access:private	signature:()
release	.\ThreadLocal.h	/^  T* release() {$/;"	f	class:folly::ThreadLocalPtr	access:public	signature:()
release	.\detail\ThreadLocalDetail.h	/^  void* release() {$/;"	f	struct:folly::threadlocal_detail::ElementWrapper	access:public	signature:()
releaseRead	.\RWSpinLock.h	/^  friend void releaseRead(RWSpinLock& l) { return l.unlock_shared(); }$/;"	f	class:folly::RWSpinLock	access:friend	signature:(RWSpinLock& l)
releaseRead	.\RWSpinLock.h	/^  friend void releaseRead(RWTicketSpinLockT& mutex) {$/;"	f	class:folly::RWTicketSpinLockT	access:friend	signature:(RWTicketSpinLockT& mutex)
releaseRead	.\Synchronized.h	/^releaseRead(T& mutex) {$/;"	f	namespace:folly::detail	signature:(T& mutex)
releaseReadWrite	.\RWSpinLock.h	/^  friend void releaseReadWrite(RWSpinLock& l) { return l.unlock(); }$/;"	f	class:folly::RWSpinLock	access:friend	signature:(RWSpinLock& l)
releaseReadWrite	.\RWSpinLock.h	/^  friend void releaseReadWrite(RWTicketSpinLockT& mutex) {$/;"	f	class:folly::RWTicketSpinLockT	access:friend	signature:(RWTicketSpinLockT& mutex)
releaseReadWrite	.\Synchronized.h	/^releaseReadWrite(T& mutex) {$/;"	f	namespace:folly::detail	signature:(T& mutex)
releaseRef	.\ConcurrentSkipList-inl.h	/^  int releaseRef() {$/;"	f	class:folly::detail::NodeRecycler	access:public	signature:()
releaseRef	.\ConcurrentSkipList-inl.h	/^  void releaseRef() { }$/;"	f	class:folly::detail::NodeRecycler	access:public	signature:()
releaseStorage	.\io\IOBuf.cpp	/^void IOBuf::releaseStorage(HeapStorage* storage, uint16_t freeFlags) {$/;"	f	class:folly::IOBuf	signature:(HeapStorage* storage, uint16_t freeFlags)
releaseStorage	.\io\IOBuf.h	/^  static void releaseStorage(HeapStorage* storage, uint16_t freeFlags);$/;"	p	class:folly::IOBuf	access:private	signature:(HeapStorage* storage, uint16_t freeFlags)
relinquish	.\FBVector.h	/^  friend _T* relinquish(fbvector<_T, _A>&);$/;"	p	signature:(fbvector<_T, _A>&)
relocate_move	.\FBVector.h	/^  void relocate_move(T* dest, T* first, T* last) {$/;"	f	signature:(T* dest, T* first, T* last)
relocate_move_or_copy	.\FBVector.h	/^  void relocate_move_or_copy(T* dest, T* first, T* last, std::false_type) {$/;"	f	signature:(T* dest, T* first, T* last, std::false_type)
relocate_move_or_copy	.\FBVector.h	/^  void relocate_move_or_copy(T* dest, T* first, T* last, std::true_type) {$/;"	f	signature:(T* dest, T* first, T* last, std::true_type)
relocate_move_or_memcpy	.\FBVector.h	/^  void relocate_move_or_memcpy(T* dest, T* first, T* last, std::false_type) {$/;"	f	signature:(T* dest, T* first, T* last, std::false_type)
relocate_move_or_memcpy	.\FBVector.h	/^  void relocate_move_or_memcpy(T* dest, T* first, T* last, std::true_type) {$/;"	f	signature:(T* dest, T* first, T* last, std::true_type)
relocate_use_memcpy	.\FBVector.h	/^    > relocate_use_memcpy;$/;"	t
relocate_use_move	.\FBVector.h	/^    > relocate_use_move;$/;"	t
remaining	.\Demangle.cpp	/^  size_t remaining;$/;"	m	struct:folly::__anon10::DemangleBuf	file:	access:public
remaining	.\Random.cpp	/^  inline size_t remaining() const {$/;"	f	class:folly::__anon82::BufferedRandomDevice	file:	access:private	signature:() const
remainingUses_	.\MPMCPipeline.h	/^        remainingUses_(amplification),$/;"	p	class:folly::MPMCPipeline::Ticket	access:private	signature:(amplification)
remainingUses_	.\MPMCPipeline.h	/^        remainingUses_(other.remainingUses_),$/;"	p	class:folly::MPMCPipeline::Ticket	access:public	signature:(other.remainingUses_)
remainingUses_	.\MPMCPipeline.h	/^    size_t remainingUses_;$/;"	m	class:folly::MPMCPipeline::Ticket	access:private
remaining_	.\GroupVarint.h	/^  size_t remaining_;$/;"	m	class:folly::GroupVarintDecoder	access:private
remove	.\ConcurrentSkipList.h	/^  bool remove(const key_type &data) { return sl_->remove(data); }$/;"	f	class:folly::ConcurrentSkipList::Accessor	access:public	signature:(const key_type &data)
remove	.\ConcurrentSkipList.h	/^  bool remove(const value_type &data) {$/;"	f	class:folly::ConcurrentSkipList	access:private	signature:(const value_type &data)
remove	.\experimental\wangle\concurrent\ThreadPoolExecutor.h	/^    void remove(const ThreadPtr& state) {$/;"	f	class:folly::wangle::ThreadPoolExecutor::ThreadList	access:public	signature:(const ThreadPtr& state)
removeConnection	.\experimental\wangle\ConnectionManager.cpp	/^ConnectionManager::removeConnection(ManagedConnection* connection) {$/;"	f	class:folly::wangle::ConnectionManager	signature:(ManagedConnection* connection)
removeConnection	.\experimental\wangle\ConnectionManager.h	/^  void removeConnection(ManagedConnection* connection);$/;"	p	class:folly::wangle::ConnectionManager	access:public	signature:(ManagedConnection* connection)
removePrefix	.\Range.h	/^  bool removePrefix(const const_range_type& prefix) {$/;"	f	class:folly::Range	access:public	signature:(const const_range_type& prefix)
removePrefix	.\Range.h	/^  bool removePrefix(value_type prefix) {$/;"	f	class:folly::Range	access:public	signature:(value_type prefix)
removeRepeatedValue	.\stats\Histogram.h	/^  void removeRepeatedValue(ValueType value, uint64_t nSamples) {$/;"	f	class:folly::Histogram	access:public	signature:(ValueType value, uint64_t nSamples)
removeSuffix	.\Range.h	/^  bool removeSuffix(const const_range_type& suffix) {$/;"	f	class:folly::Range	access:public	signature:(const const_range_type& suffix)
removeSuffix	.\Range.h	/^  bool removeSuffix(value_type suffix) {$/;"	f	class:folly::Range	access:public	signature:(value_type suffix)
removeThreads	.\experimental\wangle\concurrent\ThreadPoolExecutor.cpp	/^void ThreadPoolExecutor::removeThreads(size_t n, bool isJoin) {$/;"	f	class:folly::wangle::ThreadPoolExecutor	signature:(size_t n, bool isJoin)
removeThreads	.\experimental\wangle\concurrent\ThreadPoolExecutor.h	/^  void removeThreads(size_t n, bool isJoin);$/;"	p	class:folly::wangle::ThreadPoolExecutor	access:protected	signature:(size_t n, bool isJoin)
removeValue	.\stats\Histogram.h	/^  void removeValue(ValueType value) {$/;"	f	class:folly::Histogram	access:public	signature:(ValueType value)
remove_prefix	.\experimental\io\FsUtil.cpp	/^path remove_prefix(const path& pth, const path& prefix) {$/;"	f	namespace:folly::fs	signature:(const path& pth, const path& prefix)
remove_prefix	.\experimental\io\FsUtil.h	/^path remove_prefix(const path& p, const path& prefix);$/;"	p	namespace:folly::fs	signature:(const path& p, const path& prefix)
rend	.\EvictingCacheMap.h	/^  const_reverse_iterator rend() const {$/;"	f	class:folly::EvictingCacheMap	access:public	signature:() const
rend	.\EvictingCacheMap.h	/^  reverse_iterator rend() {$/;"	f	class:folly::EvictingCacheMap	access:public	signature:()
rend	.\small_vector.h	/^  const_reverse_iterator rend() const {$/;"	f	class:folly::small_vector	access:public	signature:() const
rend	.\small_vector.h	/^  reverse_iterator       rend()          { return reverse_iterator(begin()); }$/;"	f	class:folly::small_vector	access:public	signature:()
rend	.\sorted_vector_types.h	/^  const_reverse_iterator rend() const   { return m_.cont_.rend();   }$/;"	f	class:folly::sorted_vector_map	access:public	signature:() const
rend	.\sorted_vector_types.h	/^  const_reverse_iterator rend() const   { return m_.cont_.rend();   }$/;"	f	class:folly::sorted_vector_set	access:public	signature:() const
rend	.\sorted_vector_types.h	/^  reverse_iterator rend()               { return m_.cont_.rend();   }$/;"	f	class:folly::sorted_vector_map	access:public	signature:()
rend	.\sorted_vector_types.h	/^  reverse_iterator rend()               { return m_.cont_.rend();   }$/;"	f	class:folly::sorted_vector_set	access:public	signature:()
repeatInterval	.\TimeoutQueue.h	/^    int64_t repeatInterval;$/;"	m	struct:folly::TimeoutQueue::Event	access:public
replace	.\test\FBStringTestBenchmarks.cpp.h	/^void BENCHFUN(replace)(int iters, int arg) {$/;"	f	signature:(int iters, int arg)
replaceAll	.\Range.h	/^  size_t replaceAll(const_range_type source, const_range_type dest) {$/;"	f	class:folly::Range	access:public	signature:(const_range_type source, const_range_type dest)
replaceAt	.\Range.h	/^  bool replaceAt(size_t pos, const_range_type replacement) {$/;"	f	class:folly::Range	access:public	signature:(size_t pos, const_range_type replacement)
reposition	.\experimental\EliasFanoCoding.h	/^  void reposition(size_t dest) {$/;"	f	class:folly::compression::detail::UpperBitsReader	access:private	signature:(size_t dest)
reserve	.\FBVector.h	/^  void reserve(size_type n) {$/;"	f	signature:(size_type n)
reserve	.\Padded.h	/^  void reserve(size_type n) {$/;"	f	class:folly::Adaptor	access:public	signature:(size_type n)
reserve	.\detail\ThreadLocalDetail.h	/^  static void reserve(int id) {$/;"	f	struct:folly::threadlocal_detail::StaticMeta	access:public	signature:(int id)
reserve	.\io\IOBuf.h	/^  void reserve(uint64_t minHeadroom, uint64_t minTailroom) {$/;"	f	class:folly::IOBuf	access:public	signature:(uint64_t minHeadroom, uint64_t minTailroom)
reserve	.\io\TypedIOBuf.h	/^  void reserve(uint32_t minHeadroom, uint32_t minTailroom) {$/;"	f	class:folly::TypedIOBuf	access:public	signature:(uint32_t minHeadroom, uint32_t minTailroom)
reserve	.\io\TypedIOBuf.h	/^  void reserve(uint32_t minTailroom) { reserve(0, minTailroom); }$/;"	f	class:folly::TypedIOBuf	access:public	signature:(uint32_t minTailroom)
reserve	.\small_vector.h	/^  void reserve(size_type sz) {$/;"	f	class:folly::small_vector	access:public	signature:(size_type sz)
reserve	.\sorted_vector_types.h	/^  void reserve(size_type s)     { return m_.cont_.reserve(s); }$/;"	f	class:folly::sorted_vector_map	access:public	signature:(size_type s)
reserve	.\sorted_vector_types.h	/^  void reserve(size_type s)     { return m_.cont_.reserve(s); }$/;"	f	class:folly::sorted_vector_set	access:public	signature:(size_type s)
reserve	.\test\FBVectorTestBenchmarks.cpp.h	/^void BENCHFUN(reserve)(int iters, int size) {$/;"	f	signature:(int iters, int size)
reserveSlow	.\io\IOBuf.cpp	/^void IOBuf::reserveSlow(uint64_t minHeadroom, uint64_t minTailroom) {$/;"	f	class:folly::IOBuf	signature:(uint64_t minHeadroom, uint64_t minTailroom)
reserveSlow	.\io\IOBuf.h	/^  void reserveSlow(uint64_t minHeadroom, uint64_t minTailroom);$/;"	p	class:folly::IOBuf	access:private	signature:(uint64_t minHeadroom, uint64_t minTailroom)
reserve_in_place	.\FBVector.h	/^  bool reserve_in_place(size_type n) {$/;"	f	signature:(size_type n)
reset	.\AtomicBitSet.h	/^  bool reset(size_t idx, std::memory_order order = std::memory_order_seq_cst);$/;"	p	class:folly::AtomicBitSet	access:public	signature:(size_t idx, std::memory_order order = std::memory_order_seq_cst)
reset	.\AtomicBitSet.h	/^inline bool AtomicBitSet<N>::reset(size_t idx, std::memory_order order) {$/;"	f	class:folly::AtomicBitSet	signature:(size_t idx, std::memory_order order)
reset	.\Baton.h	/^  void reset() {$/;"	f	struct:folly::Baton	access:public	signature:()
reset	.\FBVector.h	/^    void reset() { \/\/ same as reset(0)$/;"	f	struct:folly::fbvector::Impl	access:public	signature:()
reset	.\FBVector.h	/^    void reset(size_type newCap) {$/;"	f	struct:folly::fbvector::Impl	access:public	signature:(size_type newCap)
reset	.\GroupVarint.h	/^  void reset(StringPiece data, size_t maxCount = (size_t)-1) {$/;"	f	class:folly::GroupVarintDecoder	access:public	signature:(StringPiece data, size_t maxCount = (size_t)-1)
reset	.\RWSpinLock.h	/^    void reset(RWSpinLock *lock = nullptr) {$/;"	f	class:folly::RWTicketSpinLockT::ReadHolder	access:public	signature:(RWSpinLock *lock = nullptr)
reset	.\RWSpinLock.h	/^    void reset(RWSpinLock *lock = nullptr) {$/;"	f	class:folly::RWTicketSpinLockT::WriteHolder	access:public	signature:(RWSpinLock *lock = nullptr)
reset	.\RWSpinLock.h	/^    void reset(RWSpinLock* lock = nullptr) {$/;"	f	class:folly::RWSpinLock::ReadHolder	access:public	signature:(RWSpinLock* lock = nullptr)
reset	.\RWSpinLock.h	/^    void reset(RWSpinLock* lock = nullptr) {$/;"	f	class:folly::RWSpinLock::UpgradedHolder	access:public	signature:(RWSpinLock* lock = nullptr)
reset	.\RWSpinLock.h	/^    void reset(RWSpinLock* lock = nullptr) {$/;"	f	class:folly::RWSpinLock::WriteHolder	access:public	signature:(RWSpinLock* lock = nullptr)
reset	.\Range.h	/^  void reset(Iter start, size_type size) {$/;"	f	class:folly::Range	access:public	signature:(Iter start, size_type size)
reset	.\Range.h	/^  void reset(const std::string& str) {$/;"	f	class:folly::Range	access:public	signature:(const std::string& str)
reset	.\SocketAddress.h	/^  void reset() {$/;"	f	class:folly::SocketAddress	access:public	signature:()
reset	.\ThreadLocal.h	/^  void reset(T* newPtr = nullptr) {$/;"	f	class:folly::ThreadLocal	access:public	signature:(T* newPtr = nullptr)
reset	.\ThreadLocal.h	/^  void reset(T* newPtr = nullptr) {$/;"	f	class:folly::ThreadLocalPtr	access:public	signature:(T* newPtr = nullptr)
reset	.\ThreadLocal.h	/^  void reset(T* newPtr, Deleter deleter) {$/;"	f	class:folly::ThreadLocalPtr	access:public	signature:(T* newPtr, Deleter deleter)
reset	.\experimental\EliasFanoCoding.h	/^  void reset() {$/;"	f	class:folly::compression::EliasFanoReader	access:public	signature:()
reset	.\experimental\EliasFanoCoding.h	/^  void reset() {$/;"	f	class:folly::compression::detail::UpperBitsReader	access:public	signature:()
reset	.\experimental\io\AsyncIO.cpp	/^void AsyncIOOp::reset(NotificationCallback cb) {$/;"	f	class:folly::AsyncIOOp	signature:(NotificationCallback cb)
reset	.\experimental\io\AsyncIO.h	/^  void reset(NotificationCallback cb = NotificationCallback());$/;"	p	class:folly::AsyncIOOp	access:public	signature:(NotificationCallback cb = NotificationCallback())
reset	.\experimental\symbolizer\Dwarf.cpp	/^void Dwarf::LineNumberVM::reset() {$/;"	f	class:folly::symbolizer::Dwarf::LineNumberVM	signature:()
reset	.\experimental\symbolizer\Dwarf.h	/^    void reset();$/;"	p	class:folly::symbolizer::Dwarf::LineNumberVM	access:private	signature:()
reset	.\io\Cursor.h	/^  void reset(BufType* buf) {$/;"	f	class:folly::io::detail::CursorBase	access:public	signature:(BufType* buf)
reset	.\io\Cursor.h	/^  void reset(IOBufQueue* queue, uint64_t growth) {$/;"	f	class:folly::io::QueueAppender	access:public	signature:(IOBufQueue* queue, uint64_t growth)
reset	.\io\async\EventBase.cpp	/^void EventBase::SmoothLoopTime::reset(double value) {$/;"	f	class:folly::EventBase::SmoothLoopTime	signature:(double value)
reset	.\io\async\EventBase.h	/^    void reset(double value = 0.0);$/;"	p	class:folly::EventBase::SmoothLoopTime	access:public	signature:(double value = 0.0)
reset	.\test\ThreadLocalTest.cpp	/^  void reset(T* t) {$/;"	f	class:PThreadGetSpecific	access:public	signature:(T* t)
resetLoadAvg	.\io\async\EventBase.cpp	/^void EventBase::resetLoadAvg(double value) {$/;"	f	class:folly::EventBase	signature:(double value)
resetLoadAvg	.\io\async\EventBase.h	/^  void resetLoadAvg(double value = 0.0);$/;"	p	class:folly::EventBase	access:public	signature:(double value = 0.0)
resetTimeout	.\experimental\wangle\ManagedConnection.cpp	/^ManagedConnection::resetTimeout() {$/;"	f	class:folly::wangle::ManagedConnection	signature:()
resetTimeout	.\experimental\wangle\ManagedConnection.h	/^  virtual void resetTimeout();$/;"	p	class:folly::wangle::ManagedConnection	access:public	signature:()
reset_	.\ThreadCachedInt.h	/^    std::atomic<bool> reset_;$/;"	m	struct:folly::ThreadCachedInt::IntCache	access:public
resize	.\FBVector.h	/^  void resize(size_type n) {$/;"	f	signature:(size_type n)
resize	.\FBVector.h	/^  void resize(size_type n, VT t) {$/;"	f	signature:(size_type n, VT t)
resize	.\dynamic-inl.h	/^inline void dynamic::resize(std::size_t sz, dynamic const& c) {$/;"	f	class:folly::dynamic	signature:(std::size_t sz, dynamic const& c)
resize	.\dynamic.h	/^  void resize(std::size_t n, dynamic const& = nullptr);$/;"	p	struct:folly::dynamic	access:public	signature:(std::size_t n, dynamic const& = nullptr)
resize	.\experimental\wangle\concurrent\test\ThreadPoolExecutorTest.cpp	/^static void resize() {$/;"	f	file:	signature:()
resize	.\small_vector.h	/^  void resize(size_type sz) {$/;"	f	class:folly::small_vector	access:public	signature:(size_type sz)
resize	.\small_vector.h	/^  void resize(size_type sz, value_type const& v) {$/;"	f	class:folly::small_vector	access:public	signature:(size_type sz, value_type const& v)
resize	.\test\FBStringTestBenchmarks.cpp.h	/^void BENCHFUN(resize)(int iters, int arg) {$/;"	f	signature:(int iters, int arg)
resizeUnderLoad	.\experimental\wangle\concurrent\test\ThreadPoolExecutorTest.cpp	/^static void resizeUnderLoad() {$/;"	f	file:	signature:()
resplit	.\gen\File-inl.h	/^                | resplit(delim)) {$/;"	f	namespace:folly::gen	signature:(delim)
resplit	.\gen\String.h	/^S resplit(char delimiter) {$/;"	f	namespace:folly::gen	signature:(char delimiter)
rest	.\GroupVarint.h	/^  StringPiece rest() const {$/;"	f	class:folly::GroupVarintDecoder	access:public	signature:() const
result	.\experimental\io\AsyncIO.cpp	/^ssize_t AsyncIOOp::result() const {$/;"	f	class:folly::AsyncIOOp	signature:() const
result	.\experimental\io\AsyncIO.h	/^  ssize_t result() const;$/;"	p	class:folly::AsyncIOOp	access:public	signature:() const
result_	.\experimental\EliasFanoCoding.h	/^  EliasFanoCompressedList result_;$/;"	m	struct:folly::compression::EliasFanoEncoder	access:private
result_	.\experimental\io\AsyncIO.h	/^  ssize_t result_;$/;"	m	class:folly::AsyncIOOp	access:private
result_type	.\Lazy.h	/^  typedef typename std::result_of<Func()>::type result_type;$/;"	t	struct:folly::detail::Lazy	access:public
result_type	.\Random.h	/^  typedef uint32_t result_type;$/;"	t	class:folly::ThreadLocalPRNG	access:public
results	.\wangle\detail\State.h	/^  std::tuple<Try<Ts>... > results;$/;"	m	struct:folly::wangle::detail::VariadicContext	access:public
results	.\wangle\detail\State.h	/^  std::vector<Try<T> > results;$/;"	m	struct:folly::wangle::detail::WhenAllContext	access:public
results	.\wangle\detail\State.h	/^  std::vector<Try<T> > results;$/;"	m	struct:folly::wangle::detail::WhenAllLaterContext	access:public
retVal	.\test\ApplyTupleTest.cpp	/^  double retVal(int a, double b) {$/;"	f	struct:__anon104::Wat	access:public	signature:(int a, double b)
rethrow_exception	.\experimental\exception_tracer\ExceptionTracerLib.cpp	/^void rethrow_exception(std::exception_ptr ep) {$/;"	f	namespace:std	signature:(std::exception_ptr ep)
retreat	.\io\IOBuf.h	/^  void retreat(uint64_t amount) {$/;"	f	class:folly::IOBuf	access:public	signature:(uint64_t amount)
retreat	.\io\TypedIOBuf.h	/^  void retreat(uint32_t n) {$/;"	f	class:folly::TypedIOBuf	access:public	signature:(uint32_t n)
retrieved_	.\wangle\Promise.h	/^  bool retrieved_;$/;"	m	class:folly::wangle::Promise	access:private
returnCode	.\Subprocess.h	/^  ProcessReturnCode returnCode() const { return returnCode_; }$/;"	f	class:folly::CalledProcessError	access:public	signature:() const
returnCode	.\Subprocess.h	/^  ProcessReturnCode returnCode() const { return returnCode_; }$/;"	f	class:folly::Subprocess	access:public	signature:() const
returnCode	.\test\function_benchmark\test_functions.cpp	/^int returnCode(int value) {$/;"	f	signature:(int value)
returnCode	.\test\function_benchmark\test_functions.h	/^int returnCode(int value);$/;"	p	signature:(int value)
returnCode_	.\Subprocess.h	/^  ProcessReturnCode returnCode_;$/;"	m	class:folly::CalledProcessError	access:private
returnCode_	.\Subprocess.h	/^  ProcessReturnCode returnCode_;$/;"	m	class:folly::Subprocess	access:private
returnExceptionPtr	.\test\function_benchmark\test_functions.cpp	/^std::exception_ptr returnExceptionPtr() {$/;"	f	signature:()
returnExceptionPtr	.\test\function_benchmark\test_functions.h	/^std::exception_ptr returnExceptionPtr();$/;"	p	signature:()
returnString	.\test\function_benchmark\test_functions.cpp	/^std::string returnString() {$/;"	f	signature:()
returnString	.\test\function_benchmark\test_functions.h	/^std::string returnString();$/;"	p	signature:()
returnsDouble	.\test\ScopeGuardTest.cpp	/^double returnsDouble() {$/;"	f	signature:()
retval	.\wangle\test\thens.rb	/^def retval(ret)$/;"	f
reverse_iterator	.\EvictingCacheMap.h	/^    TPair, typename NodeList::reverse_iterator> reverse_iterator;$/;"	t	class:folly::EvictingCacheMap	access:public
reverse_iterator	.\FBVector.h	/^  typedef std::reverse_iterator<iterator>             reverse_iterator;$/;"	t	class:folly::fbvector	access:public
reverse_iterator	.\small_vector.h	/^  typedef std::reverse_iterator<iterator>       reverse_iterator;$/;"	t	class:folly::small_vector	access:public
reverse_iterator	.\sorted_vector_types.h	/^  typedef typename ContainerT::reverse_iterator       reverse_iterator;$/;"	t	class:folly::sorted_vector_map	access:public
reverse_iterator	.\sorted_vector_types.h	/^  typedef typename ContainerT::reverse_iterator       reverse_iterator;$/;"	t	class:folly::sorted_vector_set	access:public
rfind	.\Range.h	/^  size_type rfind(value_type c) const {$/;"	f	class:folly::Range	access:public	signature:(value_type c) const
rfind	.\Range.h	/^inline size_t rfind(const Range<const char*>& haystack, const char& needle) {$/;"	f	namespace:folly	signature:(const Range<const char*>& haystack, const char& needle)
rfind	.\Range.h	/^inline size_t rfind(const Range<const unsigned char*>& haystack,$/;"	f	namespace:folly	signature:(const Range<const unsigned char*>& haystack, const unsigned char& needle)
rfind	.\Range.h	/^size_t rfind(const Range<T> & haystack,$/;"	p	namespace:folly	signature:(const Range<T> & haystack, const typename Range<T>::value_type& needle)
rfind	.\Range.h	/^size_t rfind(const Range<T>& haystack,$/;"	f	namespace:folly	signature:(const Range<T>& haystack, const typename Range<T>::value_type& needle)
rhs	.\IndexedMemPool.h	/^  IndexedMemPoolRecycler& operator= (const IndexedMemPoolRecycler<Pool>& rhs)$/;"	m	struct:detail::IndexedMemPoolRecycler	access:public
rhs	.\IndexedMemPool.h	/^  IndexedMemPoolRecycler(const IndexedMemPoolRecycler<Pool>& rhs)$/;"	m	struct:detail::IndexedMemPoolRecycler	access:public
right	.\test\AtomicStructTest.cpp	/^  uint32_t right;$/;"	m	struct:TwoBy32	file:	access:public
rnd	.\test\RangeFindBenchmark.cpp	/^std::mt19937 rnd;$/;"	m	namespace:__anon129	file:
rng	.\Random.cpp	/^  Random::DefaultGenerator rng;$/;"	m	class:folly::ThreadLocalPRNG::LocalInstancePRNG	file:	access:public
rng	.\test\FBStringBenchmark.cpp	/^static RandomT rng(seed);$/;"	p	file:	signature:(seed)
rng	.\test\FBStringTest.cpp	/^static RandomT rng(seed);$/;"	p	file:	signature:(seed)
rng	.\test\FBVectorBenchmark.cpp	/^static RandomT rng(seed);$/;"	p	file:	signature:(seed)
rng	.\test\FBVectorTest.cpp	/^static RandomT rng(seed);$/;"	p	file:	signature:(seed)
rng	.\test\SynchronizedTestLib-inl.h	/^static RandomT rng(seed);$/;"	p	signature:(seed)
rng_	.\gen\Base-inl.h	/^    mutable Rand rng_;$/;"	m	class:folly::gen::detail::Sample::Generator	access:private
rng_	.\gen\Base-inl.h	/^  Random rng_;$/;"	m	class:folly::gen::detail::Sample	access:private
roundUp	.\Arena.h	/^  size_t roundUp(size_t size) const {$/;"	f	class:folly::Arena	access:private	signature:(size_t size) const
rrest_	.\GroupVarint.h	/^  const char* rrest_;$/;"	m	class:folly::GroupVarintDecoder	access:private
run	.\experimental\symbolizer\SignalHandler.cpp	/^  void run();$/;"	p	class:folly::symbolizer::__anon36::FatalSignalCallbackRegistry	file:	access:public	signature:()
run	.\experimental\symbolizer\SignalHandler.cpp	/^void FatalSignalCallbackRegistry::run() {$/;"	f	class:folly::symbolizer::__anon36::FatalSignalCallbackRegistry	signature:()
run	.\test\RWSpinLockTest.cpp	/^static void run(RWSpinLockType* lock) {$/;"	f	namespace:__anon130	signature:(RWSpinLockType* lock)
run	.\wangle\ManualExecutor.cpp	/^size_t ManualExecutor::run() {$/;"	f	class:folly::wangle::ManualExecutor	signature:()
run	.\wangle\ManualExecutor.h	/^    size_t run();$/;"	p	class:folly::wangle::ManualExecutor	access:public	signature:()
runAfterDelay	.\io\async\EventBase.cpp	/^bool EventBase::runAfterDelay(const Cob& cob,$/;"	f	class:folly::EventBase	signature:(const Cob& cob, int milliseconds, TimeoutManager::InternalEnum in)
runAfterDelay	.\io\async\EventBase.h	/^  bool runAfterDelay($/;"	p	class:folly::EventBase	access:public	signature:( const Cob& c, int milliseconds, TimeoutManager::InternalEnum = TimeoutManager::InternalEnum::NORMAL)
runBenchmark	.\io\test\IOBufCursorTest.cpp	/^void runBenchmark() {$/;"	f	signature:()
runBenchmarkGetNSPerIteration	.\Benchmark.cpp	/^static double runBenchmarkGetNSPerIteration(const BenchmarkFun& fun,$/;"	f	namespace:folly	signature:(const BenchmarkFun& fun, const double globalBaseline)
runBenchmarks	.\Benchmark.cpp	/^void runBenchmarks() {$/;"	f	namespace:folly	signature:()
runBenchmarks	.\Benchmark.h	/^void runBenchmarks();$/;"	p	namespace:folly	signature:()
runBenchmarksOnFlag	.\Benchmark.h	/^inline bool runBenchmarksOnFlag() {$/;"	f	namespace:folly	signature:()
runChild	.\Subprocess.cpp	/^int Subprocess::runChild(const char* executable,$/;"	f	class:folly::Subprocess	signature:(const char* executable, char** argv, char** env, const Options& options) const
runChild	.\Subprocess.h	/^  int runChild(const char* executable, char** argv, char** env,$/;"	p	class:folly::Subprocess	access:private	signature:(const char* executable, char** argv, char** env, const Options& options) const
runChild	.\test\SubprocessTestParentDeathHelper.cpp	/^void runChild(const char* file) {$/;"	f	signature:(const char* file)
runElementTypeTest	.\test\MPMCQueueTest.cpp	/^void runElementTypeTest(T&& src) {$/;"	f	signature:(T&& src)
runElfCacheTest	.\experimental\symbolizer\test\SymbolizerTest.cpp	/^void runElfCacheTest(Symbolizer& symbolizer) {$/;"	f	namespace:folly::symbolizer::test	signature:(Symbolizer& symbolizer)
runFFSTest	.\test\BitIteratorTest.cpp	/^void runFFSTest(FFS fn) {$/;"	f	namespace:__anon110	signature:(FFS fn)
runFunctionPtr	.\io\async\EventBase.cpp	/^void EventBase::runFunctionPtr(Cob* fn) {$/;"	f	class:folly::EventBase	signature:(Cob* fn)
runFunctionPtr	.\io\async\EventBase.h	/^  static void runFunctionPtr(std::function<void()>* fn);$/;"	p	class:folly::EventBase	access:private	signature:(std::function<void()>* fn)
runInEventBaseThread	.\io\async\EventBase.cpp	/^bool EventBase::runInEventBaseThread(const Cob& fn) {$/;"	f	class:folly::EventBase	signature:(const Cob& fn)
runInEventBaseThread	.\io\async\EventBase.cpp	/^bool EventBase::runInEventBaseThread(void (*fn)(void*), void* arg) {$/;"	f	class:folly::EventBase	signature:(void (*fn)(void*), void* arg)
runInEventBaseThread	.\io\async\EventBase.h	/^  bool runInEventBaseThread(const Cob& fn);$/;"	p	class:folly::EventBase	access:public	signature:(const Cob& fn)
runInEventBaseThread	.\io\async\EventBase.h	/^  bool runInEventBaseThread(void (*fn)(T*), T* arg) {$/;"	f	class:folly::EventBase	access:public	signature:(void (*fn)(T*), T* arg)
runInEventBaseThread	.\io\async\EventBase.h	/^  bool runInEventBaseThread(void (*fn)(void*), void* arg);$/;"	p	class:folly::EventBase	access:public	signature:(void (*fn)(void*), void* arg)
runInLoop	.\io\async\EventBase.cpp	/^void EventBase::runInLoop(Cob&& cob, bool thisIteration) {$/;"	f	class:folly::EventBase	signature:(Cob&& cob, bool thisIteration)
runInLoop	.\io\async\EventBase.cpp	/^void EventBase::runInLoop(LoopCallback* callback, bool thisIteration) {$/;"	f	class:folly::EventBase	signature:(LoopCallback* callback, bool thisIteration)
runInLoop	.\io\async\EventBase.cpp	/^void EventBase::runInLoop(const Cob& cob, bool thisIteration) {$/;"	f	class:folly::EventBase	signature:(const Cob& cob, bool thisIteration)
runInLoop	.\io\async\EventBase.h	/^  void runInLoop(Cob&& c, bool thisIteration = false);$/;"	p	class:folly::EventBase	access:public	signature:(Cob&& c, bool thisIteration = false)
runInLoop	.\io\async\EventBase.h	/^  void runInLoop(LoopCallback* callback, bool thisIteration = false);$/;"	p	class:folly::EventBase	access:public	signature:(LoopCallback* callback, bool thisIteration = false)
runInLoop	.\io\async\EventBase.h	/^  void runInLoop(const Cob& c, bool thisIteration = false);$/;"	p	class:folly::EventBase	access:public	signature:(const Cob& c, bool thisIteration = false)
runInternal	.\TimeoutQueue.cpp	/^int64_t TimeoutQueue::runInternal(int64_t now, bool onceOnly) {$/;"	f	class:folly::TimeoutQueue	signature:(int64_t now, bool onceOnly)
runInternal	.\TimeoutQueue.h	/^  int64_t runInternal(int64_t now, bool runOnce);$/;"	p	class:folly::TimeoutQueue	access:private	signature:(int64_t now, bool runOnce)
runLoop	.\TimeoutQueue.h	/^  int64_t runLoop(int64_t now) { return runInternal(now, false); }$/;"	f	class:folly::TimeoutQueue	access:public	signature:(int64_t now)
runLoopCallbacks	.\io\async\EventBase.cpp	/^bool EventBase::runLoopCallbacks(bool setContext) {$/;"	f	class:folly::EventBase	signature:(bool setContext)
runLoopCallbacks	.\io\async\EventBase.h	/^  bool runLoopCallbacks(bool setContext = true);$/;"	p	class:folly::EventBase	access:private	signature:(bool setContext = true)
runMultiBitTest64	.\experimental\test\BitsTest.cpp	/^void runMultiBitTest64() {$/;"	f	signature:()
runMultiBitTest8	.\experimental\test\BitsTest.cpp	/^void runMultiBitTest8() {$/;"	f	signature:()
runNeverFailTest	.\test\MPMCQueueTest.cpp	/^uint64_t runNeverFailTest(int numThreads, int numOps) {$/;"	f	signature:(int numThreads, int numOps)
runNeverFailThread	.\test\MPMCQueueTest.cpp	/^void runNeverFailThread($/;"	f	signature:( int numThreads, int n, MPMCQueue<int, Atom>& cq, std::atomic<uint64_t>& sum, int t)
runOnDestruction	.\io\async\EventBase.cpp	/^void EventBase::runOnDestruction(LoopCallback* callback) {$/;"	f	class:folly::EventBase	signature:(LoopCallback* callback)
runOnDestruction	.\io\async\EventBase.h	/^  void runOnDestruction(LoopCallback* callback);$/;"	p	class:folly::EventBase	access:public	signature:(LoopCallback* callback)
runOnce	.\TimeoutQueue.h	/^  int64_t runOnce(int64_t now) { return runInternal(now, true); }$/;"	f	class:folly::TimeoutQueue	access:public	signature:(int64_t now)
runOnceCallbacks_	.\io\async\EventBase.h	/^  LoopCallbackList* runOnceCallbacks_;$/;"	m	class:folly::EventBase	access:private
runParent	.\test\SubprocessTestParentDeathHelper.cpp	/^void runParent(const char* file) {$/;"	f	signature:(const char* file)
runRealFFSTest	.\test\BitIteratorTest.cpp	/^void runRealFFSTest(int iters) {$/;"	f	namespace:__anon110	signature:(int iters)
runSet	.\test\ConcurrentSkipListBenchmark.cpp	/^  void runSet(int id, int iters) {$/;"	f	class:__anon113::ConcurrentAccessData	access:public	signature:(int id, int iters)
runSignedMultiBitTest8	.\experimental\test\BitsTest.cpp	/^void runSignedMultiBitTest8() {$/;"	f	signature:()
runSimpleFFSTest	.\test\BitIteratorTest.cpp	/^void runSimpleFFSTest(int iters) {$/;"	f	namespace:__anon110	signature:(int iters)
runSimpleTest	.\io\test\CompressionTest.cpp	/^   void runSimpleTest(const DataHolder& dh);$/;"	p	class:folly::io::test::CompressionTest	file:	access:protected	signature:(const DataHolder& dh)
runSimpleTest	.\io\test\CompressionTest.cpp	/^  void runSimpleTest(const DataHolder& dh);$/;"	p	class:folly::io::test::CompressionCorruptionTest	file:	access:protected	signature:(const DataHolder& dh)
runSimpleTest	.\io\test\CompressionTest.cpp	/^void CompressionCorruptionTest::runSimpleTest(const DataHolder& dh) {$/;"	f	class:folly::io::test::CompressionCorruptionTest	signature:(const DataHolder& dh)
runSimpleTest	.\io\test\CompressionTest.cpp	/^void CompressionTest::runSimpleTest(const DataHolder& dh) {$/;"	f	class:folly::io::test::CompressionTest	signature:(const DataHolder& dh)
runSimpleTest64	.\experimental\test\BitsTest.cpp	/^void runSimpleTest64() {$/;"	f	signature:()
runSimpleTest8	.\experimental\test\BitsTest.cpp	/^void runSimpleTest8() {$/;"	f	signature:()
runSkipList	.\test\ConcurrentSkipListBenchmark.cpp	/^  void runSkipList(int id, int iters) {$/;"	f	class:__anon113::ConcurrentAccessData	access:public	signature:(int id, int iters)
runThreads	.\test\AtomicHashMapTest.cpp	/^void runThreads(void *(*thread)(void*)) {$/;"	f	namespace:__anon105	signature:(void *(*thread)(void*))
runThreads	.\test\AtomicHashMapTest.cpp	/^void runThreads(void *(*thread)(void*), int numThreads, void **statuses) {$/;"	f	namespace:__anon105	signature:(void *(*thread)(void*), int numThreads, void **statuses)
runThreadsCreatedAllThreads	.\test\AtomicHashMapTest.cpp	/^std::atomic<bool> runThreadsCreatedAllThreads;$/;"	m	namespace:__anon105	file:
runTryEnqDeqTest	.\test\MPMCQueueTest.cpp	/^void runTryEnqDeqTest(int numThreads, int numOps) {$/;"	f	signature:(int numThreads, int numOps)
runTryEnqDeqThread	.\test\MPMCQueueTest.cpp	/^void runTryEnqDeqThread($/;"	f	signature:( int numThreads, int n, MPMCQueue<int, Atom>& cq, std::atomic<uint64_t>& sum, int t)
runUnsplitSuite	.\gen\test\StringTest.cpp	/^void runUnsplitSuite(F fn) {$/;"	f	signature:(F fn)
run_basic_tests	.\test\FutexTest.cpp	/^void run_basic_tests() {$/;"	f	signature:()
run_basic_thread	.\test\FutexTest.cpp	/^void run_basic_thread($/;"	f	signature:( Futex<Atom>& f)
run_basic_timed_wait_tests	.\test\BatonTest.cpp	/^void run_basic_timed_wait_tests() {$/;"	f	signature:()
run_mt_sequencer_test	.\test\MPMCQueueTest.cpp	/^void run_mt_sequencer_test(int numThreads, int numOps, uint32_t init) {$/;"	f	signature:(int numThreads, int numOps, uint32_t init)
run_mt_sequencer_thread	.\test\MPMCQueueTest.cpp	/^void run_mt_sequencer_thread($/;"	f	signature:( int numThreads, int numOps, uint32_t init, TurnSequencer<Atom>& seq, Atom<int>& spinThreshold, int& prev, int i)
run_pingpong_test	.\test\BatonTest.cpp	/^void run_pingpong_test(int numRounds) {$/;"	f	signature:(int numRounds)
run_steady_clock_test	.\test\FutexTest.cpp	/^void run_steady_clock_test() {$/;"	f	signature:()
run_system_clock_test	.\test\FutexTest.cpp	/^void run_system_clock_test() {$/;"	f	signature:()
run_timed_wait_regular_test	.\test\BatonTest.cpp	/^void run_timed_wait_regular_test() {$/;"	f	signature:()
run_timed_wait_tmo_tests	.\test\BatonTest.cpp	/^void run_timed_wait_tmo_tests() {$/;"	f	signature:()
run_try_wait_tests	.\test\BatonTest.cpp	/^void run_try_wait_tests() {$/;"	f	signature:()
run_wait_until_tests	.\test\FutexTest.cpp	/^void run_wait_until_tests();$/;"	p	file:	signature:()
run_wait_until_tests	.\test\FutexTest.cpp	/^void run_wait_until_tests<DeterministicAtomic>() {$/;"	f	signature:()
run_wait_until_tests	.\test\FutexTest.cpp	/^void run_wait_until_tests<std::atomic>() {$/;"	f	signature:()
running	.\Subprocess.h	/^  bool running() const { return state() == RUNNING; }$/;"	f	class:folly::ProcessReturnCode	access:public	signature:() const
s16	.\test\ConvTest.cpp	/^static int16_t s16;$/;"	v	file:
s32	.\test\ConvTest.cpp	/^static int32_t s32;$/;"	v	file:
s64	.\test\ConvTest.cpp	/^static int64_t s64;$/;"	v	file:
s6_addr16	.\detail\IPAddress.h	50;"	d
s8	.\test\ConvTest.cpp	/^static int8_t s8;$/;"	v	file:
s_	.\test\GroupVarintTest.cpp	/^  std::string& s_;$/;"	m	class:__anon121::StringAppender	file:	access:private
s_	.\test\OptionalTest.cpp	/^  std::string s_;$/;"	m	class:folly::MoveTester	file:	access:private
s_mockClockInstance	.\test\MemoryIdlerTest.cpp	/^  static std::weak_ptr<StrictMock<MockClock>> s_mockClockInstance;$/;"	m	struct:MockClock	file:	access:public
s_mockClockInstance	.\test\MemoryIdlerTest.cpp	/^std::weak_ptr<StrictMock<MockClock>> MockClock::s_mockClockInstance;$/;"	m	class:MockClock	file:
s_pageSize	.\detail\MemoryIdler.cpp	/^static const size_t s_pageSize = sysconf(_SC_PAGESIZE);$/;"	m	namespace:folly::detail	file:
sa_family_t	.\detail\IPAddress.h	39;"	d
sallocx	.\detail\Malloc.h	/^extern size_t (*sallocx)(const void*, int);$/;"	x
sallocx	.\detail\Malloc.h	/^size_t sallocx(const void*, int) __attribute__((__weak__));$/;"	p	signature:(const void*, int)
sallocx	.\detail\MallocImpl.cpp	/^size_t (*sallocx)(const void*, int) = nullptr;$/;"	v
sample	.\gen\Base-inl.h	/^inline detail::Sample<Random> sample(size_t count, Random rng = Random()) {$/;"	f	namespace:folly::gen	signature:(size_t count, Random rng = Random())
saveContext	.\io\async\Request.h	/^  static std::shared_ptr<RequestContext> saveContext() {$/;"	f	class:folly::RequestContext	access:public	signature:()
sc_blockSize	.\SpookyHashV1.h	/^    static const size_t sc_blockSize = sc_numVars*8;$/;"	m	class:folly::hash::SpookyHashV1	access:private
sc_blockSize	.\SpookyHashV2.h	/^    static const size_t sc_blockSize = sc_numVars*8;$/;"	m	class:folly::hash::SpookyHashV2	access:private
sc_bufSize	.\SpookyHashV1.h	/^    static const size_t sc_bufSize = 2*sc_blockSize;$/;"	m	class:folly::hash::SpookyHashV1	access:private
sc_bufSize	.\SpookyHashV2.h	/^    static const size_t sc_bufSize = 2*sc_blockSize;$/;"	m	class:folly::hash::SpookyHashV2	access:private
sc_const	.\SpookyHashV1.h	/^    static const uint64_t sc_const = 0xdeadbeefdeadbeefLL;$/;"	m	class:folly::hash::SpookyHashV1	access:private
sc_const	.\SpookyHashV2.h	/^    static const uint64_t sc_const = 0xdeadbeefdeadbeefLL;$/;"	m	class:folly::hash::SpookyHashV2	access:private
sc_numVars	.\SpookyHashV1.h	/^    static const size_t sc_numVars = 12;$/;"	m	class:folly::hash::SpookyHashV1	access:private
sc_numVars	.\SpookyHashV2.h	/^    static const size_t sc_numVars = 12;$/;"	m	class:folly::hash::SpookyHashV2	access:private
scanHaystackBlock	.\Range.cpp	/^size_t scanHaystackBlock(const StringPiece& haystack,$/;"	f	namespace:folly::detail	signature:(const StringPiece& haystack, const StringPiece& needles, int64_t blockStartIdx)
schedule	.\wangle\Executor.h	/^     void schedule(Action&& a) { add(std::move(a)); }$/;"	f	class:folly::wangle::Executor	access:public	signature:(Action&& a)
schedule	.\wangle\Executor.h	/^     void schedule(Action&& a, Duration const& dur) {$/;"	f	class:folly::wangle::Executor	access:public	signature:(Action&& a, Duration const& dur)
scheduleAt	.\wangle\Executor.h	/^     virtual void scheduleAt(Action&& a, TimePoint const& t) {$/;"	f	class:folly::wangle::Executor	access:public	signature:(Action&& a, TimePoint const& t)
scheduleTimeout	.\experimental\wangle\ConnectionManager.cpp	/^ConnectionManager::scheduleTimeout(ManagedConnection* connection) {$/;"	f	class:folly::wangle::ConnectionManager	signature:(ManagedConnection* connection)
scheduleTimeout	.\experimental\wangle\ConnectionManager.cpp	/^void ConnectionManager::scheduleTimeout($/;"	f	class:folly::wangle::ConnectionManager	signature:( folly::HHWheelTimer::Callback* callback, std::chrono::milliseconds timeout)
scheduleTimeout	.\experimental\wangle\ConnectionManager.h	/^  void scheduleTimeout(ManagedConnection* connection);$/;"	p	class:folly::wangle::ConnectionManager	access:public	signature:(ManagedConnection* connection)
scheduleTimeout	.\experimental\wangle\ConnectionManager.h	/^  void scheduleTimeout(folly::HHWheelTimer::Callback* callback,$/;"	p	class:folly::wangle::ConnectionManager	access:public	signature:(folly::HHWheelTimer::Callback* callback, std::chrono::milliseconds timeout)
scheduleTimeout	.\experimental\wangle\ManagedConnection.cpp	/^ManagedConnection::scheduleTimeout($/;"	f	class:folly::wangle::ManagedConnection	signature:( folly::HHWheelTimer::Callback* callback, std::chrono::milliseconds timeout)
scheduleTimeout	.\experimental\wangle\ManagedConnection.h	/^  virtual void scheduleTimeout($/;"	p	class:folly::wangle::ManagedConnection	access:public	signature:( folly::HHWheelTimer::Callback* callback, std::chrono::milliseconds timeout)
scheduleTimeout	.\io\async\AsyncTimeout.cpp	/^bool AsyncTimeout::scheduleTimeout(std::chrono::milliseconds timeout) {$/;"	f	class:folly::AsyncTimeout	signature:(std::chrono::milliseconds timeout)
scheduleTimeout	.\io\async\AsyncTimeout.cpp	/^bool AsyncTimeout::scheduleTimeout(uint32_t milliseconds) {$/;"	f	class:folly::AsyncTimeout	signature:(uint32_t milliseconds)
scheduleTimeout	.\io\async\AsyncTimeout.h	/^  bool scheduleTimeout(std::chrono::milliseconds timeout);$/;"	p	class:folly::AsyncTimeout	access:public	signature:(std::chrono::milliseconds timeout)
scheduleTimeout	.\io\async\AsyncTimeout.h	/^  bool scheduleTimeout(uint32_t milliseconds);$/;"	p	class:folly::AsyncTimeout	access:public	signature:(uint32_t milliseconds)
scheduleTimeout	.\io\async\EventBase.cpp	/^bool EventBase::scheduleTimeout(AsyncTimeout* obj,$/;"	f	class:folly::EventBase	signature:(AsyncTimeout* obj, std::chrono::milliseconds timeout)
scheduleTimeout	.\io\async\EventBase.h	/^  bool scheduleTimeout(AsyncTimeout* obj, std::chrono::milliseconds timeout);$/;"	p	class:folly::EventBase	access:private	signature:(AsyncTimeout* obj, std::chrono::milliseconds timeout)
scheduleTimeout	.\io\async\HHWheelTimer.cpp	/^void HHWheelTimer::scheduleTimeout(Callback* callback,$/;"	f	class:folly::HHWheelTimer	signature:(Callback* callback, std::chrono::milliseconds timeout)
scheduleTimeout	.\io\async\HHWheelTimer.h	/^  void scheduleTimeout(Callback* callback,$/;"	p	class:folly::HHWheelTimer	access:public	signature:(Callback* callback, std::chrono::milliseconds timeout)
scheduleTimeout	.\io\async\TimeoutManager.h	/^  virtual bool scheduleTimeout(AsyncTimeout* obj,$/;"	p	class:folly::TimeoutManager	access:public	signature:(AsyncTimeout* obj, std::chrono::milliseconds timeout)
scheduleTimeoutImpl	.\io\async\HHWheelTimer.cpp	/^void HHWheelTimer::scheduleTimeoutImpl(Callback* callback,$/;"	f	class:folly::HHWheelTimer	signature:(Callback* callback, std::chrono::milliseconds timeout)
scheduleTimeoutImpl	.\io\async\HHWheelTimer.h	/^  void scheduleTimeoutImpl(Callback* callback,$/;"	p	class:folly::HHWheelTimer	access:public	signature:(Callback* callback, std::chrono::milliseconds timeout)
scheduledActions_	.\wangle\ManualExecutor.h	/^    std::priority_queue<ScheduledAction> scheduledActions_;$/;"	m	class:folly::wangle::ManualExecutor	access:private
scheduler_	.\test\DeterministicSchedule.h	/^  std::function<int(int)> scheduler_;$/;"	m	class:folly::test::DeterministicSchedule	access:private
scheme	.\Uri.h	/^  const fbstring& scheme() const { return scheme_; }$/;"	f	class:folly::Uri	access:public	signature:() const
scheme_	.\Uri.h	/^  fbstring scheme_;$/;"	m	class:folly::Uri	access:private
scope_	.\experimental\TestUtil.h	/^  Scope scope_;$/;"	m	class:folly::test::TemporaryDirectory	access:private
scope_	.\experimental\TestUtil.h	/^  Scope scope_;$/;"	m	class:folly::test::TemporaryFile	access:private
sdiv	.\io\TypedIOBuf.h	/^  static uint32_t sdiv(uint32_t n) {$/;"	f	class:folly::TypedIOBuf	access:private	signature:(uint32_t n)
second_	.\gen\Core-inl.h	/^  Second second_;$/;"	m	class:folly::gen::detail::Chain	access:private
second_	.\gen\Core-inl.h	/^  Second second_;$/;"	m	class:folly::gen::detail::Composed	access:private
section	.\experimental\symbolizer\Elf-inl.h	/^const ElfW(Sym)* ElfFile::iterateSymbols(const ElfW(Shdr)& section, Fn fn)$/;"	m	namespace:folly::symbolizer
section	.\experimental\symbolizer\Elf-inl.h	/^const ElfW(Sym)* ElfFile::iterateSymbolsWithType(const ElfW(Shdr)& section,$/;"	m	namespace:folly::symbolizer
section	.\experimental\symbolizer\Elf.h	/^  const ElfW(Sym)* iterateSymbols(const ElfW(Shdr)& section, Fn fn) const;$/;"	m	class:folly::symbolizer::ElfFile	access:public
section	.\experimental\symbolizer\Elf.h	/^  const ElfW(Sym)* iterateSymbolsWithType(const ElfW(Shdr)& section,$/;"	m	class:folly::symbolizer::ElfFile	access:public
section	.\experimental\symbolizer\Elf.h	/^  const T& valueAt(const ElfW(Shdr)& section, const ElfW(Addr) addr) const {$/;"	m	class:folly::symbolizer::ElfFile	access:private
secureRandom	.\Random.cpp	/^void Random::secureRandom(void* data, size_t size) {$/;"	f	class:folly::Random	signature:(void* data, size_t size)
secureRandom	.\Random.h	/^  secureRandom() {$/;"	f	class:folly::Random	access:public	signature:()
secureRandom	.\Random.h	/^  static void secureRandom(void* data, size_t len);$/;"	p	class:folly::Random	access:public	signature:(void* data, size_t len)
seed	.\Random-inl.h	/^void Random::seed(ValidRNG<RNG>& rng) {$/;"	f	class:folly::Random	signature:(ValidRNG<RNG>& rng)
seed	.\Random.h	/^  static void seed(ValidRNG<RNG>& rng);$/;"	p	class:folly::Random	access:public	signature:(ValidRNG<RNG>& rng)
seed	.\test\FBStringBenchmark.cpp	/^static const int seed = folly::randomNumberSeed();$/;"	v	file:
seed	.\test\FBStringTest.cpp	/^static const int seed = folly::randomNumberSeed();$/;"	v	file:
seed	.\test\FBVectorBenchmark.cpp	/^auto static const seed = randomNumberSeed();$/;"	v	file:
seed	.\test\FBVectorTest.cpp	/^auto static const seed = randomNumberSeed();$/;"	v	file:
seed	.\test\SynchronizedTestLib-inl.h	/^static const auto seed = folly::randomNumberSeed();$/;"	v
seedData	.\Random-inl.h	/^  std::array<uint32_t, stateSize> seedData;$/;"	m	struct:folly::detail::SeedData	access:public
seed_	.\gen\Base-inl.h	/^  Seed seed_;$/;"	m	class:folly::gen::detail::FoldLeft	access:private
seek	.\io\RecordIO.h	/^  Iterator seek(off_t pos) const;$/;"	p	class:folly::RecordIOReader	access:public	signature:(off_t pos) const
select_on_container_copy_construction	.\test\stl_tests\StlVectorTest.cpp	/^  Alloc select_on_container_copy_construction() const {$/;"	f	struct:Alloc	access:public	signature:() const
selector_	.\gen\Base-inl.h	/^    Selector selector_;$/;"	m	class:folly::gen::detail::Distinct::Generator	access:private
selector_	.\gen\Base-inl.h	/^    Selector selector_;$/;"	m	class:folly::gen::detail::Order::Generator	access:private
selector_	.\gen\Base-inl.h	/^  Selector selector_;$/;"	m	class:folly::gen::detail::Distinct	access:private
selector_	.\gen\Base-inl.h	/^  Selector selector_;$/;"	m	class:folly::gen::detail::Min	access:private
selector_	.\gen\Base-inl.h	/^  Selector selector_;$/;"	m	class:folly::gen::detail::Order	access:private
self	.\gen\Core-inl.h	/^  Self& self() {$/;"	f	struct:folly::gen::FBounded	access:public	signature:()
self	.\gen\Core-inl.h	/^  const Self& self() const {$/;"	f	struct:folly::gen::FBounded	access:public	signature:() const
self	.\test\stl_tests\StlVectorTest.cpp	/^  Tracker* self;$/;"	m	struct:Tracker	file:	access:public
self_needy_vault	.\experimental\test\SingletonTest.cpp	/^SingletonVault self_needy_vault;$/;"	v
sem_	.\experimental\wangle\concurrent\LifoSemMPMCQueue.h	/^  LifoSem sem_;$/;"	m	class:folly::wangle::LifoSemMPMCQueue	access:private
sem_	.\experimental\wangle\concurrent\ThreadPoolExecutor.h	/^    LifoSem sem_;$/;"	m	class:folly::wangle::ThreadPoolExecutor::StoppedThreadQueue	access:private
sem_	.\wangle\ManualExecutor.h	/^    sem_t sem_;$/;"	m	class:folly::wangle::ManualExecutor	access:private
sems_	.\test\DeterministicSchedule.h	/^  std::vector<sem_t*> sems_;$/;"	m	class:folly::test::DeterministicSchedule	access:private
sendSignal	.\Subprocess.cpp	/^void Subprocess::sendSignal(int signal) {$/;"	f	class:folly::Subprocess	signature:(int signal)
sendSignal	.\Subprocess.h	/^  void sendSignal(int signal);$/;"	p	class:folly::Subprocess	access:public	signature:(int signal)
separateChain	.\io\IOBuf.h	/^  std::unique_ptr<IOBuf> separateChain(IOBuf* head, IOBuf* tail) {$/;"	f	class:folly::IOBuf	access:public	signature:(IOBuf* head, IOBuf* tail)
seq	.\LifoSem.h	/^  inline constexpr uint32_t seq() const {$/;"	f	class:folly::detail::LifoSemHead	access:public	signature:() const
seq	.\gen\Base.h	/^Gen seq(Value first) {$/;"	f	namespace:folly::gen	signature:(Value first)
seq	.\gen\Base.h	/^Gen seq(Value first, Value last) {$/;"	f	namespace:folly::gen	signature:(Value first, Value last)
seq	.\gen\Base.h	/^Gen seq(Value first, Value last, Distance step) {$/;"	f	namespace:folly::gen	signature:(Value first, Value last, Distance step)
sequencer_	.\MPMCQueue.h	/^  TurnSequencer<Atom> sequencer_;$/;"	m	struct:folly::SingleElementQueue	access:private
serial_number	.\experimental\test\SingletonTest.cpp	/^  const size_t serial_number;$/;"	m	struct:Watchdog	file:	access:public
serialization_opts	.\json.h	/^    explicit serialization_opts()$/;"	f	struct:folly::json::serialization_opts	access:public	signature:()
serialization_opts	.\json.h	/^  struct serialization_opts {$/;"	s	namespace:folly::json
serialize	.\json.cpp	/^fbstring serialize(dynamic const& dyn, serialization_opts const& opts) {$/;"	f	namespace:folly::json	signature:(dynamic const& dyn, serialization_opts const& opts)
serialize	.\json.h	/^  fbstring serialize(dynamic const&, serialization_opts const&);$/;"	p	namespace:folly::json	signature:(dynamic const&, serialization_opts const&)
set	.\AtomicBitSet.h	/^  bool set(size_t idx, std::memory_order order = std::memory_order_seq_cst);$/;"	p	class:folly::AtomicBitSet	access:public	signature:(size_t idx, std::memory_order order = std::memory_order_seq_cst)
set	.\AtomicBitSet.h	/^  bool set(size_t idx,$/;"	p	class:folly::AtomicBitSet	access:public	signature:(size_t idx, bool value, std::memory_order order = std::memory_order_seq_cst)
set	.\AtomicBitSet.h	/^inline bool AtomicBitSet<N>::set(size_t idx, std::memory_order order) {$/;"	f	class:folly::AtomicBitSet	signature:(size_t idx, std::memory_order order)
set	.\AtomicBitSet.h	/^inline bool AtomicBitSet<N>::set(size_t idx,$/;"	f	class:folly::AtomicBitSet	signature:(size_t idx, bool value, std::memory_order order)
set	.\DiscriminatedPtr.h	/^  void set(T* ptr) {$/;"	f	class:folly::DiscriminatedPtr	access:public	signature:(T* ptr)
set	.\DiscriminatedPtr.h	/^  void set(void* p, uint16_t v) {$/;"	f	class:folly::DiscriminatedPtr	access:private	signature:(void* p, uint16_t v)
set	.\EvictingCacheMap.h	/^  void set(const TKey& key, TValue value, bool promote = true) {$/;"	f	class:folly::EvictingCacheMap	access:public	signature:(const TKey& key, TValue value, bool promote = true)
set	.\FBVector.h	/^    set(pointer newB, size_type newSize, size_type newCap) {$/;"	f	struct:folly::fbvector::Impl	access:public	signature:(pointer newB, size_type newSize, size_type newCap)
set	.\PackedSyncPtr.h	/^  void set(T* t) {$/;"	f	class:folly::PackedSyncPtr	access:public	signature:(T* t)
set	.\ThreadCachedInt.h	/^  void set(IntT newVal) {$/;"	f	class:folly::ThreadCachedInt	access:public	signature:(IntT newVal)
set	.\Traits.h	/^  class set;$/;"	x
set	.\detail\BitIteratorDetail.h	/^  void set() {$/;"	f	class:folly::bititerator_detail::BitReference	access:public	signature:()
set	.\detail\ThreadLocalDetail.h	/^  void set(Ptr p) {$/;"	f	struct:folly::threadlocal_detail::ElementWrapper	access:public	signature:(Ptr p)
set	.\detail\ThreadLocalDetail.h	/^  void set(Ptr p, Deleter d) {$/;"	f	struct:folly::threadlocal_detail::ElementWrapper	access:public	signature:(Ptr p, Deleter d)
set	.\experimental\Bits.h	/^  static void set(T* p, size_t bit);$/;"	p	struct:folly::Bits	access:public	signature:(T* p, size_t bit)
set	.\experimental\Bits.h	/^  static void set(T* p, size_t bitStart, size_t count, UnderlyingType value);$/;"	p	struct:folly::Bits	access:public	signature:(T* p, size_t bitStart, size_t count, UnderlyingType value)
set	.\experimental\Bits.h	/^inline void Bits<T, Traits>::set(T* p, size_t bit) {$/;"	f	class:folly::Bits	signature:(T* p, size_t bit)
set	.\experimental\Bits.h	/^inline void Bits<T, Traits>::set(T* p, size_t bitStart, size_t count,$/;"	f	class:folly::Bits	signature:(T* p, size_t bitStart, size_t count, UnderlyingType value)
set	.\experimental\symbolizer\Symbolizer.cpp	/^void SymbolizedFrame::set(const std::shared_ptr<ElfFile>& file,$/;"	f	class:folly::symbolizer::SymbolizedFrame	signature:(const std::shared_ptr<ElfFile>& file, uintptr_t address)
set	.\experimental\symbolizer\Symbolizer.h	/^  void set(const std::shared_ptr<ElfFile>& file, uintptr_t address);$/;"	p	struct:folly::symbolizer::SymbolizedFrame	access:public	signature:(const std::shared_ptr<ElfFile>& file, uintptr_t address)
setActive	.\io\async\NotificationQueue.h	/^    void setActive(bool active, bool shouldLock = false) {$/;"	f	class:folly::NotificationQueue::Consumer	access:private	signature:(bool active, bool shouldLock = false)
setAllNonBlocking	.\Subprocess.cpp	/^void Subprocess::setAllNonBlocking() {$/;"	f	class:folly::Subprocess	signature:()
setAllNonBlocking	.\Subprocess.h	/^  void setAllNonBlocking();$/;"	p	class:folly::Subprocess	access:public	signature:()
setCacheSize	.\ThreadCachedInt.h	/^  void setCacheSize(uint32_t newSize) {$/;"	f	class:folly::ThreadCachedInt	access:public	signature:(uint32_t newSize)
setCallback	.\wangle\detail\State.h	/^  void setCallback(F func) {$/;"	f	class:folly::wangle::detail::State	access:public	signature:(F func)
setCallback_	.\wangle\Future-inl.h	/^void Future<T>::setCallback_(F&& func) {$/;"	f	class:folly::wangle::Future	signature:(F&& func)
setCallback_	.\wangle\Future.h	/^  void setCallback_(F&& func);$/;"	p	class:folly::wangle::Future	access:public	signature:(F&& func)
setCapacity	.\small_vector.h	/^  void setCapacity(size_type newCapacity) {$/;"	f	class:folly::small_vector	access:private	signature:(size_type newCapacity)
setCatchupEveryN	.\io\async\HHWheelTimer.h	/^  void setCatchupEveryN(uint32_t everyN) {$/;"	f	class:folly::HHWheelTimer	access:public	signature:(uint32_t everyN)
setClearSize	.\EvictingCacheMap.h	/^  void setClearSize(size_t clearSize) {$/;"	f	class:folly::EvictingCacheMap	access:public	signature:(size_t clearSize)
setConnectionManager	.\experimental\wangle\ManagedConnection.h	/^  void setConnectionManager(ConnectionManager* mgr) {$/;"	f	class:folly::wangle::ManagedConnection	access:private	signature:(ConnectionManager* mgr)
setContext	.\io\async\Request.h	/^  setContext(std::shared_ptr<RequestContext> ctx) {$/;"	f	class:folly::RequestContext	access:public	signature:(std::shared_ptr<RequestContext> ctx)
setContextData	.\io\async\Request.h	/^  void setContextData($/;"	f	class:folly::RequestContext	access:public	signature:( const std::string& val, std::unique_ptr<RequestData> data)
setCrashOnError	.\Format.h	/^  void setCrashOnError(bool crash) {$/;"	f	class:folly::BaseFormatter	access:public	signature:(bool crash)
setData	.\SmallLocks.h	/^  void setData(IntType w) {$/;"	f	struct:folly::PicoSpinLock	access:public	signature:(IntType w)
setDefault	.\dynamic-inl.h	/^template<class K, class V> inline dynamic& dynamic::setDefault(K&& k, V&& v) {$/;"	f	class:folly::dynamic	signature:(K&& k, V&& v)
setDefault	.\dynamic.h	/^  dynamic& setDefault(K&& k, V&& v = dynamic::object);$/;"	p	struct:folly::dynamic	access:public	signature:(K&& k, V&& v = dynamic::object)
setEntryCountThreadCacheSize	.\AtomicHashArray.h	/^  void setEntryCountThreadCacheSize(uint32_t newSize) {$/;"	f	class:folly::AtomicHashArray	access:public	signature:(uint32_t newSize)
setEntryCountThreadCacheSize	.\AtomicHashMap.h	/^  void setEntryCountThreadCacheSize(int32_t newSize) {$/;"	f	class:folly::AtomicHashMap	access:public	signature:(int32_t newSize)
setErase	.\test\ConcurrentSkipListBenchmark.cpp	/^  inline void setErase(int idx, ValueType val) {$/;"	f	class:__anon113::ConcurrentAccessData	access:public	signature:(int idx, ValueType val)
setEventBase	.\io\async\EventHandler.cpp	/^void EventHandler::setEventBase(EventBase* eventBase) {$/;"	f	class:folly::EventHandler	signature:(EventBase* eventBase)
setEventBase	.\io\async\EventHandler.h	/^  void setEventBase(EventBase* eventBase);$/;"	p	class:folly::EventHandler	access:private	signature:(EventBase* eventBase)
setException	.\wangle\Promise-inl.h	/^void Promise<T>::setException(E const& e) {$/;"	f	class:folly::wangle::Promise	signature:(E const& e)
setException	.\wangle\Promise-inl.h	/^void Promise<T>::setException(std::exception_ptr const& e) {$/;"	f	class:folly::wangle::Promise	signature:(std::exception_ptr const& e)
setException	.\wangle\Promise.h	/^  template <class E> void setException(E const&);$/;"	p	class:folly::wangle::Promise	access:public	signature:(E const&)
setException	.\wangle\Promise.h	/^  void setException(std::exception_ptr const&);$/;"	p	class:folly::wangle::Promise	access:public	signature:(std::exception_ptr const&)
setException	.\wangle\detail\State.h	/^  template <class E> void setException(E const& e) {$/;"	f	class:folly::wangle::detail::State	access:public	signature:(E const& e)
setException	.\wangle\detail\State.h	/^  void setException(std::exception_ptr const& e) {$/;"	f	class:folly::wangle::detail::State	access:public	signature:(std::exception_ptr const& e)
setExtern	.\small_vector.h	/^    void setExtern(bool b) {$/;"	f	struct:folly::detail::IntegralSizePolicy	access:protected	signature:(bool b)
setExtra	.\PackedSyncPtr.h	/^  void setExtra(uint16_t extra) {$/;"	f	class:folly::PackedSyncPtr	access:public	signature:(uint16_t extra)
setFind	.\test\ConcurrentSkipListBenchmark.cpp	/^  inline bool setFind(int idx, ValueType val) {$/;"	f	class:__anon113::ConcurrentAccessData	access:public	signature:(int idx, ValueType val)
setFlags	.\ConcurrentSkipList-inl.h	/^  void setFlags(uint16_t flags) {$/;"	f	class:folly::detail::SkipListNode	access:private	signature:(uint16_t flags)
setFlags	.\io\IOBuf.h	/^  inline void setFlags(uintptr_t flags) const {$/;"	f	class:folly::IOBuf	access:private	signature:(uintptr_t flags) const
setFlagsAndSharedInfo	.\io\IOBuf.h	/^  inline void setFlagsAndSharedInfo(uintptr_t flags, SharedInfo* info) {$/;"	f	class:folly::IOBuf	access:private	signature:(uintptr_t flags, SharedInfo* info)
setFromAddrInfo	.\SocketAddress.cpp	/^void SocketAddress::setFromAddrInfo(const struct addrinfo* info) {$/;"	f	class:folly::SocketAddress	signature:(const struct addrinfo* info)
setFromAddrInfo	.\SocketAddress.h	/^  void setFromAddrInfo(const struct addrinfo* results);$/;"	p	class:folly::SocketAddress	access:private	signature:(const struct addrinfo* results)
setFromBinary	.\IPAddressV4.cpp	/^void IPAddressV4::setFromBinary(ByteRange bytes) {$/;"	f	class:folly::IPAddressV4	signature:(ByteRange bytes)
setFromBinary	.\IPAddressV4.h	/^  void setFromBinary(ByteRange bytes);$/;"	p	class:folly::IPAddressV4	access:private	signature:(ByteRange bytes)
setFromBinary	.\IPAddressV6.cpp	/^void IPAddressV6::setFromBinary(ByteRange bytes) {$/;"	f	class:folly::IPAddressV6	signature:(ByteRange bytes)
setFromBinary	.\IPAddressV6.h	/^  void setFromBinary(ByteRange bytes);$/;"	p	class:folly::IPAddressV6	access:private	signature:(ByteRange bytes)
setFromBinary	.\MacAddress.cpp	/^void MacAddress::setFromBinary(ByteRange value) {$/;"	f	class:folly::MacAddress	signature:(ByteRange value)
setFromBinary	.\MacAddress.h	/^  void setFromBinary(ByteRange value);$/;"	p	class:folly::MacAddress	access:public	signature:(ByteRange value)
setFromHostPort	.\SocketAddress.cpp	/^void SocketAddress::setFromHostPort(const char* host, uint16_t port) {$/;"	f	class:folly::SocketAddress	signature:(const char* host, uint16_t port)
setFromHostPort	.\SocketAddress.cpp	/^void SocketAddress::setFromHostPort(const char* hostAndPort) {$/;"	f	class:folly::SocketAddress	signature:(const char* hostAndPort)
setFromHostPort	.\SocketAddress.h	/^  void setFromHostPort(const char* host, uint16_t port);$/;"	p	class:folly::SocketAddress	access:public	signature:(const char* host, uint16_t port)
setFromHostPort	.\SocketAddress.h	/^  void setFromHostPort(const char* hostAndPort);$/;"	p	class:folly::SocketAddress	access:public	signature:(const char* hostAndPort)
setFromHostPort	.\SocketAddress.h	/^  void setFromHostPort(const std::string& host, uint16_t port) {$/;"	f	class:folly::SocketAddress	access:public	signature:(const std::string& host, uint16_t port)
setFromHostPort	.\SocketAddress.h	/^  void setFromHostPort(const std::string& hostAndPort) {$/;"	f	class:folly::SocketAddress	access:public	signature:(const std::string& hostAndPort)
setFromIpPort	.\SocketAddress.cpp	/^void SocketAddress::setFromIpPort(const char* addressAndPort) {$/;"	f	class:folly::SocketAddress	signature:(const char* addressAndPort)
setFromIpPort	.\SocketAddress.cpp	/^void SocketAddress::setFromIpPort(const char* ip, uint16_t port) {$/;"	f	class:folly::SocketAddress	signature:(const char* ip, uint16_t port)
setFromIpPort	.\SocketAddress.h	/^  void setFromIpPort(const char* addressAndPort);$/;"	p	class:folly::SocketAddress	access:public	signature:(const char* addressAndPort)
setFromIpPort	.\SocketAddress.h	/^  void setFromIpPort(const char* ip, uint16_t port);$/;"	p	class:folly::SocketAddress	access:public	signature:(const char* ip, uint16_t port)
setFromIpPort	.\SocketAddress.h	/^  void setFromIpPort(const std::string& addressAndPort) {$/;"	f	class:folly::SocketAddress	access:public	signature:(const std::string& addressAndPort)
setFromIpPort	.\SocketAddress.h	/^  void setFromIpPort(const std::string& ip, uint16_t port) {$/;"	f	class:folly::SocketAddress	access:public	signature:(const std::string& ip, uint16_t port)
setFromLocalAddr	.\SocketAddress.cpp	/^void SocketAddress::setFromLocalAddr(const struct addrinfo* info) {$/;"	f	class:folly::SocketAddress	signature:(const struct addrinfo* info)
setFromLocalAddr	.\SocketAddress.h	/^  void setFromLocalAddr(const struct addrinfo* results);$/;"	p	class:folly::SocketAddress	access:private	signature:(const struct addrinfo* results)
setFromLocalAddress	.\SocketAddress.cpp	/^void SocketAddress::setFromLocalAddress(int socket) {$/;"	f	class:folly::SocketAddress	signature:(int socket)
setFromLocalAddress	.\SocketAddress.h	/^  void setFromLocalAddress(int socket);$/;"	p	class:folly::SocketAddress	access:public	signature:(int socket)
setFromLocalIpPort	.\SocketAddress.cpp	/^void SocketAddress::setFromLocalIpPort(const char* addressAndPort) {$/;"	f	class:folly::SocketAddress	signature:(const char* addressAndPort)
setFromLocalIpPort	.\SocketAddress.h	/^  void setFromLocalIpPort(const char* addressAndPort);$/;"	p	class:folly::SocketAddress	access:public	signature:(const char* addressAndPort)
setFromLocalIpPort	.\SocketAddress.h	/^  void setFromLocalIpPort(const std::string& addressAndPort) {$/;"	f	class:folly::SocketAddress	access:public	signature:(const std::string& addressAndPort)
setFromLocalPort	.\SocketAddress.cpp	/^void SocketAddress::setFromLocalPort(const char* port) {$/;"	f	class:folly::SocketAddress	signature:(const char* port)
setFromLocalPort	.\SocketAddress.cpp	/^void SocketAddress::setFromLocalPort(uint16_t port) {$/;"	f	class:folly::SocketAddress	signature:(uint16_t port)
setFromLocalPort	.\SocketAddress.h	/^  void setFromLocalPort(const char* port);$/;"	p	class:folly::SocketAddress	access:public	signature:(const char* port)
setFromLocalPort	.\SocketAddress.h	/^  void setFromLocalPort(const std::string& port) {$/;"	f	class:folly::SocketAddress	access:public	signature:(const std::string& port)
setFromLocalPort	.\SocketAddress.h	/^  void setFromLocalPort(uint16_t port);$/;"	p	class:folly::SocketAddress	access:public	signature:(uint16_t port)
setFromPath	.\SocketAddress.cpp	/^void SocketAddress::setFromPath(const char* path, size_t len) {$/;"	f	class:folly::SocketAddress	signature:(const char* path, size_t len)
setFromPath	.\SocketAddress.h	/^  void setFromPath(const char* path) {$/;"	f	class:folly::SocketAddress	access:public	signature:(const char* path)
setFromPath	.\SocketAddress.h	/^  void setFromPath(const char* path, size_t length);$/;"	p	class:folly::SocketAddress	access:public	signature:(const char* path, size_t length)
setFromPath	.\SocketAddress.h	/^  void setFromPath(const std::string& path) {$/;"	f	class:folly::SocketAddress	access:public	signature:(const std::string& path)
setFromPeerAddress	.\SocketAddress.cpp	/^void SocketAddress::setFromPeerAddress(int socket) {$/;"	f	class:folly::SocketAddress	signature:(int socket)
setFromPeerAddress	.\SocketAddress.h	/^  void setFromPeerAddress(int socket);$/;"	p	class:folly::SocketAddress	access:public	signature:(int socket)
setFromSockaddr	.\SocketAddress.cpp	/^void SocketAddress::setFromSockaddr(const struct sockaddr* address) {$/;"	f	class:folly::SocketAddress	signature:(const struct sockaddr* address)
setFromSockaddr	.\SocketAddress.cpp	/^void SocketAddress::setFromSockaddr(const struct sockaddr* address,$/;"	f	class:folly::SocketAddress	signature:(const struct sockaddr* address, socklen_t addrlen)
setFromSockaddr	.\SocketAddress.cpp	/^void SocketAddress::setFromSockaddr(const struct sockaddr_in* address) {$/;"	f	class:folly::SocketAddress	signature:(const struct sockaddr_in* address)
setFromSockaddr	.\SocketAddress.cpp	/^void SocketAddress::setFromSockaddr(const struct sockaddr_in6* address) {$/;"	f	class:folly::SocketAddress	signature:(const struct sockaddr_in6* address)
setFromSockaddr	.\SocketAddress.cpp	/^void SocketAddress::setFromSockaddr(const struct sockaddr_un* address,$/;"	f	class:folly::SocketAddress	signature:(const struct sockaddr_un* address, socklen_t addrlen)
setFromSockaddr	.\SocketAddress.h	/^  void setFromSockaddr(const struct sockaddr* address);$/;"	p	class:folly::SocketAddress	access:public	signature:(const struct sockaddr* address)
setFromSockaddr	.\SocketAddress.h	/^  void setFromSockaddr(const struct sockaddr* address,$/;"	p	class:folly::SocketAddress	access:public	signature:(const struct sockaddr* address, socklen_t addrlen)
setFromSockaddr	.\SocketAddress.h	/^  void setFromSockaddr(const struct sockaddr_in* address);$/;"	p	class:folly::SocketAddress	access:public	signature:(const struct sockaddr_in* address)
setFromSockaddr	.\SocketAddress.h	/^  void setFromSockaddr(const struct sockaddr_in6* address);$/;"	p	class:folly::SocketAddress	access:public	signature:(const struct sockaddr_in6* address)
setFromSockaddr	.\SocketAddress.h	/^  void setFromSockaddr(const struct sockaddr_un* address,$/;"	p	class:folly::SocketAddress	access:public	signature:(const struct sockaddr_un* address, socklen_t addrlen)
setFromSocket	.\SocketAddress.cpp	/^void SocketAddress::setFromSocket(int socket,$/;"	f	class:folly::SocketAddress	signature:(int socket, int (*fn)(int, sockaddr*, socklen_t*))
setFromSocket	.\SocketAddress.h	/^  void setFromSocket(int socket, int (*fn)(int, struct sockaddr*, socklen_t*));$/;"	p	class:folly::SocketAddress	access:private	signature:(int socket, int (*fn)(int, struct sockaddr*, socklen_t*))
setFullyLinked	.\ConcurrentSkipList-inl.h	/^  void setFullyLinked() {$/;"	f	class:folly::detail::SkipListNode	access:public	signature:()
setGrow	.\MemoryMapping.h	/^    Options& setGrow(bool v) { grow = v; return *this; }$/;"	f	struct:folly::MemoryMapping::Options	access:public	signature:(bool v)
setHigh8Bits	.\detail\FingerprintPolynomial.h	/^  void setHigh8Bits(uint8_t val) {$/;"	f	class:folly::detail::FingerprintPolynomial	access:public	signature:(uint8_t val)
setInsert	.\test\ConcurrentSkipListBenchmark.cpp	/^  inline void setInsert(int idx, ValueType val) {$/;"	f	class:__anon113::ConcurrentAccessData	access:public	signature:(int idx, ValueType val)
setIsHeadNode	.\ConcurrentSkipList-inl.h	/^  void setIsHeadNode() {$/;"	f	class:folly::detail::SkipListNode	access:public	signature:()
setLoadAvgMsec	.\io\async\EventBase.cpp	/^void EventBase::setLoadAvgMsec(uint32_t ms) {$/;"	f	class:folly::EventBase	signature:(uint32_t ms)
setLoadAvgMsec	.\io\async\EventBase.h	/^  void setLoadAvgMsec(uint32_t ms);$/;"	p	class:folly::EventBase	access:public	signature:(uint32_t ms)
setMarkedForRemoval	.\ConcurrentSkipList-inl.h	/^  void setMarkedForRemoval() {$/;"	f	class:folly::detail::SkipListNode	access:public	signature:()
setMaxLatency	.\io\async\EventBase.h	/^  void setMaxLatency(int64_t maxLatency, const Cob& maxLatencyCob) {$/;"	f	class:folly::EventBase	access:public	signature:(int64_t maxLatency, const Cob& maxLatencyCob)
setMaxQueueSize	.\io\async\NotificationQueue.h	/^  void setMaxQueueSize(uint32_t max) {$/;"	f	class:folly::NotificationQueue	access:public	signature:(uint32_t max)
setMaxReadAtOnce	.\io\async\EventBase.cpp	/^void EventBase::setMaxReadAtOnce(uint32_t maxAtOnce) {$/;"	f	class:folly::EventBase	signature:(uint32_t maxAtOnce)
setMaxReadAtOnce	.\io\async\EventBase.h	/^  void setMaxReadAtOnce(uint32_t maxAtOnce);$/;"	p	class:folly::EventBase	access:public	signature:(uint32_t maxAtOnce)
setMaxReadAtOnce	.\io\async\NotificationQueue.h	/^    void setMaxReadAtOnce(uint32_t maxAtOnce) {$/;"	f	class:folly::NotificationQueue::Consumer	access:public	signature:(uint32_t maxAtOnce)
setMaxSize	.\EvictingCacheMap.h	/^  void setMaxSize(size_t maxSize) {$/;"	f	class:folly::EvictingCacheMap	access:public	signature:(size_t maxSize)
setName	.\io\async\EventBase.cpp	/^void EventBase::setName(const std::string& name) {$/;"	f	class:folly::EventBase	signature:(const std::string& name)
setName	.\io\async\EventBase.h	/^  void setName(const std::string& name);$/;"	p	class:folly::EventBase	access:public	signature:(const std::string& name)
setNextIntKey	.\FormatArg.h	/^  void setNextIntKey(int val) {$/;"	f	struct:folly::FormatArg	access:public	signature:(int val)
setNextKey	.\FormatArg.h	/^  void setNextKey(StringPiece val) {$/;"	f	struct:folly::FormatArg	access:public	signature:(StringPiece val)
setNotificationCallback	.\experimental\io\AsyncIO.h	/^  void setNotificationCallback(NotificationCallback cb) { cb_ = std::move(cb); }$/;"	f	class:folly::AsyncIOOp	access:public	signature:(NotificationCallback cb)
setNumThreads	.\experimental\wangle\concurrent\ThreadPoolExecutor.cpp	/^void ThreadPoolExecutor::setNumThreads(size_t n) {$/;"	f	class:folly::wangle::ThreadPoolExecutor	signature:(size_t n)
setNumThreads	.\experimental\wangle\concurrent\ThreadPoolExecutor.h	/^  void setNumThreads(size_t numThreads);$/;"	p	class:folly::wangle::ThreadPoolExecutor	access:public	signature:(size_t numThreads)
setNumbers	.\io\test\NetworkBenchmark.cpp	/^void setNumbers(size_t size, size_t num) {$/;"	f	signature:(size_t size, size_t num)
setObserver	.\io\async\EventBase.h	/^  void setObserver($/;"	f	class:folly::EventBase	access:public	signature:( const std::shared_ptr<EventBaseObserver>& observer)
setPageSize	.\MemoryMapping.h	/^    Options& setPageSize(off_t v) { pageSize = v; return *this; }$/;"	f	struct:folly::MemoryMapping::Options	access:public	signature:(off_t v)
setPort	.\SocketAddress.cpp	/^void SocketAddress::setPort(uint16_t port) {$/;"	f	class:folly::SocketAddress	signature:(uint16_t port)
setPort	.\SocketAddress.h	/^  void setPort(uint16_t port);$/;"	p	class:folly::SocketAddress	access:public	signature:(uint16_t port)
setPort	.\Uri.h	/^  void setPort(uint16_t port) {port_ = port;}$/;"	f	class:folly::Uri	access:public	signature:(uint16_t port)
setPrefault	.\MemoryMapping.h	/^    Options& setPrefault(bool v) { prefault = v; return *this; }$/;"	f	struct:folly::MemoryMapping::Options	access:public	signature:(bool v)
setPruneHook	.\EvictingCacheMap.h	/^  void setPruneHook(PruneHookCall pruneHook) {$/;"	f	class:folly::EvictingCacheMap	access:public	signature:(PruneHookCall pruneHook)
setReadable	.\MemoryMapping.h	/^    Options& setReadable(bool v) { readable = v; return *this; }$/;"	f	struct:folly::MemoryMapping::Options	access:public	signature:(bool v)
setScheduled	.\io\async\HHWheelTimer.cpp	/^void HHWheelTimer::Callback::setScheduled(HHWheelTimer* wheel,$/;"	f	class:folly::HHWheelTimer::Callback	signature:(HHWheelTimer* wheel, std::chrono::milliseconds timeout)
setScheduled	.\io\async\HHWheelTimer.h	/^    void setScheduled(HHWheelTimer* wheel,$/;"	p	class:folly::HHWheelTimer::Callback	access:private	signature:(HHWheelTimer* wheel, std::chrono::milliseconds)
setScopeId	.\IPAddressV6.h	/^  void setScopeId(uint16_t scope) {$/;"	f	class:folly::IPAddressV6	access:public	signature:(uint16_t scope)
setShared	.\MemoryMapping.h	/^    Options& setShared(bool v) { shared = v; return *this; }$/;"	f	struct:folly::MemoryMapping::Options	access:public	signature:(bool v)
setSharedInfo	.\io\IOBuf.h	/^  inline void setSharedInfo(SharedInfo* info) {$/;"	f	class:folly::IOBuf	access:private	signature:(SharedInfo* info)
setShutdownNotice	.\LifoSem.h	/^  void setShutdownNotice() { next = uint32_t(-1); }$/;"	f	struct:folly::detail::LifoSemRawNode	access:public	signature:()
setSize	.\small_vector.h	/^    void setSize(std::size_t sz) {$/;"	f	struct:folly::detail::IntegralSizePolicy	access:protected	signature:(std::size_t sz)
setSkip	.\ConcurrentSkipList-inl.h	/^  void setSkip(uint8_t h, SkipListNode* next) {$/;"	f	class:folly::detail::SkipListNode	access:public	signature:(uint8_t h, SkipListNode* next)
setThreadName	.\ThreadName.h	/^inline bool setThreadName(StringPiece name) {$/;"	f	namespace:folly	signature:(StringPiece name)
setThreadName	.\ThreadName.h	/^inline bool setThreadName(pthread_t id, StringPiece name) {$/;"	f	namespace:folly	signature:(pthread_t id, StringPiece name)
setTimeInterval	.\io\async\EventBase.cpp	/^void EventBase::SmoothLoopTime::setTimeInterval(uint64_t timeInterval) {$/;"	f	class:folly::EventBase::SmoothLoopTime	signature:(uint64_t timeInterval)
setTimeInterval	.\io\async\EventBase.h	/^    void setTimeInterval(uint64_t timeInterval);$/;"	p	class:folly::EventBase::SmoothLoopTime	access:public	signature:(uint64_t timeInterval)
setVal	.\io\IOBuf.h	/^  void setVal() {$/;"	f	class:folly::IOBuf::Iterator	access:private	signature:()
setValue	.\experimental\EliasFanoCoding.h	/^  ValueType setValue() {$/;"	f	class:folly::compression::detail::UpperBitsReader	access:private	signature:()
setValue	.\wangle\Promise-inl.h	/^void Promise<T>::setValue() {$/;"	f	class:folly::wangle::Promise	signature:()
setValue	.\wangle\Promise-inl.h	/^void Promise<T>::setValue(M&& v) {$/;"	f	class:folly::wangle::Promise	signature:(M&& v)
setValue	.\wangle\Promise.h	/^  void setValue();$/;"	p	class:folly::wangle::Promise	access:public	signature:()
setValue	.\wangle\Promise.h	/^  void setValue(M&& value);$/;"	p	class:folly::wangle::Promise	access:public	signature:(M&& value)
setWritable	.\MemoryMapping.h	/^    Options& setWritable(bool v) { writable = v; return *this; }$/;"	f	struct:folly::MemoryMapping::Options	access:public	signature:(bool v)
sets_	.\test\ConcurrentSkipListBenchmark.cpp	/^  std::vector<SetType> sets_;$/;"	m	class:__anon113::ConcurrentAccessData	file:	access:private
setup	.\test\MemoryIdlerTest.cpp	/^  static std::shared_ptr<StrictMock<MockClock>> setup() {$/;"	f	struct:MockClock	access:public	signature:()
setupBenchmark	.\test\ForeachTest.cpp	/^void setupBenchmark(int iters) {$/;"	f	signature:(int iters)
sfinae	.\Traits.h	/^  template <unsigned long long> struct sfinae {};$/;"	s	class:folly::is_complete	access:private
shared	.\MemoryMapping.h	/^    bool shared = true;$/;"	m	struct:folly::MemoryMapping::Options	access:public
shared	.\detail\CacheLocality.h	/^  static const AccessSpreader& shared(size_t numStripes) {$/;"	f	struct:folly::detail::AccessSpreader	access:public	signature:(size_t numStripes)
shared	.\io\IOBuf.cpp	/^  SharedInfo shared;$/;"	m	struct:folly::IOBuf::HeapFullStorage	file:	access:public
sharedInfo	.\io\IOBuf.h	/^  inline SharedInfo* sharedInfo() const {$/;"	f	class:folly::IOBuf	access:private	signature:() const
sharedInstance	.\detail\CacheLocality.cpp	/^AccessSpreaderArray<std::atomic,128>::sharedInstance = {};$/;"	m	class:folly::detail::AccessSpreaderArray	file:
sharedInstance	.\detail\CacheLocality.h	/^  static AccessSpreaderArray<Atom,kMaxStripe> sharedInstance;$/;"	m	struct:folly::detail::AccessSpreaderArray	access:private
sharedInstance	.\test\DeterministicSchedule.cpp	/^AccessSpreaderArray<test::DeterministicAtomic,128>::sharedInstance = {};$/;"	m	class:folly::detail::AccessSpreaderArray	file:
shared_	.\io\test\IOBufTest.cpp	/^  bool shared_;$/;"	m	class:MoveToFbStringTest	file:	access:protected
shared_ptr	.\Traits.h	/^  class shared_ptr;$/;"	x
shared_ptr	.\Traits.h	/^FOLLY_ASSUME_FBVECTOR_COMPATIBLE_1(boost::shared_ptr);$/;"	v
shared_ptr	.\Traits.h	/^FOLLY_ASSUME_FBVECTOR_COMPATIBLE_1(std::shared_ptr);$/;"	v
shared_ptr	.\Traits.h	/^template <class T> class shared_ptr;$/;"	x
shared_ptr_test	.\test\ArenaSmartPtrTest.cpp	/^void shared_ptr_test(Allocator& allocator) {$/;"	f	signature:(Allocator& allocator)
shd_int64	.\test\ThreadCachedIntTest.cpp	/^ShardedAtomicInt shd_int64;$/;"	v
shiftPointer	.\small_vector.h	/^  inline void* shiftPointer(void* p, size_t sizeBytes) {$/;"	f	namespace:folly::detail	signature:(void* p, size_t sizeBytes)
shlor32	.\Fingerprint.h	/^  uint32_t shlor32(uint32_t v);$/;"	p	class:folly::Fingerprint	access:private	signature:(uint32_t v)
shlor32	.\Fingerprint.h	/^inline uint32_t Fingerprint<128>::shlor32(uint32_t v) {$/;"	f	class:folly::Fingerprint	signature:(uint32_t v)
shlor32	.\Fingerprint.h	/^inline uint32_t Fingerprint<64>::shlor32(uint32_t v) {$/;"	f	class:folly::Fingerprint	signature:(uint32_t v)
shlor32	.\Fingerprint.h	/^inline uint32_t Fingerprint<96>::shlor32(uint32_t v) {$/;"	f	class:folly::Fingerprint	signature:(uint32_t v)
shlor64	.\Fingerprint.h	/^  uint64_t shlor64(uint64_t v);$/;"	p	class:folly::Fingerprint	access:private	signature:(uint64_t v)
shlor64	.\Fingerprint.h	/^inline uint64_t Fingerprint<128>::shlor64(uint64_t v) {$/;"	f	class:folly::Fingerprint	signature:(uint64_t v)
shlor64	.\Fingerprint.h	/^inline uint64_t Fingerprint<64>::shlor64(uint64_t v) {$/;"	f	class:folly::Fingerprint	signature:(uint64_t v)
shlor64	.\Fingerprint.h	/^inline uint64_t Fingerprint<96>::shlor64(uint64_t v) {$/;"	f	class:folly::Fingerprint	signature:(uint64_t v)
shlor8	.\Fingerprint.h	/^  uint8_t  shlor8(uint8_t v);$/;"	p	class:folly::Fingerprint	access:private	signature:(uint8_t v)
shlor8	.\Fingerprint.h	/^inline uint8_t Fingerprint<128>::shlor8(uint8_t v) {$/;"	f	class:folly::Fingerprint	signature:(uint8_t v)
shlor8	.\Fingerprint.h	/^inline uint8_t Fingerprint<64>::shlor8(uint8_t v) {$/;"	f	class:folly::Fingerprint	signature:(uint8_t v)
shlor8	.\Fingerprint.h	/^inline uint8_t Fingerprint<96>::shlor8(uint8_t v) {$/;"	f	class:folly::Fingerprint	signature:(uint8_t v)
short_append	.\test\FBStringTestBenchmarks.cpp.h	/^void BENCHFUN(short_append)(int iters, int arg) {$/;"	f	signature:(int iters, int arg)
shouldRun	.\experimental\wangle\concurrent\IOThreadPoolExecutor.h	/^    std::atomic<bool> shouldRun;$/;"	m	struct:folly::wangle::IOThreadPoolExecutor::IOThread	access:public
shrink_to_fit	.\small_vector.h	/^  void shrink_to_fit() {$/;"	f	class:folly::small_vector	access:public	signature:()
shrink_to_fit	.\sorted_vector_types.h	/^  void shrink_to_fit()          { m_.cont_.shrink_to_fit();   }$/;"	f	class:folly::sorted_vector_map	access:public	signature:()
shrink_to_fit	.\sorted_vector_types.h	/^  void shrink_to_fit()          { m_.cont_.shrink_to_fit();   }$/;"	f	class:folly::sorted_vector_set	access:public	signature:()
shufflePrefix	.\test\DeterministicSchedule.cpp	/^  void shufflePrefix() {$/;"	f	struct:folly::test::UniformSubset	file:	access:private	signature:()
shutdown	.\LifoSem.h	/^  void shutdown() {$/;"	f	struct:folly::detail::LifoSemBase	access:public	signature:()
shutdownNoInt	.\FileUtil.cpp	/^int shutdownNoInt(int fd, int how) {$/;"	f	namespace:folly	signature:(int fd, int how)
shutdownNoInt	.\FileUtil.h	/^int shutdownNoInt(int fd, int how);$/;"	p	namespace:folly	signature:(int fd, int how)
sign	.\FormatArg.h	/^  Sign sign;$/;"	m	struct:folly::FormatArg	access:public
signalEvent	.\io\async\NotificationQueue.h	/^  inline void signalEvent(size_t numAdded = 1) const {$/;"	f	class:folly::NotificationQueue	access:private	signature:(size_t numAdded = 1) const
signalHandler	.\experimental\symbolizer\SignalHandler.cpp	/^void signalHandler(int signum, siginfo_t* info, void* uctx) {$/;"	f	namespace:folly::symbolizer::__anon36	signature:(int signum, siginfo_t* info, void* uctx)
simpleFFS	.\test\BitIteratorTest.cpp	/^BitIterator<BaseIter> simpleFFS(BitIterator<BaseIter> begin,$/;"	f	namespace:__anon110	signature:(BitIterator<BaseIter> begin, BitIterator<BaseIter> end)
simplifyPath	.\experimental\symbolizer\Dwarf.cpp	/^void simplifyPath(folly::StringPiece& sp) {$/;"	f	namespace:folly::symbolizer::__anon34	signature:(folly::StringPiece& sp)
singleUniqueValue_	.\stats\TimeseriesHistogram.h	/^  bool singleUniqueValue_;$/;"	m	class:folly::TimeseriesHistogram	access:private
singleton	.\experimental\Singleton.cpp	/^SingletonVault* SingletonVault::singleton() {$/;"	f	class:folly::SingletonVault	signature:()
singleton	.\experimental\Singleton.h	/^  static SingletonVault* singleton();$/;"	p	class:folly::SingletonVault	access:public	signature:()
singletons_	.\experimental\Singleton.h	/^                     detail::TypeDescriptorHasher> singletons_;$/;"	m	class:folly::SingletonVault	access:private
sink_	.\gen\Parallel-inl.h	/^  Sink sink_;$/;"	m	class:folly::gen::detail::Sub	access:private
size	.\AtomicBitSet.h	/^  constexpr size_t size() const {$/;"	f	class:folly::AtomicBitSet	access:public	signature:() const
size	.\AtomicHashArray.h	/^  size_t size() const {$/;"	f	class:folly::AtomicHashArray	access:public	signature:() const
size	.\AtomicHashMap-inl.h	/^size() const {$/;"	f	class:folly::AtomicHashMap	signature:() const
size	.\AtomicHashMap.h	/^  size_t size() const;$/;"	p	class:folly::AtomicHashMap	access:public	signature:() const
size	.\ConcurrentSkipList.h	/^  size_t size() const { return size_.load(std::memory_order_relaxed); }$/;"	f	class:folly::ConcurrentSkipList	access:private	signature:() const
size	.\ConcurrentSkipList.h	/^  size_t size() const { return sl_->size(); }$/;"	f	class:folly::ConcurrentSkipList::Accessor	access:public	signature:() const
size	.\EvictingCacheMap.h	/^  std::size_t size() const {$/;"	f	class:folly::EvictingCacheMap	access:public	signature:() const
size	.\Fingerprint.h	/^  static int size() {$/;"	f	class:folly::Fingerprint	access:public	signature:()
size	.\GroupVarint.h	/^  static size_t size(const uint32_t* p) {$/;"	f	class:folly::GroupVarint	access:public	signature:(const uint32_t* p)
size	.\GroupVarint.h	/^  static size_t size(const uint64_t* p) {$/;"	f	class:folly::GroupVarint	access:public	signature:(const uint64_t* p)
size	.\GroupVarint.h	/^  static size_t size(uint32_t a, uint32_t b, uint32_t c, uint32_t d) {$/;"	f	class:folly::GroupVarint	access:public	signature:(uint32_t a, uint32_t b, uint32_t c, uint32_t d)
size	.\GroupVarint.h	/^  static size_t size(uint64_t a, uint64_t b, uint64_t c, uint64_t d,$/;"	f	class:folly::GroupVarint	access:public	signature:(uint64_t a, uint64_t b, uint64_t c, uint64_t d, uint64_t e)
size	.\IndexedMemPool.h	/^    uint32_t size() const {$/;"	f	struct:folly::IndexedMemPool	access:private	signature:() const
size	.\Padded.h	/^  size_type size() const {$/;"	f	class:folly::Adaptor	access:public	signature:() const
size	.\Range.h	/^  size_type size() const {$/;"	f	class:folly::Range	access:public	signature:() const
size	.\SmallLocks.h	/^  constexpr size_t size() const { return N; }$/;"	f	struct:folly::SpinLockArray	access:public	signature:() const
size	.\detail\FingerprintPolynomial.h	/^  static int size() {$/;"	f	class:folly::detail::FingerprintPolynomial	access:public	signature:()
size	.\dynamic-inl.h	/^inline std::size_t dynamic::size() const {$/;"	f	class:folly::dynamic	signature:() const
size	.\dynamic.h	/^  std::size_t size() const;$/;"	p	struct:folly::dynamic	access:public	signature:() const
size	.\experimental\EliasFanoCoding.h	/^  size_t size = 0;$/;"	m	struct:folly::compression::EliasFanoCompressedList	access:public
size	.\experimental\EliasFanoCoding.h	/^  size_t size() const { return list_.size; }$/;"	f	class:folly::compression::EliasFanoReader	access:public	signature:() const
size	.\experimental\io\HugePages.h	/^  size_t size = 0;$/;"	m	struct:folly::HugePageSize	access:public
size	.\experimental\io\test\AsyncIOTest.cpp	/^  size_t size;$/;"	m	struct:__anon32::TestSpec	file:	access:public
size	.\experimental\symbolizer\Dwarf.cpp	/^size_t Dwarf::Path::size() const {$/;"	f	class:folly::symbolizer::Dwarf::Path	signature:() const
size	.\experimental\symbolizer\Dwarf.h	/^    size_t size() const;$/;"	p	class:folly::symbolizer::Dwarf::Path	access:public	signature:() const
size	.\experimental\wangle\concurrent\BlockingQueue.h	/^  virtual size_t size() = 0;$/;"	p	class:folly::wangle::BlockingQueue	access:public	signature:()
size	.\experimental\wangle\concurrent\ThreadPoolExecutor.cpp	/^size_t ThreadPoolExecutor::StoppedThreadQueue::size() {$/;"	f	class:folly::wangle::ThreadPoolExecutor::StoppedThreadQueue	signature:()
size	.\io\TypedIOBuf.h	/^  uint32_t size() const { return length(); }$/;"	f	class:folly::TypedIOBuf	access:public	signature:() const
size	.\io\async\NotificationQueue.h	/^  int size() {$/;"	f	class:folly::NotificationQueue	access:public	signature:()
size	.\json.cpp	/^  std::size_t size() const {$/;"	f	struct:folly::json::__anon75::Input	access:public	signature:() const
size	.\small_vector.h	/^  size_type size()         const { return this->doSize(); }$/;"	f	class:folly::small_vector	access:public	signature:() const
size	.\sorted_vector_types.h	/^  size_type size() const        { return m_.cont_.size();     }$/;"	f	class:folly::sorted_vector_map	access:public	signature:() const
size	.\sorted_vector_types.h	/^  size_type size() const        { return m_.cont_.size();     }$/;"	f	class:folly::sorted_vector_set	access:public	signature:() const
size	.\test\FileUtilTest.cpp	/^  size_t size() const;$/;"	p	class:folly::test::IovecBuffers	file:	access:public	signature:() const
size	.\test\FileUtilTest.cpp	/^size_t IovecBuffers::size() const {$/;"	f	class:folly::test::IovecBuffers	signature:() const
size	.\test\stl_tests\StlVectorTest.cpp	/^  size_type size() { return size_; }$/;"	f	class:DataState	access:public	signature:()
sizeCtor	.\test\FBVectorTestBenchmarks.cpp.h	/^void BENCHFUN(sizeCtor)(int iters, int size) {$/;"	f	signature:(int iters, int size)
sizeGuess	.\ProducerConsumerQueue.h	/^  size_t sizeGuess() const {$/;"	f	struct:folly::ProducerConsumerQueue	access:public	signature:() const
sizeLimitTable_	.\ConcurrentSkipList-inl.h	/^  size_t sizeLimitTable_[kMaxHeight];$/;"	m	class:folly::detail::SkipListRandomHeight	access:private
sizeLimit_	.\Arena.h	/^  const size_t sizeLimit_;$/;"	m	class:folly::Arena	access:private
size_	.\ConcurrentSkipList.h	/^  std::atomic<size_t> size_;$/;"	m	class:folly::ConcurrentSkipList	access:private
size_	.\IndexedMemPool.h	/^  std::atomic<uint32_t> size_;$/;"	m	namespace:folly
size_	.\ProducerConsumerQueue.h	/^  const uint32_t size_;$/;"	m	struct:folly::ProducerConsumerQueue	access:private
size_	.\Range.cpp	/^  uint16_t size_;  \/\/ can't use uint8_t because it would overflow if all$/;"	m	class:folly::__anon83::FastByteSet	file:	access:private
size_	.\experimental\EliasFanoCoding.h	/^  size_t size_ = 0;$/;"	m	struct:folly::compression::EliasFanoEncoder	access:private
size_	.\io\test\CompressionTest.cpp	/^  const size_t size_;$/;"	m	class:folly::io::test::DataHolder	file:	access:protected
size_	.\small_vector.h	/^    SizeType size_;$/;"	m	struct:folly::detail::IntegralSizePolicy	access:private
size_	.\test\stl_tests\StlVectorTest.cpp	/^  size_type size_;$/;"	m	class:DataState	file:	access:private
size_t	.\ScopeGuard.h	/^  void* operator new(size_t) = delete;$/;"	m	class:folly::ScopeGuardImpl	access:private
size_t	.\ScopeGuard.h	/^  void* operator new(size_t) = delete;$/;"	m	class:folly::detail::ScopeGuardForNewException	access:private
size_type	.\AtomicHashArray.h	/^  typedef std::size_t         size_type;$/;"	t	class:folly::AtomicHashArray	access:public
size_type	.\AtomicHashMap.h	/^  typedef std::size_t         size_type;$/;"	t	class:folly::AtomicHashMap	access:public
size_type	.\ConcurrentSkipList.h	/^  typedef size_t size_type;$/;"	t	class:folly::ConcurrentSkipList::Accessor	access:public
size_type	.\FBVector.h	/^    typedef typename A::size_type size_type;$/;"	t	struct:folly::fbvector::Impl	access:public
size_type	.\FBVector.h	/^  typedef size_t                                      size_type;$/;"	t	class:folly::fbvector	access:public
size_type	.\Memory.h	/^  typedef size_t size_type;$/;"	t	class:folly::StlAllocator	access:public
size_type	.\Padded.h	/^  typedef typename Container::size_type size_type;$/;"	t	class:folly::Adaptor	access:public
size_type	.\Range.h	/^  typedef std::size_t size_type;$/;"	t	class:folly::Range	access:public
size_type	.\io\TypedIOBuf.h	/^  typedef uint32_t size_type;$/;"	t	class:folly::TypedIOBuf	access:public
size_type	.\small_vector.h	/^  typedef std::size_t        size_type;$/;"	t	class:folly::small_vector	access:public
size_type	.\sorted_vector_types.h	/^  typedef typename ContainerT::size_type              size_type;$/;"	t	class:folly::sorted_vector_map	access:public
size_type	.\sorted_vector_types.h	/^  typedef typename ContainerT::size_type              size_type;$/;"	t	class:folly::sorted_vector_set	access:public
size_type	.\test\AtomicHashArrayTest.cpp	/^  typedef size_t size_type;$/;"	t	class:MmapAllocator	file:	access:public
size_type	.\test\stl_tests\StlVectorTest.cpp	/^  typedef typename Vector::size_type size_type;$/;"	t	class:DataState	file:	access:private
size_type	.\test\stl_tests\StlVectorTest.cpp	/^  typedef typename std::allocator<T>::size_type size_type;$/;"	t	struct:Alloc	file:	access:public
sizeof	.\AtomicStruct.h	/^  static_assert(sizeof(T) <= sizeof(Raw),$/;"	p	class:folly::AtomicStruct	access:private	signature:(T)
sizeof	.\Conv.cpp	/^static_assert(sizeof(unsigned long long) >= 8,$/;"	p	namespace:folly::detail	file:	signature:(unsigned long long)
sizeof	.\Conv.cpp	/^static_assert(sizeof(unsigned long) >= 4,$/;"	p	namespace:folly::detail	file:	signature:(unsigned long)
sizeof	.\LifoSem.h	/^  static_assert(sizeof(Handoff) <= sizeof(LifoSemRawNode<Atom>::raw),$/;"	p	struct:folly::detail::LifoSemNode	access:public	signature:(Handoff)
sizeof	.\PackedSyncPtr.h	/^static_assert(sizeof(PackedSyncPtr<void>) == 8,$/;"	p	namespace:folly	signature:(PackedSyncPtr<void>)
sizeof	.\SmallLocks.h	/^                  sizeof(IntType) == 8,$/;"	m	struct:folly::PicoSpinLock	access:public
sizeof	.\SmallLocks.h	/^                sizeof(T) <= alignof(MaxAlign),$/;"	p	struct:folly::SpinLockArray	access:private	signature:(T)
sizeof	.\dynamic-inl.h	/^  static_assert(sizeof(ObjectImpl) <= sizeof(Data::objectBuffer),$/;"	p	struct:folly::dynamic::GetAddrImpl	access:public	signature:(ObjectImpl)
sizeof	.\experimental\Bits.h	/^  static_assert(sizeof(T) == sizeof(UnderlyingType), "Size mismatch");$/;"	m	struct:folly::Bits	access:public
sizeof	.\experimental\EventCount.h	/^  static_assert(sizeof(int) == 4, "bad platform");$/;"	p	class:folly::EventCount	access:private	signature:(int)
sizeof	.\experimental\EventCount.h	/^  static_assert(sizeof(uint32_t) == 4, "bad platform");$/;"	p	class:folly::EventCount	access:private	signature:(uint32_t)
sizeof	.\experimental\EventCount.h	/^  static_assert(sizeof(uint64_t) == 8, "bad platform");$/;"	p	class:folly::EventCount	access:private	signature:(uint64_t)
sizeof	.\io\IOBuf.cpp	/^  static_assert(sizeof(HeapStorage) <= 64,$/;"	p	struct:folly::IOBuf::HeapFullStorage	file:	access:public	signature:(HeapStorage)
sizeof	.\io\RecordIO-inl.h	/^              sizeof(Header), "invalid header layout");$/;"	p	namespace:folly::recordio_helpers::detail	signature:(Header)
sizeof	.\test\OptionalTest.cpp	/^static_assert(sizeof(Optional<NoDefault>) == 4, "");$/;"	p	namespace:folly	file:	signature:(Optional<NoDefault>)
sizeof	.\test\OptionalTest.cpp	/^static_assert(sizeof(Optional<char>) == 2, "");$/;"	p	namespace:folly	file:	signature:(Optional<char>)
sizeof	.\test\OptionalTest.cpp	/^static_assert(sizeof(Optional<char>) == sizeof(boost::optional<char>), "");$/;"	m	namespace:folly	file:
sizeof	.\test\OptionalTest.cpp	/^static_assert(sizeof(Optional<double>) == sizeof(boost::optional<double>), "");$/;"	m	namespace:folly	file:
sizeof	.\test\OptionalTest.cpp	/^static_assert(sizeof(Optional<int>) == 8, "");$/;"	p	namespace:folly	file:	signature:(Optional<int>)
sizeof	.\test\OptionalTest.cpp	/^static_assert(sizeof(Optional<int>) == sizeof(boost::optional<int>), "");$/;"	m	namespace:folly	file:
sizeof	.\test\OptionalTest.cpp	/^static_assert(sizeof(Optional<short>) == sizeof(boost::optional<short>), "");$/;"	m	namespace:folly	file:
sizeof	.\test\PackedSyncPtrTest.cpp	/^static_assert(sizeof(ignore) == 9, "PackedSyncPtr wasn't packable");$/;"	p	namespace:__anon126	file:	signature:(ignore)
sizeof	.\test\SmallLocksTest.cpp	/^static_assert(sizeof(ignore1) == 3, "Size check failed");$/;"	p	namespace:__anon131	file:	signature:(ignore1)
sizeof	.\test\SmallLocksTest.cpp	/^static_assert(sizeof(ignore2) == 6, "Size check failed");$/;"	p	namespace:__anon131	file:	signature:(ignore2)
sizeof	.\test\small_vector_test.cpp	/^                10 * sizeof(int) + sizeof(std::size_t),$/;"	v
sizeof	.\test\small_vector_test.cpp	/^static_assert(sizeof(small_vector<int16_t,4,uint16_t>) == 10,$/;"	p	file:	signature:(small_vector<int16_t,4,uint16_t>)
sizeof	.\test\small_vector_test.cpp	/^static_assert(sizeof(small_vector<int32_t,1,uint16_t>) ==$/;"	p	file:	signature:(small_vector<int32_t,1,uint16_t>)
sizeof	.\test\small_vector_test.cpp	/^static_assert(sizeof(small_vector<int32_t,1,uint32_t>) ==$/;"	p	file:	signature:(small_vector<int32_t,1,uint32_t>)
sizeof	.\test\small_vector_test.cpp	/^static_assert(sizeof(small_vector<int32_t,1,uint8_t>) ==$/;"	p	file:	signature:(small_vector<int32_t,1,uint8_t>)
sizeof	.\test\small_vector_test.cpp	/^static_assert(sizeof(small_vector<int32_t,2>) == 16,$/;"	p	file:	signature:(small_vector<int32_t,2>)
skip	.\ConcurrentSkipList-inl.h	/^  inline SkipListNode* skip(int layer) const {$/;"	f	class:folly::detail::SkipListNode	access:public	signature:(int layer) const
skip	.\experimental\EliasFanoCoding.h	/^  ValueType skip(size_t n) {$/;"	f	class:folly::compression::detail::UpperBitsReader	access:public	signature:(size_t n)
skip	.\experimental\EliasFanoCoding.h	/^  bool skip(size_t n) {$/;"	f	class:folly::compression::EliasFanoReader	access:public	signature:(size_t n)
skip	.\gen\Base-inl.h	/^inline detail::Skip skip(size_t count) {$/;"	f	namespace:folly::gen	signature:(size_t count)
skip	.\io\Cursor.h	/^  void skip(size_t len) {$/;"	f	class:folly::io::detail::CursorBase	access:public	signature:(size_t len)
skipAtMost	.\io\Cursor.h	/^  size_t skipAtMost(size_t len) {$/;"	f	class:folly::io::detail::CursorBase	access:public	signature:(size_t len)
skipDigits	.\json.cpp	/^  StringPiece skipDigits() {$/;"	f	struct:folly::json::__anon75::Input	access:public	signature:()
skipListErase	.\test\ConcurrentSkipListBenchmark.cpp	/^  inline void skipListErase(int idx, ValueType val) {$/;"	f	class:__anon113::ConcurrentAccessData	access:public	signature:(int idx, ValueType val)
skipListFind	.\test\ConcurrentSkipListBenchmark.cpp	/^  inline bool skipListFind(int idx, ValueType val) {$/;"	f	class:__anon113::ConcurrentAccessData	access:public	signature:(int idx, ValueType val)
skipListInsert	.\test\ConcurrentSkipListBenchmark.cpp	/^  inline void skipListInsert(int idx, ValueType val) {$/;"	f	class:__anon113::ConcurrentAccessData	access:public	signature:(int idx, ValueType val)
skipList_	.\test\ConcurrentSkipListBenchmark.cpp	/^  SkipListType::Accessor skipList_;$/;"	m	class:__anon113::ConcurrentAccessData	file:	access:private
skipMinusAndDigits	.\json.cpp	/^  StringPiece skipMinusAndDigits() {$/;"	f	struct:folly::json::__anon75::Input	access:public	signature:()
skipNS	.\experimental\symbolizer\Symbolizer.cpp	/^void skipNS(StringPiece& sp) {$/;"	f	namespace:folly::symbolizer::__anon40	signature:(StringPiece& sp)
skipPadding	.\experimental\symbolizer\Dwarf.cpp	/^void skipPadding(folly::StringPiece& sp, const char* start, size_t alignment) {$/;"	f	namespace:folly::symbolizer::__anon34	signature:(folly::StringPiece& sp, const char* start, size_t alignment)
skipPointers	.\experimental\EliasFanoCoding.h	/^  folly::ByteRange skipPointers;$/;"	m	struct:folly::compression::EliasFanoCompressedList	access:public
skipPointersSize_	.\experimental\EliasFanoCoding.h	/^  size_t skipPointersSize_ = 0;$/;"	m	struct:folly::compression::EliasFanoEncoder	access:private
skipPointers_	.\experimental\EliasFanoCoding.h	/^  SkipValueType* skipPointers_ = nullptr;$/;"	m	struct:folly::compression::EliasFanoEncoder	access:private
skipPointers_	.\experimental\EliasFanoCoding.h	/^  const unsigned char* const skipPointers_;$/;"	m	class:folly::compression::detail::UpperBitsReader	access:private
skipPrefix	.\experimental\io\FsUtil.cpp	/^bool skipPrefix(const path& pth, const path& prefix, path::const_iterator& it) {$/;"	f	namespace:folly::fs::__anon29	signature:(const path& pth, const path& prefix, path::const_iterator& it)
skipQuantum	.\experimental\EliasFanoCoding.h	/^  static constexpr size_t skipQuantum = kSkipQuantum;$/;"	m	struct:folly::compression::EliasFanoEncoder	access:public
skipTo	.\experimental\EliasFanoCoding.h	/^  bool skipTo(ValueType value) {$/;"	f	class:folly::compression::EliasFanoReader	access:public	signature:(ValueType value)
skipToNext	.\experimental\EliasFanoCoding.h	/^  ValueType skipToNext(ValueType v) {$/;"	f	class:folly::compression::detail::UpperBitsReader	access:public	signature:(ValueType v)
skipWS	.\experimental\symbolizer\Symbolizer.cpp	/^void skipWS(StringPiece& sp) {$/;"	f	namespace:folly::symbolizer::__anon40	signature:(StringPiece& sp)
skipWhile	.\json.cpp	/^  StringPiece skipWhile(const Predicate& p) {$/;"	f	struct:folly::json::__anon75::Input	access:public	signature:(const Predicate& p)
skipWhitespace	.\String.cpp	/^StringPiece skipWhitespace(StringPiece sp) {$/;"	f	namespace:folly	signature:(StringPiece sp)
skipWhitespace	.\String.h	/^StringPiece skipWhitespace(StringPiece sp);$/;"	p	class:folly::UriEscapeMode	access:private	signature:(StringPiece sp)
skipWhitespace	.\json.cpp	/^  void skipWhitespace() {$/;"	f	struct:folly::json::__anon75::Input	access:public	signature:()
skip_	.\ConcurrentSkipList-inl.h	/^  std::atomic<SkipListNode*> skip_[0];$/;"	m	class:folly::detail::SkipListNode	access:private
skip_invalid_utf8	.\json.h	/^    bool skip_invalid_utf8;$/;"	m	struct:folly::json::serialization_opts	access:public
skiplist	.\ConcurrentSkipList.h	/^  SkipListType* skiplist() const { return sl_; }$/;"	f	class:folly::ConcurrentSkipList::Accessor	access:public	signature:() const
slHolder_	.\ConcurrentSkipList.h	/^  std::shared_ptr<SkipListType> slHolder_;$/;"	m	class:folly::ConcurrentSkipList::Accessor	access:private
sl_	.\ConcurrentSkipList.h	/^  SkipListType *sl_;$/;"	m	class:folly::ConcurrentSkipList::Accessor	access:private
sleepAndWork	.\gen\test\ParallelBenchmark.cpp	/^static auto sleepAndWork = [](int i) {$/;"	v	file:
sleepyWork	.\gen\test\ParallelBenchmark.cpp	/^static auto sleepyWork = [](int i) {$/;"	v	file:
sleepyWork	.\gen\test\ParallelTest.cpp	/^static auto sleepyWork = [](int i) {$/;"	v	file:
slot	.\IndexedMemPool.h	/^  Slot& slot(uint32_t idx) {$/;"	f	namespace:folly	signature:(uint32_t idx)
slot	.\IndexedMemPool.h	/^  const Slot& slot(uint32_t idx) const {$/;"	f	namespace:folly	signature:(uint32_t idx) const
slotIndex	.\IndexedMemPool.h	/^  size_t slotIndex(uint32_t idx) const {$/;"	f	namespace:folly	signature:(uint32_t idx) const
slots_	.\IndexedMemPool.h	/^  Slot* FOLLY_ALIGN_TO_AVOID_FALSE_SHARING slots_;$/;"	m	namespace:folly
slots_	.\MPMCQueue.h	/^    , slots_(nullptr)$/;"	p	class:folly::MPMCQueue	access:public	signature:(nullptr)
slots_	.\MPMCQueue.h	/^    , slots_(rhs.slots_)$/;"	p	class:folly::MPMCQueue	access:public	signature:(rhs.slots_)
slots_	.\MPMCQueue.h	/^  detail::SingleElementQueue<T,Atom>* slots_;$/;"	m	class:folly::MPMCQueue	access:private
slots_	.\experimental\symbolizer\ElfCache.h	/^  std::vector<std::shared_ptr<ElfFile>> slots_;$/;"	m	class:folly::symbolizer::SignalSafeElfCache	access:private
small	.\gen\test\ParallelBenchmark.cpp	/^auto small = from(v) | take(1 << 12);$/;"	v
smallInt	.\test\ConvTest.cpp	/^static size_t smallInt = 104;$/;"	v	file:
smallLines	.\gen\test\StringBenchmark.cpp	/^std::vector<std::string> smallLines;$/;"	m	namespace:__anon58	file:
small_vector	.\small_vector.h	/^  explicit small_vector() {}$/;"	f	class:folly::small_vector	access:public	signature:()
small_vector	.\small_vector.h	/^  explicit small_vector(Arg arg1, Arg arg2)  {$/;"	f	class:folly::small_vector	access:public	signature:(Arg arg1, Arg arg2)
small_vector	.\small_vector.h	/^  explicit small_vector(size_type n, value_type const& t = value_type()) {$/;"	f	class:folly::small_vector	access:public	signature:(size_type n, value_type const& t = value_type())
small_vector	.\small_vector.h	/^  small_vector(small_vector const& o) {$/;"	f	class:folly::small_vector	access:public	signature:(small_vector const& o)
small_vector	.\small_vector.h	/^  small_vector(small_vector&& o) {$/;"	f	class:folly::small_vector	access:public	signature:(small_vector&& o)
small_vector	.\small_vector.h	/^  small_vector(std::initializer_list<value_type> il) {$/;"	f	class:folly::small_vector	access:public	signature:(std::initializer_list<value_type> il)
small_vector	.\small_vector.h	/^class small_vector$/;"	c	namespace:folly	inherits:detail::small_vector_base::type
small_vector	.\small_vector.h	/^class small_vector;$/;"	x
small_vector_base	.\small_vector.h	/^  struct small_vector_base {$/;"	s	namespace:folly::detail
small_vector_policy	.\small_vector.h	/^namespace small_vector_policy {$/;"	n	namespace:folly
smul	.\io\TypedIOBuf.h	/^  static uint32_t smul(uint32_t n) {$/;"	f	class:folly::TypedIOBuf	access:private	signature:(uint32_t n)
snprintf	.\Portability.h	232;"	d
softReset	.\test\stl_tests\StlVectorTest.cpp	/^void softReset(int ticks = -1) {$/;"	f	signature:(int ticks = -1)
someFuture	.\wangle\test\Thens.h	/^Future<T> someFuture() {$/;"	f	signature:()
someString	.\test\ConvTest.cpp	/^static char someString[] = "this is some nice string";$/;"	v	file:
some_iterator	.\DynamicConverter.h	/^  typedef std::reverse_iterator<T*> some_iterator;$/;"	t	struct:folly::dynamicconverter_detail::class_is_container	access:public
sort_keys	.\json.h	/^    bool sort_keys;$/;"	m	struct:folly::json::serialization_opts	access:public
sorted_vector_map	.\sorted_vector_types.h	/^    friend class sorted_vector_map;$/;"	x
sorted_vector_map	.\sorted_vector_types.h	/^  explicit sorted_vector_map($/;"	f	class:folly::sorted_vector_map	access:public	signature:( InputIterator first, InputIterator last, const Compare& comp = Compare(), const Allocator& alloc = Allocator())
sorted_vector_map	.\sorted_vector_types.h	/^  explicit sorted_vector_map($/;"	f	class:folly::sorted_vector_map	access:public	signature:( std::initializer_list<value_type> list, const Compare& comp = Compare(), const Allocator& alloc = Allocator())
sorted_vector_map	.\sorted_vector_types.h	/^  explicit sorted_vector_map(const Compare& comp = Compare(),$/;"	f	class:folly::sorted_vector_map	access:public	signature:(const Compare& comp = Compare(), const Allocator& alloc = Allocator())
sorted_vector_map	.\sorted_vector_types.h	/^class sorted_vector_map$/;"	c	namespace:folly	inherits:boost::totally_ordered1
sorted_vector_set	.\sorted_vector_types.h	/^  explicit sorted_vector_set($/;"	f	class:folly::sorted_vector_set	access:public	signature:( InputIterator first, InputIterator last, const Compare& comp = Compare(), const Allocator& alloc = Allocator())
sorted_vector_set	.\sorted_vector_types.h	/^  explicit sorted_vector_set($/;"	f	class:folly::sorted_vector_set	access:public	signature:( std::initializer_list<value_type> list, const Compare& comp = Compare(), const Allocator& alloc = Allocator())
sorted_vector_set	.\sorted_vector_types.h	/^  explicit sorted_vector_set(const Compare& comp = Compare(),$/;"	f	class:folly::sorted_vector_set	access:public	signature:(const Compare& comp = Compare(), const Allocator& alloc = Allocator())
sorted_vector_set	.\sorted_vector_types.h	/^class sorted_vector_set$/;"	c	namespace:folly	inherits:boost::totally_ordered1
source_	.\gen\Base-inl.h	/^    Source source_;$/;"	m	class:folly::gen::detail::Batch::Generator	access:private
source_	.\gen\Base-inl.h	/^    Source source_;$/;"	m	class:folly::gen::detail::Concat::Generator	access:private
source_	.\gen\Base-inl.h	/^    Source source_;$/;"	m	class:folly::gen::detail::Cycle::Generator	access:private
source_	.\gen\Base-inl.h	/^    Source source_;$/;"	m	class:folly::gen::detail::Dereference::Generator	access:private
source_	.\gen\Base-inl.h	/^    Source source_;$/;"	m	class:folly::gen::detail::Distinct::Generator	access:private
source_	.\gen\Base-inl.h	/^    Source source_;$/;"	m	class:folly::gen::detail::Filter::Generator	access:private
source_	.\gen\Base-inl.h	/^    Source source_;$/;"	m	class:folly::gen::detail::GuardImpl::Generator	access:private
source_	.\gen\Base-inl.h	/^    Source source_;$/;"	m	class:folly::gen::detail::Map::Generator	access:private
source_	.\gen\Base-inl.h	/^    Source source_;$/;"	m	class:folly::gen::detail::Order::Generator	access:private
source_	.\gen\Base-inl.h	/^    Source source_;$/;"	m	class:folly::gen::detail::RangeConcat::Generator	access:private
source_	.\gen\Base-inl.h	/^    Source source_;$/;"	m	class:folly::gen::detail::Sample::Generator	access:private
source_	.\gen\Base-inl.h	/^    Source source_;$/;"	m	class:folly::gen::detail::Skip::Generator	access:private
source_	.\gen\Base-inl.h	/^    Source source_;$/;"	m	class:folly::gen::detail::Stride::Generator	access:private
source_	.\gen\Base-inl.h	/^    Source source_;$/;"	m	class:folly::gen::detail::Take::Generator	access:private
source_	.\gen\Base-inl.h	/^    Source source_;$/;"	m	class:folly::gen::detail::Until::Generator	access:private
source_	.\gen\Base-inl.h	/^  Source source_;$/;"	m	class:folly::gen::detail::Yield	access:private
source_	.\gen\Combine-inl.h	/^    Source source_;$/;"	m	class:folly::gen::detail::Interleave::Generator	access:private
source_	.\gen\Combine-inl.h	/^    Source source_;$/;"	m	class:folly::gen::detail::Zip::Generator	access:private
source_	.\gen\Parallel-inl.h	/^    const Source source_;$/;"	m	class:folly::gen::detail::Parallel::Generator	access:private
source_	.\gen\ParallelMap-inl.h	/^    Source source_;$/;"	m	class:folly::gen::detail::PMap::Generator	access:private
source_	.\gen\String-inl.h	/^    Source source_;$/;"	m	class:folly::gen::detail::StringResplitter::Generator	access:private
source_	.\gen\String-inl.h	/^  StringPiece source_;$/;"	m	class:folly::gen::detail::SplitStringSource	access:private
sp	.\io\test\RecordIOTest.cpp	/^StringPiece sp(ByteRange br) { return StringPiece(br); }$/;"	f	namespace:folly::test::__anon73	signature:(ByteRange br)
spaceRemaining	.\AtomicHashMap-inl.h	/^spaceRemaining() const {$/;"	f	class:folly::AtomicHashMap	signature:() const
spaceRemaining	.\AtomicHashMap.h	/^  size_t spaceRemaining() const;$/;"	p	class:folly::AtomicHashMap	access:public	signature:() const
spacehog	.\test\stl_tests\StlVectorTest.cpp	/^  char spacehog[pad ? pad : 1];$/;"	m	struct:Data	file:	access:public
sparse_	.\Range.cpp	/^  uint8_t sparse_[256];$/;"	m	class:folly::__anon83::FastByteSet	file:	access:private
spawn	.\Subprocess.cpp	/^void Subprocess::spawn($/;"	f	class:folly::Subprocess	signature:( std::unique_ptr<const char*[]> argv, const char* executable, const Options& optionsIn, const std::vector<std::string>* env)
spawn	.\Subprocess.h	/^  void spawn($/;"	p	class:folly::Subprocess	access:private	signature:( std::unique_ptr<const char*[]> argv, const char* executable, const Options& options, const std::vector<std::string>* env)
spawnInternal	.\Subprocess.cpp	/^void Subprocess::spawnInternal($/;"	f	class:folly::Subprocess	signature:( std::unique_ptr<const char*[]> argv, const char* executable, Options& options, const std::vector<std::string>* env, int errFd)
spawnInternal	.\Subprocess.h	/^  void spawnInternal($/;"	p	class:folly::Subprocess	access:private	signature:( std::unique_ptr<const char*[]> argv, const char* executable, Options& options, const std::vector<std::string>* env, int errFd)
spec	.\test\FileUtilTest.cpp	/^  const std::deque<ssize_t> spec() const { return spec_; }$/;"	f	class:folly::test::__anon117::Reader	access:public	signature:() const
spec_	.\test\FileUtilTest.cpp	/^  std::deque<ssize_t> spec_;$/;"	m	class:folly::test::__anon117::Reader	file:	access:private
special_move_assignable	.\test\stl_tests\StlVectorTest.cpp	/^struct special_move_assignable$/;"	s	file:	inherits:is_move_constructibleAndAssignable
special_move_assignable	.\test\stl_tests\StlVectorTest.cpp	/^struct special_move_assignable<Data<f, pad>>$/;"	s	file:	inherits:std::integral_constant
spinCount	.\SmallLocks.h	/^    uint32_t spinCount;$/;"	m	class:folly::detail::Sleeper	access:private
spinLock_	.\ConcurrentSkipList-inl.h	/^  MicroSpinLock spinLock_;$/;"	m	class:folly::detail::SkipListNode	access:private
spinWaitForEarlyDelivery	.\Baton.h	/^  bool spinWaitForEarlyDelivery() {$/;"	f	struct:folly::Baton	access:private	signature:()
spinlock_	.\io\async\NotificationQueue.h	/^  mutable folly::MicroSpinLock spinlock_;$/;"	m	class:folly::NotificationQueue	access:private
split	.\String-inl.h	/^split(const Delim& delimiter,$/;"	f	namespace:folly	signature:(const Delim& delimiter, StringPiece input, OutputType& outHead, OutputTypes&... outTail)
split	.\String-inl.h	/^void split(const Delim& delimiter,$/;"	f	namespace:folly	signature:(const Delim& delimiter, const String& input, fbvector<OutputType>& out, bool ignoreEmpty)
split	.\String-inl.h	/^void split(const Delim& delimiter,$/;"	f	namespace:folly	signature:(const Delim& delimiter, const String& input, std::vector<OutputType>& out, bool ignoreEmpty)
split	.\String.h	/^void split(const Delim& delimiter,$/;"	p	class:folly::UriEscapeMode	access:private	signature:(const Delim& delimiter, const String& input, folly::fbvector<OutputType>& out, bool ignoreEmpty = false)
split	.\String.h	/^void split(const Delim& delimiter,$/;"	p	class:folly::UriEscapeMode	access:private	signature:(const Delim& delimiter, const String& input, std::vector<OutputType>& out, bool ignoreEmpty = false)
split	.\gen\String.h	/^S split(StringPiece source, StringPiece delimiter) {$/;"	f	namespace:folly::gen	signature:(StringPiece source, StringPiece delimiter)
split	.\gen\String.h	/^S split(const StringPiece& source, char delimiter) {$/;"	f	namespace:folly::gen	signature:(const StringPiece& source, char delimiter)
split	.\io\IOBufQueue.cpp	/^IOBufQueue::split(size_t n) {$/;"	f	class:folly::IOBufQueue	signature:(size_t n)
split	.\io\IOBufQueue.h	/^  std::unique_ptr<folly::IOBuf> split(size_t n);$/;"	p	class:folly::IOBufQueue	access:public	signature:(size_t n)
splitFixed	.\String-inl.h	/^splitFixed(const Delim& delimiter,$/;"	f	namespace:folly::detail	signature:(const Delim& delimiter, StringPiece input, OutputType& out)
splitFixed	.\String-inl.h	/^splitFixed(const Delim& delimiter,$/;"	f	namespace:folly::detail	signature:(const Delim& delimiter, StringPiece input, OutputType& outHead, OutputTypes&... outTail)
splitIntKey	.\FormatArg.h	/^  int splitIntKey();$/;"	p	struct:folly::FormatArg	access:public	signature:()
splitIntKey	.\FormatArg.h	/^inline int FormatArg::splitIntKey() {$/;"	f	class:folly::FormatArg	signature:()
splitKey	.\FormatArg.h	/^  StringPiece splitKey();$/;"	p	struct:folly::FormatArg	access:public	signature:()
splitKey	.\FormatArg.h	/^inline StringPiece FormatArg::splitKey() {$/;"	f	class:folly::FormatArg	signature:()
splitPrefix	.\gen\String-inl.h	/^inline size_t splitPrefix(StringPiece& in,$/;"	f	namespace:folly::gen::detail	signature:(StringPiece& in, StringPiece& prefix, MixedNewlines)
splitPrefix	.\gen\String-inl.h	/^inline size_t splitPrefix(StringPiece& in,$/;"	f	namespace:folly::gen::detail	signature:(StringPiece& in, StringPiece& prefix, StringPiece delimiter)
splitPrefix	.\gen\String-inl.h	/^inline size_t splitPrefix(StringPiece& in,$/;"	f	namespace:folly::gen::detail	signature:(StringPiece& in, StringPiece& prefix, char delimiter)
splitTest	.\test\StringTest.cpp	/^void splitTest() {$/;"	f	namespace:__anon138	signature:()
splitTo	.\String-inl.h	/^void splitTo(const Delim& delimiter,$/;"	f	namespace:folly	signature:(const Delim& delimiter, const String& input, OutputIterator out, bool ignoreEmpty)
splitTo	.\String.h	/^void splitTo(const Delim& delimiter,$/;"	p	class:folly::UriEscapeMode	access:private	signature:(const Delim& delimiter, const String& input, OutputIterator out, bool ignoreEmpty = false)
split_step	.\Range.h	/^  Range split_step(Range delimiter) {$/;"	f	class:folly::Range	access:public	signature:(Range delimiter)
split_step	.\Range.h	/^  Range split_step(value_type delimiter) {$/;"	f	class:folly::Range	access:public	signature:(value_type delimiter)
split_step_with_process_noop	.\test\RangeTest.cpp	/^void split_step_with_process_noop(folly::StringPiece) {}$/;"	f	signature:(folly::StringPiece)
splock_test	.\test\SmallLocksTest.cpp	/^void splock_test() {$/;"	f	namespace:__anon131	signature:()
square	.\gen\test\BaseBenchmark.cpp	/^auto square = [](int x) { return x * x; };$/;"	v
square	.\gen\test\BaseTest.cpp	/^auto square = [](int x) { return x * x; };$/;"	v
square	.\gen\test\ParallelTest.cpp	/^const auto square = [](int i) { return i * i; };$/;"	v
ssize_t	.\Portability.h	/^typedef SSIZE_T ssize_t;$/;"	t
stages_	.\MPMCPipeline.h	/^  StageTuple stages_;$/;"	m	class:folly::MPMCPipeline	access:private
standardOpcodeLengths_	.\experimental\symbolizer\Dwarf.h	/^    const uint8_t* standardOpcodeLengths_;$/;"	m	class:folly::symbolizer::Dwarf::LineNumberVM	access:private
start	.\Arena.h	/^    char* start() {$/;"	f	struct:folly::Arena::Block	access:public	signature:()
start	.\Benchmark.h	/^  timespec start;$/;"	m	struct:folly::BenchmarkSuspender	access:private
start	.\Range.h	/^  Iter start() const { return b_; }$/;"	f	class:folly::Range	access:public	signature:() const
start	.\experimental\io\AsyncIO.cpp	/^void AsyncIOOp::start() {$/;"	f	class:folly::AsyncIOOp	signature:()
start	.\experimental\io\AsyncIO.h	/^  void start();$/;"	p	class:folly::AsyncIOOp	access:private	signature:()
start	.\experimental\io\test\AsyncIOTest.cpp	/^  off_t start;$/;"	m	struct:__anon32::TestSpec	file:	access:public
start	.\gen\test\ParallelBenchmark.cpp	/^auto start = 1 << 20;$/;"	v
startConsuming	.\io\async\NotificationQueue.h	/^    void startConsuming(EventBase* eventBase, NotificationQueue* queue) {$/;"	f	class:folly::NotificationQueue::Consumer	access:public	signature:(EventBase* eventBase, NotificationQueue* queue)
startConsumingInternal	.\io\async\NotificationQueue.h	/^    void startConsumingInternal($/;"	f	class:folly::NotificationQueue::Consumer	access:public	signature:( EventBase* eventBase, NotificationQueue* queue)
startWork_	.\io\async\EventBase.h	/^  uint64_t startWork_;$/;"	m	class:folly::EventBase	access:private
start_	.\experimental\EliasFanoCoding.h	/^  const unsigned char* const start_;$/;"	m	class:folly::compression::detail::UpperBitsReader	access:private
start_	.\gen\Base-inl.h	/^  Value start_;$/;"	m	class:folly::gen::detail::Sequence	access:private
start_	.\stats\TimeseriesHistogram.h	/^    TimeType start_;$/;"	m	struct:folly::TimeseriesHistogram::AvgFromInterval	access:private
start_	.\stats\TimeseriesHistogram.h	/^    TimeType start_;$/;"	m	struct:folly::TimeseriesHistogram::CountFromInterval	access:private
starter_	.\wangle\Later.h	/^  Promise<void> starter_;$/;"	m	class:folly::wangle::Later	access:private
startsWith	.\Range.h	/^  bool startsWith(const const_range_type& other) const {$/;"	f	class:folly::Range	access:public	signature:(const const_range_type& other) const
startsWith	.\Range.h	/^  bool startsWith(value_type c) const {$/;"	f	class:folly::Range	access:public	signature:(value_type c) const
starts_with	.\experimental\io\FsUtil.cpp	/^bool starts_with(const path& pth, const path& prefix) {$/;"	f	namespace:folly::fs	signature:(const path& pth, const path& prefix)
state	.\Subprocess.cpp	/^ProcessReturnCode::State ProcessReturnCode::state() const {$/;"	f	class:folly::ProcessReturnCode	signature:() const
state	.\Subprocess.h	/^  State state() const;$/;"	p	class:folly::ProcessReturnCode	access:public	signature:() const
state	.\experimental\Singleton.h	/^    SingletonEntryState state = SingletonEntryState::Dead;$/;"	m	struct:folly::SingletonVault::SingletonEntry	access:public
state	.\experimental\io\AsyncIO.h	/^  State state() const { return state_; }$/;"	f	class:folly::AsyncIOOp	access:public	signature:() const
stateCheck	.\experimental\Singleton.h	/^  void stateCheck(SingletonVaultState expected,$/;"	f	class:folly::SingletonVault	access:private	signature:(SingletonVaultState expected, const char* msg=)
statePtr	.\wangle\Future.h	/^  typedef detail::State<T>* statePtr;$/;"	t	class:folly::wangle::Future	access:private
statePtr	.\wangle\Promise.h	/^  typedef typename Future<T>::statePtr statePtr;$/;"	t	class:folly::wangle::Promise	access:private
stateSize	.\Random-inl.h	/^  static constexpr size_t stateSize = StateSize<RNG>::value;$/;"	m	struct:folly::detail::SeedData	access:public
state_	.\Baton.h	/^  detail::Futex<Atom> state_;$/;"	m	struct:folly::Baton	access:private
state_	.\MPMCQueue.h	/^  Futex<Atom> state_;$/;"	m	namespace:folly::detail
state_	.\experimental\Singleton.h	/^  SingletonVaultState state_ = SingletonVaultState::Registering;$/;"	m	class:folly::SingletonVault	access:private
state_	.\experimental\io\AsyncIO.h	/^  State state_;$/;"	m	class:folly::AsyncIOOp	access:private
state_	.\experimental\symbolizer\LineReader.h	/^  State state_;$/;"	m	class:folly::symbolizer::LineReader	access:private
state_	.\wangle\Future-inl.h	/^Future<T>::Future(Future<T>&& other) noexcept : state_(nullptr) {$/;"	f	namespace:folly::wangle	signature:(nullptr)
state_	.\wangle\Future.h	/^  statePtr state_;$/;"	m	class:folly::wangle::Future	access:private
state_	.\wangle\Promise.h	/^  statePtr state_;$/;"	m	class:folly::wangle::Promise	access:private
state_condvar	.\experimental\Singleton.h	/^    std::condition_variable state_condvar;$/;"	m	struct:folly::SingletonVault::SingletonEntry	access:public
static_assert	.\AtomicHashArray.h	/^  static_assert((std::is_convertible<KeyT,int32_t>::value ||$/;"	p	class:folly::AtomicHashArray	access:private	signature:(std::is_convertible<KeyT,int32_t>::value || std::is_convertible<KeyT,int64_t>::value || std::is_convertible<KeyT,const void*>::value),   
static_assert	.\DiscriminatedPtr.h	/^  static_assert(sizeof...(Types) < std::numeric_limits<uint16_t>::max(),$/;"	p	class:folly::DiscriminatedPtr	access:private	signature:(sizeof....(Types) < std::numeric_limits<uint16_t>::max(), )
static_assert	.\IndexedMemPool.h	/^  static_assert(LocalListLimit_ <= 255, "LocalListLimit must fit in 8 bits");$/;"	p	struct:folly::IndexedMemPool	access:public	signature:(LocalListLimit_ <= 255, )
static_assert	.\RWSpinLock.h	/^  static_assert(kBitWidth == 32 || kBitWidth == 64,$/;"	p	struct:folly::detail::RWTicketIntTrait	access:public	signature:(kBitWidth == 32 || kBitWidth == 64, )
static_assert	.\SmallLocks.h	/^  static_assert(std::is_integral<IntType>::value,$/;"	p	struct:folly::PicoSpinLock	access:public	signature:(std::is_integral<IntType>::value, )
static_assert	.\detail\BitIteratorDetail.h	/^  static_assert(std::is_integral<typename BaseIter::value_type>::value,$/;"	p	struct:folly::bititerator_detail::BitIteratorBase	access:public	signature:(std::is_integral<typename BaseIter::value_type>::value, )
static_assert	.\detail\CacheLocality.h	/^  static_assert((kMaxCpus & (kMaxCpus - 1)) == 0,$/;"	p	struct:folly::detail::AccessSpreader	access:private	signature:(kMaxCpus & (kMaxCpus - 1)) == 0, 
static_assert	.\detail\CacheLocality.h	/^  static_assert(kFalseSharingRange == 128,$/;"	p	struct:folly::detail::CacheLocality	access:public	signature:(kFalseSharingRange == 128, )
static_assert	.\detail\DiscriminatedPtrDetail.h	/^  static_assert(IsSameType<T, Types...>::value,$/;"	p	struct:folly::dptr_detail::SameType	access:public	signature:(IsSameType<T, Types...>::value, )
static_assert	.\experimental\EliasFanoCoding.h	/^  static_assert(std::is_integral<Value>::value &&$/;"	p	struct:folly::compression::EliasFanoEncoder	access:public	signature:(std::is_integral<Value>::value && std::is_unsigned<Value>::value, )
static_assert	.\gen\Combine-inl.h	/^    static_assert(std::is_same<const Value&, ConstRefType>::value,$/;"	p	class:folly::gen::detail::Interleave::Generator	access:private	signature:(std::is_same<const Value&, ConstRefType>::value, )
static_assert	.\io\TypedIOBuf.h	/^  static_assert(std::is_standard_layout<T>::value, "must be standard layout");$/;"	p	class:folly::TypedIOBuf	access:private	signature:(std::is_standard_layout<T>::value, )
static_assert	.\small_vector.h	/^    static_assert(HasNoHeap::value == 0 || HasNoHeap::value == 1,$/;"	p	struct:folly::detail::small_vector_base	access:public	signature:(HasNoHeap::value == 0 || HasNoHeap::value == 1,  )
static_assert	.\small_vector.h	/^    static_assert(mpl::size<Integrals>::value == 0 ||$/;"	p	struct:folly::detail::small_vector_base	access:public	signature:(mpl::size<Integrals>::value == 0 || mpl::size<Integrals>::value == 1, )
static_assert	.\small_vector.h	/^    static_assert(std::is_unsigned<SizeType>::value,$/;"	p	struct:folly::detail::small_vector_base	access:public	signature:(std::is_unsigned<SizeType>::value, )
std	.\Chrono.h	/^namespace std { namespace chrono {$/;"	n
std	.\FBString.h	/^namespace std {$/;"	n
std	.\Hash.h	/^namespace std {$/;"	n
std	.\IPAddress.h	/^namespace std {$/;"	n
std	.\IPAddressV4.h	/^namespace std {$/;"	n
std	.\IPAddressV6.h	/^namespace std {$/;"	n
std	.\SocketAddress.h	/^namespace std {$/;"	n
std	.\dynamic-inl.h	/^namespace std {$/;"	n
std	.\experimental\exception_tracer\ExceptionTracerLib.cpp	/^namespace std {$/;"	n	file:
std::chrono	.\Chrono.h	/^namespace std { namespace chrono {$/;"	n	namespace:std
std::chrono::steady_clock	.\Chrono.h	/^typedef monotonic_clock steady_clock;$/;"	t	namespace:std::chrono
std::hash	.\Hash.h	/^  struct hash<std::pair<T1, T2> > {$/;"	s	namespace:std
std::hash	.\Hash.h	/^  struct hash<std::tuple<Ts...>> {$/;"	s	namespace:std
std::hash	.\IPAddress.h	/^struct hash<folly::IPAddress> {$/;"	s	namespace:std
std::hash	.\IPAddressV4.h	/^struct hash<folly::IPAddressV4> {$/;"	s	namespace:std
std::hash	.\IPAddressV6.h	/^struct hash<folly::IPAddressV6> {$/;"	s	namespace:std
std::hash	.\SocketAddress.h	/^struct hash<folly::SocketAddress> {$/;"	s	namespace:std
std::hash	.\dynamic-inl.h	/^struct hash< ::folly::dynamic> {$/;"	s	namespace:std
std::hash::operator ()	.\Hash.h	/^    size_t operator()(const std::pair<T1, T2>& x) const {$/;"	f	struct:std::hash	access:public	signature:(const std::pair<T1, T2>& x) const
std::hash::operator ()	.\Hash.h	/^    size_t operator()(std::tuple<Ts...> const& key) const {$/;"	f	struct:std::hash	access:public	signature:(std::tuple<Ts...> const& key) const
std::hash::operator ()	.\IPAddress.h	/^  size_t operator()(const folly::IPAddress& addr) const {$/;"	f	struct:std::hash	access:public	signature:(const folly::IPAddress& addr) const
std::hash::operator ()	.\IPAddressV4.h	/^  size_t operator()(const folly::IPAddressV4 addr) const {$/;"	f	struct:std::hash	access:public	signature:(const folly::IPAddressV4 addr) const
std::hash::operator ()	.\IPAddressV6.h	/^  size_t operator()(const folly::IPAddressV6& addr) const {$/;"	f	struct:std::hash	access:public	signature:(const folly::IPAddressV6& addr) const
std::hash::operator ()	.\SocketAddress.h	/^  size_t operator()($/;"	f	struct:std::hash	access:public	signature:( const folly::SocketAddress& addr) const
std::hash::operator ()	.\dynamic-inl.h	/^  size_t operator()(::folly::dynamic const& d) const {$/;"	f	struct:std::hash	access:public	signature:(::folly::dynamic const& d) const
std::rethrow_exception	.\experimental\exception_tracer\ExceptionTracerLib.cpp	/^void rethrow_exception(std::exception_ptr ep) {$/;"	f	namespace:std	signature:(std::exception_ptr ep)
stdAtomicWaitUntilTests	.\test\FutexTest.cpp	/^void stdAtomicWaitUntilTests() {$/;"	f	signature:()
stdString	.\test\ConvTest.cpp	/^static std::string stdString = "std::strings are very nice";$/;"	v	file:
stderr	.\Subprocess.h	/^    Options& stderr(int action) { return fd(STDERR_FILENO, action); }$/;"	f	class:folly::Subprocess::Options	access:public	signature:(int action)
stderr	.\Subprocess.h	/^  int stderr() const { return parentFd(2); }$/;"	f	class:folly::Subprocess	access:public	signature:() const
stdin	.\Subprocess.h	/^    Options& stdin(int action) { return fd(STDIN_FILENO, action); }$/;"	f	class:folly::Subprocess::Options	access:public	signature:(int action)
stdin	.\Subprocess.h	/^  int stdin() const { return parentFd(0); }$/;"	f	class:folly::Subprocess	access:public	signature:() const
stdout	.\Subprocess.h	/^    Options& stdout(int action) { return fd(STDOUT_FILENO, action); }$/;"	f	class:folly::Subprocess::Options	access:public	signature:(int action)
stdout	.\Subprocess.h	/^  int stdout() const { return parentFd(1); }$/;"	f	class:folly::Subprocess	access:public	signature:() const
steady_clock	.\Chrono.h	/^typedef monotonic_clock steady_clock;$/;"	t	namespace:std::chrono
step	.\experimental\symbolizer\Dwarf.cpp	/^Dwarf::LineNumberVM::StepResult Dwarf::LineNumberVM::step($/;"	f	class:folly::symbolizer::Dwarf::LineNumberVM	signature:( folly::StringPiece& program)
step	.\experimental\symbolizer\Dwarf.h	/^    StepResult step(folly::StringPiece& program);$/;"	p	class:folly::symbolizer::Dwarf::LineNumberVM	access:private	signature:(folly::StringPiece& program)
step	.\gen\Base-inl.h	/^  void step(Value& current) const { ++current; }$/;"	f	class:folly::gen::detail::InfiniteImpl	access:public	signature:(Value& current) const
step	.\gen\Base-inl.h	/^  void step(Value& current) const { ++current; }$/;"	f	class:folly::gen::detail::RangeImpl	access:public	signature:(Value& current) const
step	.\gen\Base-inl.h	/^  void step(Value& current) const { ++current; }$/;"	f	class:folly::gen::detail::SeqImpl	access:public	signature:(Value& current) const
step	.\gen\Base-inl.h	/^  void step(Value& current) const { current += step_; }$/;"	f	class:folly::gen::detail::RangeWithStepImpl	access:public	signature:(Value& current) const
step	.\gen\Base-inl.h	/^  void step(Value& current) const { current += step_; }$/;"	f	class:folly::gen::detail::SeqWithStepImpl	access:public	signature:(Value& current) const
step_	.\gen\Base-inl.h	/^  Distance step_;$/;"	m	class:folly::gen::detail::RangeWithStepImpl	access:private
step_	.\gen\Base-inl.h	/^  Distance step_;$/;"	m	class:folly::gen::detail::SeqWithStepImpl	access:private
stepsBetweenSelect_	.\test\DeterministicSchedule.cpp	/^  const int stepsBetweenSelect_;$/;"	m	struct:folly::test::UniformSubset	file:	access:private
stepsLeft_	.\test\DeterministicSchedule.cpp	/^  int stepsLeft_;$/;"	m	struct:folly::test::UniformSubset	file:	access:private
stop	.\experimental\wangle\concurrent\ThreadPoolExecutor.cpp	/^void ThreadPoolExecutor::stop() {$/;"	f	class:folly::wangle::ThreadPoolExecutor	signature:()
stop	.\experimental\wangle\concurrent\ThreadPoolExecutor.h	/^  void stop();$/;"	p	class:folly::wangle::ThreadPoolExecutor	access:public	signature:()
stop	.\experimental\wangle\concurrent\test\ThreadPoolExecutorTest.cpp	/^static void stop() {$/;"	f	file:	signature:()
stop	.\gen\ParallelMap-inl.h	/^      void stop() {$/;"	f	class:folly::gen::detail::PMap::Generator::ExecutionPipeline	access:public	signature:()
stopConsuming	.\io\async\NotificationQueue.h	/^    void stopConsuming();$/;"	p	class:folly::NotificationQueue::Consumer	access:public	signature:()
stopConsuming	.\io\async\NotificationQueue.h	/^void NotificationQueue<MessageT>::Consumer::stopConsuming() {$/;"	f	class:folly::NotificationQueue::Consumer	signature:()
stopThread	.\test\RWSpinLockTest.cpp	/^static std::atomic<bool> stopThread;$/;"	m	namespace:__anon130	file:
stopThreads	.\experimental\wangle\concurrent\CPUThreadPoolExecutor.cpp	/^void CPUThreadPoolExecutor::stopThreads(size_t n) {$/;"	f	class:folly::wangle::CPUThreadPoolExecutor	signature:(size_t n)
stopThreads	.\experimental\wangle\concurrent\IOThreadPoolExecutor.cpp	/^void IOThreadPoolExecutor::stopThreads(size_t n) {$/;"	f	class:folly::wangle::IOThreadPoolExecutor	signature:(size_t n)
stopThreads	.\experimental\wangle\concurrent\ThreadPoolExecutor.h	/^  virtual void stopThreads(size_t n) = 0;$/;"	p	class:folly::wangle::ThreadPoolExecutor	access:protected	signature:(size_t n)
stop_	.\io\async\EventBase.h	/^  bool stop_;$/;"	m	class:folly::EventBase	access:private
stoppedThreads_	.\experimental\wangle\concurrent\ThreadPoolExecutor.h	/^  StoppedThreadQueue stoppedThreads_;$/;"	m	class:folly::wangle::ThreadPoolExecutor	access:protected
storage_	.\SocketAddress.h	/^  } storage_;$/;"	m	class:folly::SocketAddress	typeref:union:folly::SocketAddress::__anon91	access:private
store	.\experimental\Bits.h	/^  static void store(T& x, T v) { x = v; }$/;"	f	struct:folly::detail::BitsTraits	access:public	signature:(T& x, T v)
store	.\experimental\Bits.h	/^  static void store(Unaligned<T>& x, T v) { x.value = v; }$/;"	f	struct:folly::detail::BitsTraits	access:public	signature:(Unaligned<T>& x, T v)
store	.\experimental\Bits.h	/^  store(UnalignedNoASan<T>& x, T v) { x.value = v; }$/;"	f	struct:folly::detail::BitsTraits	access:public	signature:(UnalignedNoASan<T>& x, T v)
storeCurrent	.\json.cpp	/^  void storeCurrent() {$/;"	f	struct:folly::json::__anon75::Input	file:	access:private	signature:()
store_release	.\RWSpinLock.h	/^  static void store_release(T* addr, T v) {$/;"	f	class:folly::RWTicketSpinLockT	access:private	signature:(T* addr, T v)
str	.\Format.h	/^  std::string str() const {$/;"	f	class:folly::BaseFormatter	access:public	signature:() const
str	.\IPAddress.h	/^  std::string str() const {$/;"	f	class:folly::IPAddress	access:public	signature:() const
str	.\IPAddressV4.cpp	/^string IPAddressV4::str() const {$/;"	f	class:folly::IPAddressV4	signature:() const
str	.\IPAddressV4.h	/^  std::string str() const;$/;"	p	class:folly::IPAddressV4	access:public	signature:() const
str	.\IPAddressV6.cpp	/^string IPAddressV6::str() const {$/;"	f	class:folly::IPAddressV6	signature:() const
str	.\IPAddressV6.h	/^  std::string str() const;$/;"	p	class:folly::IPAddressV6	access:public	signature:() const
str	.\Range.h	/^  std::string str() const { return std::string(b_, size()); }$/;"	f	class:folly::Range	access:public	signature:() const
str	.\Subprocess.cpp	/^std::string ProcessReturnCode::str() const {$/;"	f	class:folly::ProcessReturnCode	signature:() const
str	.\Subprocess.h	/^  std::string str() const;$/;"	p	class:folly::ProcessReturnCode	access:public	signature:() const
str	.\Uri.h	/^  std::string str() const { return toString<std::string>(); }$/;"	f	class:folly::Uri	access:public	signature:() const
str	.\experimental\symbolizer\Symbolizer.h	/^  std::string str() const { return buf_.toStdString(); }$/;"	f	class:folly::symbolizer::StringSymbolizePrinter	access:public	signature:() const
str	.\test\RangeFindBenchmark.cpp	/^std::string str;$/;"	m	namespace:__anon129	file:
str_	.\Format.h	/^  StringPiece str_;$/;"	v
str_to_bool	.\Conv.cpp	/^bool str_to_bool(StringPiece* src) {$/;"	f	namespace:folly::detail	signature:(StringPiece* src)
streamSplitter	.\gen\String.h	/^StreamSplitter<Callback> streamSplitter(char delimiter,$/;"	f	namespace:folly::gen	signature:(char delimiter, Callback&& pieceCb, uint64_t capacity = 0)
strerror_r	.\Portability.h	235;"	d
stride	.\gen\Base-inl.h	/^inline detail::Stride stride(size_t s) {$/;"	f	namespace:folly::gen	signature:(size_t s)
stride_	.\MPMCQueue.h	/^    , stride_(rhs.stride_)$/;"	p	class:folly::MPMCQueue	access:public	signature:(rhs.stride_)
stride_	.\MPMCQueue.h	/^  int stride_;$/;"	m	class:folly::MPMCQueue	access:private
stride_	.\gen\Base-inl.h	/^    size_t stride_;$/;"	m	class:folly::gen::detail::Stride::Generator	access:private
stride_	.\gen\Base-inl.h	/^  size_t stride_;$/;"	m	class:folly::gen::detail::Stride	access:private
string	.\dynamic.h	/^    fbstring string;$/;"	m	union:folly::dynamic::Data	access:public
stringAppendf	.\String.cpp	/^std::string& stringAppendf(std::string* output, const char* format, ...) {$/;"	f	namespace:folly	signature:(std::string* output, const char* format, ...)
stringIdenticalToBM	.\test\ConvTest.cpp	/^static const StringIdenticalToBM<std::string> stringIdenticalToBM;$/;"	v	file:
stringPrintf	.\String.cpp	/^std::string stringPrintf(const char* format, ...) {$/;"	f	namespace:folly	signature:(const char* format, ...)
stringPrintf	.\String.cpp	/^void stringPrintf(std::string* output, const char* format, ...) {$/;"	f	namespace:folly	signature:(std::string* output, const char* format, ...)
stringPrintfImpl	.\String.cpp	/^inline void stringPrintfImpl(std::string& output, const char* format,$/;"	f	namespace:folly::__anon93	signature:(std::string& output, const char* format, va_list args)
stringTable	.\experimental\symbolizer\Elf-inl.h	/^const char* ElfFile::iterateStrings(const ElfW(Shdr)& stringTable, Fn fn)$/;"	m	namespace:folly::symbolizer
stringTable	.\experimental\symbolizer\Elf.cpp	/^const char* ElfFile::getString(const ElfW(Shdr)& stringTable, size_t offset)$/;"	m	namespace:folly::symbolizer	file:
stringTable	.\experimental\symbolizer\Elf.h	/^  const char* getString(const ElfW(Shdr)& stringTable, size_t offset) const;$/;"	m	class:folly::symbolizer::ElfFile	access:public
stringTable	.\experimental\symbolizer\Elf.h	/^  const char* iterateStrings(const ElfW(Shdr)& stringTable, Fn fn) const;$/;"	m	class:folly::symbolizer::ElfFile	access:public
stringToIOBuf	.\io\test\IOBufQueueTest.cpp	/^stringToIOBuf(const char* s, uint32_t len) {$/;"	f	namespace:__anon70	signature:(const char* s, uint32_t len)
stringVariadicToBM	.\test\ConvTest.cpp	/^static const StringVariadicToBM<std::string> stringVariadicToBM;$/;"	v	file:
strings	.\gen\test\BaseBenchmark.cpp	/^static vector<fbstring> strings =$/;"	v	file:
strings_	.\experimental\symbolizer\Dwarf.h	/^  folly::StringPiece strings_;    \/\/ .debug_str$/;"	m	class:folly::symbolizer::Dwarf	access:private
stripComments	.\json.cpp	/^fbstring stripComments(StringPiece jsonC) {$/;"	f	namespace:folly::json	signature:(StringPiece jsonC)
stripComments	.\json.h	/^  fbstring stripComments(StringPiece jsonC);$/;"	p	namespace:folly::json	signature:(StringPiece jsonC)
stripeByChip	.\detail\CacheLocality.h	/^  static const AccessSpreader stripeByChip;$/;"	m	struct:folly::detail::AccessSpreader	access:public
stripeByCore	.\detail\CacheLocality.h	/^  static const AccessSpreader stripeByCore;$/;"	m	struct:folly::detail::AccessSpreader	access:public
stripeByCpu	.\detail\CacheLocality.h	/^  CompactStripe stripeByCpu[kMaxCpus];$/;"	m	struct:folly::detail::AccessSpreader	access:private
sub	.\gen\Parallel.h	/^Sub sub(Sink sink) {$/;"	f	namespace:folly::gen	signature:(Sink sink)
subDir	.\experimental\symbolizer\Dwarf.h	/^    folly::StringPiece subDir() const { return subDir_; }$/;"	f	class:folly::symbolizer::Dwarf::Path	access:public	signature:() const
subDir_	.\experimental\symbolizer\Dwarf.h	/^    folly::StringPiece subDir_;$/;"	m	class:folly::symbolizer::Dwarf::Path	access:private
subIt_	.\AtomicHashMap-inl.h	/^  SubIt subIt_;$/;"	m	struct:folly::AtomicHashMap::ahm_iterator	access:private
subMap_	.\AtomicHashMap-inl.h	/^  uint32_t subMap_;$/;"	m	struct:folly::AtomicHashMap::ahm_iterator	access:private
subMaps_	.\AtomicHashMap.h	/^  std::atomic<SubMap*> subMaps_[kNumSubMaps_];$/;"	m	class:folly::AtomicHashMap	access:private
submatch	.\Uri.cpp	/^fbstring submatch(const boost::cmatch& m, size_t idx) {$/;"	f	namespace:folly::__anon153	signature:(const boost::cmatch& m, size_t idx)
submit	.\experimental\io\AsyncIO.cpp	/^void AsyncIO::submit(Op* op) {$/;"	f	class:folly::AsyncIO	signature:(Op* op)
submit	.\experimental\io\AsyncIO.cpp	/^void AsyncIOQueue::submit(AsyncIOOp* op) {$/;"	f	class:folly::AsyncIOQueue	signature:(AsyncIOOp* op)
submit	.\experimental\io\AsyncIO.cpp	/^void AsyncIOQueue::submit(OpFactory op) {$/;"	f	class:folly::AsyncIOQueue	signature:(OpFactory op)
submit	.\experimental\io\AsyncIO.h	/^  void submit(AsyncIOOp* op);$/;"	p	class:folly::AsyncIOQueue	access:public	signature:(AsyncIOOp* op)
submit	.\experimental\io\AsyncIO.h	/^  void submit(Op* op);$/;"	p	class:folly::AsyncIO	access:public	signature:(Op* op)
submit	.\experimental\io\AsyncIO.h	/^  void submit(OpFactory op);$/;"	p	class:folly::AsyncIOQueue	access:public	signature:(OpFactory op)
submitted_	.\experimental\io\AsyncIO.h	/^  std::atomic<size_t> submitted_;$/;"	m	class:folly::AsyncIO	access:private
subnet	.\test\IPAddressTest.h	/^  std::string subnet;$/;"	m	struct:folly::MaskData	access:public
subpiece	.\Range.h	/^  Range subpiece(size_type first,$/;"	f	class:folly::Range	access:public	signature:(size_type first, size_type length = std::string::npos) const
subsetSize_	.\test\DeterministicSchedule.cpp	/^  const int subsetSize_;$/;"	m	struct:folly::test::UniformSubset	file:	access:private
subtract	.\Range.h	/^  void subtract(size_type n) {$/;"	f	class:folly::Range	access:public	signature:(size_type n)
subtract	.\stats\Histogram.h	/^  void subtract(const Histogram &hist) {$/;"	f	class:folly::Histogram	access:public	signature:(const Histogram &hist)
succeed	.\test\SafeAssertTest.cpp	/^void succeed() {$/;"	f	signature:()
success	.\AtomicHashArray.h	/^  struct SimpleRetT { size_t idx; bool success;$/;"	m	struct:folly::AtomicHashArray::SimpleRetT	access:public
success	.\AtomicHashMap.h	/^  struct SimpleRetT { uint32_t i; size_t j; bool success;$/;"	m	struct:folly::AtomicHashMap::SimpleRetT	access:public
succs_	.\ConcurrentSkipList.h	/^  NodeType *succs_[MAX_HEIGHT], *preds_[MAX_HEIGHT];$/;"	m	class:folly::ConcurrentSkipList::Skipper	access:private
suffix	.\Benchmark.cpp	/^  const char* suffix;$/;"	m	struct:folly::ScaleInfo	file:	access:public
suffix	.\String.cpp	/^  const char* suffix;$/;"	m	struct:folly::__anon94::PrettySuffix	file:	access:public
suffix_	.\experimental\wangle\concurrent\NamedThreadFactory.h	/^  std::atomic<uint64_t> suffix_;$/;"	m	class:folly::wangle::NamedThreadFactory	access:private
sum	.\detail\Stats.h	/^  ValueType sum;$/;"	m	struct:folly::detail::Bucket	access:public
sum	.\gen\Base-inl.h	/^static const detail::Sum sum;$/;"	m	namespace:folly::gen
sum	.\stats\BucketedTimeSeries-defs.h	/^VT BucketedTimeSeries<VT, TT>::sum(TimeType start, TimeType end) const {$/;"	f	class:folly::BucketedTimeSeries	signature:(TimeType start, TimeType end) const
sum	.\stats\BucketedTimeSeries.h	/^  ValueType sum(TimeType start, TimeType end) const;$/;"	p	class:folly::BucketedTimeSeries	access:public	signature:(TimeType start, TimeType end) const
sum	.\stats\BucketedTimeSeries.h	/^  const ValueType& sum() const {$/;"	f	class:folly::BucketedTimeSeries	access:public	signature:() const
sum	.\stats\MultiLevelTimeSeries.h	/^  ValueType sum(TimeType start, TimeType end) const {$/;"	f	class:folly::MultiLevelTimeSeries	access:public	signature:(TimeType start, TimeType end) const
sum	.\stats\MultiLevelTimeSeries.h	/^  ValueType sum(int level) const {$/;"	f	class:folly::MultiLevelTimeSeries	access:public	signature:(int level) const
sum	.\stats\TimeseriesHistogram.h	/^  ValueType sum(TimeType start, TimeType end) const {$/;"	f	class:folly::TimeseriesHistogram	access:public	signature:(TimeType start, TimeType end) const
sum	.\stats\TimeseriesHistogram.h	/^  ValueType sum(int level) const {$/;"	f	class:folly::TimeseriesHistogram	access:public	signature:(int level) const
sumAllValues	.\test\ConcurrentSkipListTest.cpp	/^static void sumAllValues(SkipListAccessor skipList, int64_t *sum) {$/;"	f	namespace:__anon114	signature:(SkipListAccessor skipList, int64_t *sum)
supported	.\experimental\EliasFanoCoding.h	/^  static bool supported() {$/;"	f	struct:folly::compression::instructions::Default	access:public	signature:()
supported	.\experimental\EliasFanoCoding.h	/^  static bool supported() {$/;"	f	struct:folly::compression::instructions::Fast	access:public	signature:()
swap	.\FBVector.h	/^  static void swap(Impl& a, Impl& b) {$/;"	f	class:folly::fbvector	access:private	signature:(Impl& a, Impl& b)
swap	.\File.cpp	/^void File::swap(File& other) {$/;"	f	class:folly::File	signature:(File& other)
swap	.\File.cpp	/^void swap(File& a, File& b) {$/;"	f	namespace:folly	signature:(File& a, File& b)
swap	.\File.h	/^  void swap(File& other);$/;"	p	class:folly::File	access:public	signature:(File& other)
swap	.\File.h	/^void swap(File& a, File& b);$/;"	p	namespace:folly	signature:(File& a, File& b)
swap	.\MemoryMapping.cpp	/^void MemoryMapping::swap(MemoryMapping& other) {$/;"	f	class:folly::MemoryMapping	signature:(MemoryMapping& other)
swap	.\MemoryMapping.cpp	/^void swap(MemoryMapping& a, MemoryMapping& b) { a.swap(b); }$/;"	f	namespace:folly	signature:(MemoryMapping& a, MemoryMapping& b)
swap	.\MemoryMapping.h	/^  void swap(MemoryMapping& other);$/;"	p	class:folly::MemoryMapping	access:public	signature:(MemoryMapping& other)
swap	.\MemoryMapping.h	/^void swap(MemoryMapping&, MemoryMapping&);$/;"	p	namespace:folly	signature:(MemoryMapping&, MemoryMapping&)
swap	.\Optional.h	/^void swap(Optional<T>& a, Optional<T>& b) {$/;"	f	namespace:folly	signature:(Optional<T>& a, Optional<T>& b)
swap	.\Padded.h	/^  void swap(Adaptor& other) {$/;"	f	class:folly::Adaptor	access:public	signature:(Adaptor& other)
swap	.\RWSpinLock.h	/^    void swap(ReadHolder *other) {$/;"	f	class:folly::RWTicketSpinLockT::ReadHolder	access:public	signature:(ReadHolder *other)
swap	.\RWSpinLock.h	/^    void swap(ReadHolder* other) {$/;"	f	class:folly::RWSpinLock::ReadHolder	access:public	signature:(ReadHolder* other)
swap	.\RWSpinLock.h	/^    void swap(UpgradedHolder* other) {$/;"	f	class:folly::RWSpinLock::UpgradedHolder	access:public	signature:(UpgradedHolder* other)
swap	.\RWSpinLock.h	/^    void swap(WriteHolder *other) {$/;"	f	class:folly::RWTicketSpinLockT::WriteHolder	access:public	signature:(WriteHolder *other)
swap	.\RWSpinLock.h	/^    void swap(WriteHolder* other) {$/;"	f	class:folly::RWSpinLock::WriteHolder	access:public	signature:(WriteHolder* other)
swap	.\Range.h	/^  void swap(Range& rhs) {$/;"	f	class:folly::Range	access:public	signature:(Range& rhs)
swap	.\Range.h	/^void swap(Range<T>& lhs, Range<T>& rhs) {$/;"	f	namespace:folly	signature:(Range<T>& lhs, Range<T>& rhs)
swap	.\Synchronized.h	/^  void swap(Synchronized& rhs) {$/;"	f	struct:folly::Synchronized	access:public	signature:(Synchronized& rhs)
swap	.\Synchronized.h	/^  void swap(T& rhs) {$/;"	f	struct:folly::Synchronized	access:public	signature:(T& rhs)
swap	.\Synchronized.h	/^void swap(Synchronized<T, M>& lhs, Synchronized<T, M>& rhs) {$/;"	f	namespace:folly	signature:(Synchronized<T, M>& lhs, Synchronized<T, M>& rhs)
swap	.\small_vector.h	/^  void swap(small_vector& o) {$/;"	f	class:folly::small_vector	access:public	signature:(small_vector& o)
swap	.\sorted_vector_types.h	/^  void swap(sorted_vector_map& o) {$/;"	f	class:folly::sorted_vector_map	access:public	signature:(sorted_vector_map& o)
swap	.\sorted_vector_types.h	/^  void swap(sorted_vector_set& o) {$/;"	f	class:folly::sorted_vector_set	access:public	signature:(sorted_vector_set& o)
swap	.\sorted_vector_types.h	/^inline void swap(sorted_vector_map<K,V,C,A,G>& a,$/;"	f	namespace:folly	signature:(sorted_vector_map<K,V,C,A,G>& a, sorted_vector_map<K,V,C,A,G>& b)
swap	.\sorted_vector_types.h	/^inline void swap(sorted_vector_set<T,C,A,G>& a,$/;"	f	namespace:folly	signature:(sorted_vector_set<T,C,A,G>& a, sorted_vector_set<T,C,A,G>& b)
swapData	.\FBVector.h	/^    void swapData(Impl& other) {$/;"	f	struct:folly::fbvector::Impl	access:public	signature:(Impl& other)
swapSizePolicy	.\small_vector.h	/^    void swapSizePolicy(IntegralSizePolicy& o) {$/;"	f	struct:folly::detail::IntegralSizePolicy	access:protected	signature:(IntegralSizePolicy& o)
symbolize	.\experimental\symbolizer\Symbolizer.cpp	/^void Symbolizer::symbolize(const uintptr_t* addresses,$/;"	f	class:folly::symbolizer::Symbolizer	signature:(const uintptr_t* addresses, SymbolizedFrame* frames, size_t addressCount)
symbolize	.\experimental\symbolizer\Symbolizer.h	/^  bool symbolize(uintptr_t address, SymbolizedFrame& frame) {$/;"	f	class:folly::symbolizer::Symbolizer	access:public	signature:(uintptr_t address, SymbolizedFrame& frame)
symbolize	.\experimental\symbolizer\Symbolizer.h	/^  void symbolize(FrameArray<N>& fa) {$/;"	f	class:folly::symbolizer::Symbolizer	access:public	signature:(FrameArray<N>& fa)
symbolize	.\experimental\symbolizer\Symbolizer.h	/^  void symbolize(const uintptr_t* addresses,$/;"	p	class:folly::symbolizer::Symbolizer	access:public	signature:(const uintptr_t* addresses, SymbolizedFrame* frames, size_t frameCount)
symbolizer	.\experimental\symbolizer\Dwarf.cpp	/^namespace symbolizer {$/;"	n	namespace:folly	file:
symbolizer	.\experimental\symbolizer\Dwarf.h	/^namespace symbolizer {$/;"	n	namespace:folly
symbolizer	.\experimental\symbolizer\Elf-inl.h	/^namespace symbolizer {$/;"	n	namespace:folly
symbolizer	.\experimental\symbolizer\Elf.cpp	/^namespace symbolizer {$/;"	n	namespace:folly	file:
symbolizer	.\experimental\symbolizer\Elf.h	/^namespace symbolizer {$/;"	n	namespace:folly
symbolizer	.\experimental\symbolizer\ElfCache.cpp	/^namespace folly { namespace symbolizer {$/;"	n	namespace:folly	file:
symbolizer	.\experimental\symbolizer\ElfCache.h	/^namespace folly { namespace symbolizer {$/;"	n	namespace:folly
symbolizer	.\experimental\symbolizer\LineReader.cpp	/^namespace folly { namespace symbolizer {$/;"	n	namespace:folly	file:
symbolizer	.\experimental\symbolizer\LineReader.h	/^namespace folly { namespace symbolizer {$/;"	n	namespace:folly
symbolizer	.\experimental\symbolizer\SignalHandler.cpp	/^namespace folly { namespace symbolizer {$/;"	n	namespace:folly	file:
symbolizer	.\experimental\symbolizer\SignalHandler.h	/^namespace folly { namespace symbolizer {$/;"	n	namespace:folly
symbolizer	.\experimental\symbolizer\StackTrace.cpp	/^namespace folly { namespace symbolizer {$/;"	n	namespace:folly	file:
symbolizer	.\experimental\symbolizer\StackTrace.h	/^namespace folly { namespace symbolizer {$/;"	n	namespace:folly
symbolizer	.\experimental\symbolizer\Symbolizer.cpp	/^namespace symbolizer {$/;"	n	namespace:folly	file:
symbolizer	.\experimental\symbolizer\Symbolizer.h	/^namespace symbolizer {$/;"	n	namespace:folly
symbolizer	.\experimental\symbolizer\test\LineReaderTest.cpp	/^namespace folly { namespace symbolizer { namespace test {$/;"	n	namespace:folly	file:
symbolizer	.\experimental\symbolizer\test\SignalHandlerTest.cpp	/^namespace folly { namespace symbolizer { namespace test {$/;"	n	namespace:folly	file:
symbolizer	.\experimental\symbolizer\test\SignalHandlerTest.h	/^namespace folly { namespace symbolizer { namespace test {$/;"	n	namespace:folly
symbolizer	.\experimental\symbolizer\test\SymbolizerTest.cpp	/^namespace folly { namespace symbolizer { namespace test {$/;"	n	namespace:folly	file:
system	.\detail\CacheLocality.cpp	/^const CacheLocality& CacheLocality::system<std::atomic>() {$/;"	f	class:folly::detail::CacheLocality	signature:()
system	.\detail\CacheLocality.h	/^  static const CacheLocality& system();$/;"	p	struct:folly::detail::CacheLocality	access:public	signature:()
system	.\test\DeterministicSchedule.cpp	/^CacheLocality const& CacheLocality::system<test::DeterministicAtomic>() {$/;"	f	class:folly::detail::CacheLocality	signature:()
t	.\wangle\Try.h	/^  Try& operator=(const Try<T>& t) = delete;$/;"	m	class:folly::wangle::Try	access:public
t	.\wangle\Try.h	/^  Try(const Try<T>& t) = delete;$/;"	m	class:folly::wangle::Try	access:public
t	.\wangle\test\LaterTest.cpp	/^  std::thread t;$/;"	m	struct:LaterFixture	file:	access:public
t	.\wangle\test\ThreadGateTest.cpp	/^  thread t;$/;"	m	struct:GenericThreadGateFixture	file:	access:public
tVals	.\test\stl_tests\StlVectorTest.cpp	/^static const vector<int> tVals = { 0, 1, 2, 3, 17, 66, 521 };$/;"	v	file:
table	.\Fingerprint.h	/^  static const uint64_t table[8][256][1 + (BITS-1)\/64];$/;"	m	struct:folly::detail::FingerprintTable	access:public
tag	.\experimental\symbolizer\Dwarf.h	/^    uint64_t tag;$/;"	m	struct:folly::symbolizer::Dwarf::DIEAbbreviation	access:public
tagAndSize	.\IndexedMemPool.h	/^    uint32_t tagAndSize;$/;"	m	struct:folly::IndexedMemPool::TaggedPtr	access:public
tail	.\io\IOBuf.h	/^  const uint8_t* tail() const {$/;"	f	class:folly::IOBuf	access:public	signature:() const
tail	.\io\TypedIOBuf.h	/^  const T* tail() const {$/;"	f	class:folly::TypedIOBuf	access:public	signature:() const
tailBuf	.\io\IOBufQueue.h	/^  IOBuf* tailBuf() const {$/;"	f	class:folly::IOBufQueue	access:private	signature:() const
tailroom	.\io\IOBuf.h	/^  uint64_t tailroom() const {$/;"	f	class:folly::IOBuf	access:public	signature:() const
tailroom	.\io\IOBufQueue.h	/^  size_t tailroom() const {$/;"	f	class:folly::IOBufQueue	access:public	signature:() const
tailroom	.\io\TypedIOBuf.h	/^  uint32_t tailroom() const {$/;"	f	class:folly::TypedIOBuf	access:public	signature:() const
take	.\experimental\wangle\concurrent\BlockingQueue.h	/^  virtual T take() = 0;$/;"	p	class:folly::wangle::BlockingQueue	access:public	signature:()
take	.\experimental\wangle\concurrent\ThreadPoolExecutor.cpp	/^ThreadPoolExecutor::ThreadPtr ThreadPoolExecutor::StoppedThreadQueue::take() {$/;"	f	class:folly::wangle::ThreadPoolExecutor::StoppedThreadQueue	signature:()
take	.\gen\Base-inl.h	/^inline detail::Take take(size_t count) {$/;"	f	namespace:folly::gen	signature:(size_t count)
takeOwnership	.\io\IOBuf.cpp	/^unique_ptr<IOBuf> IOBuf::takeOwnership(void* buf, uint64_t capacity,$/;"	f	class:folly::IOBuf	signature:(void* buf, uint64_t capacity, uint64_t length, FreeFunction freeFn, void* userData, bool freeOnError)
takeOwnership	.\io\IOBuf.h	/^  static std::unique_ptr<IOBuf> takeOwnership(void* buf, uint64_t capacity,$/;"	f	class:folly::IOBuf	access:public	signature:(void* buf, uint64_t capacity, FreeFunction freeFn = nullptr, void* userData = nullptr, bool freeOnError = true)
takeOwnership	.\io\IOBuf.h	/^  static std::unique_ptr<IOBuf> takeOwnership(void* buf, uint64_t capacity,$/;"	p	class:folly::IOBuf	access:public	signature:(void* buf, uint64_t capacity, uint64_t length, FreeFunction freeFn = nullptr, void* userData = nullptr, bool freeOnError = true)
takeOwnership	.\io\IOBuf.h	/^  takeOwnership(UniquePtr&& buf, size_t count=1);$/;"	p	class:folly::IOBuf	access:public	signature:(UniquePtr&& buf, size_t count=1)
takeOwnership	.\io\IOBuf.h	/^IOBuf::takeOwnership(UniquePtr&& buf, size_t count) {$/;"	f	class:folly::IOBuf	signature:(UniquePtr&& buf, size_t count)
takeOwnershipError	.\io\IOBuf.cpp	/^void takeOwnershipError(bool freeOnError, void* buf,$/;"	f	namespace:__anon66	signature:(bool freeOnError, void* buf, folly::IOBuf::FreeFunction freeFn, void* userData)
tally	.\Benchmark.h	/^  void tally() {$/;"	f	struct:folly::BenchmarkSuspender	access:private	signature:()
target_	.\ThreadCachedInt.h	/^  std::atomic<IntT> target_;$/;"	m	class:folly::ThreadCachedInt	access:private
taskQueue_	.\experimental\wangle\concurrent\CPUThreadPoolExecutor.h	/^  std::unique_ptr<BlockingQueue<Task>> taskQueue_;$/;"	m	class:folly::wangle::CPUThreadPoolExecutor	access:private
tb_info	.\detail\Clock.cpp	/^static mach_timebase_info_data_t tb_info;$/;"	v	file:
tb_init	.\detail\Clock.cpp	/^static bool tb_init = mach_timebase_info(&tb_info) == KERN_SUCCESS;$/;"	v	file:
teardown	.\experimental\Singleton.h	/^    TeardownFunc teardown = nullptr;$/;"	m	struct:folly::SingletonVault::SingletonEntry	access:public
temporary	.\File.cpp	/^\/* static *\/ File File::temporary() {$/;"	f	class:folly::File	signature:()
temporary	.\File.h	/^  static File temporary();$/;"	p	class:folly::File	access:public	signature:()
terminate	.\Subprocess.h	/^  void terminate() { sendSignal(SIGTERM); }$/;"	f	class:folly::Subprocess	access:public	signature:()
terminateHandler	.\experimental\exception_tracer\ExceptionAbi.h	/^  std::terminate_handler terminateHandler;$/;"	m	struct:__cxxabiv1::__cxa_exception	access:public
terminateHandler	.\experimental\exception_tracer\ExceptionTracer.cpp	/^void terminateHandler() {$/;"	f	namespace:folly::exception_tracer::__anon24	signature:()
terminateLoopSoon	.\io\async\EventBase.cpp	/^void EventBase::terminateLoopSoon() {$/;"	f	class:folly::EventBase	signature:()
terminateLoopSoon	.\io\async\EventBase.h	/^  void terminateLoopSoon();$/;"	p	class:folly::EventBase	access:public	signature:()
test	.\AtomicBitSet.h	/^  bool test(size_t idx,$/;"	p	class:folly::AtomicBitSet	access:public	signature:(size_t idx, std::memory_order order = std::memory_order_seq_cst) const
test	.\AtomicBitSet.h	/^inline bool AtomicBitSet<N>::test(size_t idx, std::memory_order order) const {$/;"	f	class:folly::AtomicBitSet	signature:(size_t idx, std::memory_order order) const
test	.\Foreach.h	/^  template <typename, typename> static BiggerThanChar test(...);$/;"	p	class:folly::detail::HasLess	access:private	signature:(....)
test	.\Traits.h	/^  constexpr static bool test(sfinae<sizeof(U)>*) { return true; }$/;"	f	class:folly::is_complete	access:private	signature:(sfinae<sizeof(U)>*)
test	.\Traits.h	/^  template <typename> constexpr static bool test(...) { return false; }$/;"	f	class:folly::is_complete	access:private	signature:(....)
test	.\experimental\Bits.h	/^  static bool test(const T* p, size_t bit);$/;"	p	struct:folly::Bits	access:public	signature:(const T* p, size_t bit)
test	.\experimental\Bits.h	/^inline bool Bits<T, Traits>::test(const T* p, size_t bit) {$/;"	f	class:folly::Bits	signature:(const T* p, size_t bit)
test	.\experimental\TestUtil.cpp	/^namespace test {$/;"	n	namespace:folly	file:
test	.\experimental\TestUtil.h	/^namespace test {$/;"	n	namespace:folly
test	.\experimental\symbolizer\test\LineReaderTest.cpp	/^namespace folly { namespace symbolizer { namespace test {$/;"	n	namespace:folly::symbolizer	file:
test	.\experimental\symbolizer\test\SignalHandlerTest.cpp	/^namespace folly { namespace symbolizer { namespace test {$/;"	n	namespace:folly::symbolizer	file:
test	.\experimental\symbolizer\test\SignalHandlerTest.h	/^namespace folly { namespace symbolizer { namespace test {$/;"	n	namespace:folly::symbolizer
test	.\experimental\symbolizer\test\SymbolizerTest.cpp	/^namespace folly { namespace symbolizer { namespace test {$/;"	n	namespace:folly::symbolizer	file:
test	.\gen\Base-inl.h	/^  bool test(const Value& current) const { return current < end_; }$/;"	f	class:folly::gen::detail::RangeImpl	access:public	signature:(const Value& current) const
test	.\gen\Base-inl.h	/^  bool test(const Value& current) const { return current < end_; }$/;"	f	class:folly::gen::detail::RangeWithStepImpl	access:public	signature:(const Value& current) const
test	.\gen\Base-inl.h	/^  bool test(const Value& current) const { return current <= end_; }$/;"	f	class:folly::gen::detail::SeqImpl	access:public	signature:(const Value& current) const
test	.\gen\Base-inl.h	/^  bool test(const Value& current) const { return current <= end_; }$/;"	f	class:folly::gen::detail::SeqWithStepImpl	access:public	signature:(const Value& current) const
test	.\gen\Base-inl.h	/^  bool test(const Value& current) const { return true; }$/;"	f	class:folly::gen::detail::InfiniteImpl	access:public	signature:(const Value& current) const
test	.\io\test\CompressionTest.cpp	/^namespace folly { namespace io { namespace test {$/;"	n	namespace:folly::io	file:
test	.\io\test\RecordIOTest.cpp	/^namespace folly { namespace test {$/;"	n	namespace:folly	file:
test	.\test\AtomicBitSetTest.cpp	/^namespace folly { namespace test {$/;"	n	namespace:folly	file:
test	.\test\DeterministicSchedule.cpp	/^namespace folly { namespace test {$/;"	n	namespace:folly	file:
test	.\test\DeterministicSchedule.h	/^namespace folly { namespace test {$/;"	n	namespace:folly
test	.\test\ExceptionTest.cpp	/^namespace folly { namespace test {$/;"	n	namespace:folly	file:
test	.\test\FileUtilTest.cpp	/^namespace folly { namespace test {$/;"	n	namespace:folly	file:
test	.\test\HasMemberFnTraitsTest.cpp	/^  double test(int,long);$/;"	p	struct:Bar	file:	access:public	signature:(int,long)
test	.\test\HasMemberFnTraitsTest.cpp	/^  int test() const;$/;"	p	struct:Foo	file:	access:public	signature:() const
test	.\test\HasMemberFnTraitsTest.cpp	/^  int test();$/;"	p	struct:Bar	file:	access:public	signature:()
test	.\test\HasMemberFnTraitsTest.cpp	/^  int test();$/;"	p	struct:Foo	file:	access:public	signature:()
test	.\test\HasMemberFnTraitsTest.cpp	/^  long test(int) const;$/;"	p	struct:Bar	file:	access:public	signature:(int) const
test	.\test\HasMemberFnTraitsTest.cpp	/^  string test(const string&) const;$/;"	p	struct:Foo	file:	access:public	signature:(const string&) const
test	.\test\HasMemberFnTraitsTest.cpp	/^  void test() const volatile;$/;"	p	struct:CV	file:	access:public	signature:() const volatile
test	.\test\HasMemberFnTraitsTest.cpp	/^  void test() const volatile;$/;"	p	struct:Gaz	file:	access:public	signature:() const volatile
test	.\test\HasMemberFnTraitsTest.cpp	/^  void test() const;$/;"	p	struct:Const	file:	access:public	signature:() const
test	.\test\HasMemberFnTraitsTest.cpp	/^  void test() const;$/;"	p	struct:Gaz	file:	access:public	signature:() const
test	.\test\HasMemberFnTraitsTest.cpp	/^  void test() volatile;$/;"	p	struct:Gaz	file:	access:public	signature:() volatile
test	.\test\HasMemberFnTraitsTest.cpp	/^  void test() volatile;$/;"	p	struct:Volatile	file:	access:public	signature:() volatile
test	.\test\HasMemberFnTraitsTest.cpp	/^  void test();$/;"	p	struct:Gaz	file:	access:public	signature:()
test	.\test\HasMemberFnTraitsTest.cpp	/^  void test();$/;"	p	struct:NoCV	file:	access:public	signature:()
test	.\test\MPMCPipelineTest.cpp	/^namespace folly { namespace test {$/;"	n	namespace:folly	file:
test	.\test\VarintTest.cpp	/^namespace folly { namespace test {$/;"	n	namespace:folly	file:
test	.\wangle\test\thens.rb	/^def test(*args)$/;"	f
test128Bit2String	.\test\ConvTest.cpp	/^void test128Bit2String() {$/;"	f	signature:()
testAll	.\experimental\test\CodingTestUtils.h	/^void testAll(const std::vector<uint32_t>& data) {$/;"	f	namespace:folly::compression	signature:(const std::vector<uint32_t>& data)
testAllocSize	.\io\test\IOBufTest.cpp	/^void testAllocSize(uint32_t requestedCapacity) {$/;"	f	signature:(uint32_t requestedCapacity)
testArgs	.\gen\Core-inl.h	/^  static constexpr bool testArgs(...) {$/;"	f	class:folly::gen::IsCompatibleSignature	access:private	signature:(....)
testArgs	.\gen\Core-inl.h	/^  static constexpr bool testArgs(int* p) {$/;"	f	class:folly::gen::IsCompatibleSignature	access:private	signature:(int* p)
testBasic	.\test\SynchronizedTestLib-inl.h	/^void testBasic() {$/;"	f	signature:()
testBasic	.\test\SynchronizedTestLib.h	/^template <class Mutex> void testBasic();$/;"	p	signature:()
testCRC32C	.\test\ChecksumTest.cpp	/^void testCRC32C($/;"	f	namespace:__anon112	signature:( std::function<uint32_t(const uint8_t*, size_t, uint32_t)> impl)
testCRC32CContinuation	.\test\ChecksumTest.cpp	/^void testCRC32CContinuation($/;"	f	namespace:__anon112	signature:( std::function<uint32_t(const uint8_t*, size_t, uint32_t)> impl)
testCmp	.\test\MacAddressTest.cpp	/^void testCmp(const char* str1, const char* str2) {$/;"	f	signature:(const char* str1, const char* str2)
testConcatenation	.\experimental\test\BitsTest.cpp	/^void testConcatenation() {$/;"	f	signature:()
testConcurrency	.\test\SynchronizedTestLib-inl.h	/^template <class Mutex> void testConcurrency() {$/;"	f	signature:()
testConcurrency	.\test\SynchronizedTestLib.h	/^template <class Mutex> void testConcurrency();$/;"	p	signature:()
testConcurrentAccess	.\test\ConcurrentSkipListTest.cpp	/^static void testConcurrentAccess($/;"	f	namespace:__anon114	signature:( int numInsertions, int numDeletions, int maxValue)
testConcurrentAdd	.\test\ConcurrentSkipListTest.cpp	/^void testConcurrentAdd(int numThreads) {$/;"	f	namespace:__anon114	signature:(int numThreads)
testConcurrentRemoval	.\test\ConcurrentSkipListTest.cpp	/^void testConcurrentRemoval(int numThreads, int maxValue) {$/;"	f	namespace:__anon114	signature:(int numThreads, int maxValue)
testConstCopy	.\test\SynchronizedTestLib-inl.h	/^template <class Mutex> void testConstCopy() {$/;"	f	signature:()
testConstCopy	.\test\SynchronizedTestLib.h	/^template <class Mutex> void testConstCopy();$/;"	p	signature:()
testData	.\test\TimeseriesTest.cpp	/^vector<TestData> testData = {$/;"	v
testData_	.\test\ProducerConsumerQueueTest.cpp	/^  std::vector<T> testData_;$/;"	m	struct:__anon128::CorrectnessTest	file:	access:public
testDoubleToString	.\test\ConvTest.cpp	/^void testDoubleToString() {$/;"	f	signature:()
testDualLocking	.\test\SynchronizedTestLib-inl.h	/^template <class Mutex> void testDualLocking() {$/;"	f	signature:()
testDualLocking	.\test\SynchronizedTestLib.h	/^template <class Mutex> void testDualLocking();$/;"	p	signature:()
testDualLockingWithConst	.\test\SynchronizedTestLib-inl.h	/^template <class Mutex> void testDualLockingWithConst() {$/;"	f	signature:()
testDualLockingWithConst	.\test\SynchronizedTestLib.h	/^template <class Mutex> void testDualLockingWithConst();$/;"	p	signature:()
testEmpty	.\experimental\test\CodingTestUtils.h	/^void testEmpty() {$/;"	f	namespace:folly::compression	signature:()
testEraseEraseThread	.\test\AtomicHashMapTest.cpp	/^void* testEraseEraseThread(void*) {$/;"	f	namespace:__anon107	signature:(void*)
testEraseInsertThread	.\test\AtomicHashMapTest.cpp	/^void* testEraseInsertThread(void*) {$/;"	f	namespace:__anon107	signature:(void*)
testExceptionPtr1	.\experimental\exception_tracer\ExceptionTracerTest.cpp	/^void testExceptionPtr1() {$/;"	f	signature:()
testExceptionPtr2	.\experimental\exception_tracer\ExceptionTracerTest.cpp	/^void testExceptionPtr2() {$/;"	f	signature:()
testFFS	.\test\BitsTest.cpp	/^void testFFS() {$/;"	f	namespace:__anon111	signature:()
testFLS	.\test\BitsTest.cpp	/^void testFLS() {$/;"	f	namespace:__anon111	signature:()
testFinally	.\test\ScopeGuardTest.cpp	/^void testFinally(ErrorBehavior error) {$/;"	f	signature:(ErrorBehavior error)
testFreeFn	.\io\test\IOBufTest.cpp	/^void testFreeFn(void* buffer, void* ptr) {$/;"	f	signature:(void* buffer, void* ptr)
testFromBinary	.\test\MacAddressTest.cpp	/^void testFromBinary(const char* str, uint64_t expectedHBO) {$/;"	f	signature:(const char* str, uint64_t expectedHBO)
testGet	.\experimental\test\BitsTest.cpp	/^typename std::enable_if<!aligned, T>::type testGet(uint8_t *buf,$/;"	f	namespace:__anon45	signature:(uint8_t *buf, size_t start, size_t bits)
testGet	.\experimental\test\BitsTest.cpp	/^typename std::enable_if<aligned, T>::type testGet(uint8_t *buf,$/;"	f	namespace:__anon45	signature:(uint8_t *buf, size_t start, size_t bits)
testGroupVarint32	.\test\GroupVarintTest.cpp	/^void testGroupVarint32(uint32_t a, uint32_t b, uint32_t c, uint32_t d, ...) {$/;"	f	namespace:__anon121	signature:(uint32_t a, uint32_t b, uint32_t c, uint32_t d, ...)
testGroupVarint64	.\test\GroupVarintTest.cpp	/^void testGroupVarint64(uint64_t a, uint64_t b, uint64_t c, uint64_t d,$/;"	f	namespace:__anon121	signature:(uint64_t a, uint64_t b, uint64_t c, uint64_t d, uint64_t e, ...)
testIdenticalTo	.\test\ConvTest.cpp	/^void testIdenticalTo() {$/;"	f	signature:()
testIdenticalToDelim	.\test\ConvTest.cpp	/^void testIdenticalToDelim() {$/;"	f	signature:()
testIntegral2String	.\test\ConvTest.cpp	/^void testIntegral2String() {$/;"	f	signature:()
testJump	.\experimental\test\CodingTestUtils.h	/^void testJump(const std::vector<uint32_t>& data, const List& list) {$/;"	f	namespace:folly::compression	signature:(const std::vector<uint32_t>& data, const List& list)
testJumpTo	.\experimental\test\CodingTestUtils.h	/^void testJumpTo(const std::vector<uint32_t>& data, const List& list) {$/;"	f	namespace:folly::compression	signature:(const std::vector<uint32_t>& data, const List& list)
testMAC	.\test\MacAddressTest.cpp	/^void testMAC(const std::string& str, uint64_t expectedHBO) {$/;"	f	signature:(const std::string& str, uint64_t expectedHBO)
testMap	.\test\AtomicHashArrayTest.cpp	/^void testMap() {$/;"	f	signature:()
testNext	.\experimental\test\CodingTestUtils.h	/^void testNext(const std::vector<uint32_t>& data, const List& list) {$/;"	f	namespace:folly::compression	signature:(const std::vector<uint32_t>& data, const List& list)
testNoncopyableMap	.\test\AtomicHashArrayTest.cpp	/^void testNoncopyableMap() {$/;"	f	signature:()
testPowTwo	.\test\BitsTest.cpp	92;"	d	file:
testRangeFunc	.\test\RangeTest.cpp	/^void testRangeFunc(C&& x, size_t n) {$/;"	f	signature:(C&& x, size_t n)
testReads	.\experimental\io\test\AsyncIOTest.cpp	/^void testReads(const std::vector<TestSpec>& specs,$/;"	f	namespace:__anon32	signature:(const std::vector<TestSpec>& specs, AsyncIO::PollMode pollMode)
testReadsParallel	.\experimental\io\test\AsyncIOTest.cpp	/^void testReadsParallel(const std::vector<TestSpec>& specs,$/;"	f	namespace:__anon32	signature:(const std::vector<TestSpec>& specs, AsyncIO::PollMode pollMode, bool multithreaded)
testReadsQueued	.\experimental\io\test\AsyncIOTest.cpp	/^void testReadsQueued(const std::vector<TestSpec>& specs,$/;"	f	namespace:__anon32	signature:(const std::vector<TestSpec>& specs, AsyncIO::PollMode pollMode)
testReadsSerially	.\experimental\io\test\AsyncIOTest.cpp	/^void testReadsSerially(const std::vector<TestSpec>& specs,$/;"	f	namespace:__anon32	signature:(const std::vector<TestSpec>& specs, AsyncIO::PollMode pollMode)
testScopeFailAndScopeSuccess	.\test\ScopeGuardTest.cpp	/^void testScopeFailAndScopeSuccess(ErrorBehavior error, bool expectFail) {$/;"	f	signature:(ErrorBehavior error, bool expectFail)
testSet	.\experimental\test\BitsTest.cpp	/^typename std::enable_if<!aligned>::type testSet(uint8_t *buf,$/;"	f	namespace:__anon45	signature:(uint8_t *buf, size_t start, size_t bits, T value)
testSet	.\experimental\test\BitsTest.cpp	/^typename std::enable_if<aligned>::type testSet(uint8_t *buf,$/;"	f	namespace:__anon45	signature:(uint8_t *buf, size_t start, size_t bits, T value)
testSetFromSocket	.\test\SocketAddressTest.cpp	/^void testSetFromSocket(const SocketAddress *serverBindAddr,$/;"	f	signature:(const SocketAddress *serverBindAddr, const SocketAddress *clientBindAddr, SocketAddress *listenAddrRet, SocketAddress *acceptAddrRet, SocketAddress *serverAddrRet, SocketAddress *serverPeerAddrRet, SocketAddress *clientAddrRet, SocketAddress *clientPeerAddrRet)
testSkip	.\experimental\test\CodingTestUtils.h	/^void testSkip(const std::vector<uint32_t>& data, const List& list) {$/;"	f	namespace:folly::compression	signature:(const std::vector<uint32_t>& data, const List& list)
testSkip	.\experimental\test\CodingTestUtils.h	/^void testSkip(const std::vector<uint32_t>& data, const List& list,$/;"	f	namespace:folly::compression	signature:(const std::vector<uint32_t>& data, const List& list, size_t skipStep)
testSkipTo	.\experimental\test\CodingTestUtils.h	/^void testSkipTo(const std::vector<uint32_t>& data, const List& list) {$/;"	f	namespace:folly::compression	signature:(const std::vector<uint32_t>& data, const List& list)
testSkipTo	.\experimental\test\CodingTestUtils.h	/^void testSkipTo(const std::vector<uint32_t>& data, const List& list,$/;"	f	namespace:folly::compression	signature:(const std::vector<uint32_t>& data, const List& list, size_t skipToStep)
testStr2Bool	.\test\ConvTest.cpp	/^void testStr2Bool() {$/;"	f	signature:()
testStrVector	.\gen\test\StringBenchmark.cpp	/^static vector<fbstring> testStrVector$/;"	m	namespace:__anon58	file:
testString2Integral	.\test\ConvTest.cpp	/^void testString2Integral() {$/;"	f	signature:()
testTemporaryDirectory	.\experimental\test\TestUtilTest.cpp	/^void testTemporaryDirectory(TemporaryDirectory::Scope scope) {$/;"	f	signature:(TemporaryDirectory::Scope scope)
testTimedSynchronized	.\test\SynchronizedTestLib-inl.h	/^template <class Mutex> void testTimedSynchronized() {$/;"	f	signature:()
testTimedSynchronized	.\test\SynchronizedTestLib.h	/^template <class Mutex> void testTimedSynchronized();$/;"	p	signature:()
testTimedSynchronizedWithConst	.\test\SynchronizedTestLib-inl.h	/^template <class Mutex> void testTimedSynchronizedWithConst() {$/;"	f	signature:()
testTimedSynchronizedWithConst	.\test\SynchronizedTestLib.h	/^template <class Mutex> void testTimedSynchronizedWithConst();$/;"	p	signature:()
testToLowerAscii	.\test\StringTest.cpp	/^void testToLowerAscii(Range<const char*> src) {$/;"	f	namespace:__anon139	signature:(Range<const char*> src)
testUndoAction	.\test\ScopeGuardTest.cpp	/^void testUndoAction(bool failure) {$/;"	f	signature:(bool failure)
testUpdate100x10	.\test\TimeseriesTest.cpp	/^void testUpdate100x10(size_t offset) {$/;"	f	signature:(size_t offset)
testValue	.\experimental\test\BitsTest.cpp	/^T testValue(int bits) {$/;"	f	namespace:__anon45	signature:(int bits)
testVariadicTo	.\test\ConvTest.cpp	/^void testVariadicTo() {$/;"	f	signature:()
testVariadicToDelim	.\test\ConvTest.cpp	/^void testVariadicToDelim() {$/;"	f	signature:()
testVarint	.\test\VarintTest.cpp	/^void testVarint(uint64_t val, std::initializer_list<uint8_t> bytes) {$/;"	f	namespace:folly::test	signature:(uint64_t val, std::initializer_list<uint8_t> bytes)
testVector	.\gen\test\BaseBenchmark.cpp	/^static vector<int> testVector =$/;"	v	file:
testVectorVector	.\gen\test\BaseBenchmark.cpp	/^static vector<vector<int>> testVectorVector =$/;"	v	file:
test_operator_on_search	.\test\AsciiCaseInsensitiveBenchmark.cpp	/^inline void test_operator_on_search(int iters) {$/;"	f	signature:(int iters)
testingCpu	.\test\CacheLocalityTest.cpp	/^static FOLLY_TLS unsigned testingCpu = 0;$/;"	v	file:
testingGetcpu	.\test\CacheLocalityTest.cpp	/^static int testingGetcpu(unsigned* cpu, unsigned* node, void* unused) {$/;"	f	file:	signature:(unsigned* cpu, unsigned* node, void* unused)
texsformat	.\test\FormatTest.cpp	/^  friend std::string texsformat(StringPiece fmt, A&&... arg);$/;"	p	class:TestExtendingFormatter	file:	access:friend	signature:(StringPiece fmt, A&&... arg)
texsformat	.\test\FormatTest.cpp	/^std::string texsformat(StringPiece fmt, Args&&... args) {$/;"	f	signature:(StringPiece fmt, Args&&... args)
tg	.\wangle\test\ThreadGateTest.cpp	/^    shared_ptr<ManualWaiter>> tg;$/;"	m	struct:GenericThreadGateFixture	file:	access:public
then	.\wangle\Future-inl.h	/^Future<T>::then(F&& func) {$/;"	f	class:folly::wangle::Future	signature:(F&& func)
then	.\wangle\Future-inl.h	/^Future<void> Future<T>::then() {$/;"	f	class:folly::wangle::Future	signature:()
then	.\wangle\Future.h	/^  Future<void> then();$/;"	p	class:folly::wangle::Future	access:public	signature:()
then	.\wangle\Future.h	/^  inline then(Caller *instance, R(Caller::*func)(Try<T>&&)) {$/;"	f	class:folly::wangle::Future::std::enable_if	access:public	signature:(Caller *instance, R(Caller::*func)(Try<T>&&))
then	.\wangle\Future.h	/^  inline then(R(*func)(Try<T>&&)) {$/;"	f	class:folly::wangle::Future::std::enable_if	access:public	signature:(R(func)Try<T>&&))
then	.\wangle\Future.h	/^  then(F&& func);$/;"	p	class:folly::wangle::Future	access:public	signature:(F&& func)
then	.\wangle\Later-inl.h	/^Later<T>::then(F&& fn) {$/;"	f	class:folly::wangle::Later	signature:(F&& fn)
then	.\wangle\Later.h	/^  inline then(Caller *instance, R(Caller::*func)(Try<T>&&)) {$/;"	f	class:folly::wangle::Later::std::enable_if	access:public	signature:(Caller *instance, R(Caller::*func)(Try<T>&&))
then	.\wangle\Later.h	/^  inline then(R(*func)(Try<T>&&)) {$/;"	f	class:folly::wangle::Later::std::enable_if	access:public	signature:(R(func)Try<T>&&))
then	.\wangle\Later.h	/^  then(F&& fn);$/;"	p	class:folly::wangle::Later	access:public	signature:(F&& fn)
thousandsSeparator	.\FormatArg.h	/^  bool thousandsSeparator;$/;"	m	struct:folly::FormatArg	access:public
thread	.\test\DeterministicSchedule.h	/^  static inline std::thread thread(Func&& func, Args&&... args) {$/;"	f	class:folly::test::DeterministicSchedule	access:public	signature:(Func&& func, Args&&... args)
threadEntry_	.\detail\ThreadLocalDetail.h	/^  static FOLLY_TLS ThreadEntry threadEntry_;$/;"	m	struct:folly::threadlocal_detail::StaticMeta	access:public
threadFactory_	.\experimental\wangle\concurrent\ThreadPoolExecutor.h	/^  std::unique_ptr<ThreadFactory> threadFactory_;$/;"	m	class:folly::wangle::ThreadPoolExecutor	access:protected
threadListLock_	.\experimental\wangle\concurrent\ThreadPoolExecutor.h	/^  RWSpinLock threadListLock_;$/;"	m	class:folly::wangle::ThreadPoolExecutor	access:protected
threadList_	.\experimental\wangle\concurrent\ThreadPoolExecutor.h	/^  ThreadList threadList_;$/;"	m	class:folly::wangle::ThreadPoolExecutor	access:protected
threadRun	.\experimental\wangle\concurrent\CPUThreadPoolExecutor.cpp	/^void CPUThreadPoolExecutor::threadRun(std::shared_ptr<Thread> thread) {$/;"	f	class:folly::wangle::CPUThreadPoolExecutor	signature:(std::shared_ptr<Thread> thread)
threadRun	.\experimental\wangle\concurrent\IOThreadPoolExecutor.cpp	/^void IOThreadPoolExecutor::threadRun(ThreadPtr thread) {$/;"	f	class:folly::wangle::IOThreadPoolExecutor	signature:(ThreadPtr thread)
threadRun	.\experimental\wangle\concurrent\ThreadPoolExecutor.h	/^  virtual void threadRun(ThreadPtr thread) = 0;$/;"	p	class:folly::wangle::ThreadPoolExecutor	access:protected	signature:(ThreadPtr thread)
threadlocal_detail	.\detail\ThreadLocalDetail.h	/^namespace threadlocal_detail {$/;"	n	namespace:folly
threads_	.\gen\Parallel-inl.h	/^    const size_t threads_;$/;"	m	class:folly::gen::detail::Parallel::Generator	access:private
threads_	.\gen\Parallel-inl.h	/^  size_t threads_;$/;"	m	class:folly::gen::detail::Parallel	access:private
throw	.\FBString.h	2459;"	d
throw	.\FBString.h	89;"	d
throwCounter	.\test\small_vector_test.cpp	/^int throwCounter = 1;$/;"	m	namespace:__anon132	file:
throwException	.\ExceptionWrapper.h	/^  void throwException() const {$/;"	f	class:folly::exception_wrapper	access:public	signature:() const
throwException	.\test\function_benchmark\test_functions.cpp	/^void throwException() {$/;"	f	signature:()
throwException	.\test\function_benchmark\test_functions.h	/^void throwException();$/;"	p	signature:()
throwIfFailed	.\wangle\Try-inl.h	/^void Try<T>::throwIfFailed() const {$/;"	f	class:folly::wangle::Try	signature:() const
throwIfFailed	.\wangle\Try-inl.h	/^void Try<void>::throwIfFailed() const {$/;"	f	class:folly::wangle::Try	signature:() const
throwIfFailed	.\wangle\Try.h	/^  inline void throwIfFailed() const;$/;"	p	class:folly::wangle::Try	access:public	signature:() const
throwIfFailed	.\wangle\Try.h	/^  void throwIfFailed() const;$/;"	p	class:folly::wangle::Try	access:public	signature:() const
throwIfFulfilled	.\wangle\Promise-inl.h	/^void Promise<T>::throwIfFulfilled() {$/;"	f	class:folly::wangle::Promise	signature:()
throwIfFulfilled	.\wangle\Promise.h	/^  void throwIfFulfilled();$/;"	p	class:folly::wangle::Promise	access:private	signature:()
throwIfInvalid	.\wangle\Future-inl.h	/^void Future<T>::throwIfInvalid() const {$/;"	f	class:folly::wangle::Future	signature:() const
throwIfInvalid	.\wangle\Future.h	/^  void throwIfInvalid() const;$/;"	p	class:folly::wangle::Future	access:private	signature:() const
throwIfRetrieved	.\wangle\Promise-inl.h	/^void Promise<T>::throwIfRetrieved() {$/;"	f	class:folly::wangle::Promise	signature:()
throwIfRetrieved	.\wangle\Promise.h	/^  void throwIfRetrieved();$/;"	p	class:folly::wangle::Promise	access:private	signature:()
throwOnFail	.\Exception.h	/^void throwOnFail(V&& value, Args&&... args) {$/;"	f	namespace:folly	signature:(V&& value, Args&&... args)
throwSystemError	.\Exception.h	/^FOLLY_NORETURN void throwSystemError(Args&&... args);$/;"	p	namespace:folly	signature:(Args&&.... args)
throwSystemError	.\Exception.h	/^void throwSystemError(Args&&... args) {$/;"	f	namespace:folly	signature:(Args&&.... args)
throwSystemErrorExplicit	.\Exception.h	/^FOLLY_NORETURN void throwSystemErrorExplicit(int err, const char*);$/;"	p	namespace:folly	signature:(int err, const char*)
throwSystemErrorExplicit	.\Exception.h	/^FOLLY_NORETURN void throwSystemErrorExplicit(int, Args&&... args);$/;"	p	namespace:folly	signature:(int, Args&&... args)
throwSystemErrorExplicit	.\Exception.h	/^inline void throwSystemErrorExplicit(int err, const char* msg) {$/;"	f	namespace:folly	signature:(int err, const char* msg)
throwSystemErrorExplicit	.\Exception.h	/^void throwSystemErrorExplicit(int err, Args&&... args) {$/;"	f	namespace:folly	signature:(int err, Args&&... args)
throwfn_	.\ExceptionWrapper.h	/^  void (*throwfn_)(std::exception*);$/;"	m	class:folly::exception_wrapper	access:protected
ti_	.\experimental\Singleton.h	/^  const std::type_index ti_;$/;"	m	class:folly::detail::TypeDescriptor	access:private
ticket	.\RWSpinLock.h	/^  } ticket;$/;"	m	class:folly::RWTicketSpinLockT	typeref:union:folly::RWTicketSpinLockT::RWTicket	access:private
time	.\wangle\ManualExecutor.h	/^      TimePoint time;$/;"	m	struct:folly::wangle::ManualExecutor::ScheduledAction	access:public
timePointToTimeSpec	.\detail\Futex.h	/^struct timespec timePointToTimeSpec(const time_point<Clock, Duration>& tp) {$/;"	f	namespace:folly::detail	signature:(const time_point<Clock, Duration>& tp)
timeToWheelTicks	.\io\async\HHWheelTimer.h	/^  uint32_t timeToWheelTicks(std::chrono::milliseconds t) {$/;"	f	class:folly::HHWheelTimer	access:private	signature:(std::chrono::milliseconds t)
time_cost_	.\test\ProducerConsumerQueueBenchmark.cpp	/^  int time_cost_;$/;"	m	struct:__anon127::LatencyTest	file:	access:public
time_point	.\test\MemoryIdlerTest.cpp	/^  typedef std::chrono::steady_clock::time_point time_point;$/;"	t	struct:MockClock	file:	access:public
timedAcquire	.\Synchronized.h	/^  ConstLockedPtr timedAcquire(unsigned int milliseconds) const {$/;"	f	struct:folly::Synchronized	access:public	signature:(unsigned int milliseconds) const
timedAcquire	.\Synchronized.h	/^  LockedPtr timedAcquire(unsigned int milliseconds) {$/;"	f	struct:folly::Synchronized	access:public	signature:(unsigned int milliseconds)
timed_wait	.\Baton.h	/^  bool timed_wait(const std::chrono::time_point<Clock,Duration>& deadline) {$/;"	f	struct:folly::Baton	access:public	signature:(const std::chrono::time_point<Clock,Duration>& deadline)
timeoutManager_	.\io\async\AsyncTimeout.h	/^  TimeoutManager* timeoutManager_;$/;"	m	class:folly::AsyncTimeout	access:private
timeout_	.\experimental\wangle\ConnectionManager.h	/^  std::chrono::milliseconds timeout_;$/;"	m	class:folly::wangle::ConnectionManager	access:private
timeouts_	.\TimeoutQueue.h	/^  Set timeouts_;$/;"	m	class:folly::TimeoutQueue	access:private
timespecDiff	.\Benchmark.h	/^inline uint64_t timespecDiff(timespec end, timespec start) {$/;"	f	namespace:folly::detail	signature:(timespec end, timespec start)
timespecDiff	.\Benchmark.h	/^inline uint64_t timespecDiff(timespec end, timespec start,$/;"	f	namespace:folly::detail	signature:(timespec end, timespec start, timespec endCoarse, timespec startCoarse)
tl	.\test\ThreadLocalTest.cpp	/^  folly::ThreadLocal<int, Tag> tl;$/;"	m	struct:__anon145::Foo	file:	access:public
tlp	.\test\ThreadLocalTest.cpp	/^REG(tlp);$/;"	v
tlp	.\test\ThreadLocalTest.cpp	/^ThreadLocalPtr<int> tlp;$/;"	v
tlp_	.\ThreadLocal.h	/^  mutable ThreadLocalPtr<T,Tag> tlp_;$/;"	m	class:folly::ThreadLocal	access:private
tls_sched	.\test\DeterministicSchedule.cpp	/^FOLLY_TLS DeterministicSchedule* DeterministicSchedule::tls_sched;$/;"	m	class:folly::test::DeterministicSchedule	file:
tls_sched	.\test\DeterministicSchedule.h	/^  static FOLLY_TLS DeterministicSchedule* tls_sched;$/;"	m	class:folly::test::DeterministicSchedule	access:private
tls_sem	.\test\DeterministicSchedule.cpp	/^FOLLY_TLS sem_t* DeterministicSchedule::tls_sem;$/;"	m	class:folly::test::DeterministicSchedule	file:
tls_sem	.\test\DeterministicSchedule.h	/^  static FOLLY_TLS sem_t* tls_sem;$/;"	m	class:folly::test::DeterministicSchedule	access:private
tls_stackLimit	.\detail\MemoryIdler.cpp	/^static FOLLY_TLS uintptr_t tls_stackLimit;$/;"	m	namespace:folly::detail	file:
tls_stackSize	.\detail\MemoryIdler.cpp	/^static FOLLY_TLS size_t tls_stackSize;$/;"	m	namespace:folly::detail	file:
tmp_	.\GroupVarint.h	/^  char tmp_[2 * Base::kMaxSize];$/;"	m	class:folly::GroupVarintDecoder	access:private
tmp_	.\GroupVarint.h	/^  char tmp_[Base::kMaxSize];$/;"	m	class:folly::GroupVarintEncoder	access:private
to	.\ConcurrentSkipList.h	/^  bool to(const value_type &data) {$/;"	f	class:folly::ConcurrentSkipList::Skipper	access:public	signature:(const value_type &data)
to	.\Conv.h	/^to(const Src & value) {$/;"	f	namespace:folly	signature:(const Src & value)
toAddr	.\IPAddressV4.h	/^  in_addr toAddr() const { return addr_.inAddr_; }$/;"	f	class:folly::IPAddressV4	access:public	signature:() const
toAddr	.\IPAddressV6.h	/^  in6_addr toAddr() const { return addr_.in6Addr_; }$/;"	f	class:folly::IPAddressV6	access:public	signature:() const
toAppend	.\Conv.h	/^toAppend(Src value, Tgt * result) {$/;"	f	namespace:folly	signature:(Src value, Tgt * result)
toAppend	.\Conv.h	/^toAppend(StringPiece value, Tgt * result) {$/;"	f	namespace:folly	signature:(StringPiece value, Tgt * result)
toAppend	.\Conv.h	/^toAppend(__int128 value, Tgt * result) {$/;"	f	namespace:folly	signature:(__int128 value, Tgt * result)
toAppend	.\Conv.h	/^toAppend(const Src& value, Tgt * result) {$/;"	f	namespace:folly	signature:(const Src& value, Tgt * result)
toAppend	.\Conv.h	/^toAppend(const fbstring& value, Tgt * result) {$/;"	f	namespace:folly	signature:(const fbstring& value, Tgt * result)
toAppend	.\Conv.h	/^toAppend(unsigned __int128 value, Tgt * result) {$/;"	f	namespace:folly	signature:(unsigned __int128 value, Tgt * result)
toAppend	.\Conv.h	/^void toAppend(char value, Tgt * result) {$/;"	f	namespace:folly	signature:(char value, Tgt * result)
toAppend	.\IPAddress.cpp	/^void toAppend(IPAddress addr, fbstring* result) {$/;"	f	namespace:folly	signature:(IPAddress addr, fbstring* result)
toAppend	.\IPAddress.cpp	/^void toAppend(IPAddress addr, string* result) {$/;"	f	namespace:folly	signature:(IPAddress addr, string* result)
toAppend	.\IPAddress.h	/^void toAppend(IPAddress addr, fbstring* result);$/;"	p	namespace:folly	signature:(IPAddress addr, fbstring* result)
toAppend	.\IPAddress.h	/^void toAppend(IPAddress addr, std::string* result);$/;"	p	namespace:folly	signature:(IPAddress addr, std::string* result)
toAppend	.\IPAddressV4.cpp	/^void toAppend(IPAddressV4 addr, fbstring* result) {$/;"	f	namespace:folly	signature:(IPAddressV4 addr, fbstring* result)
toAppend	.\IPAddressV4.cpp	/^void toAppend(IPAddressV4 addr, string* result) {$/;"	f	namespace:folly	signature:(IPAddressV4 addr, string* result)
toAppend	.\IPAddressV4.h	/^void toAppend(IPAddressV4 addr, fbstring* result);$/;"	p	namespace:folly	signature:(IPAddressV4 addr, fbstring* result)
toAppend	.\IPAddressV4.h	/^void toAppend(IPAddressV4 addr, std::string* result);$/;"	p	namespace:folly	signature:(IPAddressV4 addr, std::string* result)
toAppend	.\IPAddressV6.cpp	/^void toAppend(IPAddressV6 addr, fbstring* result) {$/;"	f	namespace:folly	signature:(IPAddressV6 addr, fbstring* result)
toAppend	.\IPAddressV6.cpp	/^void toAppend(IPAddressV6 addr, string* result) {$/;"	f	namespace:folly	signature:(IPAddressV6 addr, string* result)
toAppend	.\IPAddressV6.h	/^void toAppend(IPAddressV6 addr, fbstring* result);$/;"	p	namespace:folly	signature:(IPAddressV6 addr, fbstring* result)
toAppend	.\IPAddressV6.h	/^void toAppend(IPAddressV6 addr, std::string* result);$/;"	p	namespace:folly	signature:(IPAddressV6 addr, std::string* result)
toAppend	.\MacAddress.h	/^toAppend(MacAddress address, Tgt* result) {$/;"	f	namespace:folly	signature:(MacAddress address, Tgt* result)
toBuffer	.\experimental\symbolizer\Dwarf.cpp	/^size_t Dwarf::Path::toBuffer(char* buf, size_t bufSize) const {$/;"	f	class:folly::symbolizer::Dwarf::Path	signature:(char* buf, size_t bufSize) const
toBuffer	.\experimental\symbolizer\Dwarf.h	/^    size_t toBuffer(char* buf, size_t bufSize) const;$/;"	p	class:folly::symbolizer::Dwarf::Path	access:public	signature:(char* buf, size_t bufSize) const
toByteArray	.\IPAddressV4.h	/^  ByteArray4 toByteArray() const {$/;"	f	class:folly::IPAddressV4	access:public	signature:() const
toByteArray	.\IPAddressV6.h	/^  ByteArray16 toByteArray() const {$/;"	f	class:folly::IPAddressV6	access:public	signature:() const
toDynamic	.\DynamicConverter.h	/^  template <typename T> dynamic toDynamic(const T&);$/;"	p	namespace:folly	signature:(const T&)
toDynamic	.\DynamicConverter.h	/^dynamic toDynamic(const T& x) {$/;"	f	namespace:folly	signature:(const T& x)
toFbstring	.\Range.h	/^  fbstring toFbstring() const { return fbstr(); }$/;"	f	class:folly::Range	access:public	signature:() const
toFile	.\gen\File.h	/^S toFile(File file, size_t bufferSize=4096) {$/;"	f	namespace:folly::gen	signature:(File file, size_t bufferSize=4096)
toFile	.\gen\File.h	/^S toFile(File file, std::unique_ptr<IOBuf> buffer) {$/;"	f	namespace:folly::gen	signature:(File file, std::unique_ptr<IOBuf> buffer)
toFullyQualified	.\IPAddress.h	/^  std::string toFullyQualified() const {$/;"	f	class:folly::IPAddress	access:public	signature:() const
toFullyQualified	.\IPAddressV4.h	/^  std::string toFullyQualified() const { return str(); }$/;"	f	class:folly::IPAddressV4	access:public	signature:() const
toFullyQualified	.\IPAddressV6.cpp	/^string IPAddressV6::toFullyQualified() const {$/;"	f	class:folly::IPAddressV6	signature:() const
toFullyQualified	.\IPAddressV6.h	/^  std::string toFullyQualified() const;$/;"	p	class:folly::IPAddressV6	access:public	signature:() const
toHex	.\detail\IPAddress.h	/^  static std::string toHex(const uint8_t* src, std::size_t len) {$/;"	f	struct:folly::detail::Bytes	access:public	signature:(const uint8_t* src, std::size_t len)
toInteger	.\RWSpinLock.h	/^  static inline uint32_t toInteger(__m128i in) {$/;"	f	struct:folly::detail::RWTicketIntTrait	access:public	signature:(__m128i in)
toInteger	.\RWSpinLock.h	/^  static inline uint64_t toInteger(__m128i in) {$/;"	f	struct:folly::detail::RWTicketIntTrait	access:public	signature:(__m128i in)
toJson	.\IPAddress.h	/^  std::string toJson() const {$/;"	f	class:folly::IPAddress	access:public	signature:() const
toJson	.\IPAddressV4.cpp	/^string IPAddressV4::toJson() const {$/;"	f	class:folly::IPAddressV4	signature:() const
toJson	.\IPAddressV4.h	/^  std::string toJson() const;$/;"	p	class:folly::IPAddressV4	access:public	signature:() const
toJson	.\IPAddressV6.cpp	/^string IPAddressV6::toJson() const {$/;"	f	class:folly::IPAddressV6	signature:() const
toJson	.\IPAddressV6.h	/^  std::string toJson() const;$/;"	p	class:folly::IPAddressV6	access:public	signature:() const
toJson	.\json.cpp	/^fbstring toJson(dynamic const& dyn) {$/;"	f	namespace:folly	signature:(dynamic const& dyn)
toJson	.\json.h	/^fbstring toJson(dynamic const&);$/;"	p	namespace:folly	signature:(dynamic const&)
toLong	.\IPAddressV4.cpp	/^uint32_t IPAddressV4::toLong(StringPiece ip) {$/;"	f	class:folly::IPAddressV4	signature:(StringPiece ip)
toLong	.\IPAddressV4.h	/^  static uint32_t toLong(StringPiece ip);$/;"	p	class:folly::IPAddressV4	access:public	signature:(StringPiece ip)
toLong	.\IPAddressV4.h	/^  uint32_t toLong() const {$/;"	f	class:folly::IPAddressV4	access:public	signature:() const
toLongHBO	.\IPAddressV4.cpp	/^uint32_t IPAddressV4::toLongHBO(StringPiece ip) {$/;"	f	class:folly::IPAddressV4	signature:(StringPiece ip)
toLongHBO	.\IPAddressV4.h	/^  static uint32_t toLongHBO(StringPiece ip);$/;"	p	class:folly::IPAddressV4	access:public	signature:(StringPiece ip)
toLongHBO	.\IPAddressV4.h	/^  uint32_t toLongHBO() const {$/;"	f	class:folly::IPAddressV4	access:public	signature:() const
toLower	.\Uri.cpp	/^void toLower(String& s) {$/;"	f	namespace:folly::__anon153	signature:(String& s)
toLowerAscii	.\String.cpp	/^void toLowerAscii(char* str, size_t length) {$/;"	f	namespace:folly	signature:(char* str, size_t length)
toLowerAscii	.\String.h	/^inline void toLowerAscii(MutableStringPiece str) {$/;"	f	class:folly::UriEscapeMode	access:private	signature:(MutableStringPiece str)
toLowerAscii	.\String.h	/^void toLowerAscii(char* str, size_t length);$/;"	p	class:folly::UriEscapeMode	access:private	signature:(char* str, size_t length)
toLowerAscii32	.\String.cpp	/^void toLowerAscii32(uint32_t& c) {$/;"	f	namespace:folly::__anon95	signature:(uint32_t& c)
toLowerAscii64	.\String.cpp	/^void toLowerAscii64(uint64_t& c) {$/;"	f	namespace:folly::__anon95	signature:(uint64_t& c)
toLowerAscii8	.\String.cpp	/^void toLowerAscii8(char& c) {$/;"	f	namespace:folly::__anon95	signature:(char& c)
toPrettyJson	.\json.cpp	/^fbstring toPrettyJson(dynamic const& dyn) {$/;"	f	namespace:folly	signature:(dynamic const& dyn)
toPrettyJson	.\json.h	/^fbstring toPrettyJson(dynamic const&);$/;"	p	namespace:folly	signature:(dynamic const&)
toSockAddr	.\IPAddressV4.h	/^  sockaddr_in toSockAddr() const {$/;"	f	class:folly::IPAddressV4	access:public	signature:() const
toSockAddr	.\IPAddressV6.h	/^  sockaddr_in6 toSockAddr() const {$/;"	f	class:folly::IPAddressV6	access:public	signature:() const
toSockaddrStorage	.\IPAddress.h	/^  int toSockaddrStorage(sockaddr_storage *dest, uint16_t port = 0) const {$/;"	f	class:folly::IPAddress	access:public	signature:(sockaddr_storage *dest, uint16_t port = 0) const
toStdString	.\String.h	/^const std::string& toStdString(const std::string& s) {$/;"	f	namespace:folly	signature:(const std::string& s)
toStdString	.\String.h	/^std::string toStdString(const folly::fbstring& s) {$/;"	f	namespace:folly	signature:(const folly::fbstring& s)
toStdString	.\String.h	/^std::string&& toStdString(std::string&& s) {$/;"	f	namespace:folly	signature:(std::string&& s)
toString	.\MacAddress.cpp	/^string MacAddress::toString() const {$/;"	f	class:folly::MacAddress	signature:() const
toString	.\MacAddress.h	/^  std::string toString() const;$/;"	p	class:folly::MacAddress	access:public	signature:() const
toString	.\Range.h	/^  std::string toString() const { return str(); }$/;"	f	class:folly::Range	access:public	signature:() const
toString	.\Uri-inl.h	/^String Uri::toString() const {$/;"	f	class:folly::Uri	signature:() const
toString	.\Uri.h	/^  String toString() const;$/;"	p	class:folly::Uri	access:public	signature:() const
toString	.\experimental\symbolizer\Dwarf.cpp	/^void Dwarf::Path::toString(std::string& dest) const {$/;"	f	class:folly::symbolizer::Dwarf::Path	signature:(std::string& dest) const
toString	.\experimental\symbolizer\Dwarf.h	/^    std::string toString() const {$/;"	f	class:folly::symbolizer::Dwarf::Path	access:public	signature:() const
toString	.\experimental\symbolizer\Dwarf.h	/^    void toString(std::string& dest) const;$/;"	p	class:folly::symbolizer::Dwarf::Path	access:public	signature:(std::string& dest) const
toString	.\io\test\IOBufCursorTest.cpp	/^std::string toString(const IOBuf& buf) {$/;"	f	namespace:__anon69	signature:(const IOBuf& buf)
toString	.\test\AtomicHashMapTest.cpp	/^  string toString() {$/;"	f	class:Counters	access:public	signature:()
toTSV	.\stats\Histogram-defs.h	/^void Histogram<T>::toTSV(std::ostream& out, bool skipEmptyBuckets) const {$/;"	f	class:folly::Histogram	signature:(std::ostream& out, bool skipEmptyBuckets) const
toTSV	.\stats\Histogram.h	/^  void toTSV(std::ostream& out, bool skipEmptyBuckets = true) const;$/;"	p	class:folly::Histogram	access:public	signature:(std::ostream& out, bool skipEmptyBuckets = true) const
top	.\experimental\exception_tracer\StackTrace.cpp	/^StackTrace* StackTraceStack::top() {$/;"	f	class:folly::exception_tracer::StackTraceStack	signature:()
top	.\experimental\exception_tracer\StackTrace.h	/^  StackTrace* top();$/;"	p	class:folly::exception_tracer::StackTraceStack	access:public	signature:()
top_	.\experimental\exception_tracer\StackTrace.h	/^  Node* top_;$/;"	m	class:folly::exception_tracer::StackTraceStack	access:private
total	.\Demangle.cpp	/^  size_t total;$/;"	m	struct:folly::__anon10::DemangleBuf	file:	access:public
total	.\wangle\detail\State.h	/^  size_t total;$/;"	m	struct:folly::wangle::detail::VariadicContext	access:public
total	.\wangle\detail\State.h	/^  size_t total;$/;"	m	struct:folly::wangle::detail::WhenAllContext	access:public
total	.\wangle\detail\State.h	/^  size_t total;$/;"	m	struct:folly::wangle::detail::WhenAllLaterContext	access:public
totalAllocatedSize_	.\Arena.h	/^  size_t totalAllocatedSize_;$/;"	m	class:folly::Arena	access:private
totalLength	.\io\Cursor.h	/^  size_t totalLength() const {$/;"	f	class:folly::io::detail::CursorBase	access:public	signature:() const
totalSize	.\Arena.h	/^  size_t totalSize() const {$/;"	f	class:folly::Arena	access:public	signature:() const
totalSize	.\detail\GroupVarintDetail.h	/^  static size_t totalSize(const T* p, size_t n) {$/;"	f	class:folly::detail::GroupVarintBase	access:public	signature:(const T* p, size_t n)
totalSubmits	.\experimental\io\AsyncIO.h	/^  size_t totalSubmits() const { return submitted_; }$/;"	f	class:folly::AsyncIO	access:public	signature:() const
totalVal_	.\test\ThreadLocalTest.cpp	/^  static int totalVal_;$/;"	m	struct:Widget	file:	access:public
totalVal_	.\test\ThreadLocalTest.cpp	/^int Widget::totalVal_ = 0;$/;"	m	class:Widget	file:
totalValue	.\test\ThreadLocalTest.cpp	/^int totalValue() {$/;"	f	namespace:__anon147	signature:()
total_	.\stats\BucketedTimeSeries.h	/^  Bucket total_;                 \/\/ sum and count of everything in time series$/;"	m	class:folly::BucketedTimeSeries	access:private
trailingDot	.\FormatArg.h	/^  bool trailingDot;$/;"	m	struct:folly::FormatArg	access:public
traits_	.\test\ProducerConsumerQueueTest.cpp	/^  TestTraits<T> traits_;$/;"	m	struct:__anon128::CorrectnessTest	file:	access:public
traits_	.\test\ProducerConsumerQueueTest.cpp	/^  TestTraits<T> traits_;$/;"	m	struct:__anon128::PerfTest	file:	access:public
traits_detail	.\Traits.h	/^namespace traits_detail {$/;"	n	namespace:folly
traits_type	.\Range.h	/^    traits_type;$/;"	t	class:folly::Range	access:public
trimEnd	.\io\IOBuf.h	/^  void trimEnd(uint64_t amount) {$/;"	f	class:folly::IOBuf	access:public	signature:(uint64_t amount)
trimEnd	.\io\IOBufQueue.cpp	/^void IOBufQueue::trimEnd(size_t amount) {$/;"	f	class:folly::IOBufQueue	signature:(size_t amount)
trimEnd	.\io\IOBufQueue.h	/^  void trimEnd(size_t amount);$/;"	p	class:folly::IOBufQueue	access:public	signature:(size_t amount)
trimEnd	.\io\TypedIOBuf.h	/^  void trimEnd(uint32_t n) {$/;"	f	class:folly::TypedIOBuf	access:public	signature:(uint32_t n)
trimStart	.\io\IOBuf.h	/^  void trimStart(uint64_t amount) {$/;"	f	class:folly::IOBuf	access:public	signature:(uint64_t amount)
trimStart	.\io\IOBufQueue.cpp	/^void IOBufQueue::trimStart(size_t amount) {$/;"	f	class:folly::IOBufQueue	signature:(size_t amount)
trimStart	.\io\IOBufQueue.h	/^  void trimStart(size_t amount);$/;"	p	class:folly::IOBufQueue	access:public	signature:(size_t amount)
trimStart	.\io\TypedIOBuf.h	/^  void trimStart(uint32_t n) {$/;"	f	class:folly::TypedIOBuf	access:public	signature:(uint32_t n)
truncateNoInt	.\FileUtil.cpp	/^int truncateNoInt(const char* path, off_t len) {$/;"	f	namespace:folly	signature:(const char* path, off_t len)
truncateNoInt	.\FileUtil.h	/^int truncateNoInt(const char* path, off_t len);$/;"	p	namespace:folly	signature:(const char* path, off_t len)
tryAdvanceBuffer	.\io\Cursor.h	/^  bool tryAdvanceBuffer() {$/;"	f	class:folly::io::detail::CursorBase	access:protected	signature:()
tryConsume	.\io\async\NotificationQueue.h	/^  bool tryConsume(MessageT& result) {$/;"	f	class:folly::NotificationQueue	access:public	signature:(MessageT& result)
tryConsumeEvent	.\io\async\NotificationQueue.h	/^  bool tryConsumeEvent() {$/;"	f	class:folly::NotificationQueue	access:private	signature:()
tryConvertToIPv4	.\SocketAddress.cpp	/^bool SocketAddress::tryConvertToIPv4() {$/;"	f	class:folly::SocketAddress	signature:()
tryConvertToIPv4	.\SocketAddress.h	/^  bool tryConvertToIPv4();$/;"	p	class:folly::SocketAddress	access:public	signature:()
tryDown	.\experimental\test\EventCountTest.cpp	/^  bool tryDown() {$/;"	f	class:__anon46::Semaphore	file:	access:private	signature:()
tryGet	.\test\AHMIntStressTest.cpp	/^  std::shared_ptr<MyObject> tryGet(int key) {$/;"	f	struct:__anon102::MyObjectDirectory	access:public	signature:(int key)
tryGrowChain	.\io\Cursor.h	/^  bool tryGrowChain() {$/;"	f	class:folly::io::Appender	access:private	signature:()
tryLockCell	.\AtomicHashArray.h	/^  inline bool tryLockCell(value_type* const cell) {$/;"	f	class:folly::AtomicHashArray	access:private	signature:(value_type* const cell)
tryLockMap	.\AtomicHashMap.h	/^  inline bool tryLockMap(int idx) {$/;"	f	class:folly::AtomicHashMap	access:private	signature:(int idx)
tryPutMessage	.\io\async\NotificationQueue.h	/^  void tryPutMessage(MessageT&& message) {$/;"	f	class:folly::NotificationQueue	access:public	signature:(MessageT&& message)
tryPutMessage	.\io\async\NotificationQueue.h	/^  void tryPutMessage(const MessageT& message) {$/;"	f	class:folly::NotificationQueue	access:public	signature:(const MessageT& message)
tryPutMessageNoThrow	.\io\async\NotificationQueue.h	/^  bool tryPutMessageNoThrow(MessageT&& message) {$/;"	f	class:folly::NotificationQueue	access:public	signature:(MessageT&& message)
tryPutMessageNoThrow	.\io\async\NotificationQueue.h	/^  bool tryPutMessageNoThrow(const MessageT& message) {$/;"	f	class:folly::NotificationQueue	access:public	signature:(const MessageT& message)
tryWait	.\LifoSem.h	/^  bool tryWait() {$/;"	f	struct:folly::detail::LifoSemBase	access:public	signature:()
tryWait	.\LifoSem.h	/^  uint32_t tryWait(uint32_t n) {$/;"	f	struct:folly::detail::LifoSemBase	access:public	signature:(uint32_t n)
tryWait	.\test\DeterministicSchedule.cpp	/^DeterministicSchedule::tryWait(sem_t* sem) {$/;"	f	class:folly::test::DeterministicSchedule	signature:(sem_t* sem)
tryWait	.\test\DeterministicSchedule.h	/^  static bool tryWait(sem_t* sem);$/;"	p	class:folly::test::DeterministicSchedule	access:public	signature:(sem_t* sem)
tryWaitOrPush	.\LifoSem.h	/^  WaitResult tryWaitOrPush(LifoSemNode<Handoff, Atom>& waiterNode) {$/;"	f	struct:folly::detail::LifoSemBase	access:protected	signature:(LifoSemNode<Handoff, Atom>& waiterNode)
try_and_catch	.\ExceptionWrapper.h	/^  explicit try_and_catch(F&& fn) : Base() {$/;"	f	class:folly::try_and_catch	access:public	signature:(F&& fn)
try_and_catch	.\ExceptionWrapper.h	/^  try_and_catch() : Base() {}$/;"	f	class:folly::try_and_catch	access:protected	signature:()
try_and_catch	.\ExceptionWrapper.h	/^  try_and_catch() {}$/;"	f	class:folly::try_and_catch	access:public	signature:()
try_and_catch	.\ExceptionWrapper.h	/^class try_and_catch;$/;"	x
try_and_catch	.\ExceptionWrapper.h	/^class try_and_catch<> : public exception_wrapper {$/;"	c	namespace:folly	inherits:exception_wrapper
try_and_catch	.\ExceptionWrapper.h	/^class try_and_catch<LastException, Exceptions...> :$/;"	c	namespace:folly	inherits:try_and_catch
try_lock	.\File.cpp	/^bool File::try_lock() { return doTryLock(LOCK_EX); }$/;"	f	class:folly::File	signature:()
try_lock	.\File.h	/^  bool try_lock();$/;"	p	class:folly::File	access:public	signature:()
try_lock	.\PackedSyncPtr.h	/^  bool try_lock() const { return data_.try_lock(); }$/;"	f	class:folly::PackedSyncPtr	access:public	signature:() const
try_lock	.\RWSpinLock.h	/^  bool try_lock() {$/;"	f	class:folly::RWSpinLock	access:public	signature:()
try_lock	.\RWSpinLock.h	/^  bool try_lock() {$/;"	f	class:folly::RWTicketSpinLockT	access:public	signature:()
try_lock	.\SmallLocks.h	/^  bool try_lock() const {$/;"	f	struct:folly::PicoSpinLock	access:public	signature:() const
try_lock	.\SmallLocks.h	/^  bool try_lock() {$/;"	f	struct:folly::MicroSpinLock	access:public	signature:()
try_lock_shared	.\File.cpp	/^bool File::try_lock_shared() { return doTryLock(LOCK_SH); }$/;"	f	class:folly::File	signature:()
try_lock_shared	.\File.h	/^  bool try_lock_shared();$/;"	p	class:folly::File	access:public	signature:()
try_lock_shared	.\RWSpinLock.h	/^  bool try_lock_shared() {$/;"	f	class:folly::RWSpinLock	access:public	signature:()
try_lock_shared	.\RWSpinLock.h	/^  bool try_lock_shared() {$/;"	f	class:folly::RWTicketSpinLockT	access:public	signature:()
try_lock_upgrade	.\RWSpinLock.h	/^  bool try_lock_upgrade() {$/;"	f	class:folly::RWSpinLock	access:public	signature:()
try_unlock_upgrade_and_lock	.\RWSpinLock.h	/^  bool try_unlock_upgrade_and_lock() {$/;"	f	class:folly::RWSpinLock	access:public	signature:()
try_wait	.\Baton.h	/^  bool try_wait() {$/;"	f	struct:folly::Baton	access:public	signature:()
ttype	.\DynamicConverter.h	/^  typedef typename T::value_type ttype;$/;"	t	class:folly::dynamicconverter_detail::Transformer	access:private
tuple_flatten	.\gen\Combine-inl.h	/^static const detail::Map<detail::MergeTuples> tuple_flatten;$/;"	m	namespace:folly::gen
twang_32from64	.\Hash.h	/^inline uint32_t twang_32from64(uint64_t key) {$/;"	f	namespace:folly::hash	signature:(uint64_t key)
twang_mix64	.\Hash.h	/^inline uint64_t twang_mix64(uint64_t key) {$/;"	f	namespace:folly::hash	signature:(uint64_t key)
twang_unmix64	.\Hash.h	/^inline uint64_t twang_unmix64(uint64_t key) {$/;"	f	namespace:folly::hash	signature:(uint64_t key)
type	.\AtomicStruct.h	/^template <> struct AtomicStructIntPick<1> { typedef uint8_t type; };$/;"	t	struct:folly::detail::AtomicStructIntPick	access:public
type	.\AtomicStruct.h	/^template <> struct AtomicStructIntPick<2> { typedef uint16_t type; };$/;"	t	struct:folly::detail::AtomicStructIntPick	access:public
type	.\AtomicStruct.h	/^template <> struct AtomicStructIntPick<3> { typedef uint32_t type; };$/;"	t	struct:folly::detail::AtomicStructIntPick	access:public
type	.\AtomicStruct.h	/^template <> struct AtomicStructIntPick<4> { typedef uint32_t type; };$/;"	t	struct:folly::detail::AtomicStructIntPick	access:public
type	.\AtomicStruct.h	/^template <> struct AtomicStructIntPick<5> { typedef uint64_t type; };$/;"	t	struct:folly::detail::AtomicStructIntPick	access:public
type	.\AtomicStruct.h	/^template <> struct AtomicStructIntPick<6> { typedef uint64_t type; };$/;"	t	struct:folly::detail::AtomicStructIntPick	access:public
type	.\AtomicStruct.h	/^template <> struct AtomicStructIntPick<7> { typedef uint64_t type; };$/;"	t	struct:folly::detail::AtomicStructIntPick	access:public
type	.\AtomicStruct.h	/^template <> struct AtomicStructIntPick<8> { typedef uint64_t type; };$/;"	t	struct:folly::detail::AtomicStructIntPick	access:public
type	.\Conv.h	/^    >::type>::type type;$/;"	t	struct:folly::detail::last_element	access:public
type	.\Conv.h	/^  typedef void type;$/;"	t	struct:folly::detail::last_element	access:public
type	.\GroupVarint.h	/^  typedef T type;$/;"	t	class:folly::GroupVarintDecoder	access:public
type	.\GroupVarint.h	/^  typedef T type;$/;"	t	class:folly::GroupVarintEncoder	access:public
type	.\IPAddressV6.cpp	/^IPAddressV6::Type IPAddressV6::type() const {$/;"	f	class:folly::IPAddressV6	signature:() const
type	.\IPAddressV6.h	/^  Type type() const;$/;"	p	class:folly::IPAddressV6	access:public	signature:() const
type	.\Memory.h	/^  > type;$/;"	t	struct:folly::AllocatorUniquePtr	access:public
type	.\Memory.h	/^  >::type type;$/;"	t	struct:folly::as_stl_allocator	access:public
type	.\detail\BitIteratorDetail.h	/^    ssize_t> type;$/;"	t	struct:folly::bititerator_detail::BitIteratorBase	access:public
type	.\detail\DiscriminatedPtrDetail.h	/^    typename ConstVisitorResult1<V,Types>::type...>::type type;$/;"	t	struct:folly::dptr_detail::ConstVisitorResult	access:public
type	.\detail\DiscriminatedPtrDetail.h	/^    typename VisitorResult1<V,Types>::type...>::type type;$/;"	t	struct:folly::dptr_detail::VisitorResult	access:public
type	.\detail\DiscriminatedPtrDetail.h	/^  typedef T type;$/;"	t	struct:folly::dptr_detail::SameType	access:public
type	.\detail\DiscriminatedPtrDetail.h	/^  typedef typename std::result_of<V (T*)>::type type;$/;"	t	struct:folly::dptr_detail::VisitorResult1	access:public
type	.\detail\DiscriminatedPtrDetail.h	/^  typedef typename std::result_of<V (const T*)>::type type;$/;"	t	struct:folly::dptr_detail::ConstVisitorResult1	access:public
type	.\detail\GroupVarintDetail.h	/^  typedef T type;$/;"	t	class:folly::detail::GroupVarintBase	access:public
type	.\dynamic-inl.h	/^    typedef T type;$/;"	t	struct:folly::detail::ConversionHelper	access:public
type	.\dynamic-inl.h	/^    typedef int64_t type;$/;"	t	struct:folly::detail::ConversionHelper	access:public
type	.\dynamic-inl.h	/^    typedef void* type;$/;"	t	struct:folly::detail::ConversionHelper	access:public
type	.\dynamic-inl.h	/^  static Type const type;$/;"	m	struct:folly::dynamic::TypeInfo	access:public
type	.\dynamic-inl.h	/^inline dynamic::Type dynamic::type() const {$/;"	f	class:folly::dynamic	signature:() const
type	.\dynamic.h	/^  Type type() const;$/;"	p	struct:folly::dynamic	access:public	signature:() const
type	.\experimental\Bits.h	/^  typedef T type;$/;"	t	struct:folly::Bits	access:public
type	.\experimental\exception_tracer\ExceptionTracer.h	/^  const std::type_info* type;$/;"	m	struct:folly::exception_tracer::ExceptionInfo	access:public
type	.\experimental\symbolizer\Elf-inl.h	/^                                                 uint32_t type, Fn fn) const {$/;"	m	namespace:folly::symbolizer
type	.\experimental\symbolizer\Elf.h	/^                                          uint32_t type, Fn fn) const;$/;"	m	class:folly::symbolizer::ElfFile	access:public
type	.\io\Compression.h	/^  CodecType type() const { return type_; }$/;"	f	class:folly::io::Codec	access:public	signature:() const
type	.\small_vector.h	/^    > type;$/;"	t	struct:folly::detail::small_vector_base	access:public
type	.\wangle\detail\State.h	/^  typedef Future<std::tuple<Try<Ts>...>> type;$/;"	t	struct:folly::wangle::detail::VariadicContext	access:public
typeHackDoNotUse	.\Synchronized.h	/^    Unsynchronizer typeHackDoNotUse();$/;"	p	struct:folly::Synchronized::ConstLockedPtr	access:public	signature:()
typeHackDoNotUse	.\Synchronized.h	/^    Unsynchronizer typeHackDoNotUse();$/;"	p	struct:folly::Synchronized::LockedPtr	access:public	signature:()
typeIndex	.\DiscriminatedPtr.h	/^  size_t typeIndex() const {$/;"	f	class:folly::DiscriminatedPtr	access:private	signature:() const
typeName	.\dynamic-inl.h	/^inline char const* dynamic::typeName(Type t) {$/;"	f	class:folly::dynamic	signature:(Type t)
typeName	.\dynamic.cpp	/^const char* dynamic::typeName() const {$/;"	f	class:folly::dynamic	signature:() const
typeName	.\dynamic.h	/^  const char* typeName() const;$/;"	p	struct:folly::dynamic	access:public	signature:() const
typeName	.\dynamic.h	/^  static char const* typeName(Type);$/;"	p	struct:folly::dynamic	access:private	signature:(Type)
type_	.\dynamic.h	/^  Type type_;$/;"	m	struct:folly::dynamic	access:private
type_	.\experimental\Singleton.h	/^  Type type_ = Type::Relaxed;$/;"	m	class:folly::SingletonVault	access:private
type_	.\io\Compression.h	/^  CodecType type_;$/;"	m	class:folly::io::Codec	access:private
type_	.\io\test\IOBufTest.cpp	/^  BufType type_;$/;"	m	class:MoveToFbStringTest	file:	access:protected
type_descriptor_	.\experimental\Singleton.h	/^  detail::TypeDescriptor type_descriptor_;$/;"	m	class:folly::Singleton	access:private
u16	.\test\ConvTest.cpp	/^static uint16_t u16;$/;"	v	file:
u2aAppendClassicBM	.\test\ConvTest.cpp	/^void u2aAppendClassicBM(unsigned int n, uint64_t value) {$/;"	f	signature:(unsigned int n, uint64_t value)
u2aAppendFollyBM	.\test\ConvTest.cpp	/^void u2aAppendFollyBM(unsigned int n, uint64_t value) {$/;"	f	signature:(unsigned int n, uint64_t value)
u32	.\test\ConvTest.cpp	/^static uint32_t u32;$/;"	v	file:
u64	.\test\ConvTest.cpp	/^static uint64_t u64;$/;"	v	file:
u64HBO	.\MacAddress.h	/^  uint64_t u64HBO() const {$/;"	f	class:folly::MacAddress	access:public	signature:() const
u64NBO	.\MacAddress.h	/^  uint64_t u64NBO() const {$/;"	f	class:folly::MacAddress	access:public	signature:() const
u64ToAsciiClassic	.\test\ConvTest.cpp	/^unsigned u64ToAsciiClassic(uint64_t value, char* dst) {$/;"	f	signature:(uint64_t value, char* dst)
u64ToAsciiClassicBM	.\test\ConvTest.cpp	/^void u64ToAsciiClassicBM(unsigned int n, uint64_t value) {$/;"	f	signature:(unsigned int n, uint64_t value)
u64ToAsciiFollyBM	.\test\ConvTest.cpp	/^void u64ToAsciiFollyBM(unsigned int n, uint64_t value) {$/;"	f	signature:(unsigned int n, uint64_t value)
u64ToAsciiTable	.\test\ConvTest.cpp	/^unsigned u64ToAsciiTable(uint64_t value, char* dst) {$/;"	f	signature:(uint64_t value, char* dst)
u64ToAsciiTableBM	.\test\ConvTest.cpp	/^void u64ToAsciiTableBM(unsigned int n, uint64_t value) {$/;"	f	signature:(unsigned int n, uint64_t value)
u8	.\test\ConvTest.cpp	/^static uint8_t u8;$/;"	v	file:
u_	.\dynamic.h	/^  } u_;$/;"	m	struct:folly::dynamic	typeref:union:folly::dynamic::Data	access:private
uid	.\test\stl_tests\StlVectorTest.cpp	/^  int uid;$/;"	m	struct:Tracker	file:	access:public
uint64ToBufferUnsafe	.\Conv.h	/^inline uint32_t uint64ToBufferUnsafe(uint64_t v, char *const buffer) {$/;"	f	namespace:folly	signature:(uint64_t v, char *const buffer)
uintToBinary	.\Format-inl.h	/^size_t uintToBinary(char* buffer, size_t bufLen, Uint v) {$/;"	f	namespace:folly::detail	signature:(char* buffer, size_t bufLen, Uint v)
uintToHex	.\Format-inl.h	/^size_t uintToHex(char* buffer, size_t bufLen, Uint v,$/;"	f	namespace:folly::detail	signature:(char* buffer, size_t bufLen, Uint v, const char (&repr)[256][2])
uintToHexLower	.\Format-inl.h	/^inline size_t uintToHexLower(char* buffer, size_t bufLen, Uint v) {$/;"	f	namespace:folly::detail	signature:(char* buffer, size_t bufLen, Uint v)
uintToHexUpper	.\Format-inl.h	/^inline size_t uintToHexUpper(char* buffer, size_t bufLen, Uint v) {$/;"	f	namespace:folly::detail	signature:(char* buffer, size_t bufLen, Uint v)
uintToOctal	.\Format-inl.h	/^size_t uintToOctal(char* buffer, size_t bufLen, Uint v) {$/;"	f	namespace:folly::detail	signature:(char* buffer, size_t bufLen, Uint v)
un	.\SocketAddress.h	/^    ExternalUnixAddr un;$/;"	m	union:folly::SocketAddress::__anon91	access:public
uncaughtExceptions	.\experimental\exception_tracer\ExceptionAbi.h	/^  unsigned int uncaughtExceptions;$/;"	m	struct:__cxxabiv1::__cxa_eh_globals	access:public
uncompress	.\io\Compression.cpp	/^std::unique_ptr<IOBuf> Codec::uncompress(const IOBuf* data,$/;"	f	class:folly::io::Codec	signature:(const IOBuf* data, uint64_t uncompressedLength)
uncompress	.\io\Compression.h	/^  std::unique_ptr<IOBuf> uncompress($/;"	p	class:folly::io::Codec	access:public	signature:( const IOBuf* data, uint64_t uncompressedLength = UNKNOWN_UNCOMPRESSED_LENGTH)
uncompressedLength_	.\io\test\CompressionTest.cpp	/^   uint64_t uncompressedLength_;$/;"	m	class:folly::io::test::CompressionTest	file:	access:protected
unconst	.\small_vector.h	/^  static iterator unconst(const_iterator it) {$/;"	f	class:folly::small_vector	access:private	signature:(const_iterator it)
unexpectedHandler	.\experimental\exception_tracer\ExceptionAbi.h	/^  std::unexpected_handler unexpectedHandler;$/;"	m	struct:__cxxabiv1::__cxa_exception	access:public
unexpectedHandler	.\experimental\exception_tracer\ExceptionTracer.cpp	/^void unexpectedHandler() {$/;"	f	namespace:folly::exception_tracer::__anon24	signature:()
unhexlify	.\String-inl.h	/^bool unhexlify(const InputString& input, OutputString& output) {$/;"	f	namespace:folly	signature:(const InputString& input, OutputString& output)
unhexlify	.\String.h	/^bool unhexlify(const InputString& input, OutputString& output);$/;"	p	class:folly::UriEscapeMode	access:private	signature:(const InputString& input, OutputString& output)
uniform	.\detail\CacheLocality.cpp	/^CacheLocality CacheLocality::uniform(size_t numCpus) {$/;"	f	class:folly::detail::CacheLocality	signature:(size_t numCpus)
uniform	.\detail\CacheLocality.h	/^  static CacheLocality uniform(size_t numCpus);$/;"	p	struct:folly::detail::CacheLocality	access:public	signature:(size_t numCpus)
uniform	.\test\DeterministicSchedule.cpp	/^DeterministicSchedule::uniform(long seed) {$/;"	f	class:folly::test::DeterministicSchedule	signature:(long seed)
uniform	.\test\DeterministicSchedule.h	/^  static std::function<int(int)> uniform(long seed);$/;"	p	class:folly::test::DeterministicSchedule	access:public	signature:(long seed)
uniformSubset	.\test\DeterministicSchedule.cpp	/^DeterministicSchedule::uniformSubset(long seed, int n, int m) {$/;"	f	class:folly::test::DeterministicSchedule	signature:(long seed, int n, int m)
uniformSubset	.\test\DeterministicSchedule.h	/^  static std::function<int(int)> uniformSubset(long seed, int n = 2,$/;"	p	class:folly::test::DeterministicSchedule	access:public	signature:(long seed, int n = 2, int m = 64)
uniform_	.\test\DeterministicSchedule.cpp	/^  std::function<int(int)> uniform_;$/;"	m	struct:folly::test::UniformSubset	file:	access:private
unique_ptr	.\Traits.h	/^FOLLY_ASSUME_FBVECTOR_COMPATIBLE_2(std::unique_ptr);$/;"	v
unique_ptr_test	.\test\ArenaSmartPtrTest.cpp	/^void unique_ptr_test(Allocator& allocator) {$/;"	f	signature:(Allocator& allocator)
unlink	.\io\IOBuf.h	/^  std::unique_ptr<IOBuf> unlink() {$/;"	f	class:folly::IOBuf	access:public	signature:()
unlock	.\File.cpp	/^void File::unlock() {$/;"	f	class:folly::File	signature:()
unlock	.\File.h	/^  void unlock();$/;"	p	class:folly::File	access:public	signature:()
unlock	.\PackedSyncPtr.h	/^  void unlock() const { data_.unlock(); }$/;"	f	class:folly::PackedSyncPtr	access:public	signature:() const
unlock	.\RWSpinLock.h	/^  void unlock() {$/;"	f	class:folly::RWSpinLock	access:public	signature:()
unlock	.\RWSpinLock.h	/^  void unlock() {$/;"	f	class:folly::RWTicketSpinLockT	access:public	signature:()
unlock	.\SmallLocks.h	/^  void unlock() const {$/;"	f	struct:folly::PicoSpinLock	access:public	signature:() const
unlock	.\SmallLocks.h	/^  void unlock() {$/;"	f	struct:folly::MicroSpinLock	access:public	signature:()
unlock	.\test\PackedSyncPtrTest.cpp	/^  void unlock() {$/;"	f	struct:SyncVec	access:public	signature:()
unlockCell	.\AtomicHashArray.h	/^  inline void unlockCell(value_type* const cell, KeyT newKey) {$/;"	f	class:folly::AtomicHashArray	access:private	signature:(value_type* const cell, KeyT newKey)
unlock_and_lock_shared	.\RWSpinLock.h	/^  void unlock_and_lock_shared() {$/;"	f	class:folly::RWSpinLock	access:public	signature:()
unlock_and_lock_shared	.\RWSpinLock.h	/^  void unlock_and_lock_shared() {$/;"	f	class:folly::RWTicketSpinLockT	access:public	signature:()
unlock_and_lock_upgrade	.\RWSpinLock.h	/^  void unlock_and_lock_upgrade() {$/;"	f	class:folly::RWSpinLock	access:public	signature:()
unlock_shared	.\File.cpp	/^void File::unlock_shared() { unlock(); }$/;"	f	class:folly::File	signature:()
unlock_shared	.\File.h	/^  void unlock_shared();$/;"	p	class:folly::File	access:public	signature:()
unlock_shared	.\RWSpinLock.h	/^  void unlock_shared() {$/;"	f	class:folly::RWSpinLock	access:public	signature:()
unlock_shared	.\RWSpinLock.h	/^  void unlock_shared() {$/;"	f	class:folly::RWTicketSpinLockT	access:public	signature:()
unlock_upgrade	.\RWSpinLock.h	/^  void unlock_upgrade() {$/;"	f	class:folly::RWSpinLock	access:public	signature:()
unlock_upgrade_and_lock	.\RWSpinLock.h	/^  void unlock_upgrade_and_lock() {$/;"	f	class:folly::RWSpinLock	access:public	signature:()
unlock_upgrade_and_lock_shared	.\RWSpinLock.h	/^  void unlock_upgrade_and_lock_shared() {$/;"	f	class:folly::RWSpinLock	access:public	signature:()
unmapUnusedStack	.\detail\MemoryIdler.cpp	/^void MemoryIdler::unmapUnusedStack(size_t retain) {$/;"	f	class:folly::detail::MemoryIdler	signature:(size_t retain)
unmapUnusedStack	.\detail\MemoryIdler.h	/^  static void unmapUnusedStack(size_t retain = kDefaultStackToRetain);$/;"	p	struct:folly::detail::MemoryIdler	access:public	signature:(size_t retain = kDefaultStackToRetain)
unpack	.\IPAddressV6.cpp	/^static inline uint16_t unpack(uint8_t lobyte, uint8_t hibyte) {$/;"	f	namespace:folly	signature:(uint8_t lobyte, uint8_t hibyte)
unpackHack	.\small_vector.h	/^  template<class T> static T& unpackHack(T* p) {$/;"	f	class:folly::small_vector	access:private	signature:(T* p)
unpackInto	.\IPAddressV6.cpp	/^static inline void unpackInto(const unsigned char* src,$/;"	f	namespace:folly	signature:(const unsigned char* src, uint16_t* dest, size_t count)
unregisterHandler	.\io\async\EventHandler.cpp	/^void EventHandler::unregisterHandler() {$/;"	f	class:folly::EventHandler	signature:()
unregisterHandler	.\io\async\EventHandler.h	/^  void unregisterHandler();$/;"	p	class:folly::EventHandler	access:public	signature:()
unsafeTelescope128	.\Conv.h	/^unsafeTelescope128(char * buffer, unsigned int room, unsigned __int128 x) {$/;"	f	namespace:folly::detail	signature:(char * buffer, unsigned int room, unsigned __int128 x)
unshare	.\io\IOBuf.h	/^  void unshare() {$/;"	f	class:folly::IOBuf	access:public	signature:()
unshareChained	.\io\IOBuf.cpp	/^void IOBuf::unshareChained() {$/;"	f	class:folly::IOBuf	signature:()
unshareChained	.\io\IOBuf.h	/^  void unshareChained();$/;"	p	class:folly::IOBuf	access:private	signature:()
unshareOne	.\io\IOBuf.h	/^  void unshareOne() {$/;"	f	class:folly::IOBuf	access:public	signature:()
unshareOneSlow	.\io\IOBuf.cpp	/^void IOBuf::unshareOneSlow() {$/;"	f	class:folly::IOBuf	signature:()
unshareOneSlow	.\io\IOBuf.h	/^  void unshareOneSlow();$/;"	p	class:folly::IOBuf	access:private	signature:()
unsplit	.\gen\String.h	/^Unsplit unsplit(const Delimiter& delimiter) {$/;"	f	namespace:folly::gen	signature:(const Delimiter& delimiter)
unsplit	.\gen\String.h	/^Unsplit unsplit(const char* delimiter) {$/;"	f	namespace:folly::gen	signature:(const char* delimiter)
unsplit	.\gen\String.h	/^UnsplitBuffer unsplit(Delimiter delimiter, OutputBuffer* outputBuffer) {$/;"	f	namespace:folly::gen	signature:(Delimiter delimiter, OutputBuffer* outputBuffer)
unsplit	.\gen\String.h	/^UnsplitBuffer unsplit(const char* delimiter, OutputBuffer* outputBuffer) {$/;"	f	namespace:folly::gen	signature:(const char* delimiter, OutputBuffer* outputBuffer)
until	.\gen\Base.h	/^Until until(Predicate pred = Predicate()) {$/;"	f	namespace:folly::gen	signature:(Predicate pred = Predicate())
unused	.\Foreach.h	/^  struct BiggerThanChar { char unused[2]; };$/;"	m	struct:folly::detail::HasLess::BiggerThanChar	access:public
unwindHeader	.\experimental\exception_tracer\ExceptionAbi.h	/^  _Unwind_Exception unwindHeader;$/;"	m	struct:__cxxabiv1::__cxa_exception	access:public
up	.\experimental\test\EventCountTest.cpp	/^  void up() {$/;"	f	class:__anon46::Semaphore	access:public	signature:()
update	.\Fingerprint.h	/^  Fingerprint& update(StringPiece str) {$/;"	f	class:folly::Fingerprint	access:public	signature:(StringPiece str)
update	.\detail\SlowFingerprint.h	/^  SlowFingerprint& update(const folly::StringPiece& str) {$/;"	f	class:folly::detail::SlowFingerprint	access:public	signature:(const folly::StringPiece& str)
update	.\stats\BucketedTimeSeries-defs.h	/^size_t BucketedTimeSeries<VT, TT>::update(TimeType now) {$/;"	f	class:folly::BucketedTimeSeries	signature:(TimeType now)
update	.\stats\BucketedTimeSeries.h	/^  size_t update(TimeType now);$/;"	p	class:folly::BucketedTimeSeries	access:public	signature:(TimeType now)
update	.\stats\MultiLevelTimeSeries-defs.h	/^void MultiLevelTimeSeries<VT, TT>::update(TimeType now) {$/;"	f	class:folly::MultiLevelTimeSeries	signature:(TimeType now)
update	.\stats\MultiLevelTimeSeries.h	/^  void update(TimeType now);$/;"	p	class:folly::MultiLevelTimeSeries	access:public	signature:(TimeType now)
update	.\stats\TimeseriesHistogram-defs.h	/^void TimeseriesHistogram<T, TT, C>::update(TimeType now) {$/;"	f	class:folly::TimeseriesHistogram	signature:(TimeType now)
update	.\stats\TimeseriesHistogram.h	/^  void update(TimeType now);$/;"	p	class:folly::TimeseriesHistogram	access:public	signature:(TimeType now)
update32	.\Fingerprint.h	/^  Fingerprint& update32(uint32_t v) {$/;"	f	class:folly::Fingerprint	access:public	signature:(uint32_t v)
update32	.\detail\SlowFingerprint.h	/^  SlowFingerprint& update32(uint32_t v) {$/;"	f	class:folly::detail::SlowFingerprint	access:public	signature:(uint32_t v)
update64	.\Fingerprint.h	/^  Fingerprint& update64(uint64_t v) {$/;"	f	class:folly::Fingerprint	access:public	signature:(uint64_t v)
update64	.\detail\SlowFingerprint.h	/^  SlowFingerprint& update64(uint64_t v) {$/;"	f	class:folly::detail::SlowFingerprint	access:public	signature:(uint64_t v)
update8	.\Fingerprint.h	/^  Fingerprint& update8(uint8_t v) {$/;"	f	class:folly::Fingerprint	access:public	signature:(uint8_t v)
update8	.\detail\SlowFingerprint.h	/^  SlowFingerprint& update8(uint8_t v) {$/;"	f	class:folly::detail::SlowFingerprint	access:public	signature:(uint8_t v)
updateBit	.\detail\SlowFingerprint.h	/^  void updateBit(bool bit) {$/;"	f	class:folly::detail::SlowFingerprint	access:private	signature:(bool bit)
updateBuckets	.\stats\BucketedTimeSeries-defs.h	/^size_t BucketedTimeSeries<VT, TT>::updateBuckets(TimeType now) {$/;"	f	class:folly::BucketedTimeSeries	signature:(TimeType now)
updateBuckets	.\stats\BucketedTimeSeries.h	/^  size_t updateBuckets(TimeType now);$/;"	p	class:folly::BucketedTimeSeries	access:private	signature:(TimeType now)
updateLSB	.\detail\SlowFingerprint.h	/^  void updateLSB(uint64_t val, int bits) {$/;"	f	class:folly::detail::SlowFingerprint	access:private	signature:(uint64_t val, int bits)
updateUnixAddressLength	.\SocketAddress.cpp	/^void SocketAddress::updateUnixAddressLength(socklen_t addrlen) {$/;"	f	class:folly::SocketAddress	signature:(socklen_t addrlen)
updateUnixAddressLength	.\SocketAddress.h	/^  void updateUnixAddressLength(socklen_t addrlen);$/;"	p	class:folly::SocketAddress	access:private	signature:(socklen_t addrlen)
upper	.\experimental\EliasFanoCoding.h	/^  folly::ByteRange upper;$/;"	m	struct:folly::compression::EliasFanoCompressedList	access:public
upper_	.\experimental\EliasFanoCoding.h	/^  detail::UpperBitsReader<Encoder, Instructions> upper_;$/;"	m	class:folly::compression::EliasFanoReader	access:private
upper_	.\experimental\EliasFanoCoding.h	/^  unsigned char* upper_ = nullptr;$/;"	m	struct:folly::compression::EliasFanoEncoder	access:private
upper_bound	.\sorted_vector_types.h	/^  const_iterator upper_bound(const key_type& key) const {$/;"	f	class:folly::sorted_vector_map	access:public	signature:(const key_type& key) const
upper_bound	.\sorted_vector_types.h	/^  const_iterator upper_bound(const key_type& key) const {$/;"	f	class:folly::sorted_vector_set	access:public	signature:(const key_type& key) const
upper_bound	.\sorted_vector_types.h	/^  iterator upper_bound(const key_type& key) {$/;"	f	class:folly::sorted_vector_map	access:public	signature:(const key_type& key)
upper_bound	.\sorted_vector_types.h	/^  iterator upper_bound(const key_type& key) {$/;"	f	class:folly::sorted_vector_set	access:public	signature:(const key_type& key)
uriEscape	.\String-inl.h	/^void uriEscape(StringPiece str, String& out, UriEscapeMode mode) {$/;"	f	namespace:folly	signature:(StringPiece str, String& out, UriEscapeMode mode)
uriEscape	.\String.h	/^String uriEscape(StringPiece str, UriEscapeMode mode = UriEscapeMode::ALL) {$/;"	f	class:folly::UriEscapeMode	access:private	signature:(StringPiece str, UriEscapeMode mode = UriEscapeMode::ALL)
uriEscape	.\String.h	/^void uriEscape(StringPiece str,$/;"	p	class:folly::UriEscapeMode	access:private	signature:(StringPiece str, String& out, UriEscapeMode mode = UriEscapeMode::ALL)
uriEscapedString	.\test\StringTest.cpp	/^fbstring uriEscapedString;$/;"	m	namespace:__anon136	file:
uriUnescape	.\String-inl.h	/^void uriUnescape(StringPiece str, String& out, UriEscapeMode mode) {$/;"	f	namespace:folly	signature:(StringPiece str, String& out, UriEscapeMode mode)
uriUnescape	.\String.h	/^String uriUnescape(StringPiece str, UriEscapeMode mode = UriEscapeMode::ALL) {$/;"	f	class:folly::UriEscapeMode	access:private	signature:(StringPiece str, UriEscapeMode mode = UriEscapeMode::ALL)
uriUnescape	.\String.h	/^void uriUnescape(StringPiece str,$/;"	p	class:folly::UriEscapeMode	access:private	signature:(StringPiece str, String& out, UriEscapeMode mode = UriEscapeMode::ALL)
uriUnescapedString	.\test\StringTest.cpp	/^fbstring uriUnescapedString;$/;"	m	namespace:__anon136	file:
uribmEscapedString	.\test\StringTest.cpp	/^fbstring uribmEscapedString;$/;"	m	namespace:__anon136	file:
uribmString	.\test\StringTest.cpp	/^fbstring uribmString;$/;"	m	namespace:__anon136	file:
usage	.\experimental\io\HugePageUtil.cpp	/^FOLLY_NORETURN void usage(const char* name);$/;"	p	namespace:__anon31	file:	signature:(const char* name)
usage	.\experimental\io\HugePageUtil.cpp	/^void usage(const char* name) {$/;"	f	namespace:__anon31	signature:(const char* name)
use	.\MPMCPipeline.h	/^    uint64_t use(MPMCPipeline* owner) {$/;"	f	class:folly::MPMCPipeline::Ticket	access:private	signature:(MPMCPipeline* owner)
usePath	.\Subprocess.h	/^    Options& usePath() { usePath_ = true; return *this; }$/;"	f	class:folly::Subprocess::Options	access:public	signature:()
usePath_	.\Subprocess.h	/^    bool usePath_;$/;"	m	class:folly::Subprocess::Options	access:private
userData	.\io\IOBuf.h	/^    void* userData;$/;"	m	struct:folly::IOBuf::SharedInfo	access:public
username	.\Uri.h	/^  const fbstring& username() const { return username_; }$/;"	f	class:folly::Uri	access:public	signature:() const
username_	.\Uri.h	/^  fbstring username_;$/;"	m	class:folly::Uri	access:private
users	.\RWSpinLock.h	/^      QuarterInt users;$/;"	m	struct:folly::RWTicketSpinLockT::RWTicket::__anon85	access:public
usingJEMallocSlow	.\Malloc.cpp	/^bool usingJEMallocSlow() {$/;"	f	namespace:folly	signature:()
v	.\gen\test\ParallelBenchmark.cpp	/^auto v = seq(start) | take(1 << 20) | as<vector>();$/;"	v
v	.\test\SmallLocksTest.cpp	/^LockedVal v;$/;"	m	namespace:__anon131	file:
v6types	.\test\IPAddressTest.cpp	/^static vector<pair<string, IPAddressV6::Type> > v6types = {$/;"	v	file:
v_	.\test\AtomicHashMapTest.cpp	/^  KeyT v_;$/;"	m	class:Integer	file:	access:private
v_	.\test\PaddedTest.cpp	/^  IntNodeVec v_;$/;"	m	class:IntPaddedTestBase	file:	access:protected
v_	.\test\PaddedTest.cpp	/^  PointNodeVec v_;$/;"	m	class:StructPaddedTestBase	file:	access:protected
val	.\String.cpp	/^  double val;$/;"	m	struct:folly::__anon94::PrettySuffix	file:	access:public
val	.\experimental\test\SingletonTest.cpp	/^  int val = 0;$/;"	m	struct:BenchmarkSingleton	file:	access:public
val	.\io\test\IOBufTest.cpp	/^  int val;$/;"	m	struct:__anon71::OwnershipTestClass	file:	access:public
val	.\test\ThreadLocalTest.cpp	/^  uint64_t val() const {$/;"	f	class:__anon146::FillObject	file:	access:private	signature:() const
val_	.\Format-inl.h	/^  StringPiece val_;$/;"	m	class:folly::FormatValue	access:private
val_	.\Format-inl.h	/^  T val_;$/;"	m	class:folly::FormatValue	access:private
val_	.\Format-inl.h	/^  T* val_;$/;"	m	class:folly::FormatValue	access:private
val_	.\Format-inl.h	/^  bool val_;$/;"	m	class:folly::FormatValue	access:private
val_	.\Format-inl.h	/^  double val_;$/;"	m	class:folly::FormatValue	access:private
val_	.\Format-inl.h	/^  float val_;$/;"	m	class:folly::FormatValue	access:private
val_	.\ThreadCachedInt.h	/^    mutable std::atomic<IntT> val_;$/;"	m	struct:folly::ThreadCachedInt::IntCache	access:public
val_	.\detail\FingerprintPolynomial.h	/^  uint64_t val_[1 + DEG\/64];$/;"	m	class:folly::detail::FingerprintPolynomial	access:private
val_	.\dynamic-inl.h	/^  const detail::DefaultValueWrapper<dynamic, V>& val_;$/;"	m	class:folly::FormatValue	access:private
val_	.\dynamic-inl.h	/^  const dynamic& val_;$/;"	m	class:folly::FormatValue	access:private
val_	.\dynamic-inl.h	/^  dynamic val_;$/;"	m	struct:folly::dynamic::ObjectMaker	access:private
val_	.\experimental\EventCount.h	/^  std::atomic<uint64_t> val_;$/;"	m	class:folly::EventCount	access:private
val_	.\io\IOBuf.h	/^  ByteRange val_;$/;"	m	class:folly::IOBuf::Iterator	access:private
val_	.\test\ThreadLocalTest.cpp	/^  ThreadLocal<int,NewTag> val_;$/;"	m	class:SimpleThreadCachedInt	file:	access:private
val_	.\test\ThreadLocalTest.cpp	/^  int val_;$/;"	m	struct:Widget	file:	access:public
val_	.\test\sorted_vector_test.cpp	/^  int val_;$/;"	m	struct:__anon133::CountCopyCtor	file:	access:public
valid	.\ThreadLocal.h	/^      bool valid() const {$/;"	f	class:folly::ThreadLocalPtr::Accessor::Iterator	access:private	signature:() const
validAddressProvider	.\test\IPAddressTest.cpp	/^static vector<AddressData> validAddressProvider = {$/;"	v	file:
valid_	.\DynamicConverter.h	/^  mutable bool valid_;$/;"	m	class:folly::dynamicconverter_detail::Transformer	access:private
validate	.\Format.cpp	/^void FormatArg::validate(Type type) const {$/;"	f	class:folly::FormatArg	signature:(Type type) const
validate	.\FormatArg.h	/^  void validate(Type type) const;$/;"	p	struct:folly::FormatArg	access:public	signature:(Type type) const
validateRecord	.\io\RecordIO.cpp	/^RecordInfo validateRecord(ByteRange range, uint32_t fileId) {$/;"	f	namespace:folly::recordio_helpers	signature:(ByteRange range, uint32_t fileId)
validateRecord	.\io\RecordIO.h	/^RecordInfo validateRecord(ByteRange range, uint32_t fileId);$/;"	p	namespace:folly::recordio_helpers	signature:(ByteRange range, uint32_t fileId)
validate_utf8	.\json.h	/^    bool validate_utf8;$/;"	m	struct:folly::json::serialization_opts	access:public
value	.\ApplyTuple.h	/^    value = sizeof...(Unpacked) < DerefSize<Tuple>::value$/;"	e	enum:folly::detail::ExprDoUnpack::__anon1
value	.\Conv.cpp	/^template <> const char *const MaxString<__uint128_t>::value =$/;"	m	class:folly::detail::MaxString	file:
value	.\Conv.cpp	/^template <> const char *const MaxString<bool>::value = "true";$/;"	m	class:folly::detail::MaxString	file:
value	.\Conv.cpp	/^template <> const char *const MaxString<uint16_t>::value = "65535";$/;"	m	class:folly::detail::MaxString	file:
value	.\Conv.cpp	/^template <> const char *const MaxString<uint32_t>::value = "4294967295";$/;"	m	class:folly::detail::MaxString	file:
value	.\Conv.cpp	/^template <> const char *const MaxString<uint8_t>::value = "255";$/;"	m	class:folly::detail::MaxString	file:
value	.\Conv.cpp	/^template <> const char *const MaxString<unsigned long long>::value =$/;"	m	class:folly::detail::MaxString	file:
value	.\Conv.cpp	/^template <> const char *const MaxString<unsigned long>::value =$/;"	m	class:folly::detail::MaxString	file:
value	.\Conv.h	/^  enum { value = std::is_same<T, std::string>::value$/;"	e	enum:folly::IsSomeString::__anon8
value	.\DynamicConverter.h	/^  enum { value = has_value_type<T>::value &&$/;"	e	enum:folly::dynamicconverter_detail::class_is_container::__anon20
value	.\DynamicConverter.h	/^  enum { value = has_value_type<T>::value &&$/;"	e	enum:folly::dynamicconverter_detail::class_is_range::__anon21
value	.\ExceptionWrapper.h	/^    static const bool value =$/;"	m	struct:folly::try_and_catch::optimize	access:public
value	.\Foreach.h	/^  enum { value = sizeof(test<T, U>(0)) == 1 };$/;"	e	enum:folly::detail::HasLess::__anon51
value	.\LifoSem.h	/^  inline uint32_t value() const {$/;"	f	class:folly::detail::LifoSemHead	access:public	signature:() const
value	.\Memory.h	/^  constexpr static bool value = !has_destroy<allocator, void(pointer)>::value$/;"	m	class:folly::is_simple_allocator	access:public
value	.\MoveWrapper.h	/^  mutable T value;$/;"	m	class:folly::MoveWrapper	access:private
value	.\Optional.h	/^  Value& value() {$/;"	f	class:folly::Optional	access:public	signature:()
value	.\Optional.h	/^  const Value& value() const {$/;"	f	class:folly::Optional	access:public	signature:() const
value	.\Random-inl.h	/^                                       a, u, d, s, b, t, c, l, f>>::value;$/;"	m	class:folly::detail::StateSize
value	.\Random-inl.h	/^    parity1, parity2, parity3, parity4>>::value;$/;"	m	class:folly::detail::StateSize
value	.\Random-inl.h	/^  static constexpr size_t value = 512;$/;"	m	struct:folly::detail::StateSize	access:public
value	.\Random-inl.h	/^  static constexpr size_t value = r * ((w + 31) \/ 32);$/;"	m	struct:folly::detail::StateSize	access:public
value	.\Random-inl.h	/^  static constexpr size_t value =$/;"	m	struct:folly::detail::StateSize	access:public
value	.\Random-inl.h	/^StateSize<std::linear_congruential_engine<UIntType, a, c, m>>::value;$/;"	m	class:folly::detail::StateSize
value	.\Random-inl.h	/^StateSize<std::subtract_with_carry_engine<UIntType, w, s, r>>::value;$/;"	m	class:folly::detail::StateSize
value	.\Random-inl.h	/^constexpr size_t StateSize<RNG>::value;$/;"	m	class:folly::detail::StateSize
value	.\Range.h	/^    value =$/;"	e	enum:folly::detail::ComparableAsStringPiece::__anon84
value	.\String-inl.h	/^  enum { value = IsSomeString<T>::value$/;"	e	enum:folly::detail::IsSizableString::__anon92
value	.\String.h	/^  enum { value = true };$/;"	e	enum:folly::boost::has_nothrow_constructor::__anon96
value	.\Synchronized.h	/^  enum { value = IsOneOf<T,$/;"	e	enum:folly::detail::HasLockUnlock::__anon101
value	.\Traits.h	/^  constexpr static bool value = test<T>(nullptr);$/;"	m	class:folly::is_complete	access:public
value	.\Traits.h	/^  enum { value = false };$/;"	e	enum:folly::IsOneOf::__anon151
value	.\Traits.h	/^  enum { value = std::is_same<T, T1>::value || IsOneOf<T, Ts...>::value };$/;"	e	enum:folly::IsOneOf::__anon152
value	.\detail\DiscriminatedPtrDetail.h	/^  static const bool value = true;$/;"	m	struct:folly::dptr_detail::IsSameType	access:public
value	.\detail\DiscriminatedPtrDetail.h	/^  static const bool value =$/;"	m	struct:folly::dptr_detail::IsSameType	access:public
value	.\detail\DiscriminatedPtrDetail.h	/^  static const size_t value = 1 + GetTypeIndex<T, Types...>::value;$/;"	m	struct:folly::dptr_detail::GetTypeIndex	access:public
value	.\detail\DiscriminatedPtrDetail.h	/^  static const size_t value = 1;$/;"	m	struct:folly::dptr_detail::GetTypeIndex	access:public
value	.\detail\MPMCPipelineDetail.h	/^  static constexpr size_t value = 1;$/;"	m	struct:folly::detail::AmplificationProduct	access:public
value	.\detail\MPMCPipelineDetail.h	/^  static constexpr size_t value =$/;"	m	struct:folly::detail::AmplificationProduct	access:public
value	.\experimental\EliasFanoCoding.h	/^  ValueType value() const { return value_; }$/;"	f	class:folly::compression::EliasFanoReader	access:public	signature:() const
value	.\experimental\EliasFanoCoding.h	/^  ValueType value() const { return value_; }$/;"	f	class:folly::compression::detail::UpperBitsReader	access:public	signature:() const
value	.\experimental\test\EventCountTest.cpp	/^  int value() const {$/;"	f	class:__anon46::Semaphore	access:public	signature:() const
value	.\gen\Base.h	/^    value = Constness == Const$/;"	e	enum:folly::gen::ExprIsConst::__anon54
value	.\gen\Base.h	/^    value = Constness == Mutable$/;"	e	enum:folly::gen::ExprIsMutable::__anon55
value	.\gen\Core-inl.h	/^  static constexpr bool value = false;$/;"	m	class:folly::gen::IsCompatibleSignature	access:private
value	.\gen\Core-inl.h	/^  static constexpr bool value = testArgs<Candidate>(nullptr);$/;"	m	class:folly::gen::IsCompatibleSignature	access:public
value	.\test\FormatTest.cpp	/^  int value;$/;"	m	struct:__anon119::KeyValue	file:	access:public
value	.\test\OptionalTest.cpp	/^  int value() const { return opt_.value(); }$/;"	f	class:folly::ContainsOptional	access:public	signature:() const
value	.\test\ThreadLocalTest.cpp	/^  int value() const { return value_; }$/;"	f	class:__anon147::HoldsOne	access:public	signature:() const
value	.\wangle\Future-inl.h	/^  static const bool value = false;$/;"	m	struct:folly::wangle::isFuture	access:public
value	.\wangle\Future-inl.h	/^  static const bool value = true;$/;"	m	struct:folly::wangle::isFuture	access:public
value	.\wangle\Future-inl.h	/^typename std::add_lvalue_reference<T>::type Future<T>::value() {$/;"	f	class:folly::wangle::Future	signature:()
value	.\wangle\Future-inl.h	/^typename std::add_lvalue_reference<const T>::type Future<T>::value() const {$/;"	f	class:folly::wangle::Future	signature:() const
value	.\wangle\Future.h	/^  value() const;$/;"	p	class:folly::wangle::Future	access:public	signature:() const
value	.\wangle\Future.h	/^  value();$/;"	p	class:folly::wangle::Future	access:public	signature:()
value	.\wangle\Later-inl.h	/^  static const bool value = false;$/;"	m	struct:folly::wangle::isLater	access:public
value	.\wangle\Later-inl.h	/^  static const bool value = false;$/;"	m	struct:folly::wangle::isLaterOrFuture	access:public
value	.\wangle\Later-inl.h	/^  static const bool value = true;$/;"	m	struct:folly::wangle::isLater	access:public
value	.\wangle\Later-inl.h	/^  static const bool value = true;$/;"	m	struct:folly::wangle::isLaterOrFuture	access:public
value	.\wangle\ThreadGate.h	/^  value(Future<T> const& f) {$/;"	f	class:folly::wangle::ThreadGate	access:public	signature:(Future<T> const& f)
value	.\wangle\ThreadGate.h	/^  value(Future<T>& f) {$/;"	f	class:folly::wangle::ThreadGate	access:public	signature:(Future<T>& f)
value	.\wangle\Try-inl.h	/^T& Try<T>::value() {$/;"	f	class:folly::wangle::Try	signature:()
value	.\wangle\Try-inl.h	/^const T& Try<T>::value() const {$/;"	f	class:folly::wangle::Try	signature:() const
value	.\wangle\Try.h	/^  T& value();$/;"	p	class:folly::wangle::Try	access:public	signature:()
value	.\wangle\Try.h	/^  const T& value() const;$/;"	p	class:folly::wangle::Try	access:public	signature:() const
value	.\wangle\Try.h	/^  void value() const { throwIfFailed(); }$/;"	f	class:folly::wangle::Try	access:public	signature:() const
value	.\wangle\detail\State.h	/^  typename std::add_lvalue_reference<T>::type value() {$/;"	f	class:folly::wangle::detail::State	access:public	signature:()
valueCount	.\Format.h	/^  static constexpr size_t valueCount = std::tuple_size<ValueTuple>::value;$/;"	m	class:folly::BaseFormatter	access:private
valueGuess	.\LifoSem.h	/^  uint32_t valueGuess() const {$/;"	f	struct:folly::detail::LifoSemBase	access:public	signature:() const
value_	.\Lazy.h	/^  Optional<result_type> value_;$/;"	m	struct:folly::detail::Lazy	access:private
value_	.\MPMCPipeline.h	/^        value_(other.value_) {$/;"	f	class:folly::MPMCPipeline::Ticket	access:public	signature:(other.value_)
value_	.\MPMCPipeline.h	/^        value_(value * amplification) {$/;"	f	class:folly::MPMCPipeline::Ticket	access:private	signature:(value * amplification)
value_	.\MPMCPipeline.h	/^    uint64_t value_;$/;"	m	class:folly::MPMCPipeline::Ticket	access:private
value_	.\Optional.h	/^  union { Value value_; };$/;"	m	union:folly::Optional::__anon81	access:public
value_	.\experimental\EliasFanoCoding.h	/^  ValueType value_ = 0;$/;"	m	class:folly::compression::EliasFanoReader	access:private
value_	.\experimental\EliasFanoCoding.h	/^  ValueType value_;$/;"	m	class:folly::compression::detail::UpperBitsReader	access:private
value_	.\experimental\test\EventCountTest.cpp	/^  std::atomic<int> value_;$/;"	m	class:__anon46::Semaphore	file:	access:private
value_	.\gen\Base-inl.h	/^  const Value value_;$/;"	m	class:folly::gen::detail::Just	access:private
value_	.\io\async\EventBase.h	/^    double  value_;$/;"	m	class:folly::EventBase::SmoothLoopTime	access:private
value_	.\test\ThreadLocalTest.cpp	/^  int value_;$/;"	m	class:__anon147::HoldsOne	file:	access:private
value_	.\test\function_benchmark\test_functions.cpp	/^  std::string value_;$/;"	m	class:Exception	file:	access:private
value_	.\wangle\Try.h	/^    T value_;$/;"	m	union:folly::wangle::Try::__anon154	access:public
value_	.\wangle\detail\State.h	/^  folly::Optional<Try<T>> value_;$/;"	m	class:folly::wangle::detail::State	access:private
value_before	.\Range.h	/^value_before(Iter i) {$/;"	f	namespace:folly::detail	signature:(Iter i)
value_comp	.\sorted_vector_types.h	/^  value_compare value_comp() const { return m_; }$/;"	f	class:folly::sorted_vector_map	access:public	signature:() const
value_comp	.\sorted_vector_types.h	/^  value_compare value_comp() const { return m_; }$/;"	f	class:folly::sorted_vector_set	access:public	signature:() const
value_compare	.\ConcurrentSkipList.h	/^  typedef Comp value_compare;$/;"	t	class:folly::ConcurrentSkipList::Accessor	access:public
value_compare	.\sorted_vector_types.h	/^    explicit value_compare(const Compare& c) : Compare(c) {}$/;"	f	struct:folly::sorted_vector_map::value_compare	access:protected	signature:(const Compare& c)
value_compare	.\sorted_vector_types.h	/^  struct value_compare$/;"	s	class:folly::sorted_vector_map	inherits:std::binary_function,Compare	access:public
value_compare	.\sorted_vector_types.h	/^  typedef Compare value_compare;$/;"	t	class:folly::sorted_vector_set	access:public
value_or	.\Optional.h	/^  Value value_or(U&& dflt) && {$/;"	f	class:folly::Optional	access:public	signature:(U&& dflt)
value_or	.\Optional.h	/^  Value value_or(U&& dflt) const& {$/;"	f	class:folly::Optional	access:public	signature:(U&& dflt) const
value_type	.\AtomicHashArray.h	/^  typedef std::pair<const KeyT, ValueT> value_type;$/;"	t	class:folly::AtomicHashArray	access:public
value_type	.\AtomicHashMap.h	/^  typedef std::pair<const KeyT, ValueT> value_type;$/;"	t	class:folly::AtomicHashMap	access:public
value_type	.\ConcurrentSkipList-inl.h	/^  typedef T value_type;$/;"	t	class:folly::detail::SkipListNode	access:public
value_type	.\ConcurrentSkipList.h	/^  typedef T  value_type;$/;"	t	class:folly::ConcurrentSkipList::Skipper	access:public
value_type	.\ConcurrentSkipList.h	/^  typedef T value_type;$/;"	t	class:folly::ConcurrentSkipList	access:public
value_type	.\ConcurrentSkipList.h	/^  typedef T value_type;$/;"	t	class:folly::ConcurrentSkipList::Accessor	access:public
value_type	.\ConcurrentSkipList.h	/^  typedef ValT value_type;$/;"	t	class:folly::detail::csl_iterator	access:public
value_type	.\FBVector.h	/^  typedef T                                           value_type;$/;"	t	class:folly::fbvector	access:public
value_type	.\IndexedMemPool.h	/^  typedef T value_type;$/;"	t	struct:folly::IndexedMemPool	access:public
value_type	.\MPMCQueue.h	/^  typedef T value_type;$/;"	t	class:folly::MPMCQueue	access:public
value_type	.\Memory.h	/^  typedef T value_type;$/;"	t	class:folly::StlAllocator	access:public
value_type	.\Memory.h	/^  typedef typename std::remove_reference<T>::type value_type;$/;"	t	class:folly::is_simple_allocator	access:private
value_type	.\Memory.h	/^  typedef void value_type;$/;"	t	class:folly::StlAllocator	access:public
value_type	.\Padded.h	/^  typedef typename Node::value_type value_type;$/;"	t	class:folly::Adaptor	access:public
value_type	.\ProducerConsumerQueue.h	/^  typedef T value_type;$/;"	t	struct:folly::ProducerConsumerQueue	access:public
value_type	.\Range.h	/^  value_type;$/;"	t	class:folly::Range	access:public
value_type	.\detail\MPMCPipelineDetail.h	/^  typedef T value_type;$/;"	t	class:folly::MPMCPipelineStage	access:public
value_type	.\detail\MPMCPipelineDetail.h	/^  typedef T value_type;$/;"	t	class:folly::detail::MPMCPipelineStageImpl	access:public
value_type	.\detail\MPMCPipelineDetail.h	/^  typedef T value_type;$/;"	t	struct:folly::detail::PipelineStageInfo	access:public
value_type	.\dynamic-inl.h	/^  typedef typename It::value_type value_type;$/;"	t	struct:folly::dynamic::IterableProxy	access:public
value_type	.\dynamic.h	/^  typedef dynamic value_type;$/;"	t	struct:folly::dynamic	access:public
value_type	.\io\IOBuf.h	/^  typedef ByteRange value_type;$/;"	t	class:folly::IOBuf	access:public
value_type	.\io\RecordIO.h	/^  typedef std::pair<ByteRange, off_t> value_type;$/;"	t	class:folly::RecordIOReader	access:public
value_type	.\io\TypedIOBuf.h	/^  typedef T value_type;$/;"	t	class:folly::TypedIOBuf	access:public
value_type	.\small_vector.h	/^  typedef Value              value_type;$/;"	t	class:folly::small_vector	access:public
value_type	.\sorted_vector_types.h	/^  typedef T       value_type;$/;"	t	class:folly::sorted_vector_set	access:public
value_type	.\sorted_vector_types.h	/^  typedef std::pair<key_type,mapped_type>           value_type;$/;"	t	class:folly::sorted_vector_map	access:public
value_type	.\test\AtomicHashArrayTest.cpp	/^  typedef T value_type;$/;"	t	class:MmapAllocator	file:	access:public
value_type	.\test\stl_tests\StlVectorTest.cpp	/^  typedef typename std::allocator<T>::value_type value_type;$/;"	t	struct:Alloc	file:	access:public
value_type	.\wangle\Future.h	/^  typedef T value_type;$/;"	t	class:folly::wangle::Future	access:public
value_type	.\wangle\Later.h	/^  typedef T value_type;$/;"	t	class:folly::wangle::Later	access:public
values	.\dynamic-inl.h	/^inline dynamic::IterableProxy<dynamic::const_value_iterator> dynamic::values()$/;"	f	class:folly::dynamic	signature:() const
values	.\dynamic.h	/^  IterableProxy<const_value_iterator> values() const;$/;"	p	struct:folly::dynamic	access:public	signature:() const
values_	.\Format.h	/^  ValueTuple values_;$/;"	v
vault_	.\experimental\Singleton.h	/^  SingletonVault* vault_;$/;"	m	class:folly::Singleton	access:private
vdsoFunc	.\detail\CacheLocality.cpp	/^Getcpu::Func Getcpu::vdsoFunc() {$/;"	f	class:folly::detail::Getcpu	signature:()
vdsoFunc	.\detail\CacheLocality.h	/^  static Func vdsoFunc();$/;"	p	struct:folly::detail::Getcpu	access:public	signature:()
vec	.\test\small_vector_test.cpp	/^  folly::small_vector<Thrower,3> vec;$/;"	m	struct:__anon132::TestBasicGuarantee	file:	access:public
vec_	.\experimental\wangle\concurrent\ThreadPoolExecutor.h	/^    std::vector<ThreadPtr> vec_;$/;"	m	class:folly::wangle::ThreadPoolExecutor::ThreadList	access:private
vector	.\Traits.h	/^  class vector;$/;"	x
vector	.\Traits.h	/^FOLLY_ASSUME_FBVECTOR_COMPATIBLE_2(std::vector);$/;"	v
verify	.\test\ThreadCachedArenaTest.cpp	/^  void verify();$/;"	p	class:__anon143::ArenaTester	file:	access:public	signature:()
verify	.\test\ThreadCachedArenaTest.cpp	/^void ArenaTester::verify() {$/;"	f	class:__anon143::ArenaTester	signature:()
verify	.\test\stl_tests\StlVectorTest.cpp	/^void verify(int extras) {$/;"	f	signature:(int extras)
verify	.\test\stl_tests\StlVectorTest.cpp	/^void verify(int extras, const Vector& v) {$/;"	f	signature:(int extras, const Vector& v)
verify	.\test\stl_tests\StlVectorTest.cpp	/^void verify(int extras, const Vector& v1, const Vector& v2) {$/;"	f	signature:(int extras, const Vector& v1, const Vector& v2)
verifyAllocator	.\test\stl_tests\StlVectorTest.cpp	/^void verifyAllocator(int ele, int cap) {$/;"	f	signature:(int ele, int cap)
verifyEqual	.\test\ConcurrentSkipListTest.cpp	/^bool verifyEqual(SkipListAccessor skipList,$/;"	f	namespace:__anon114	signature:(SkipListAccessor skipList, const SetType &verifier)
verifyStackTraces	.\experimental\symbolizer\test\StackTraceTest.cpp	/^void verifyStackTraces() {$/;"	f	signature:()
verifyVector	.\test\stl_tests\StlVectorTest.cpp	/^void verifyVector(const Vector& v) {$/;"	f	signature:(const Vector& v)
version	.\IPAddress.h	/^  uint8_t version() const {$/;"	f	class:folly::IPAddress	access:public	signature:() const
version	.\IPAddressV4.h	/^  size_t version() const { return 4; }$/;"	f	class:folly::IPAddressV4	access:public	signature:() const
version	.\IPAddressV6.h	/^  size_t version() const { return 6; }$/;"	f	class:folly::IPAddressV6	access:public	signature:() const
version	.\experimental\EliasFanoCoding.h	/^  static constexpr size_t version = kVersion;$/;"	m	struct:folly::compression::EliasFanoEncoder	access:public
version	.\io\RecordIO-inl.h	/^  uint8_t  version;       \/\/ backwards incompatible version, currently 0$/;"	m	struct:folly::recordio_helpers::detail::Header	access:public
version	.\test\IPAddressTest.h	/^  uint8_t version;$/;"	m	struct:folly::AddressData	access:public
version	.\test\IPAddressTest.h	/^  uint8_t version;$/;"	m	struct:folly::AddressFlags	access:public
version_	.\experimental\symbolizer\Dwarf.h	/^    uint16_t version_;$/;"	m	class:folly::symbolizer::Dwarf::LineNumberVM	access:private
vformat	.\Format.h	/^Formatter<true, C> vformat(StringPiece fmt, C&& container);$/;"	p	namespace:folly	signature:(StringPiece fmt, C&& container)
via	.\wangle\Future-inl.h	/^inline Future<T> Future<T>::via(Executor* executor) {$/;"	f	class:folly::wangle::Future	signature:(Executor* executor)
via	.\wangle\Future.h	/^  Future<T> via(Executor* executor);$/;"	p	class:folly::wangle::Future	access:public	signature:(Executor* executor)
via	.\wangle\Later-inl.h	/^Later<T> Later<T>::via(Executor* executor) {$/;"	f	class:folly::wangle::Later	signature:(Executor* executor)
via	.\wangle\Later.h	/^  Later<T> via(Executor* executor);$/;"	p	class:folly::wangle::Later	access:public	signature:(Executor* executor)
vstr	.\test\RangeFindBenchmark.cpp	/^std::vector<std::string> vstr;$/;"	m	namespace:__anon129	file:
vstrp	.\test\RangeFindBenchmark.cpp	/^std::vector<StringPiece> vstrp;$/;"	m	namespace:__anon129	file:
wait	.\Baton.h	/^  void wait() {$/;"	f	struct:folly::Baton	access:public	signature:()
wait	.\LifoSem.h	/^  void wait() {$/;"	f	struct:folly::detail::LifoSemBase	access:public	signature:()
wait	.\SmallLocks.h	/^    void wait() {$/;"	f	class:folly::detail::Sleeper	access:public	signature:()
wait	.\Subprocess.cpp	/^ProcessReturnCode Subprocess::wait() {$/;"	f	class:folly::Subprocess	signature:()
wait	.\Subprocess.h	/^  ProcessReturnCode wait();$/;"	p	class:folly::Subprocess	access:public	signature:()
wait	.\experimental\io\AsyncIO.cpp	/^Range<AsyncIO::Op**> AsyncIO::wait(size_t minRequests) {$/;"	f	class:folly::AsyncIO	signature:(size_t minRequests)
wait	.\experimental\io\AsyncIO.h	/^  Range<Op**> wait(size_t minRequests);$/;"	p	class:folly::AsyncIO	access:public	signature:(size_t minRequests)
wait	.\test\DeterministicSchedule.cpp	/^DeterministicSchedule::wait(sem_t* sem) {$/;"	f	class:folly::test::DeterministicSchedule	signature:(sem_t* sem)
wait	.\test\DeterministicSchedule.h	/^  static void wait(sem_t* sem);$/;"	p	class:folly::test::DeterministicSchedule	access:public	signature:(sem_t* sem)
wait	.\wangle\ManualExecutor.cpp	/^void ManualExecutor::wait() {$/;"	f	class:folly::wangle::ManualExecutor	signature:()
wait	.\wangle\ManualExecutor.h	/^    void wait();$/;"	p	class:folly::wangle::ManualExecutor	access:public	signature:()
waitChecked	.\Subprocess.cpp	/^void Subprocess::waitChecked() {$/;"	f	class:folly::Subprocess	signature:()
waitChecked	.\Subprocess.h	/^  void waitChecked();$/;"	p	class:folly::Subprocess	access:public	signature:()
waitFor	.\wangle\ManualExecutor.h	/^    template <class F> void waitFor(F const& f) {$/;"	f	class:folly::wangle::ManualExecutor	access:public	signature:(F const& f)
waitFor	.\wangle\ThreadGate.h	/^  void waitFor(Future<T> const& f) {$/;"	f	class:folly::wangle::ThreadGate	access:public	signature:(Future<T> const& f)
waitUntilReadable	.\experimental\io\test\AsyncIOTest.cpp	/^void waitUntilReadable(int fd) {$/;"	f	namespace:__anon32	signature:(int fd)
waitUntilRunning	.\io\async\EventBase.cpp	/^void EventBase::waitUntilRunning() {$/;"	f	class:folly::EventBase	signature:()
waitUntilRunning	.\io\async\EventBase.h	/^  void waitUntilRunning();$/;"	p	class:folly::EventBase	access:public	signature:()
waitWithSemaphore	.\wangle\Future-inl.h	/^inline Future<void> waitWithSemaphore<void>(Future<void>&& f) {$/;"	f	namespace:folly::wangle	signature:(Future<void>&& f)
waitWithSemaphore	.\wangle\Future-inl.h	/^waitWithSemaphore(Future<T>&& f) {$/;"	f	namespace:folly::wangle	signature:(Future<T>&& f)
waitWithSemaphore	.\wangle\Future-inl.h	/^waitWithSemaphore(Future<T>&& f, Duration timeout) {$/;"	f	namespace:folly::wangle	signature:(Future<T>&& f, Duration timeout)
waitWithSemaphore	.\wangle\Future-inl.h	/^waitWithSemaphore(Future<void>&& f, Duration timeout) {$/;"	f	namespace:folly::wangle	signature:(Future<void>&& f, Duration timeout)
waitWithSemaphore	.\wangle\Future.h	/^Future<T> waitWithSemaphore(Future<T>&& f);$/;"	p	namespace:folly::wangle	signature:(Future<T>&& f)
waitWithSemaphore	.\wangle\Future.h	/^Future<T> waitWithSemaphore(Future<T>&& f, Duration timeout);$/;"	p	namespace:folly::wangle	signature:(Future<T>&& f, Duration timeout)
waiter	.\wangle\GenericThreadGate.h	/^  WaiterPtr waiter;$/;"	m	class:folly::wangle::GenericThreadGate	access:public
waiter	.\wangle\test\LaterTest.cpp	/^  std::shared_ptr<ManualWaiter> waiter;$/;"	m	struct:LaterFixture	file:	access:public
waiter	.\wangle\test\ThreadGateTest.cpp	/^  shared_ptr<ManualWaiter> waiter;$/;"	m	struct:GenericThreadGateFixture	file:	access:public
wakeConsumer_	.\gen\Parallel-inl.h	/^  folly::EventCount wakeConsumer_;$/;"	m	class:folly::gen::detail::ClosableMPMCQueue	access:private
wakeProducer_	.\gen\Parallel-inl.h	/^  folly::EventCount wakeProducer_;$/;"	m	class:folly::gen::detail::ClosableMPMCQueue	access:private
wake_	.\gen\ParallelMap-inl.h	/^      EventCount wake_;$/;"	m	class:folly::gen::detail::PMap::Generator::ExecutionPipeline	access:private
walk_size	.\Range.h	/^  size_type walk_size() const {$/;"	f	class:folly::Range	access:public	signature:() const
wangle	.\experimental\wangle\ConnectionManager.cpp	/^namespace folly { namespace wangle {$/;"	n	namespace:folly	file:
wangle	.\experimental\wangle\ConnectionManager.h	/^namespace folly { namespace wangle {$/;"	n	namespace:folly
wangle	.\experimental\wangle\ManagedConnection.cpp	/^namespace folly { namespace wangle {$/;"	n	namespace:folly	file:
wangle	.\experimental\wangle\ManagedConnection.h	/^namespace folly { namespace wangle {$/;"	n	namespace:folly
wangle	.\experimental\wangle\concurrent\BlockingQueue.h	/^namespace folly { namespace wangle {$/;"	n	namespace:folly
wangle	.\experimental\wangle\concurrent\CPUThreadPoolExecutor.cpp	/^namespace folly { namespace wangle {$/;"	n	namespace:folly	file:
wangle	.\experimental\wangle\concurrent\CPUThreadPoolExecutor.h	/^namespace folly { namespace wangle {$/;"	n	namespace:folly
wangle	.\experimental\wangle\concurrent\Executor.h	/^namespace folly { namespace wangle {$/;"	n	namespace:folly
wangle	.\experimental\wangle\concurrent\IOThreadPoolExecutor.cpp	/^namespace folly { namespace wangle {$/;"	n	namespace:folly	file:
wangle	.\experimental\wangle\concurrent\IOThreadPoolExecutor.h	/^namespace folly { namespace wangle {$/;"	n	namespace:folly
wangle	.\experimental\wangle\concurrent\LifoSemMPMCQueue.h	/^namespace folly { namespace wangle {$/;"	n	namespace:folly
wangle	.\experimental\wangle\concurrent\NamedThreadFactory.h	/^namespace folly { namespace wangle {$/;"	n	namespace:folly
wangle	.\experimental\wangle\concurrent\ThreadFactory.h	/^namespace folly { namespace wangle {$/;"	n	namespace:folly
wangle	.\experimental\wangle\concurrent\ThreadPoolExecutor.cpp	/^namespace folly { namespace wangle {$/;"	n	namespace:folly	file:
wangle	.\experimental\wangle\concurrent\ThreadPoolExecutor.h	/^namespace folly { namespace wangle {$/;"	n	namespace:folly
wangle	.\wangle\Executor.h	/^namespace folly { namespace wangle {$/;"	n	namespace:folly
wangle	.\wangle\Future-inl.h	/^namespace folly { namespace wangle {$/;"	n	namespace:folly
wangle	.\wangle\Future.h	/^namespace folly { namespace wangle {$/;"	n	namespace:folly
wangle	.\wangle\GenericThreadGate.h	/^namespace folly { namespace wangle {$/;"	n	namespace:folly
wangle	.\wangle\InlineExecutor.h	/^namespace folly { namespace wangle {$/;"	n	namespace:folly
wangle	.\wangle\Later-inl.h	/^namespace folly { namespace wangle {$/;"	n	namespace:folly
wangle	.\wangle\Later.h	/^namespace folly { namespace wangle {$/;"	n	namespace:folly
wangle	.\wangle\ManualExecutor.cpp	/^namespace folly { namespace wangle {$/;"	n	namespace:folly	file:
wangle	.\wangle\ManualExecutor.h	/^namespace folly { namespace wangle {$/;"	n	namespace:folly
wangle	.\wangle\OpaqueCallbackShunt.h	/^namespace folly { namespace wangle {$/;"	n	namespace:folly
wangle	.\wangle\Promise-inl.h	/^namespace folly { namespace wangle {$/;"	n	namespace:folly
wangle	.\wangle\Promise.h	/^namespace folly { namespace wangle {$/;"	n	namespace:folly
wangle	.\wangle\QueuedImmediateExecutor.cpp	/^namespace folly { namespace wangle {$/;"	n	namespace:folly	file:
wangle	.\wangle\QueuedImmediateExecutor.h	/^namespace folly { namespace wangle {$/;"	n	namespace:folly
wangle	.\wangle\ThreadGate.cpp	/^namespace folly { namespace wangle {$/;"	n	namespace:folly	file:
wangle	.\wangle\ThreadGate.h	/^namespace folly { namespace wangle {$/;"	n	namespace:folly
wangle	.\wangle\Try-inl.h	/^namespace folly { namespace wangle {$/;"	n	namespace:folly
wangle	.\wangle\Try.h	/^namespace folly { namespace wangle {$/;"	n	namespace:folly
wangle	.\wangle\WangleException.h	/^namespace folly { namespace wangle {$/;"	n	namespace:folly
wangle	.\wangle\detail\State.h	/^namespace folly { namespace wangle { namespace detail {$/;"	n	namespace:folly
westExecutor	.\wangle\GenericThreadGate.h	/^  WestExecutorPtr westExecutor;$/;"	m	class:folly::wangle::GenericThreadGate	access:public
westExecutor	.\wangle\test\LaterTest.cpp	/^  std::shared_ptr<ManualExecutor> westExecutor;$/;"	m	struct:LaterFixture	file:	access:public
westExecutor	.\wangle\test\ThreadGateTest.cpp	/^  shared_ptr<ManualExecutor> westExecutor;$/;"	m	struct:GenericThreadGateFixture	file:	access:public
what	.\ExceptionWrapper.h	/^  fbstring what() const {$/;"	f	class:folly::exception_wrapper	access:public	signature:() const
what	.\test\function_benchmark\test_functions.cpp	/^  virtual const char *what(void) const throw() {$/;"	f	class:Exception	access:public	signature:(void) const
what	.\wangle\WangleException.h	/^  virtual const char *what() const throw() {$/;"	f	class:folly::wangle::WangleException	access:public	signature:() const
what_	.\Subprocess.h	/^  std::string what_;$/;"	m	class:folly::CalledProcessError	access:private
what_	.\Subprocess.h	/^  std::string what_;$/;"	m	class:folly::SubprocessSpawnError	access:private
what_	.\test\ExceptionWrapperTest.cpp	/^  mutable std::string what_;$/;"	m	class:IntException	file:	access:private
whatevs_	.\test\FBVectorTest.cpp	/^class UserDefinedType { int whatevs_; };$/;"	m	class:__anon115::UserDefinedType	file:	access:private
wheel_	.\io\async\HHWheelTimer.h	/^    HHWheelTimer* wheel_;$/;"	m	class:folly::HHWheelTimer::Callback	access:private
whenAll	.\wangle\Future-inl.h	/^whenAll(Fs&&... fs)$/;"	f	namespace:folly::wangle	signature:(Fs&&.... fs)
whenAll	.\wangle\Future-inl.h	/^whenAll(InputIterator first, InputIterator last)$/;"	f	namespace:folly::wangle	signature:(InputIterator first, InputIterator last)
whenAll	.\wangle\Future.h	/^whenAll(Fs&&... fs);$/;"	p	namespace:folly::wangle	signature:(Fs&&.... fs)
whenAll	.\wangle\Future.h	/^whenAll(InputIterator first, InputIterator last);$/;"	p	namespace:folly::wangle	signature:(InputIterator first, InputIterator last)
whenAllLater	.\wangle\Later-inl.h	/^Later<std::vector<Try<T>>> whenAllLater(std::vector<Later<T>>&& laters) {$/;"	f	namespace:folly::wangle	signature:(std::vector<Later<T>>&& laters)
whenAllLater	.\wangle\Later.h	/^Later<std::vector<Try<T>>> whenAllLater(std::vector<Later<T>>&& laters);$/;"	p	namespace:folly::wangle	signature:(std::vector<Later<T>>&& laters)
whenAllVariadicHelper	.\wangle\detail\State.h	/^whenAllVariadicHelper(VariadicContext<Ts...> *ctx, THead&& head, Fs&&... tail) {$/;"	f	namespace:folly::wangle::detail	signature:(VariadicContext<Ts...> *ctx, THead&& head, Fs&&... tail)
whenAny	.\wangle\Future-inl.h	/^whenAny(InputIterator first, InputIterator last) {$/;"	f	namespace:folly::wangle	signature:(InputIterator first, InputIterator last)
whenAny	.\wangle\Future.h	/^whenAny(InputIterator first, InputIterator last);$/;"	p	namespace:folly::wangle	signature:(InputIterator first, InputIterator last)
whenN	.\wangle\Future-inl.h	/^whenN(InputIterator first, InputIterator last, size_t n) {$/;"	f	namespace:folly::wangle	signature:(InputIterator first, InputIterator last, size_t n)
whenN	.\wangle\Future.h	/^whenN(InputIterator first, InputIterator last, size_t n);$/;"	p	namespace:folly::wangle	signature:(InputIterator first, InputIterator last, size_t n)
whole	.\RWSpinLock.h	/^    FullInt whole;$/;"	m	union:folly::RWTicketSpinLockT::RWTicket	access:public
width	.\FormatArg.h	/^  int width;$/;"	m	struct:folly::FormatArg	access:public
withEmpty	.\IndexedMemPool.h	/^    TaggedPtr withEmpty() const {$/;"	f	struct:folly::IndexedMemPool	access:private	signature:() const
withIdx	.\IndexedMemPool.h	/^    TaggedPtr withIdx(uint32_t repl) const {$/;"	f	struct:folly::IndexedMemPool	access:private	signature:(uint32_t repl) const
withPop	.\LifoSem.h	/^  inline LifoSemHead withPop(uint32_t idxNext) const {$/;"	f	class:folly::detail::LifoSemHead	access:public	signature:(uint32_t idxNext) const
withPush	.\LifoSem.h	/^  inline LifoSemHead withPush(uint32_t _idx) const {$/;"	f	class:folly::detail::LifoSemHead	access:public	signature:(uint32_t _idx) const
withShutdown	.\LifoSem.h	/^  inline LifoSemHead withShutdown() const {$/;"	f	class:folly::detail::LifoSemHead	access:public	signature:() const
withSize	.\IndexedMemPool.h	/^    TaggedPtr withSize(uint32_t repl) const {$/;"	f	struct:folly::IndexedMemPool	access:private	signature:(uint32_t repl) const
withSizeDecr	.\IndexedMemPool.h	/^    TaggedPtr withSizeDecr() const {$/;"	f	struct:folly::IndexedMemPool	access:private	signature:() const
withSizeIncr	.\IndexedMemPool.h	/^    TaggedPtr withSizeIncr() const {$/;"	f	struct:folly::IndexedMemPool	access:private	signature:() const
withValueDecr	.\LifoSem.h	/^  inline LifoSemHead withValueDecr(uint32_t delta) const {$/;"	f	class:folly::detail::LifoSemHead	access:public	signature:(uint32_t delta) const
withValueIncr	.\LifoSem.h	/^  inline LifoSemHead withValueIncr(uint32_t delta) const {$/;"	f	class:folly::detail::LifoSemHead	access:public	signature:(uint32_t delta) const
with_exception	.\ExceptionWrapper.h	/^  bool with_exception(F f) const {$/;"	f	class:folly::exception_wrapper	access:public	signature:(F f) const
with_exception	.\ExceptionWrapper.h	/^  bool with_exception(F f) {$/;"	f	class:folly::exception_wrapper	access:public	signature:(F f)
with_exception1	.\ExceptionWrapper.h	/^  static bool with_exception1(F f, T* that) {$/;"	f	class:folly::exception_wrapper	access:private	signature:(F f, T* that)
work	.\gen\Parallel-inl.h	/^      void work() {$/;"	f	class:folly::gen::detail::Parallel::Generator::Executor	access:private	signature:()
workAndBlock	.\gen\test\ParallelBenchmark.cpp	/^static auto workAndBlock = [](int i) {$/;"	v	file:
workers_	.\gen\Parallel-inl.h	/^      std::vector<std::thread> workers_;$/;"	m	class:folly::gen::detail::Parallel::Generator::Executor	access:private
workers_	.\gen\ParallelMap-inl.h	/^      std::vector<std::thread> workers_;$/;"	m	class:folly::gen::detail::PMap::Generator::ExecutionPipeline	access:private
wrapBuffer	.\io\IOBuf.cpp	/^unique_ptr<IOBuf> IOBuf::wrapBuffer(const void* buf, uint64_t capacity) {$/;"	f	class:folly::IOBuf	signature:(const void* buf, uint64_t capacity)
wrapBuffer	.\io\IOBuf.h	/^  static std::unique_ptr<IOBuf> wrapBuffer(ByteRange br) {$/;"	f	class:folly::IOBuf	access:public	signature:(ByteRange br)
wrapBuffer	.\io\IOBuf.h	/^  static std::unique_ptr<IOBuf> wrapBuffer(const void* buf, uint64_t capacity);$/;"	p	class:folly::IOBuf	access:public	signature:(const void* buf, uint64_t capacity)
wrapBuffer	.\io\IOBufQueue.cpp	/^IOBufQueue::wrapBuffer(const void* buf, size_t len, uint64_t blockSize) {$/;"	f	class:folly::IOBufQueue	signature:(const void* buf, size_t len, uint64_t blockSize)
wrapBuffer	.\io\IOBufQueue.h	/^  void wrapBuffer(const void* buf, size_t len,$/;"	p	class:folly::IOBufQueue	access:public	signature:(const void* buf, size_t len, uint64_t blockSize=(1U << 31))
wrapFull	.\detail\FileUtilDetail.h	/^ssize_t wrapFull(F f, int fd, void* buf, size_t count, Offset... offset) {$/;"	f	namespace:folly::fileutil_detail	signature:(F f, int fd, void* buf, size_t count, Offset... offset)
wrapNoInt	.\detail\FileUtilDetail.h	/^ssize_t wrapNoInt(F f, Args... args) {$/;"	f	namespace:folly::fileutil_detail	signature:(F f, Args... args)
wrap_frame	.\FBVector.h	/^  void wrap_frame(T* ledge, size_type idx, size_type n) {$/;"	f	signature:(T* ledge, size_type idx, size_type n)
wrapped_	.\gen\Base-inl.h	/^    Wrapped wrapped_;$/;"	m	class:folly::gen::VirtualGen::WrapperImpl	access:private
wrapper_	.\gen\Base-inl.h	/^  std::unique_ptr<const WrapperBase> wrapper_;$/;"	m	class:folly::gen::VirtualGen	access:private
wrapvFull	.\detail\FileUtilDetail.h	/^ssize_t wrapvFull(F f, int fd, iovec* iov, int count, Offset... offset) {$/;"	f	namespace:folly::fileutil_detail	signature:(F f, int fd, iovec* iov, int count, Offset... offset)
writable	.\MemoryMapping.h	/^    bool writable = false;$/;"	m	struct:folly::MemoryMapping::Options	access:public
writable	.\MemoryMapping.h	/^  static Options writable() {$/;"	f	class:folly::MemoryMapping	access:public	signature:()
writableBuffer	.\io\IOBuf.h	/^  uint8_t* writableBuffer() {$/;"	f	class:folly::IOBuf	access:public	signature:()
writableBuffer	.\io\TypedIOBuf.h	/^  T* writableBuffer() {$/;"	f	class:folly::TypedIOBuf	access:public	signature:()
writableData	.\io\Cursor.h	/^  uint8_t* writableData() {$/;"	f	class:folly::io::Appender	access:public	signature:()
writableData	.\io\Cursor.h	/^  uint8_t* writableData() {$/;"	f	class:folly::io::QueueAppender	access:public	signature:()
writableData	.\io\Cursor.h	/^  uint8_t* writableData() {$/;"	f	class:folly::io::RWCursor	access:public	signature:()
writableData	.\io\IOBuf.h	/^  uint8_t* writableData() {$/;"	f	class:folly::IOBuf	access:public	signature:()
writableData	.\io\TypedIOBuf.h	/^  T* writableData() {$/;"	f	class:folly::TypedIOBuf	access:public	signature:()
writableRange	.\MemoryMapping.h	/^  MutableByteRange writableRange() const {$/;"	f	class:folly::MemoryMapping	access:public	signature:() const
writableTail	.\io\IOBuf.h	/^  uint8_t* writableTail() {$/;"	f	class:folly::IOBuf	access:public	signature:()
writableTail	.\io\IOBufQueue.h	/^  void* writableTail() const {$/;"	f	class:folly::IOBufQueue	access:public	signature:() const
writableTail	.\io\TypedIOBuf.h	/^  T* writableTail() {$/;"	f	class:folly::TypedIOBuf	access:public	signature:()
write	.\Fingerprint.h	/^  void write(uint64_t* out) const {$/;"	f	class:folly::Fingerprint	access:public	signature:(uint64_t* out) const
write	.\MPMCPipeline.h	/^  bool write(Args&&... args) {$/;"	f	class:folly::MPMCPipeline	access:public	signature:(Args&&.... args)
write	.\ProducerConsumerQueue.h	/^  bool write(Args&&... recordArgs) {$/;"	f	struct:folly::ProducerConsumerQueue	access:public	signature:(Args&&.... recordArgs)
write	.\RWSpinLock.h	/^      QuarterInt write;$/;"	m	struct:folly::RWTicketSpinLockT::RWTicket::__anon85	access:public
write	.\detail\FingerprintPolynomial.h	/^  void write(uint64_t* out) const {$/;"	f	class:folly::detail::FingerprintPolynomial	access:public	signature:(uint64_t* out) const
write	.\detail\SlowFingerprint.h	/^  void write(uint64_t* out) const {$/;"	f	class:folly::detail::SlowFingerprint	access:public	signature:(uint64_t* out) const
write	.\gen\File-inl.h	/^  void write(ByteRange v) const {$/;"	f	class:folly::gen::detail::FileWriter	access:private	signature:(ByteRange v) const
write	.\gen\ParallelMap-inl.h	/^      bool write(Value&& value) {$/;"	f	class:folly::gen::detail::PMap::Generator::ExecutionPipeline	access:public	signature:(Value&& value)
write	.\io\Cursor.h	/^  write(T value) {$/;"	f	class:folly::io::QueueAppender	access:public	signature:(T value)
write	.\io\Cursor.h	/^  write(T value) {$/;"	f	class:folly::io::detail::Writable	access:public	signature:(T value)
write	.\io\RecordIO.cpp	/^void RecordIOWriter::write(std::unique_ptr<IOBuf> buf) {$/;"	f	class:folly::RecordIOWriter	signature:(std::unique_ptr<IOBuf> buf)
write	.\io\RecordIO.h	/^  void write(std::unique_ptr<IOBuf> buf);$/;"	p	class:folly::RecordIOWriter	access:public	signature:(std::unique_ptr<IOBuf> buf)
writeAll	.\experimental\symbolizer\test\LineReaderTest.cpp	/^void writeAll(int fd, const char* str) {$/;"	f	namespace:folly::symbolizer::test	signature:(int fd, const char* str)
writeBE	.\io\Cursor.h	/^  void writeBE(T value) {$/;"	f	class:folly::io::detail::Writable	access:public	signature:(T value)
writeBits56	.\experimental\EliasFanoCoding.h	/^  static void writeBits56(unsigned char* data, size_t pos,$/;"	f	struct:folly::compression::EliasFanoEncoder	access:private	signature:(unsigned char* data, size_t pos, uint8_t len, uint64_t value)
writeFull	.\FileUtil.cpp	/^ssize_t writeFull(int fd, const void* buf, size_t count) {$/;"	f	namespace:folly	signature:(int fd, const void* buf, size_t count)
writeFull	.\FileUtil.h	/^ssize_t writeFull(int fd, const void* buf, size_t n);$/;"	p	namespace:folly	signature:(int fd, const void* buf, size_t n)
writeIndex_	.\ProducerConsumerQueue.h	/^  std::atomic<int> writeIndex_;$/;"	m	struct:folly::ProducerConsumerQueue	access:private
writeIntegerString	.\detail\IPAddress.h	/^  inline void writeIntegerString($/;"	f	namespace:folly::detail	signature:( IntegralType val, char** buffer)
writeLE	.\io\Cursor.h	/^  void writeLE(T value) {$/;"	f	class:folly::io::detail::Writable	access:public	signature:(T value)
writeLockAggressive	.\RWSpinLock.h	/^  void writeLockAggressive() {$/;"	f	class:folly::RWTicketSpinLockT	access:public	signature:()
writeLockNice	.\RWSpinLock.h	/^  void writeLockNice() {$/;"	f	class:folly::RWTicketSpinLockT	access:public	signature:()
writeLock_	.\io\RecordIO.h	/^  std::unique_lock<File> writeLock_;$/;"	m	class:folly::RecordIOWriter	access:private
writeNoInt	.\FileUtil.cpp	/^ssize_t writeNoInt(int fd, const void* buf, size_t count) {$/;"	f	namespace:folly	signature:(int fd, const void* buf, size_t count)
writeNoInt	.\FileUtil.h	/^ssize_t writeNoInt(int fd, const void* buf, size_t n);$/;"	p	namespace:folly	signature:(int fd, const void* buf, size_t n)
writeStderr	.\SafeAssert.cpp	/^void writeStderr(const char* s) {$/;"	f	namespace:folly::detail::__anon86	signature:(const char* s)
writeStringToFileOrDie	.\test\MemoryMappingTest.cpp	/^void writeStringToFileOrDie(const std::string& str, int fd) {$/;"	f	namespace:folly::__anon125	signature:(const std::string& str, int fd)
writeTo	.\Format-inl.h	/^void writeTo(FILE* fp,$/;"	f	namespace:folly	signature:(FILE* fp, const BaseFormatter<Derived, containerMode, Args...>& formatter)
writeUnlessClosed	.\gen\Parallel-inl.h	/^      bool writeUnlessClosed(Input&& input) {$/;"	f	class:folly::gen::detail::Parallel::Generator::Executor	access:public	signature:(Input&& input)
writeUnlessClosed	.\gen\Parallel-inl.h	/^  bool writeUnlessClosed(Args&&... args) {$/;"	f	class:folly::gen::detail::ClosableMPMCQueue	access:public	signature:(Args&&.... args)
writeUnlessFull	.\gen\Parallel-inl.h	/^      bool writeUnlessFull(Input&& input) {$/;"	f	class:folly::gen::detail::Parallel::Generator::Executor	access:public	signature:(Input&& input)
writeValues_	.\test\ConcurrentSkipListBenchmark.cpp	/^  std::vector<ValueType> writeValues_;$/;"	m	class:__anon113::ConcurrentAccessData	file:	access:private
writevFull	.\FileUtil.cpp	/^ssize_t writevFull(int fd, iovec* iov, int count) {$/;"	f	namespace:folly	signature:(int fd, iovec* iov, int count)
writevFull	.\FileUtil.h	/^ssize_t writevFull(int fd, iovec* iov, int count);$/;"	p	namespace:folly	signature:(int fd, iovec* iov, int count)
writevNoInt	.\FileUtil.cpp	/^ssize_t writevNoInt(int fd, const iovec* iov, int count) {$/;"	f	namespace:folly	signature:(int fd, const iovec* iov, int count)
writevNoInt	.\FileUtil.h	/^ssize_t writevNoInt(int fd, const iovec* iov, int count);$/;"	p	namespace:folly	signature:(int fd, const iovec* iov, int count)
x	.\test\PaddedTest.cpp	/^    uint8_t x;$/;"	m	struct:StructPaddedTestBase::Point	file:	access:public
xallocx	.\detail\Malloc.h	/^extern size_t (*xallocx)(void*, size_t, size_t, int);$/;"	x
xallocx	.\detail\Malloc.h	/^size_t xallocx(void*, size_t, size_t, int) __attribute__((__weak__));$/;"	p	signature:(void*, size_t, size_t, int)
xallocx	.\detail\MallocImpl.cpp	/^size_t (*xallocx)(void*, size_t, size_t, int) = nullptr;$/;"	v
xortab	.\Fingerprint.h	/^  void xortab(const uint64_t* tab) {$/;"	f	class:folly::Fingerprint	access:private	signature:(const uint64_t* tab)
y	.\test\PaddedTest.cpp	/^    uint8_t y;$/;"	m	struct:StructPaddedTestBase::Point	file:	access:public
z	.\test\PaddedTest.cpp	/^    uint8_t z;$/;"	m	struct:StructPaddedTestBase::Point	file:	access:public
z_	.\FBVector.h	/^        b_(other.b_), e_(other.e_), z_(other.z_)$/;"	f	struct:folly::fbvector::Impl	access:public	signature:(other.z_)
z_	.\FBVector.h	/^    pointer b_, e_, z_;$/;"	m	struct:folly::fbvector::Impl	access:public
zero	.\experimental\Bits.h	/^  static constexpr UnderlyingType zero = UnderlyingType(0);$/;"	m	struct:folly::Bits	access:private
zip	.\gen\Combine-inl.h	/^Zip zip(Source&& source) {$/;"	f	namespace:folly::gen	signature:(Source&& source)
zombiesMutex_	.\ThreadCachedArena.h	/^  std::mutex zombiesMutex_;$/;"	m	class:folly::ThreadCachedArena	access:private
zombies_	.\ThreadCachedArena.h	/^  SysArena zombies_;  \/\/ allocated from threads that are now dead$/;"	m	class:folly::ThreadCachedArena	access:private
zombify	.\ThreadCachedArena.cpp	/^void ThreadCachedArena::zombify(SysArena&& arena) {$/;"	f	class:folly::ThreadCachedArena	signature:(SysArena&& arena)
zombify	.\ThreadCachedArena.h	/^  void zombify(SysArena&& arena);$/;"	p	class:folly::ThreadCachedArena	access:private	signature:(SysArena&& arena)
~AccessSpreaderArray	.\detail\CacheLocality.h	/^  ~AccessSpreaderArray() {$/;"	f	struct:folly::detail::AccessSpreaderArray	access:public	signature:()
~Accessor	.\ConcurrentSkipList.h	/^  ~Accessor() {$/;"	f	class:folly::ConcurrentSkipList::Accessor	access:public	signature:()
~Accessor	.\ThreadLocal.h	/^    ~Accessor() {$/;"	f	class:folly::ThreadLocalPtr::Accessor	access:public	signature:()
~Arena	.\Arena-inl.h	/^Arena<Alloc>::~Arena() {$/;"	f	class:folly::Arena	signature:()
~Arena	.\Arena.h	/^  ~Arena();$/;"	p	class:folly::Arena	access:public	signature:()
~AsyncIO	.\experimental\io\AsyncIO.cpp	/^AsyncIO::~AsyncIO() {$/;"	f	class:folly::AsyncIO	signature:()
~AsyncIO	.\experimental\io\AsyncIO.h	/^  ~AsyncIO();$/;"	p	class:folly::AsyncIO	access:public	signature:()
~AsyncIOOp	.\experimental\io\AsyncIO.cpp	/^AsyncIOOp::~AsyncIOOp() {$/;"	f	class:folly::AsyncIOOp	signature:()
~AsyncIOOp	.\experimental\io\AsyncIO.h	/^  ~AsyncIOOp();$/;"	p	class:folly::AsyncIOOp	access:public	signature:()
~AsyncIOQueue	.\experimental\io\AsyncIO.cpp	/^AsyncIOQueue::~AsyncIOQueue() {$/;"	f	class:folly::AsyncIOQueue	signature:()
~AsyncIOQueue	.\experimental\io\AsyncIO.h	/^  ~AsyncIOQueue();$/;"	p	class:folly::AsyncIOQueue	access:public	signature:()
~AsyncTimeout	.\io\async\AsyncTimeout.cpp	/^AsyncTimeout::~AsyncTimeout() {$/;"	f	class:folly::AsyncTimeout	signature:()
~AsyncTimeout	.\io\async\AsyncTimeout.h	/^  virtual ~AsyncTimeout();$/;"	p	class:folly::AsyncTimeout	access:public	signature:()
~AtomicHashArray	.\AtomicHashArray.h	/^  ~AtomicHashArray() {}$/;"	f	class:folly::AtomicHashArray	access:private	signature:()
~AtomicHashMap	.\AtomicHashMap.h	/^  ~AtomicHashMap() {$/;"	f	class:folly::AtomicHashMap	access:public	signature:()
~AtomicStruct	.\AtomicStruct.h	/^  ~AtomicStruct() = default;$/;"	p	class:folly::AtomicStruct	access:public	signature:()
~Base	.\test\PortabilityTest.cpp	/^  virtual ~Base() { }$/;"	f	class:Base	access:public	signature:()
~Baton	.\Baton.h	/^  ~Baton() {$/;"	f	struct:folly::Baton	access:public	signature:()
~BenchmarkSuspender	.\Benchmark.h	/^  ~BenchmarkSuspender() {$/;"	f	struct:folly::BenchmarkSuspender	access:public	signature:()
~Block	.\Arena.h	/^    ~Block() { }$/;"	f	struct:folly::Arena::Block	access:private	signature:()
~BlockingQueue	.\experimental\wangle\concurrent\BlockingQueue.h	/^  virtual ~BlockingQueue() {}$/;"	f	class:folly::wangle::BlockingQueue	access:public	signature:()
~Bytes	.\detail\IPAddress.h	/^  ~Bytes() = delete;$/;"	p	struct:folly::detail::Bytes	access:private	signature:()
~CPUThreadPoolExecutor	.\experimental\wangle\concurrent\CPUThreadPoolExecutor.cpp	/^CPUThreadPoolExecutor::~CPUThreadPoolExecutor() {$/;"	f	class:folly::wangle::CPUThreadPoolExecutor	signature:()
~CPUThreadPoolExecutor	.\experimental\wangle\concurrent\CPUThreadPoolExecutor.h	/^  ~CPUThreadPoolExecutor();$/;"	p	class:folly::wangle::CPUThreadPoolExecutor	access:public	signature:()
~Callback	.\experimental\wangle\ConnectionManager.h	/^    virtual ~Callback() {}$/;"	f	class:folly::wangle::ConnectionManager::Callback	access:public	signature:()
~Callback	.\io\async\HHWheelTimer.cpp	/^HHWheelTimer::Callback::~Callback() {$/;"	f	class:folly::HHWheelTimer::Callback	signature:()
~Callback	.\io\async\HHWheelTimer.h	/^    virtual ~Callback();$/;"	p	class:folly::HHWheelTimer::Callback	access:public	signature:()
~CalledProcessError	.\Subprocess.h	/^  ~CalledProcessError() throw() { }$/;"	f	class:folly::CalledProcessError	access:public	signature:()
~ClosableMPMCQueue	.\gen\Parallel-inl.h	/^  ~ClosableMPMCQueue() {$/;"	f	class:folly::gen::detail::ClosableMPMCQueue	access:public	signature:()
~Codec	.\io\Compression.h	/^  virtual ~Codec() { }$/;"	f	class:folly::io::Codec	access:public	signature:()
~ConcurrentAccessData	.\test\ConcurrentSkipListBenchmark.cpp	/^  ~ConcurrentAccessData() {$/;"	f	class:__anon113::ConcurrentAccessData	access:public	signature:()
~ConcurrentSkipList	.\ConcurrentSkipList.h	/^  ~ConcurrentSkipList() {$/;"	f	class:folly::ConcurrentSkipList	access:public	signature:()
~ConnectionManager	.\experimental\wangle\ConnectionManager.h	/^  ~ConnectionManager() {}$/;"	f	class:folly::wangle::ConnectionManager	access:private	signature:()
~ConstLockedPtr	.\Synchronized.h	/^    ~ConstLockedPtr() {$/;"	f	struct:folly::Synchronized::ConstLockedPtr	access:public	signature:()
~Consumer	.\io\async\NotificationQueue.h	/^    virtual ~Consumer();$/;"	p	class:folly::NotificationQueue::Consumer	access:public	signature:()
~Consumer	.\io\async\NotificationQueue.h	/^NotificationQueue<MessageT>::Consumer::~Consumer() {$/;"	f	class:folly::NotificationQueue::Consumer	signature:()
~CopyCounter	.\gen\test\BaseTest.cpp	/^  ~CopyCounter() {$/;"	f	struct:CopyCounter	access:public	signature:()
~CursorBase	.\io\Cursor.h	/^  ~CursorBase(){}$/;"	f	class:folly::io::detail::CursorBase	access:protected	signature:()
~Data	.\dynamic.h	/^    ~Data() {}$/;"	f	union:folly::dynamic::Data	access:public	signature:()
~Data	.\test\stl_tests\StlVectorTest.cpp	/^  ~Data() = default;$/;"	p	struct:Data	file:	access:public	signature:()
~DataState	.\test\stl_tests\StlVectorTest.cpp	/^  ~DataState() {$/;"	f	class:DataState	access:public	signature:()
~DelayedDestruction	.\io\async\DelayedDestruction.h	/^  virtual ~DelayedDestruction() {}$/;"	f	class:folly::DelayedDestruction	access:protected	signature:()
~DeleterBase	.\detail\ThreadLocalDetail.h	/^  virtual ~DeleterBase() { }$/;"	f	class:folly::threadlocal_detail::DeleterBase	access:public	signature:()
~DeleterBase	.\io\IOBuf.h	/^    virtual ~DeleterBase() { }$/;"	f	struct:folly::IOBuf::DeleterBase	access:public	signature:()
~DestructorGuard	.\io\async\DelayedDestruction.h	/^    ~DestructorGuard() {$/;"	f	class:folly::DelayedDestruction::DestructorGuard	access:public	signature:()
~DeterministicAtomic	.\test\DeterministicSchedule.h	/^  ~DeterministicAtomic() = default;$/;"	p	struct:folly::test::DeterministicAtomic	access:public	signature:()
~DeterministicSchedule	.\test\DeterministicSchedule.cpp	/^DeterministicSchedule::~DeterministicSchedule() {$/;"	f	class:folly::test::DeterministicSchedule	signature:()
~DeterministicSchedule	.\test\DeterministicSchedule.h	/^  ~DeterministicSchedule();$/;"	p	class:folly::test::DeterministicSchedule	access:public	signature:()
~DtorChecker	.\test\ProducerConsumerQueueTest.cpp	/^  ~DtorChecker() { --numInstances; }$/;"	f	struct:__anon128::DtorChecker	access:public	signature:()
~ElfCacheBase	.\experimental\symbolizer\ElfCache.h	/^  virtual ~ElfCacheBase() { }$/;"	f	class:folly::symbolizer::ElfCacheBase	access:public	signature:()
~ElfFile	.\experimental\symbolizer\Elf.cpp	/^ElfFile::~ElfFile() {$/;"	f	class:folly::symbolizer::ElfFile	signature:()
~ElfFile	.\experimental\symbolizer\Elf.h	/^  ~ElfFile();$/;"	p	class:folly::symbolizer::ElfFile	access:public	signature:()
~ElfTest	.\experimental\symbolizer\test\ElfTests.cpp	/^  virtual ~ElfTest() {$/;"	f	class:ElfTest	access:public	signature:()
~EventBase	.\io\async\EventBase.cpp	/^EventBase::~EventBase() {$/;"	f	class:folly::EventBase	signature:()
~EventBase	.\io\async\EventBase.h	/^  ~EventBase();$/;"	p	class:folly::EventBase	access:public	signature:()
~EventBaseObserver	.\io\async\EventBase.h	/^  virtual ~EventBaseObserver() {}$/;"	f	class:folly::EventBaseObserver	access:public	signature:()
~EventHandler	.\io\async\EventHandler.cpp	/^EventHandler::~EventHandler() {$/;"	f	class:folly::EventHandler	signature:()
~EventHandler	.\io\async\EventHandler.h	/^  virtual ~EventHandler();$/;"	p	class:folly::EventHandler	access:public	signature:()
~EvictingCacheMap	.\EvictingCacheMap.h	/^  ~EvictingCacheMap() {$/;"	f	class:folly::EvictingCacheMap	access:public	signature:()
~Exception	.\test\function_benchmark\test_functions.cpp	/^  virtual ~Exception(void) throw() {}$/;"	f	class:Exception	access:public	signature:(void)
~ExecutionPipeline	.\gen\ParallelMap-inl.h	/^      ~ExecutionPipeline() {$/;"	f	class:folly::gen::detail::PMap::Generator::ExecutionPipeline	access:public	signature:()
~Executor	.\experimental\wangle\concurrent\Executor.h	/^  virtual ~Executor() {};$/;"	f	class:folly::wangle::Executor	access:public	signature:()
~Executor	.\gen\Parallel-inl.h	/^      ~Executor() {$/;"	f	class:folly::gen::detail::Parallel::Generator::Executor	access:public	signature:()
~Executor	.\wangle\Executor.h	/^     virtual ~Executor() = default;$/;"	p	class:folly::wangle::Executor	access:public	signature:()
~FDSymbolizePrinter	.\experimental\symbolizer\Symbolizer.cpp	/^FDSymbolizePrinter::~FDSymbolizePrinter() {$/;"	f	class:folly::symbolizer::FDSymbolizePrinter	signature:()
~FDSymbolizePrinter	.\experimental\symbolizer\Symbolizer.h	/^  ~FDSymbolizePrinter();$/;"	p	class:folly::symbolizer::FDSymbolizePrinter	access:public	signature:()
~File	.\File.cpp	/^File::~File() {$/;"	f	class:folly::File	signature:()
~File	.\File.h	/^  ~File();$/;"	p	class:folly::File	access:public	signature:()
~FillObject	.\test\ThreadLocalTest.cpp	/^  ~FillObject() {$/;"	f	class:__anon146::FillObject	access:public	signature:()
~Foo	.\test\ArenaSmartPtrTest.cpp	/^  ~Foo() {$/;"	f	struct:Foo	access:public	signature:()
~Foo	.\test\ScopeGuardTest.cpp	/^  ~Foo() {$/;"	f	class:Foo	access:public	signature:()
~Future	.\wangle\Future-inl.h	/^Future<T>::~Future() {$/;"	f	class:folly::wangle::Future	signature:()
~Future	.\wangle\Future.h	/^  ~Future();$/;"	p	class:folly::wangle::Future	access:public	signature:()
~GenericThreadGateFixture	.\wangle\test\ThreadGateTest.cpp	/^  ~GenericThreadGateFixture() {$/;"	f	struct:GenericThreadGateFixture	access:public	signature:()
~GroupVarintEncoder	.\GroupVarint.h	/^  ~GroupVarintEncoder() {$/;"	f	class:folly::GroupVarintEncoder	access:public	signature:()
~GuardObj	.\test\ApplyTupleTest.cpp	/^  ~GuardObj() {$/;"	f	struct:__anon104::GuardObj	access:public	signature:()
~HHWheelTimer	.\io\async\HHWheelTimer.cpp	/^HHWheelTimer::~HHWheelTimer() {$/;"	f	class:folly::HHWheelTimer	signature:()
~HHWheelTimer	.\io\async\HHWheelTimer.h	/^  virtual ~HHWheelTimer();$/;"	p	class:folly::HHWheelTimer	access:protected	signature:()
~HeapPrefix	.\io\IOBuf.cpp	/^  ~HeapPrefix() {$/;"	f	struct:folly::IOBuf::HeapPrefix	access:public	signature:()
~HostAndPort	.\SocketAddress.cpp	/^  ~HostAndPort() {$/;"	f	struct:__anon90::HostAndPort	access:public	signature:()
~IOBuf	.\io\IOBuf.cpp	/^IOBuf::~IOBuf() {$/;"	f	class:folly::IOBuf	signature:()
~IOBuf	.\io\IOBuf.h	/^  ~IOBuf();$/;"	p	class:folly::IOBuf	access:public	signature:()
~IOThreadPoolExecutor	.\experimental\wangle\concurrent\IOThreadPoolExecutor.cpp	/^IOThreadPoolExecutor::~IOThreadPoolExecutor() {$/;"	f	class:folly::wangle::IOThreadPoolExecutor	signature:()
~IOThreadPoolExecutor	.\experimental\wangle\concurrent\IOThreadPoolExecutor.h	/^  ~IOThreadPoolExecutor();$/;"	p	class:folly::wangle::IOThreadPoolExecutor	access:public	signature:()
~Impl	.\FBVector.h	/^    ~Impl() {$/;"	f	struct:folly::fbvector::Impl	access:public	signature:()
~IndexedMemPool	.\IndexedMemPool.h	/^  ~IndexedMemPool() {$/;"	f	struct:folly::IndexedMemPool	access:public	signature:()
~IntCache	.\ThreadCachedInt.h	/^    ~IntCache() {$/;"	f	struct:folly::ThreadCachedInt::IntCache	access:public	signature:()
~LaterFixture	.\wangle\test\LaterTest.cpp	/^  ~LaterFixture() {$/;"	f	struct:LaterFixture	access:public	signature:()
~LockedPtr	.\Synchronized.h	/^    ~LockedPtr() {$/;"	f	struct:folly::Synchronized::LockedPtr	access:public	signature:()
~LoopCallback	.\io\async\EventBase.h	/^    virtual ~LoopCallback() {}$/;"	f	class:folly::EventBase::LoopCallback	access:public	signature:()
~MPMCQueue	.\MPMCQueue.h	/^  ~MPMCQueue() {$/;"	f	class:folly::MPMCQueue	access:public	signature:()
~ManagedConnection	.\experimental\wangle\ManagedConnection.cpp	/^ManagedConnection::~ManagedConnection() {$/;"	f	class:folly::wangle::ManagedConnection	signature:()
~ManagedConnection	.\experimental\wangle\ManagedConnection.h	/^  virtual ~ManagedConnection();$/;"	p	class:folly::wangle::ManagedConnection	access:protected	signature:()
~MemoryMapping	.\MemoryMapping.cpp	/^MemoryMapping::~MemoryMapping() {$/;"	f	class:folly::MemoryMapping	signature:()
~MemoryMapping	.\MemoryMapping.h	/^  ~MemoryMapping();$/;"	p	class:folly::MemoryMapping	access:public	signature:()
~Node	.\experimental\exception_tracer\StackTrace.cpp	/^  ~Node() { }$/;"	f	class:folly::exception_tracer::StackTraceStack::Node	file:	access:private	signature:()
~NodeRecycler	.\ConcurrentSkipList-inl.h	/^  ~NodeRecycler() {$/;"	f	class:folly::detail::NodeRecycler	access:public	signature:()
~NoncopyableCounter	.\test\small_vector_test.cpp	/^  ~NoncopyableCounter() {$/;"	f	struct:__anon132::NoncopyableCounter	access:public	signature:()
~NotificationQueue	.\io\async\NotificationQueue.h	/^  ~NotificationQueue() {$/;"	f	class:folly::NotificationQueue	access:public	signature:()
~OwnershipTestClass	.\io\test\IOBufTest.cpp	/^  ~OwnershipTestClass() {$/;"	f	struct:__anon71::OwnershipTestClass	access:public	signature:()
~ProducerConsumerQueue	.\ProducerConsumerQueue.h	/^  ~ProducerConsumerQueue() {$/;"	f	struct:folly::ProducerConsumerQueue	access:public	signature:()
~Promise	.\wangle\Promise-inl.h	/^Promise<T>::~Promise() {$/;"	f	class:folly::wangle::Promise	signature:()
~Promise	.\wangle\Promise.h	/^  ~Promise();$/;"	p	class:folly::wangle::Promise	access:public	signature:()
~ReadHolder	.\RWSpinLock.h	/^    ~ReadHolder() { if (lock_) lock_->unlock_shared(); }$/;"	f	class:folly::RWSpinLock::ReadHolder	access:public	signature:()
~ReadHolder	.\RWSpinLock.h	/^    ~ReadHolder() {$/;"	f	class:folly::RWTicketSpinLockT::ReadHolder	access:public	signature:()
~RequestContextGuard	.\io\async\Request.h	/^  ~RequestContextGuard() {$/;"	f	class:folly::RequestContextGuard	access:public	signature:()
~RequestData	.\io\async\Request.h	/^  virtual ~RequestData() {}$/;"	f	class:folly::RequestData	access:public	signature:()
~ScopedAddrInfo	.\SocketAddress.cpp	/^  ~ScopedAddrInfo() {$/;"	f	struct:__anon90::ScopedAddrInfo	access:public	signature:()
~SingletonVault	.\experimental\Singleton.cpp	/^SingletonVault::~SingletonVault() { destroyInstances(); }$/;"	f	class:folly::SingletonVault	signature:()
~SingletonVault	.\experimental\Singleton.h	/^  ~SingletonVault();$/;"	p	class:folly::SingletonVault	access:public	signature:()
~SkipListNode	.\ConcurrentSkipList-inl.h	/^  ~SkipListNode() {$/;"	f	class:folly::detail::SkipListNode	access:private	signature:()
~SocketAddress	.\SocketAddress.h	/^  ~SocketAddress() {$/;"	f	class:folly::SocketAddress	access:public	signature:()
~State	.\wangle\detail\State.h	/^  ~State() {$/;"	f	class:folly::wangle::detail::State	access:public	signature:()
~StaticMeta	.\detail\ThreadLocalDetail.h	/^  ~StaticMeta() {$/;"	f	struct:folly::threadlocal_detail::StaticMeta	access:public	signature:()
~Subprocess	.\Subprocess.cpp	/^Subprocess::~Subprocess() {$/;"	f	class:folly::Subprocess	signature:()
~Subprocess	.\Subprocess.h	/^  ~Subprocess();$/;"	p	class:folly::Subprocess	access:public	signature:()
~SubprocessSpawnError	.\Subprocess.h	/^  ~SubprocessSpawnError() throw() {}$/;"	f	class:folly::SubprocessSpawnError	access:public	signature:()
~SymbolizePrinter	.\experimental\symbolizer\Symbolizer.h	/^  virtual ~SymbolizePrinter() { }$/;"	f	class:folly::symbolizer::SymbolizePrinter	access:public	signature:()
~T	.\FBVector.h	/^      if (!boost::has_trivial_destructor<T>::value) p->~T();$/;"	t	class:folly::fbvector	access:private
~TemporaryDirectory	.\experimental\TestUtil.cpp	/^TemporaryDirectory::~TemporaryDirectory() {$/;"	f	class:folly::test::TemporaryDirectory	signature:()
~TemporaryDirectory	.\experimental\TestUtil.h	/^  ~TemporaryDirectory();$/;"	p	class:folly::test::TemporaryDirectory	access:public	signature:()
~TemporaryFile	.\experimental\TestUtil.cpp	/^TemporaryFile::~TemporaryFile() {$/;"	f	class:folly::test::TemporaryFile	signature:()
~TemporaryFile	.\experimental\TestUtil.h	/^  ~TemporaryFile();$/;"	p	class:folly::test::TemporaryFile	access:public	signature:()
~TemporaryFile	.\experimental\io\test\AsyncIOTest.cpp	/^  ~TemporaryFile();$/;"	p	class:__anon32::TemporaryFile	file:	access:public	signature:()
~TemporaryFile	.\experimental\io\test\AsyncIOTest.cpp	/^TemporaryFile::~TemporaryFile() {$/;"	f	class:__anon32::TemporaryFile	signature:()
~TestBasicGuarantee	.\test\small_vector_test.cpp	/^  ~TestBasicGuarantee() {$/;"	f	struct:__anon132::TestBasicGuarantee	access:public	signature:()
~Thread	.\experimental\wangle\concurrent\ThreadPoolExecutor.h	/^    virtual ~Thread() {}$/;"	f	struct:folly::wangle::ThreadPoolExecutor::Thread	access:public	signature:()
~ThreadCachedInt	.\ThreadCachedInt.h	/^  ~ThreadCachedInt() {$/;"	f	class:folly::ThreadCachedInt	access:public	signature:()
~ThreadFactory	.\experimental\wangle\concurrent\ThreadFactory.h	/^  virtual ~ThreadFactory() {}$/;"	f	class:folly::wangle::ThreadFactory	access:public	signature:()
~ThreadGate	.\wangle\ThreadGate.h	/^  virtual ~ThreadGate() {}$/;"	f	class:folly::wangle::ThreadGate	access:public	signature:()
~ThreadLocalPtr	.\ThreadLocal.h	/^  ~ThreadLocalPtr() {$/;"	f	class:folly::ThreadLocalPtr	access:public	signature:()
~ThreadPoolExecutor	.\experimental\wangle\concurrent\ThreadPoolExecutor.cpp	/^ThreadPoolExecutor::~ThreadPoolExecutor() {$/;"	f	class:folly::wangle::ThreadPoolExecutor	signature:()
~ThreadPoolExecutor	.\experimental\wangle\concurrent\ThreadPoolExecutor.h	/^  ~ThreadPoolExecutor();$/;"	p	class:folly::wangle::ThreadPoolExecutor	access:public	signature:()
~TimeoutManager	.\io\async\TimeoutManager.h	/^  virtual ~TimeoutManager() {}$/;"	f	class:folly::TimeoutManager	access:public	signature:()
~Try	.\wangle\Try-inl.h	/^Try<T>::~Try() {$/;"	f	class:folly::wangle::Try	signature:()
~Try	.\wangle\Try.h	/^  ~Try();$/;"	p	class:folly::wangle::Try	access:public	signature:()
~Unsynchronizer	.\Synchronized.h	/^      ~Unsynchronizer() {$/;"	f	struct:folly::Synchronized::ConstLockedPtr::Unsynchronizer	access:public	signature:()
~Unsynchronizer	.\Synchronized.h	/^      ~Unsynchronizer() {$/;"	f	struct:folly::Synchronized::LockedPtr::Unsynchronizer	access:public	signature:()
~UpgradedHolder	.\RWSpinLock.h	/^    ~UpgradedHolder() { if (lock_) lock_->unlock_upgrade(); }$/;"	f	class:folly::RWSpinLock::UpgradedHolder	access:public	signature:()
~VirtualClass	.\test\function_benchmark\test_functions.cpp	/^VirtualClass::~VirtualClass() {$/;"	f	class:VirtualClass	signature:()
~VirtualClass	.\test\function_benchmark\test_functions.h	/^  virtual ~VirtualClass();$/;"	p	class:VirtualClass	access:public	signature:()
~WangleException	.\wangle\WangleException.h	/^  ~WangleException() throw(){}$/;"	f	class:folly::wangle::WangleException	access:public	signature:()
~Watchdog	.\experimental\test\SingletonTest.cpp	/^  ~Watchdog() {$/;"	f	struct:Watchdog	access:public	signature:()
~Widget	.\test\ThreadLocalTest.cpp	/^  ~Widget() {$/;"	f	struct:Widget	access:public	signature:()
~WriteHolder	.\RWSpinLock.h	/^    ~WriteHolder () { if (lock_) lock_->unlock(); }$/;"	f	class:folly::RWSpinLock::WriteHolder	access:public	signature:()
~WriteHolder	.\RWSpinLock.h	/^    ~WriteHolder() {$/;"	f	class:folly::RWTicketSpinLockT::WriteHolder	access:public	signature:()
~dynamic	.\dynamic-inl.h	/^inline dynamic::~dynamic() { destroy(); }$/;"	f	class:folly::dynamic	signature:()
~dynamic	.\dynamic.h	/^  ~dynamic();$/;"	p	struct:folly::dynamic	access:public	signature:()
~small_vector	.\small_vector.h	/^  ~small_vector() {$/;"	f	class:folly::small_vector	access:public	signature:()
